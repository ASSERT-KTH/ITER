bugid	buggy	buggy_class	suspiciousness	buggy_line	endbuggycode	original_failing_test_number	action	patch	original_buggy	execution_result	diagnosis	previous_bug_id	new_failing_test_number	this_action
1	[BUG]  [BUGGY]  int  paru  =  1.0  /  Math.min(delta,  0.1);  [CE]  <identifier>  expected  [FE]          AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  int  paru  =  1.0  /  Math.min(delta,  0.1);  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	int  paru  =  1.0  /  Math.min(delta,  0.1);	  if(paru    >    0.0)    {    int    paru    =    2.2251e-308    /    Math.min(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	79	None	replace
2	[BUG]  [BUGGY]  int  paru  =  0.5  /  Math.min(delta,  0.1);  [CE]  <identifier>  expected  [FE]            AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  int  paru  =  0.5  /  Math.min(delta,  0.1);  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	int  paru  =  0.5  /  Math.min(delta,  0.1);	  if(paru    >    0.0)    {    int    paru    =    2.2251e-308    /    Math.min(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	79	None	replace
3	[BUG]  [BUGGY]  int  paru  =  2.0  /  Math.min(delta,  0.1);  [CE]  <identifier>  expected  [FE]              AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  int  paru  =  2.0  /  Math.min(delta,  0.1);  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	int  paru  =  2.0  /  Math.min(delta,  0.1);	  if(paru    >    0.0)    {    int    paru    =    2.2251e-308    /    Math.min(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	79	None	replace
4	[BUG]  [BUGGY]  int  paru  =  0.0  /  Math.min(delta,  0.1);  [CE]  <identifier>  expected  [FE]                AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  int  paru  =  0.0  /  Math.min(delta,  0.1);  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	int  paru  =  0.0  /  Math.min(delta,  0.1);	  if(paru    >    0.0)    {    int    paru    =    2.2251e-308    /    Math.min(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	79	None	replace
5	[BUG]  [BUGGY]  paru  =  1.0  /  Math.min(delta,  0.0);  [CE]  <identifier>  expected  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  paru  =  1.0  /  Math.min(delta,  0.0);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	paru  =  1.0  /  Math.min(delta,  0.0);	          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    paru    =    2.2252e-308    /    Math.min(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	142	None	replace
6	[BUG]  [BUGGY]  if(delta  >  0.0)  {  if(delta  >  0.0)  {  [CE]  illegal  start  of  expression  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(delta  >  0.0)  {  if(delta  >  0.0)  {  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(delta    >    0.0)    {    if(delta  >  0.0)  {	  	non-compiled	[CE]  illegal  start  of  expression	9	None	add
7	[BUG]  [BUGGY]  if(delta  >  0.0)  {  If(delta  >  0.0)  {  [CE]  ';'  expected  [FE]      AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(delta  >  0.0)  {  If(delta  >  0.0)  {  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(delta    >    0.0)    {    If(delta  >  0.0)  {	  	non-compiled	[CE]  ';'  expected	9	None	add
8	[BUG]  [BUGGY]  if(delta  >  0.0)  {  if(delta  >  0.00)  {  [CE]  illegal  start  of  expression  [FE]        AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(delta  >  0.0)  {  if(delta  >  0.00)  {  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(delta    >    0.0)    {    if(delta  >  0.00)  {	  	non-compiled	[CE]  illegal  start  of  expression	9	None	add
9	[BUG]  [BUGGY]  paru  =  22251e-308  /  Math.min(delta,  0.5);  [CE]  <identifier>  expected  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  paru  =  22251e-308  /  Math.min(delta,  0.5);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	paru  =  22251e-308  /  Math.min(delta,  0.5);	          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.5);    }    else    {    paru    =    22251e-308    /    Math.min(delta,    0.5);    }    	non-compiled	[CE]  <identifier>  expected	160	None	replace
10	[BUG]  [BUGGY]  ParserParser  parl  =  parser.parseParser(gNorm);  [CE]  <identifier>  expected  [FE]      AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  ParserParser  parl  =  parser.parseParser(gNorm);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	ParserParser  parl  =  parser.parseParser(gNorm);	          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.5);    }    else    {    paru    =    22251e-308    /    Math.min(delta,    0.5);    }    	non-compiled	[CE]  <identifier>  expected	160	None	replace
11	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    paru  =  2.2251e-308  /  Math.min(delta,  0.2);  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  paru  =  2.2251e-308  /  Math.min(delta,  0.2);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	add	                paru        =        2.2251e-308        /        Math.min(delta,        0.1);        paru    =    2.2251e-308    /    Math.min(delta,    0.2);    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  paru  =  2.2251e-308  /  Math.min(delta,  0.2);	  	compilable	  [FE]  AssertionFailedError  	39	4	add
12	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    paru  =  2.2251e-308  /  Math.min(delta,  0.2);  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  paru  =  2.2251e-308  /  Math.min(delta,  0.2);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    paru  =  2.2251e-308  /  Math.min(delta,  0.2);  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  paru  =  2.2251e-308  /  Math.min(delta,  0.2);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.min(delta,        0.1);        paru    =    2.2251e-308    /    Math.min(delta,    0.2);    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  paru  =  2.2251e-308  /  Math.min(delta,  0.2);	  	compilable	  [FE]  AssertionFailedError  	39	4	add
13	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    paru  =  2.2251e-308  /  Math.min(delta,  0.2);  Paru  =  2.2251e-308  /  Math.min(delta,  0.1);  paru  =  2.2251e-308  /  Math.min(delta,  0.2);  [CE]  cannot  find  symbol  Paru  [FE]      AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    paru  =  2.2251e-308  /  Math.min(delta,  0.2);  Paru  =  2.2251e-308  /  Math.min(delta,  0.1);  paru  =  2.2251e-308  /  Math.min(delta,  0.2);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.min(delta,        0.1);        paru    =    2.2251e-308    /    Math.min(delta,    0.2);    Paru  =  2.2251e-308  /  Math.min(delta,  0.1);  paru  =  2.2251e-308  /  Math.min(delta,  0.2);	  	non-compiled	[CE]  cannot  find  symbol  Paru	39	None	add
14	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    paru  =  2.2251e-308  /  Math.min(delta,  0.2);  paru  =  22251e-308  /  Math.min(delta,  0.1);  paru  =  2.2251e-308  /  Math.min(delta,  0.2);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	add	                paru        =        2.2251e-308        /        Math.min(delta,        0.1);        paru    =    2.2251e-308    /    Math.min(delta,    0.2);    paru  =  22251e-308  /  Math.min(delta,  0.1);  paru  =  2.2251e-308  /  Math.min(delta,  0.2);	  	compilable	  [FE]  AssertionFailedError  	39	4	add
15	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    paru  =  2.2251e-308  /  Math.min(delta,  0.2);  paru  =  22251e-308  /  Math.min(delta,  0.1);  paru  =  2.2251e-308  /  Math.min(delta,  0.2);  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    paru  =  2.2251e-308  /  Math.min(delta,  0.2);  paru  =  22251e-308  /  Math.min(delta,  0.1);  paru  =  2.2251e-308  /  Math.min(delta,  0.2);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.min(delta,        0.1);        paru    =    2.2251e-308    /    Math.min(delta,    0.2);    paru  =  22251e-308  /  Math.min(delta,  0.1);  paru  =  2.2251e-308  /  Math.min(delta,  0.2);	  	compilable	  [FE]  AssertionFailedError  	39	4	add
16	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    paru  =  2.2251e-308  /  Math.min(delta,  0.2);  paru  =  2.2252e-308  /  Math.min(delta,  0.1);  paru  =  2.2251e-308  /  Math.min(delta,  0.2);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	add	                paru        =        2.2251e-308        /        Math.min(delta,        0.1);        paru    =    2.2251e-308    /    Math.min(delta,    0.2);    paru  =  2.2252e-308  /  Math.min(delta,  0.1);  paru  =  2.2251e-308  /  Math.min(delta,  0.2);	  	compilable	  [FE]  AssertionFailedError  	39	4	add
17	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    paru  =  2.2251e-308  /  Math.min(delta,  0.2);  paru  =  2.2252e-308  /  Math.min(delta,  0.1);  paru  =  2.2251e-308  /  Math.min(delta,  0.2);  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    paru  =  2.2251e-308  /  Math.min(delta,  0.2);  paru  =  2.2252e-308  /  Math.min(delta,  0.1);  paru  =  2.2251e-308  /  Math.min(delta,  0.2);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.min(delta,        0.1);        paru    =    2.2251e-308    /    Math.min(delta,    0.2);    paru  =  2.2252e-308  /  Math.min(delta,  0.1);  paru  =  2.2251e-308  /  Math.min(delta,  0.2);	  	compilable	  [FE]  AssertionFailedError  	39	4	add
18	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    paru  =  2.2251e-308  /  Math.min(delta,  0.2);  paru  =  2.0  /  Math.min(delta,  0.1);  paru  =  2.0  /  Math.min(delta,  0.2);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	add	                paru        =        2.2251e-308        /        Math.min(delta,        0.1);        paru    =    2.2251e-308    /    Math.min(delta,    0.2);    paru  =  2.0  /  Math.min(delta,  0.1);  paru  =  2.0  /  Math.min(delta,  0.2);	  	compilable	  [FE]  AssertionFailedError  	39	3	add
19	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    paru  =  2.2251e-308  /  Math.min(delta,  0.2);  paru  =  2.0  /  Math.min(delta,  0.1);  paru  =  2.0  /  Math.min(delta,  0.2);  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    paru  =  2.2251e-308  /  Math.min(delta,  0.2);  paru  =  2.0  /  Math.min(delta,  0.1);  paru  =  2.0  /  Math.min(delta,  0.2);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.min(delta,        0.1);        paru    =    2.2251e-308    /    Math.min(delta,    0.2);    paru  =  2.0  /  Math.min(delta,  0.1);  paru  =  2.0  /  Math.min(delta,  0.2);	  	compilable	  [FE]  AssertionFailedError  	39	3	add
20	[BUG]  [BUGGY]  double  parl  =  Math.max(paru,  Math.min(delta,  0.5));  [CE]  <identifier>  expected  [FE]                AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  double  parl  =  Math.max(paru,  Math.min(delta,  0.5));  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  parl  =  Math.max(paru,  Math.min(delta,  0.5));	  double    parl    =    Math.max(paru,    Math.min(delta,    0.1));    	non-compiled	[CE]  <identifier>  expected	30	None	replace
21	[BUG]  [BUGGY]  double  parl  =  Math.max(paru,  Math.min(delta,  2.0));  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  double  parl  =  Math.max(paru,  Math.min(delta,  2.0));  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  parl  =  Math.max(paru,  Math.min(delta,  2.0));	  double    parl    =    Math.max(paru,    Math.min(delta,    0.1));    	non-compiled	[CE]  <identifier>  expected	30	None	replace
22	[BUG]  [BUGGY]  Integer  parl  =  Math.max(delta,  1.0);  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  Integer  parl  =  Math.max(delta,  1.0);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	Integer  parl  =  Math.max(delta,  1.0);	  Integer    parl    =    Math.max(paru,    1.0);    	non-compiled	[CE]  <identifier>  expected	27	None	replace
23	[BUG]  [BUGGY]  int  parl  =  Math.max(paru,  2.0);  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  int  parl  =  Math.max(paru,  2.0);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	int  parl  =  Math.max(paru,  2.0);	  int    parl    =    Math.max(paru,    1.0);    	non-compiled	[CE]  <identifier>  expected	90	None	replace
24	[BUG]  [BUGGY]  int  parl  =  Math.max(paru,  0.5);  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  int  parl  =  Math.max(paru,  0.5);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	int  parl  =  Math.max(paru,  0.5);	  int    parl    =    Math.max(paru,    1.0);    	non-compiled	[CE]  <identifier>  expected	90	None	replace
25	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  else  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	add	                paru        =        2.2251e-308        /        Math.min(delta,        0.5);        if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.5);    }    else    {    paru    =    2.2251e-308    /    Math.min(delta,    0.5);    }    paru  =  2.2251e-308  /  Math.min(delta,  0.5);	  	compilable	  [FE]  AssertionFailedError  	24	4	add
26	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  else  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  else  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.min(delta,        0.5);        if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.5);    }    else    {    paru    =    2.2251e-308    /    Math.min(delta,    0.5);    }    paru  =  2.2251e-308  /  Math.min(delta,  0.5);	  	compilable	  [FE]  AssertionFailedError  	24	4	add
27	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  else  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  else  {  paru  =  2.2251e  [CE]  malformed  floating  point  literal  [FE]      AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  else  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  else  {  paru  =  2.2251e  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.min(delta,        0.5);        if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.5);    }    else    {    paru    =    2.2251e-308    /    Math.min(delta,    0.5);    }    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  else  {  paru  =  2.2251e	  	non-compiled	[CE]  malformed  floating  point  literal	24	None	add
28	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  else  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  else  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	add	                paru        =        2.2251e-308        /        Math.min(delta,        0.5);        if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.5);    }    else    {    paru    =    2.2251e-308    /    Math.min(delta,    0.5);    }    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  else  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }	  	compilable	  [FE]  AssertionFailedError  	24	4	add
29	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  else  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  else  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  else  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  else  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.min(delta,        0.5);        if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.5);    }    else    {    paru    =    2.2251e-308    /    Math.min(delta,    0.5);    }    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  else  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }	  	compilable	  [FE]  AssertionFailedError  	24	4	add
30	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  else  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	add	                paru        =        2.2251e-308        /        Math.min(delta,        0.5);        if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.5);    }    else    {    paru    =    2.2251e-308    /    Math.min(delta,    0.5);    }    paru  =  2.2251e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }	  	compilable	  [FE]  AssertionFailedError  	24	4	add
31	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  else  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  else  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.min(delta,        0.5);        if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.5);    }    else    {    paru    =    2.2251e-308    /    Math.min(delta,    0.5);    }    paru  =  2.2251e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }	  	compilable	  [FE]  AssertionFailedError  	24	4	add
32	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  else  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  [CE]  illegal  start  of  expression  [FE]            AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  else  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.min(delta,        0.5);        if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.5);    }    else    {    paru    =    2.2251e-308    /    Math.min(delta,    0.5);    }    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }	  	non-compiled	[CE]  illegal  start  of  expression	24	None	add
33	[BUG]  [BUGGY]  Paru  =  0.5  /  Math.min(delta,  0.1);  [CE]  <identifier>  expected  [FE]          AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  Paru  =  0.5  /  Math.min(delta,  0.1);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	Paru  =  0.5  /  Math.min(delta,  0.1);	          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    Paru    =    2.2251e-308    /    Math.min(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	36	None	replace
34	[BUG]  [BUGGY]  Paru  =  1.0  /  Math.min(delta,  0.1);  [CE]  <identifier>  expected  [FE]            AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  Paru  =  1.0  /  Math.min(delta,  0.1);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	Paru  =  1.0  /  Math.min(delta,  0.1);	          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    Paru    =    2.2251e-308    /    Math.min(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	36	None	replace
35	[BUG]  [BUGGY]  Paru  =  2.0  /  Math.min(delta,  0.1);  [CE]  <identifier>  expected  [FE]              AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  Paru  =  2.0  /  Math.min(delta,  0.1);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	Paru  =  2.0  /  Math.min(delta,  0.1);	          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    Paru    =    2.2251e-308    /    Math.min(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	36	None	replace
36	[BUG]  [BUGGY]  Paru  =  2.3  /  Math.min(delta,  0.1);  [CE]  <identifier>  expected  [FE]                AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  Paru  =  2.3  /  Math.min(delta,  0.1);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	Paru  =  2.3  /  Math.min(delta,  0.1);	          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    Paru    =    2.2251e-308    /    Math.min(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	36	None	replace
37	[BUG]  [BUGGY]  int  paru  =  Math.max(paru,  2.0);  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  int  paru  =  Math.max(paru,  2.0);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	int  paru  =  Math.max(paru,  2.0);	  int    paru    =    Math.max(paru,    0.5);    	non-compiled	[CE]  <identifier>  expected	121	None	replace
38	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	add	                paru        =        2.2251e-308        /        Math.min(delta,        0.1);        if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.1);    }    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }	  	compilable	  [FE]  AssertionFailedError  	37	4	add
39	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.min(delta,        0.1);        if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.1);    }    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }	  	compilable	  [FE]  AssertionFailedError  	37	4	add
40	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  [CE]  illegal  start  of  expression  [FE]      AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.min(delta,        0.1);        if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.1);    }    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }	  	non-compiled	[CE]  illegal  start  of  expression	37	None	add
41	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  if(paru  >=  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  [CE]  illegal  start  of  expression  [FE]        AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  if(paru  >=  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.min(delta,        0.1);        if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.1);    }    if(paru  >=  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }	  	non-compiled	[CE]  illegal  start  of  expression	37	None	add
42	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  Paru  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  [CE]  cannot  find  symbol  [FE]          AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  Paru  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.min(delta,        0.1);        if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.1);    }    Paru  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }	  	non-compiled	[CE]  cannot  find  symbol	37	None	add
43	[BUG]  [BUGGY]  int  parl  =  permutation[0]  /  1;  [CE]  <identifier>  expected  [FE]            AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  int  parl  =  permutation[0]  /  1;  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	int  parl  =  permutation[0]  /  1;	  int    parl    =    permutation[0]    &    1;    	non-compiled	[CE]  <identifier>  expected	129	None	replace
44	[BUG]  [BUGGY]  int  parl  =  permutation[0]  &  2;  [CE]  <identifier>  expected  [FE]              AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  int  parl  =  permutation[0]  &  2;  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	int  parl  =  permutation[0]  &  2;	  int    parl    =    permutation[0]    &    1;    	non-compiled	[CE]  <identifier>  expected	129	None	replace
45	[BUG]  [BUGGY]  int  parl  =  Math.min(delta,  0.0);  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  int  parl  =  Math.min(delta,  0.0);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	int  parl  =  Math.min(delta,  0.0);	  int    parl    =    Math.max(param,    0.0);    	non-compiled	[CE]  <identifier>  expected	69	None	replace
46	[BUG]  [BUGGY]  paru  =  1.0  /  Math.min(delta,  0.1);if(paru  ==  0)  {  paru  =  1.0  /  Math.min(delta,  0.1);  }  [CE]  <identifier>  expected  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  paru  =  1.0  /  Math.min(delta,  0.1);if(paru  ==  0)  {  paru  =  1.0  /  Math.min(delta,  0.1);  }  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	paru  =  1.0  /  Math.min(delta,  0.1);if(paru  ==  0)  {  paru  =  1.0  /  Math.min(delta,  0.1);  }	          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.1);    }    if    (paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.1);    }    	non-compiled	[CE]  <identifier>  expected	132	None	replace
47	[BUG]  [BUGGY]  paru  =  0.5  /  Math.min(delta,  0.1);if(paru  ==  0)  {  paru  =  0.5  /  Math.min(delta,  0.1);  }  [CE]  <identifier>  expected  [FE]      AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  paru  =  0.5  /  Math.min(delta,  0.1);if(paru  ==  0)  {  paru  =  0.5  /  Math.min(delta,  0.1);  }  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	paru  =  0.5  /  Math.min(delta,  0.1);if(paru  ==  0)  {  paru  =  0.5  /  Math.min(delta,  0.1);  }	          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.1);    }    if    (paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.1);    }    	non-compiled	[CE]  <identifier>  expected	132	None	replace
48	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(delta  >=  0)  {  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	add	if(delta  >=  0)  {	  if(paru    >=    0)    {    	compilable	  [FE]  AssertionFailedError  	109	4	replace
49	[BUG]  [BUGGY]  if(delta  >=  0)  {  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(delta  >=  0)  {  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(delta  >=  0)  {	  if(paru    >=    0)    {    	compilable	  [FE]  AssertionFailedError  	109	4	replace
50	[BUG]  [BUGGY]  if(delta  >  0.0)  {  if(paru  >=  0.0)  {  [CE]  illegal  start  of  expression  [FE]          AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(delta  >  0.0)  {  if(paru  >=  0.0)  {  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(delta  >  0.0)  {  if(paru  >=  0.0)  {	  if(paru    >=    0.0)    {    if(paru    >>    0.0)    {    	non-compiled	[CE]  illegal  start  of  expression	12	None	replace
51	[BUG]  [BUGGY]  if(delta  <  0.0)  {  if(paru  >=  0.0)  {  [CE]  illegal  start  of  expression  [FE]            AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(delta  <  0.0)  {  if(paru  >=  0.0)  {  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(delta  <  0.0)  {  if(paru  >=  0.0)  {	  if(paru    >=    0.0)    {    if(paru    >>    0.0)    {    	non-compiled	[CE]  illegal  start  of  expression	12	None	replace
52	[BUG]  [BUGGY]  if(delta  <  0.0)  {  if(delta  <  0.0)  {  [CE]  illegal  start  of  expression  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(delta  <  0.0)  {  if(delta  <  0.0)  {  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(delta    <    0.0)    {    if(delta  <  0.0)  {	  	non-compiled	[CE]  illegal  start  of  expression	7	None	add
53	[BUG]  [BUGGY]  if(delta  <  0.0)  {  If(delta  <  0.0)  {  [CE]  ';'  expected  [FE]      AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(delta  <  0.0)  {  If(delta  <  0.0)  {  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(delta    <    0.0)    {    If(delta  <  0.0)  {	  	non-compiled	[CE]  ';'  expected	7	None	add
54	[BUG]  [BUGGY]  if(delta  <  0.0)  {  if(delta  <  0.00)  {  [CE]  illegal  start  of  expression  [FE]        AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(delta  <  0.0)  {  if(delta  <  0.00)  {  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(delta    <    0.0)    {    if(delta  <  0.00)  {	  	non-compiled	[CE]  illegal  start  of  expression	7	None	add
55	[BUG]  [BUGGY]  double  parl  =  Math.max(work1,  Math.max(paru,  work3));  [CE]  <identifier>  expected  [FE]                AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  double  parl  =  Math.max(work1,  Math.max(paru,  work3));  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  parl  =  Math.max(work1,  Math.max(paru,  work3));	  double    parl    =    Math.max(work3,    Math.max(paru,    work1));    	non-compiled	[CE]  <identifier>  expected	83	None	replace
56	[BUG]  [BUGGY]  double  parl  =  Math.max(work3,  Math.max(paru,  gNorm));  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  double  parl  =  Math.max(work3,  Math.max(paru,  gNorm));  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  parl  =  Math.max(work3,  Math.max(paru,  gNorm));	  double    parl    =    Math.max(work3,    Math.max(paru,    work1));    	non-compiled	[CE]  <identifier>  expected	83	None	replace
57	[BUG]  [BUGGY]  double  parl  =  Math.max(work3,  Math.max(paru,  sum));  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  double  parl  =  Math.max(work3,  Math.max(paru,  sum));  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  parl  =  Math.max(work3,  Math.max(paru,  sum));	  double    parl    =    Math.max(work3,    Math.max(paru,    work1));    	non-compiled	[CE]  <identifier>  expected	83	None	replace
58	[BUG]  [BUGGY]  double  parl  =  Math.max(work3,  Math.max(paru,  0.0));  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  double  parl  =  Math.max(work3,  Math.max(paru,  0.0));  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  parl  =  Math.max(work3,  Math.max(paru,  0.0));	  double    parl    =    Math.max(work3,    Math.max(paru,    work1));    	non-compiled	[CE]  <identifier>  expected	83	None	replace
59	[BUG]  [BUGGY]  double  parl  =  Math.max(paru,  Math.max(work2,  sum));  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  double  parl  =  Math.max(paru,  Math.max(work2,  sum));  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  parl  =  Math.max(paru,  Math.max(work2,  sum));	  double    parl    =    Math.max(paru,    Math.max(work3,    work2));    	non-compiled	[CE]  <identifier>  expected	85	None	replace
60	[BUG]  [BUGGY]  double  parl  =  Math.max(paru,  Math.max(work3,  sum));  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  double  parl  =  Math.max(paru,  Math.max(work3,  sum));  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  parl  =  Math.max(paru,  Math.max(work3,  sum));	  double    parl    =    Math.max(paru,    Math.max(work3,    work2));    	non-compiled	[CE]  <identifier>  expected	85	None	replace
61	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	add	                paru        =        2.2251e-308        /        Math.min(delta,        0.5);        if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.5);    }    if    (paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.5);    }    paru  =  2.2251e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }	  	compilable	  [FE]  AssertionFailedError  	111	4	add
62	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.min(delta,        0.5);        if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.5);    }    if    (paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.5);    }    paru  =  2.2251e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }	  	compilable	  [FE]  AssertionFailedError  	111	4	add
63	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  [CE]  illegal  start  of  expression  [FE]      AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.min(delta,        0.5);        if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.5);    }    if    (paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.5);    }    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }	  	non-compiled	[CE]  illegal  start  of  expression	111	None	add
64	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	add	                paru        =        2.2251e-308        /        Math.min(delta,        0.5);        if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.5);    }    if    (paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.5);    }    paru  =  2.2251e-308  /  Math.min(delta,  0.5);	  	compilable	  [FE]  AssertionFailedError  	111	4	add
65	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.min(delta,        0.5);        if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.5);    }    if    (paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.5);    }    paru  =  2.2251e-308  /  Math.min(delta,  0.5);	  	compilable	  [FE]  AssertionFailedError  	111	4	add
66	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	add	                paru        =        2.2251e-308        /        Math.min(delta,        0.5);        if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.5);    }    if    (paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.5);    }    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }	  	compilable	  [FE]  AssertionFailedError  	111	4	add
67	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.min(delta,        0.5);        if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.5);    }    if    (paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.5);    }    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }	  	compilable	  [FE]  AssertionFailedError  	111	4	add
68	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  [CE]  illegal  start  of  expression  [FE]            AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.min(delta,        0.5);        if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.5);    }    if    (paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.5);    }    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }	  	non-compiled	[CE]  illegal  start  of  expression	111	None	add
69	[BUG]  [BUGGY]  double  paru  =  2.0  /  Math.min(delta,  1.0);  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  double  paru  =  2.0  /  Math.min(delta,  1.0);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  paru  =  2.0  /  Math.min(delta,  1.0);	  double    paru    =    2.0    /    Math.min(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	76	None	replace
70	[BUG]  [BUGGY]  double  paru  =  2.0  /  Math.min(delta,  0.0);  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  double  paru  =  2.0  /  Math.min(delta,  0.0);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  paru  =  2.0  /  Math.min(delta,  0.0);	  double    paru    =    2.0    /    Math.min(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	76	None	replace
71	[BUG]  [BUGGY]  double  paru  =  2.0  /  Math.min(delta,  0.5);  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  double  paru  =  2.0  /  Math.min(delta,  0.5);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  paru  =  2.0  /  Math.min(delta,  0.5);	  double    paru    =    2.0    /    Math.min(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	76	None	replace
72	[BUG]  [BUGGY]  Integer  parl  =  Math.max(paru,  2.0  /  2.0);  [CE]  <identifier>  expected  [FE]                        AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  Integer  parl  =  Math.max(paru,  2.0  /  2.0);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	Integer  parl  =  Math.max(paru,  2.0  /  2.0);	  Integer    parl    =    Math.max(paru,    2.0);    	non-compiled	[CE]  <identifier>  expected	29	None	replace
73	[BUG]  [BUGGY]  int  paru  =  1.0  /  Math.min(delta,  0.0);  [CE]  <identifier>  expected  [FE]            AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  int  paru  =  1.0  /  Math.min(delta,  0.0);  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	int  paru  =  1.0  /  Math.min(delta,  0.0);	  if(paru    >    0.0)    {    int    paru    =    2.2251e-308    /    Math.min(delta,    0.0);    	non-compiled	[CE]  <identifier>  expected	80	None	replace
74	[BUG]  [BUGGY]  int  paru  =  0.5  /  Math.min(delta,  0.0);  [CE]  <identifier>  expected  [FE]              AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  int  paru  =  0.5  /  Math.min(delta,  0.0);  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	int  paru  =  0.5  /  Math.min(delta,  0.0);	  if(paru    >    0.0)    {    int    paru    =    2.2251e-308    /    Math.min(delta,    0.0);    	non-compiled	[CE]  <identifier>  expected	80	None	replace
75	[BUG]  [BUGGY]  int  paru  =  0.0  /  Math.min(delta,  0.0);  [CE]  <identifier>  expected  [FE]                AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  int  paru  =  0.0  /  Math.min(delta,  0.0);  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	int  paru  =  0.0  /  Math.min(delta,  0.0);	  if(paru    >    0.0)    {    int    paru    =    2.2251e-308    /    Math.min(delta,    0.0);    	non-compiled	[CE]  <identifier>  expected	80	None	replace
76	[BUG]  [BUGGY]  int  paru  =  2.0  /  Math.min(delta,  0.0);  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  int  paru  =  2.0  /  Math.min(delta,  0.0);  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	int  paru  =  2.0  /  Math.min(delta,  0.0);	  if(paru    >    0.0)    {    int    paru    =    2.2251e-308    /    Math.min(delta,    0.0);    	non-compiled	[CE]  <identifier>  expected	80	None	replace
77	[BUG]  [BUGGY]  if(delta  ==  0.0)  {  if(paru  >=  0.0)  {  [CE]  illegal  start  of  expression  [FE]          AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(delta  ==  0.0)  {  if(paru  >=  0.0)  {  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(delta  ==  0.0)  {  if(paru  >=  0.0)  {	  if(paru    ==    0.0)    {    if(paru    >=    0.0)    {    	non-compiled	[CE]  illegal  start  of  expression	99	None	replace
78	[BUG]  [BUGGY]  if(delta!=  0.0)  {  if(paru  >=  0.0)  {  [CE]  illegal  start  of  expression  [FE]            AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(delta!=  0.0)  {  if(paru  >=  0.0)  {  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(delta!=  0.0)  {  if(paru  >=  0.0)  {	  if(paru    ==    0.0)    {    if(paru    >=    0.0)    {    	non-compiled	[CE]  illegal  start  of  expression	99	None	replace
79	[BUG]  [BUGGY]  if(delta  >=  0.0)  {  if(paru  >=  0.0)  {  [CE]  illegal  start  of  expression  [FE]              AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(delta  >=  0.0)  {  if(paru  >=  0.0)  {  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(delta  >=  0.0)  {  if(paru  >=  0.0)  {	  if(paru    ==    0.0)    {    if(paru    >=    0.0)    {    	non-compiled	[CE]  illegal  start  of  expression	99	None	replace
80	[BUG]  [BUGGY]  paru  =  1.0  /  Math.min(delta,  1.0);  [CE]  <identifier>  expected  [FE]        AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  paru  =  1.0  /  Math.min(delta,  1.0);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	paru  =  1.0  /  Math.min(delta,  1.0);	  paru    =    1.0    /    Math.min(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	56	None	replace
81	[BUG]  [BUGGY]  paru  =  2.0  /  Math.min(delta,  1.0);  [CE]  <identifier>  expected  [FE]          AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  paru  =  2.0  /  Math.min(delta,  1.0);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	paru  =  2.0  /  Math.min(delta,  1.0);	  paru    =    1.0    /    Math.min(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	56	None	replace
82	[BUG]  [BUGGY]  paru  =  1.0  /  Math.min(delta,  0.5);  Paru  =  1.0  /  Math.min(delta,  0.5);  [CE]  <identifier>  expected  [FE]          AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  paru  =  1.0  /  Math.min(delta,  0.5);  Paru  =  1.0  /  Math.min(delta,  0.5);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	paru  =  1.0  /  Math.min(delta,  0.5);  Paru  =  1.0  /  Math.min(delta,  0.5);	          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    Paru    =    2.2251e-308    /    Math.min(delta,    0.5);    	non-compiled	[CE]  <identifier>  expected	21	None	replace
83	[BUG]  [BUGGY]  paru  =  0.5  /  Math.min(delta,  0.5);  Paru  =  0.5  /  Math.min(delta,  0.5);  [CE]  <identifier>  expected  [FE]            AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  paru  =  0.5  /  Math.min(delta,  0.5);  Paru  =  0.5  /  Math.min(delta,  0.5);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	paru  =  0.5  /  Math.min(delta,  0.5);  Paru  =  0.5  /  Math.min(delta,  0.5);	          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    Paru    =    2.2251e-308    /    Math.min(delta,    0.5);    	non-compiled	[CE]  <identifier>  expected	21	None	replace
84	[BUG]  [BUGGY]  Paru  =  0.5  /  Math.min(delta,  0.5);  [CE]  <identifier>  expected  [FE]              AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  Paru  =  0.5  /  Math.min(delta,  0.5);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	Paru  =  0.5  /  Math.min(delta,  0.5);	          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    Paru    =    2.2251e-308    /    Math.min(delta,    0.5);    	non-compiled	[CE]  <identifier>  expected	21	None	replace
85	[BUG]  [BUGGY]  Paru  =  2.0  /  Math.min(delta,  0.5);  [CE]  <identifier>  expected  [FE]                AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  Paru  =  2.0  /  Math.min(delta,  0.5);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	Paru  =  2.0  /  Math.min(delta,  0.5);	          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    Paru    =    2.2251e-308    /    Math.min(delta,    0.5);    	non-compiled	[CE]  <identifier>  expected	21	None	replace
86	[BUG]  [BUGGY]  int  parl  =  permutation[1]  -  1;  [CE]  <identifier>  expected  [FE]                AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  int  parl  =  permutation[1]  -  1;  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	int  parl  =  permutation[1]  -  1;	  int    parl    =    permutation[0]    -    1;    	non-compiled	[CE]  <identifier>  expected	62	None	replace
87	[BUG]  [BUGGY]  int  parl  =  permutation[0]  -  2;  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  int  parl  =  permutation[0]  -  2;  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	int  parl  =  permutation[0]  -  2;	  int    parl    =    permutation[0]    -    1;    	non-compiled	[CE]  <identifier>  expected	62	None	replace
88	[BUG]  [BUGGY]  int  paru  =  Math.max(delta,  1.0);  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  int  paru  =  Math.max(delta,  1.0);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	int  paru  =  Math.max(delta,  1.0);	  int    paru    =    Math.max(delta,    0.0);    	non-compiled	[CE]  <identifier>  expected	94	None	replace
89	[BUG]  [BUGGY]  int  paru  =  Math.max(delta,  0.1);  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  int  paru  =  Math.max(delta,  0.1);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	int  paru  =  Math.max(delta,  0.1);	  int    paru    =    Math.max(delta,    0.0);    	non-compiled	[CE]  <identifier>  expected	94	None	replace
90	[BUG]  [BUGGY]  paru  =  1.0  /  Math.max(delta,  0.0);  [CE]  <identifier>  expected  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  paru  =  1.0  /  Math.max(delta,  0.0);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	paru  =  1.0  /  Math.max(delta,  0.0);	          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    paru    =    2.2251e-308    /    Math.max(delta,    0.0);    	non-compiled	[CE]  <identifier>  expected	47	None	replace
91	[BUG]  [BUGGY]  paru  =  0.5  /  Math.max(delta,  0.0);  [CE]  <identifier>  expected  [FE]      AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  paru  =  0.5  /  Math.max(delta,  0.0);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	paru  =  0.5  /  Math.max(delta,  0.0);	          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    paru    =    2.2251e-308    /    Math.max(delta,    0.0);    	non-compiled	[CE]  <identifier>  expected	47	None	replace
92	[BUG]  [BUGGY]  paru  =  2.0  /  Math.max(delta,  0.0);  [CE]  <identifier>  expected  [FE]        AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  paru  =  2.0  /  Math.max(delta,  0.0);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	paru  =  2.0  /  Math.max(delta,  0.0);	          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    paru    =    2.2251e-308    /    Math.max(delta,    0.0);    	non-compiled	[CE]  <identifier>  expected	47	None	replace
93	[BUG]  [BUGGY]  paru  =  0.0  /  Math.max(delta,  0.1);  [CE]  <identifier>  expected  [FE]          AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  paru  =  0.0  /  Math.max(delta,  0.1);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	paru  =  0.0  /  Math.max(delta,  0.1);	          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    paru    =    2.2251e-308    /    Math.max(delta,    0.0);    	non-compiled	[CE]  <identifier>  expected	47	None	replace
94	[BUG]  [BUGGY]  int  parl  =  Math.max(params,  2.0);  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  int  parl  =  Math.max(params,  2.0);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	int  parl  =  Math.max(params,  2.0);	  int    parl    =    Math.max(params,    1.0);    	non-compiled	[CE]  <identifier>  expected	137	None	replace
95	[BUG]  [BUGGY]  int  parl  =  Math.max(params,  10.0);  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  int  parl  =  Math.max(params,  10.0);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	int  parl  =  Math.max(params,  10.0);	  int    parl    =    Math.max(params,    1.0);    	non-compiled	[CE]  <identifier>  expected	137	None	replace
96	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(dxNorm  >  0.0)  {  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	add	if(dxNorm  >  0.0)  {	  if(param    >    0.0)    {    	compilable	  [FE]  AssertionFailedError  	120	4	replace
97	[BUG]  [BUGGY]  if(dxNorm  >  0.0)  {  [FE]  AssertionFailedError  [FE]        AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(dxNorm  >  0.0)  {  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(dxNorm  >  0.0)  {	  if(param    >    0.0)    {    	compilable	  [FE]  AssertionFailedError  	120	4	replace
98	[BUG]  [BUGGY]  paru  =  1.0  /  Math.min(delta,  0.5);if(paru  ==  0)  {  paru  =  1.0  /  Math.min(delta,  0.5);  }  [CE]  <identifier>  expected  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  paru  =  1.0  /  Math.min(delta,  0.5);if(paru  ==  0)  {  paru  =  1.0  /  Math.min(delta,  0.5);  }  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	paru  =  1.0  /  Math.min(delta,  0.5);if(paru  ==  0)  {  paru  =  1.0  /  Math.min(delta,  0.5);  }	          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.5);    }    else    {    paru    =    2.2251e-308    /    Math.min(delta,    0.5);    }    	non-compiled	[CE]  <identifier>  expected	25	None	replace
99	[BUG]  [BUGGY]  paru  =  0.5  /  Math.min(delta,  0.5);if(paru  ==  0)  {  paru  =  0.5  /  Math.min(delta,  0.5);  }  [CE]  <identifier>  expected  [FE]      AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  paru  =  0.5  /  Math.min(delta,  0.5);if(paru  ==  0)  {  paru  =  0.5  /  Math.min(delta,  0.5);  }  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	paru  =  0.5  /  Math.min(delta,  0.5);if(paru  ==  0)  {  paru  =  0.5  /  Math.min(delta,  0.5);  }	          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.5);    }    else    {    paru    =    2.2251e-308    /    Math.min(delta,    0.5);    }    	non-compiled	[CE]  <identifier>  expected	25	None	replace
100	[BUG]  [BUGGY]  paru  =  2.0  /  Math.max(delta,  1.0);  [CE]  <identifier>  expected  [FE]            AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  paru  =  2.0  /  Math.max(delta,  1.0);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	paru  =  2.0  /  Math.max(delta,  1.0);	  paru    =    2.0    /    Math.max(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	3	None	replace
101	[BUG]  [BUGGY]  paru  =  2.0  /  Math.max(paru,  0.1);  [CE]  <identifier>  expected  [FE]              AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  paru  =  2.0  /  Math.max(paru,  0.1);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	paru  =  2.0  /  Math.max(paru,  0.1);	  paru    =    2.0    /    Math.max(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	3	None	replace
102	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  else  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	add	                paru        =        2.2251e-308        /        Math.max(delta,        0.1);        if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.max(delta,    0.1);    }    else    {    paru    =    2.2251e-308    /    Math.max(delta,    0.1);    }    paru  =  2.2251e-308  /  Math.max(delta,  0.1);	  	compilable	  [FE]  AssertionFailedError  	125	4	add
103	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  else  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  else  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.max(delta,        0.1);        if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.max(delta,    0.1);    }    else    {    paru    =    2.2251e-308    /    Math.max(delta,    0.1);    }    paru  =  2.2251e-308  /  Math.max(delta,  0.1);	  	compilable	  [FE]  AssertionFailedError  	125	4	add
104	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  else  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  else  {  paru  =  2.2251e  [CE]  malformed  floating  point  literal  [FE]      AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  else  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  else  {  paru  =  2.2251e  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.max(delta,        0.1);        if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.max(delta,    0.1);    }    else    {    paru    =    2.2251e-308    /    Math.max(delta,    0.1);    }    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  else  {  paru  =  2.2251e	  	non-compiled	[CE]  malformed  floating  point  literal	125	None	add
105	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  else  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  else  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	add	                paru        =        2.2251e-308        /        Math.max(delta,        0.1);        if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.max(delta,    0.1);    }    else    {    paru    =    2.2251e-308    /    Math.max(delta,    0.1);    }    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  else  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }	  	compilable	  [FE]  AssertionFailedError  	125	4	add
106	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  else  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  else  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  else  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  else  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.max(delta,        0.1);        if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.max(delta,    0.1);    }    else    {    paru    =    2.2251e-308    /    Math.max(delta,    0.1);    }    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  else  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }	  	compilable	  [FE]  AssertionFailedError  	125	4	add
107	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  else  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  else  {  paru  =  2.2251e  [CE]  malformed  floating  point  literal  [FE]          AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  else  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  else  {  paru  =  2.2251e  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.max(delta,        0.1);        if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.max(delta,    0.1);    }    else    {    paru    =    2.2251e-308    /    Math.max(delta,    0.1);    }    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  else  {  paru  =  2.2251e	  	non-compiled	[CE]  malformed  floating  point  literal	125	None	add
108	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  else  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  [CE]  illegal  start  of  expression  [FE]            AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  else  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.max(delta,        0.1);        if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.max(delta,    0.1);    }    else    {    paru    =    2.2251e-308    /    Math.max(delta,    0.1);    }    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }	  	non-compiled	[CE]  illegal  start  of  expression	125	None	add
109	[BUG]  [BUGGY]  if(delta  <  0.0)  {  if(paru  ==  0.0)  {  [CE]  illegal  start  of  expression  [FE]              AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(delta  <  0.0)  {  if(paru  ==  0.0)  {  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(delta  <  0.0)  {  if(paru  ==  0.0)  {	  if(paru    >=    0.0)    {    if(paru    ==    0.0)    {    	non-compiled	[CE]  illegal  start  of  expression	14	None	replace
110	[BUG]  [BUGGY]  double  paru  =  1.0  /  Math.max(delta,  1.0);  [CE]  <identifier>  expected  [FE]                AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  double  paru  =  1.0  /  Math.max(delta,  1.0);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  paru  =  1.0  /  Math.max(delta,  1.0);	  double    paru    =    1.0    /    Math.max(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	102	None	replace
111	[BUG]  [BUGGY]  double  paru  =  1.0  /  Math.max(delta,  0.0);  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  double  paru  =  1.0  /  Math.max(delta,  0.0);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  paru  =  1.0  /  Math.max(delta,  0.0);	  double    paru    =    1.0    /    Math.max(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	102	None	replace
112	[BUG]  [BUGGY]  double  paru  =  2.0  /  Math.max(delta,  1.0);  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  double  paru  =  2.0  /  Math.max(delta,  1.0);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  paru  =  2.0  /  Math.max(delta,  1.0);	  double    paru    =    1.0    /    Math.max(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	102	None	replace
113	[BUG]  [BUGGY]  double  paru  =  1.0  /  Math.max(parl,  0.1);  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  double  paru  =  1.0  /  Math.max(parl,  0.1);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  paru  =  1.0  /  Math.max(parl,  0.1);	  double    paru    =    1.0    /    Math.max(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	102	None	replace
114	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(delta  >  0)  {  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	add	if(delta  >  0)  {	  if(paru    >    0)    {    	compilable	  [FE]  AssertionFailedError  	147	4	replace
115	[BUG]  [BUGGY]  if(delta  >  0)  {  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(delta  >  0)  {  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(delta  >  0)  {	  if(paru    >    0)    {    	compilable	  [FE]  AssertionFailedError  	147	4	replace
116	[BUG]  [BUGGY]  paru  =  2.2252e-308  /  Math.min(delta,  0.1);  [CE]  <identifier>  expected  [FE]          AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  paru  =  2.2252e-308  /  Math.min(delta,  0.1);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	paru  =  2.2252e-308  /  Math.min(delta,  0.1);	  paru    =    2.8    /    Math.min(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	128	None	replace
117	[BUG]  [BUGGY]  paru  =  2.8  /  Math.min(delta,  1.0);  [CE]  <identifier>  expected  [FE]            AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  paru  =  2.8  /  Math.min(delta,  1.0);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	paru  =  2.8  /  Math.min(delta,  1.0);	  paru    =    2.8    /    Math.min(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	128	None	replace
118	[BUG]  [BUGGY]  paru  =  0.0  /  Math.min(delta,  0.1);  [CE]  <identifier>  expected  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  paru  =  0.0  /  Math.min(delta,  0.1);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	paru  =  0.0  /  Math.min(delta,  0.1);	          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    paru    =    2.2251e-308    /    Math.min(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	35	None	replace
119	[BUG]  [BUGGY]  if(paru  >  0)  {  if(paru  >  0)  {  [CE]  illegal  start  of  expression  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(paru  >  0)  {  if(paru  >  0)  {  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(paru    >    0)    {    if(paru  >  0)  {	  	non-compiled	[CE]  illegal  start  of  expression	146	None	add
120	[BUG]  [BUGGY]  if(paru  >  0)  {  int  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  [CE]  illegal  start  of  expression  [FE]      AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(paru  >  0)  {  int  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(paru    >    0)    {    int  paru  =  2.2251e-308  /  Math.min(delta,  0.1);	  	non-compiled	[CE]  illegal  start  of  expression	146	None	add
121	[BUG]  [BUGGY]  if(paru  >  0)  {  If(paru  >  0)  {  [CE]  ';'  expected  [FE]        AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(paru  >  0)  {  If(paru  >  0)  {  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(paru    >    0)    {    If(paru  >  0)  {	  	non-compiled	[CE]  ';'  expected	146	None	add
122	[BUG]  [BUGGY]  if(paru  >  0)  {  int  paru  =  2.2251e-308  /  Math.min(delta,  0.2);  [CE]  illegal  start  of  expression  [FE]          AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(paru  >  0)  {  int  paru  =  2.2251e-308  /  Math.min(delta,  0.2);  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(paru    >    0)    {    int  paru  =  2.2251e-308  /  Math.min(delta,  0.2);	  	non-compiled	[CE]  illegal  start  of  expression	146	None	add
123	[BUG]  [BUGGY]  double  parl  =  diag[0];  [CE]  <identifier>  expected  [FE]            AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  double  parl  =  diag[0];  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  parl  =  diag[0];	  int    parl    =    diag[0];    	non-compiled	[CE]  <identifier>  expected	154	None	replace
124	[BUG]  [BUGGY]  int  parl  =  diag[1];  [CE]  <identifier>  expected  [FE]              AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  int  parl  =  diag[1];  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	int  parl  =  diag[1];	  int    parl    =    diag[0];    	non-compiled	[CE]  <identifier>  expected	154	None	replace
125	[BUG]  [BUGGY]  int  parl  =  gNorm[0];  [CE]  <identifier>  expected  [FE]                AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  int  parl  =  gNorm[0];  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	int  parl  =  gNorm[0];	  int    parl    =    diag[0];    	non-compiled	[CE]  <identifier>  expected	154	None	replace
126	[BUG]  [BUGGY]  double  parl  =  Math.max(paru,  1.0,  sum);  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  double  parl  =  Math.max(paru,  1.0,  sum);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  parl  =  Math.max(paru,  1.0,  sum);	  double    parl    =    Math.max(paru,    0.0,    sum);    	non-compiled	[CE]  <identifier>  expected	88	None	replace
127	[BUG]  [BUGGY]  double  parl  =  Math.max(sum,  0.0,  paru);  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  double  parl  =  Math.max(sum,  0.0,  paru);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  parl  =  Math.max(sum,  0.0,  paru);	  double    parl    =    Math.max(paru,    0.0,    sum);    	non-compiled	[CE]  <identifier>  expected	88	None	replace
128	[BUG]  [BUGGY]  double  parl  =  Math.max(paru,  0,  sum);  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  double  parl  =  Math.max(paru,  0,  sum);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  parl  =  Math.max(paru,  0,  sum);	  double    parl    =    Math.max(paru,    0.0,    sum);    	non-compiled	[CE]  <identifier>  expected	88	None	replace
129	[BUG]  [BUGGY]  double  parl  =  Math.max(paru,  2.0,  sum);  [CE]  <identifier>  expected  [FE]                        AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  double  parl  =  Math.max(paru,  2.0,  sum);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  parl  =  Math.max(paru,  2.0,  sum);	  double    parl    =    Math.max(paru,    0.0,    sum);    	non-compiled	[CE]  <identifier>  expected	88	None	replace
130	[BUG]  [BUGGY]  if(delta  ==  0.0)  {  if(delta  ==  0.0)  {  [CE]  illegal  start  of  expression  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(delta  ==  0.0)  {  if(delta  ==  0.0)  {  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(delta    ==    0.0)    {    if(delta  ==  0.0)  {	  	non-compiled	[CE]  illegal  start  of  expression	64	None	add
131	[BUG]  [BUGGY]  if(delta  ==  0.0)  {  If(delta  ==  0.0)  {  [CE]  ';'  expected  [FE]      AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(delta  ==  0.0)  {  If(delta  ==  0.0)  {  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(delta    ==    0.0)    {    If(delta  ==  0.0)  {	  	non-compiled	[CE]  ';'  expected	64	None	add
132	[BUG]  [BUGGY]  if(delta  ==  0.0)  {  if(delta  >=  0.0)  {  [CE]  illegal  start  of  expression  [FE]        AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(delta  ==  0.0)  {  if(delta  >=  0.0)  {  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(delta    ==    0.0)    {    if(delta  >=  0.0)  {	  	non-compiled	[CE]  illegal  start  of  expression	64	None	add
133	[BUG]  [BUGGY]  if(delta  ==  0.0)  {  if(delta!=  0.0)  {  [CE]  illegal  start  of  expression  [FE]          AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(delta  ==  0.0)  {  if(delta!=  0.0)  {  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(delta    ==    0.0)    {    if(delta!=  0.0)  {	  	non-compiled	[CE]  illegal  start  of  expression	64	None	add
134	[BUG]  [BUGGY]  paru  =  4.0  /  Math.min(delta,  1.0);  [CE]  <identifier>  expected  [FE]          AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  paru  =  4.0  /  Math.min(delta,  1.0);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	paru  =  4.0  /  Math.min(delta,  1.0);	  paru    =    4.0    /    Math.min(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	158	None	replace
135	[BUG]  [BUGGY]  paru  =  3.25  /  Math.min(delta,  0.1);  [CE]  <identifier>  expected  [FE]            AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  paru  =  3.25  /  Math.min(delta,  0.1);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	paru  =  3.25  /  Math.min(delta,  0.1);	  paru    =    4.0    /    Math.min(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	158	None	replace
136	[BUG]  [BUGGY]  double  parl  =  Math.max(paru,  2.0  /  2.0);  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  double  parl  =  Math.max(paru,  2.0  /  2.0);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  parl  =  Math.max(paru,  2.0  /  2.0);	  double    parl    =    Math.max(paru,    2.0);    	non-compiled	[CE]  <identifier>  expected	89	None	replace
137	[BUG]  [BUGGY]  paru  =  1.0  /  Math.max(delta,  1.0);  [CE]  <identifier>  expected  [FE]        AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  paru  =  1.0  /  Math.max(delta,  1.0);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	paru  =  1.0  /  Math.max(delta,  1.0);	  paru    =    1.0    /    Math.max(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	1	None	replace
138	[BUG]  [BUGGY]  paru  =  1.0  /  Math.max(paru,  0.1);  [CE]  <identifier>  expected  [FE]          AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  paru  =  1.0  /  Math.max(paru,  0.1);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	paru  =  1.0  /  Math.max(paru,  0.1);	  paru    =    1.0    /    Math.max(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	1	None	replace
139	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	add	                paru        =        2.2251e-308        /        Math.min(delta,        0.5);        if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.5);    }    paru  =  2.2251e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }	  	compilable	  [FE]  AssertionFailedError  	22	4	add
140	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.min(delta,        0.5);        if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.5);    }    paru  =  2.2251e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }	  	compilable	  [FE]  AssertionFailedError  	22	4	add
141	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  [CE]  illegal  start  of  expression  [FE]      AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.min(delta,        0.5);        if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.5);    }    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }	  	non-compiled	[CE]  illegal  start  of  expression	22	None	add
142	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  Paru  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  [CE]  cannot  find  symbol  [FE]        AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  Paru  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.min(delta,        0.5);        if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.5);    }    Paru  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }	  	non-compiled	[CE]  cannot  find  symbol	22	None	add
143	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  [CE]  illegal  start  of  expression  [FE]          AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.min(delta,        0.5);        if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.5);    }    paru  =  2.2251e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);	  	non-compiled	[CE]  illegal  start  of  expression	22	None	add
144	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    paru  =  2.2251e-308  /  Math.max(delta,  0.0);  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  paru  =  2.2251e-308  /  Math.max(delta,  0.0);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	add	                paru        =        2.2251e-308        /        Math.max(delta,        0.1);        paru    =    2.2251e-308    /    Math.max(delta,    0.0);    paru  =  2.2251e-308  /  Math.max(delta,  0.1);  paru  =  2.2251e-308  /  Math.max(delta,  0.0);	  	compilable	  [FE]  AssertionFailedError  	46	4	add
145	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    paru  =  2.2251e-308  /  Math.max(delta,  0.0);  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  paru  =  2.2251e-308  /  Math.max(delta,  0.0);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    paru  =  2.2251e-308  /  Math.max(delta,  0.0);  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  paru  =  2.2251e-308  /  Math.max(delta,  0.0);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.max(delta,        0.1);        paru    =    2.2251e-308    /    Math.max(delta,    0.0);    paru  =  2.2251e-308  /  Math.max(delta,  0.1);  paru  =  2.2251e-308  /  Math.max(delta,  0.0);	  	compilable	  [FE]  AssertionFailedError  	46	4	add
146	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    paru  =  2.2251e-308  /  Math.max(delta,  0.0);  Paru  =  2.2251e-308  /  Math.max(delta,  0.1);  paru  =  2.2251e-308  /  Math.max(delta,  0.0);  [CE]  cannot  find  symbol  Paru  [FE]      AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    paru  =  2.2251e-308  /  Math.max(delta,  0.0);  Paru  =  2.2251e-308  /  Math.max(delta,  0.1);  paru  =  2.2251e-308  /  Math.max(delta,  0.0);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.max(delta,        0.1);        paru    =    2.2251e-308    /    Math.max(delta,    0.0);    Paru  =  2.2251e-308  /  Math.max(delta,  0.1);  paru  =  2.2251e-308  /  Math.max(delta,  0.0);	  	non-compiled	[CE]  cannot  find  symbol  Paru	46	None	add
147	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    paru  =  2.2251e-308  /  Math.max(delta,  0.0);  paru  =  3.2251e-308  /  Math.max(delta,  0.1);  paru  =  2.2251e-308  /  Math.max(delta,  0.0);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	add	                paru        =        2.2251e-308        /        Math.max(delta,        0.1);        paru    =    2.2251e-308    /    Math.max(delta,    0.0);    paru  =  3.2251e-308  /  Math.max(delta,  0.1);  paru  =  2.2251e-308  /  Math.max(delta,  0.0);	  	compilable	  [FE]  AssertionFailedError  	46	4	add
148	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    paru  =  2.2251e-308  /  Math.max(delta,  0.0);  paru  =  3.2251e-308  /  Math.max(delta,  0.1);  paru  =  2.2251e-308  /  Math.max(delta,  0.0);  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    paru  =  2.2251e-308  /  Math.max(delta,  0.0);  paru  =  3.2251e-308  /  Math.max(delta,  0.1);  paru  =  2.2251e-308  /  Math.max(delta,  0.0);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.max(delta,        0.1);        paru    =    2.2251e-308    /    Math.max(delta,    0.0);    paru  =  3.2251e-308  /  Math.max(delta,  0.1);  paru  =  2.2251e-308  /  Math.max(delta,  0.0);	  	compilable	  [FE]  AssertionFailedError  	46	4	add
149	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    paru  =  2.2251e-308  /  Math.max(delta,  0.0);  paru  =  2.2252e-308  /  Math.max(delta,  0.1);  paru  =  2.2251e-308  /  Math.max(delta,  0.0);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	add	                paru        =        2.2251e-308        /        Math.max(delta,        0.1);        paru    =    2.2251e-308    /    Math.max(delta,    0.0);    paru  =  2.2252e-308  /  Math.max(delta,  0.1);  paru  =  2.2251e-308  /  Math.max(delta,  0.0);	  	compilable	  [FE]  AssertionFailedError  	46	4	add
150	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    paru  =  2.2251e-308  /  Math.max(delta,  0.0);  paru  =  2.2252e-308  /  Math.max(delta,  0.1);  paru  =  2.2251e-308  /  Math.max(delta,  0.0);  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    paru  =  2.2251e-308  /  Math.max(delta,  0.0);  paru  =  2.2252e-308  /  Math.max(delta,  0.1);  paru  =  2.2251e-308  /  Math.max(delta,  0.0);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.max(delta,        0.1);        paru    =    2.2251e-308    /    Math.max(delta,    0.0);    paru  =  2.2252e-308  /  Math.max(delta,  0.1);  paru  =  2.2251e-308  /  Math.max(delta,  0.0);	  	compilable	  [FE]  AssertionFailedError  	46	4	add
151	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    paru  =  2.2251e-308  /  Math.max(delta,  0.0);  paru  =  2.0  /  Math.max(delta,  0.1);  paru  =  2.0  /  Math.max(delta,  0.0);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	add	                paru        =        2.2251e-308        /        Math.max(delta,        0.1);        paru    =    2.2251e-308    /    Math.max(delta,    0.0);    paru  =  2.0  /  Math.max(delta,  0.1);  paru  =  2.0  /  Math.max(delta,  0.0);	  	compilable	  [FE]  AssertionFailedError  	46	3	add
152	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    paru  =  2.2251e-308  /  Math.max(delta,  0.0);  paru  =  2.0  /  Math.max(delta,  0.1);  paru  =  2.0  /  Math.max(delta,  0.0);  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    paru  =  2.2251e-308  /  Math.max(delta,  0.0);  paru  =  2.0  /  Math.max(delta,  0.1);  paru  =  2.0  /  Math.max(delta,  0.0);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.max(delta,        0.1);        paru    =    2.2251e-308    /    Math.max(delta,    0.0);    paru  =  2.0  /  Math.max(delta,  0.1);  paru  =  2.0  /  Math.max(delta,  0.0);	  	compilable	  [FE]  AssertionFailedError  	46	3	add
153	[BUG]  [BUGGY]  int  parl  =  Math.max(permutation,  2.0);  [CE]  <identifier>  expected  [FE]                        AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  int  parl  =  Math.max(permutation,  2.0);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	int  parl  =  Math.max(permutation,  2.0);	  int    parl    =    Math.max(permutation,    1.0);    	non-compiled	[CE]  <identifier>  expected	93	None	replace
154	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	add	                paru        =        2.2251e-308        /        Math.max(delta,        0.1);        if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.max(delta,    0.1);    }    if    (paru    ==    0)    {    paru    =    2.2251e-308    /    Math.max(delta,    0.1);    }    paru  =  2.2251e-308  /  Math.max(delta,  0.1);	  	compilable	  [FE]  AssertionFailedError  	123	4	add
155	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.max(delta,        0.1);        if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.max(delta,    0.1);    }    if    (paru    ==    0)    {    paru    =    2.2251e-308    /    Math.max(delta,    0.1);    }    paru  =  2.2251e-308  /  Math.max(delta,  0.1);	  	compilable	  [FE]  AssertionFailedError  	123	4	add
156	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  [CE]  illegal  start  of  expression  [FE]      AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.max(delta,        0.1);        if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.max(delta,    0.1);    }    if    (paru    ==    0)    {    paru    =    2.2251e-308    /    Math.max(delta,    0.1);    }    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }	  	non-compiled	[CE]  illegal  start  of  expression	123	None	add
157	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	add	                paru        =        2.2251e-308        /        Math.max(delta,        0.1);        if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.max(delta,    0.1);    }    if    (paru    ==    0)    {    paru    =    2.2251e-308    /    Math.max(delta,    0.1);    }    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }	  	compilable	  [FE]  AssertionFailedError  	123	4	add
158	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.max(delta,        0.1);        if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.max(delta,    0.1);    }    if    (paru    ==    0)    {    paru    =    2.2251e-308    /    Math.max(delta,    0.1);    }    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }	  	compilable	  [FE]  AssertionFailedError  	123	4	add
159	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  [CE]  illegal  start  of  expression  [FE]          AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.max(delta,        0.1);        if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.max(delta,    0.1);    }    if    (paru    ==    0)    {    paru    =    2.2251e-308    /    Math.max(delta,    0.1);    }    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }	  	non-compiled	[CE]  illegal  start  of  expression	123	None	add
160	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	add	                paru        =        2.2251e-308        /        Math.max(delta,        0.1);        if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.max(delta,    0.1);    }    if    (paru    ==    0)    {    paru    =    2.2251e-308    /    Math.max(delta,    0.1);    }    paru  =  2.2251e-308  /  Math.max(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }	  	compilable	  [FE]  AssertionFailedError  	123	4	add
161	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.max(delta,        0.1);        if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.max(delta,    0.1);    }    if    (paru    ==    0)    {    paru    =    2.2251e-308    /    Math.max(delta,    0.1);    }    paru  =  2.2251e-308  /  Math.max(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }	  	compilable	  [FE]  AssertionFailedError  	123	4	add
162	[BUG]  [BUGGY]  double  parl  =  permutation[1];  [CE]  <identifier>  expected  [FE]            AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  double  parl  =  permutation[1];  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  parl  =  permutation[1];	  double    parl    =    permutation[0];    	non-compiled	[CE]  <identifier>  expected	60	None	replace
163	[BUG]  [BUGGY]  double  parl  =  permutation[0]  -  1;  [CE]  <identifier>  expected  [FE]              AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  double  parl  =  permutation[0]  -  1;  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  parl  =  permutation[0]  -  1;	  double    parl    =    permutation[0];    	non-compiled	[CE]  <identifier>  expected	60	None	replace
164	[BUG]  [BUGGY]  double  parl  =  permutation[0]  /  2;  [CE]  <identifier>  expected  [FE]                AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  double  parl  =  permutation[0]  /  2;  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  parl  =  permutation[0]  /  2;	  double    parl    =    permutation[0];    	non-compiled	[CE]  <identifier>  expected	60	None	replace
165	[BUG]  [BUGGY]  double  parl  =  permutation[0]  +  1;  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  double  parl  =  permutation[0]  +  1;  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  parl  =  permutation[0]  +  1;	  double    parl    =    permutation[0];    	non-compiled	[CE]  <identifier>  expected	60	None	replace
166	[BUG]  [BUGGY]  paru  =  0.2  /  Math.min(delta,  1.0);  [CE]  <identifier>  expected  [FE]              AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  paru  =  0.2  /  Math.min(delta,  1.0);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	paru  =  0.2  /  Math.min(delta,  1.0);	  paru    =    0.2    /    Math.min(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	59	None	replace
167	[BUG]  [BUGGY]  Integer  parl  =  Math.max(param,  0.0);  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  Integer  parl  =  Math.max(param,  0.0);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	Integer  parl  =  Math.max(param,  0.0);	  Integer    parl    =    Math.max(delta,    0.0);    	non-compiled	[CE]  <identifier>  expected	26	None	replace
168	[BUG]  [BUGGY]  double  parl  =  Math.max(delta,  1.0);  [CE]  <identifier>  expected  [FE]                AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  double  parl  =  Math.max(delta,  1.0);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  parl  =  Math.max(delta,  1.0);	  double    parl    =    Math.max(paru,    1.0);    	non-compiled	[CE]  <identifier>  expected	87	None	replace
169	[BUG]  [BUGGY]  double  parl  =  Math.min(delta,  0.5);  [CE]  <identifier>  expected  [FE]                AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  double  parl  =  Math.min(delta,  0.5);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  parl  =  Math.min(delta,  0.5);	  double    parl    =    Math.min(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	52	None	replace
170	[BUG]  [BUGGY]  double  parl  =  Math.min(delta,  0.0);  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  double  parl  =  Math.min(delta,  0.0);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  parl  =  Math.min(delta,  0.0);	  double    parl    =    Math.min(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	52	None	replace
171	[BUG]  [BUGGY]  double  parl  =  Math.min(delta,  0.2);  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  double  parl  =  Math.min(delta,  0.2);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  parl  =  Math.min(delta,  0.2);	  double    parl    =    Math.min(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	52	None	replace
172	[BUG]  [BUGGY]  paru  =  0.2  /  Math.max(delta,  1.0);  [CE]  <identifier>  expected  [FE]              AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  paru  =  0.2  /  Math.max(delta,  1.0);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	paru  =  0.2  /  Math.max(delta,  1.0);	  paru    =    0.2    /    Math.max(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	4	None	replace
173	[BUG]  [BUGGY]  int  parl  =  Math.min(paru,  0.5);  [CE]  <identifier>  expected  [FE]            AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  int  parl  =  Math.min(paru,  0.5);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	int  parl  =  Math.min(paru,  0.5);	  int    parl    =    Math.min(delta,    0.5);    	non-compiled	[CE]  <identifier>  expected	119	None	replace
174	[BUG]  [BUGGY]  int  parl  =  permutation[1]  +  1;  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  int  parl  =  permutation[1]  +  1;  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	int  parl  =  permutation[1]  +  1;	  int    parl    =    permutation[0]    +    1;    	non-compiled	[CE]  <identifier>  expected	63	None	replace
175	[BUG]  [BUGGY]  paru  =  0.5  /  Math.max(delta,  1.0);  [CE]  <identifier>  expected  [FE]          AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  paru  =  0.5  /  Math.max(delta,  1.0);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	paru  =  0.5  /  Math.max(delta,  1.0);	  paru    =    0.5    /    Math.max(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	2	None	replace
176	[BUG]  [BUGGY]  paru  =  0.5  /  Math.max(paru,  0.1);  [CE]  <identifier>  expected  [FE]            AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  paru  =  0.5  /  Math.max(paru,  0.1);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	paru  =  0.5  /  Math.max(paru,  0.1);	  paru    =    0.5    /    Math.max(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	2	None	replace
177	[BUG]  [BUGGY]  int  parl  =  Math.max(delta,  0.5);  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  int  parl  =  Math.max(delta,  0.5);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	int  parl  =  Math.max(delta,  0.5);	  int    parl    =    Math.max(delta,    1.0);    	non-compiled	[CE]  <identifier>  expected	91	None	replace
178	[BUG]  [BUGGY]  double  parl  =  Math.max(delta,  0.1);  [CE]  <identifier>  expected  [FE]              AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  double  parl  =  Math.max(delta,  0.1);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  parl  =  Math.max(delta,  0.1);	  double    parl    =    Math.max(delta,    0.0);    	non-compiled	[CE]  <identifier>  expected	86	None	replace
179	[BUG]  [BUGGY]  paru  =  0.0  /  Math.min(delta,  0.5);  [CE]  <identifier>  expected  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  paru  =  0.0  /  Math.min(delta,  0.5);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	paru  =  0.0  /  Math.min(delta,  0.5);	          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    paru    =    2.2251e-308    /    Math.min(delta,    0.5);    	non-compiled	[CE]  <identifier>  expected	20	None	replace
180	[BUG]  [BUGGY]  int  parl  =  Math.min(paru,  2.0);  [CE]  <identifier>  expected  [FE]                AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  int  parl  =  Math.min(paru,  2.0);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	int  parl  =  Math.min(paru,  2.0);	  int    parl    =    Math.min(paru,    1.0);    	non-compiled	[CE]  <identifier>  expected	53	None	replace
181	[BUG]  [BUGGY]  paru  =  2.3  /  Math.min(delta,  1.0);  [CE]  <identifier>  expected  [FE]        AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  paru  =  2.3  /  Math.min(delta,  1.0);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	paru  =  2.3  /  Math.min(delta,  1.0);	  paru    =    2.3    /    Math.min(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	157	None	replace
182	[BUG]  [BUGGY]  int  parl  =  Math.min(paru,  0,  parl.length);  [CE]  <identifier>  expected  [FE]              AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  int  parl  =  Math.min(paru,  0,  parl.length);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	int  parl  =  Math.min(paru,  0,  parl.length);	  int    parl    =    Math.min(paru,    0,    0.1);    	non-compiled	[CE]  <identifier>  expected	51	None	replace
183	[BUG]  [BUGGY]  int  parl  =  Math.min(paru,  2,  0.1);  [CE]  <identifier>  expected  [FE]                AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  int  parl  =  Math.min(paru,  2,  0.1);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	int  parl  =  Math.min(paru,  2,  0.1);	  int    parl    =    Math.min(paru,    0,    0.1);    	non-compiled	[CE]  <identifier>  expected	51	None	replace
184	[BUG]  [BUGGY]  int  parl  =  Math.min(paru,  0,  1.0);  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  int  parl  =  Math.min(paru,  0,  1.0);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	int  parl  =  Math.min(paru,  0,  1.0);	  int    parl    =    Math.min(paru,    0,    0.1);    	non-compiled	[CE]  <identifier>  expected	51	None	replace
185	[BUG]  [BUGGY]  int  parl  =  Math.min(paru,  2,  1.0);  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  int  parl  =  Math.min(paru,  2,  1.0);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	int  parl  =  Math.min(paru,  2,  1.0);	  int    parl    =    Math.min(paru,    0,    0.1);    	non-compiled	[CE]  <identifier>  expected	51	None	replace
186	[BUG]  [BUGGY]  int  parl  =  Math.max(param,  2.0);  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  int  parl  =  Math.max(param,  2.0);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	int  parl  =  Math.max(param,  2.0);	  int    parl    =    Math.max(param,    1.0);    	non-compiled	[CE]  <identifier>  expected	92	None	replace
187	[BUG]  [BUGGY]  paru  =  1.0  /  Math.max(delta,  0.1);if(paru  ==  0)  {  paru  =  1.0  /  Math.max(delta,  0.1);  }  [CE]  <identifier>  expected  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  paru  =  1.0  /  Math.max(delta,  0.1);if(paru  ==  0)  {  paru  =  1.0  /  Math.max(delta,  0.1);  }  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	paru  =  1.0  /  Math.max(delta,  0.1);if(paru  ==  0)  {  paru  =  1.0  /  Math.max(delta,  0.1);  }	          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.max(delta,    0.1);    }    if    (paru    ==    0)    {    paru    =    2.2251e-308    /    Math.max(delta,    0.1);    }    	non-compiled	[CE]  <identifier>  expected	124	None	replace
188	[BUG]  [BUGGY]  paru  =  0.5  /  Math.max(delta,  0.1);if(paru  ==  0)  {  paru  =  0.5  /  Math.max(delta,  0.1);  }  [CE]  <identifier>  expected  [FE]      AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  paru  =  0.5  /  Math.max(delta,  0.1);if(paru  ==  0)  {  paru  =  0.5  /  Math.max(delta,  0.1);  }  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	paru  =  0.5  /  Math.max(delta,  0.1);if(paru  ==  0)  {  paru  =  0.5  /  Math.max(delta,  0.1);  }	          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.max(delta,    0.1);    }    if    (paru    ==    0)    {    paru    =    2.2251e-308    /    Math.max(delta,    0.1);    }    	non-compiled	[CE]  <identifier>  expected	124	None	replace
189	[BUG]  [BUGGY]  double  paru  =  2.0  /  Math.max(delta,  0.0);  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  double  paru  =  2.0  /  Math.max(delta,  0.0);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  paru  =  2.0  /  Math.max(delta,  0.0);	  double    paru    =    2.0    /    Math.max(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	104	None	replace
190	[BUG]  [BUGGY]  double  paru  =  2.0  /  Math.max(delta,  0.5);  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  double  paru  =  2.0  /  Math.max(delta,  0.5);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  paru  =  2.0  /  Math.max(delta,  0.5);	  double    paru    =    2.0    /    Math.max(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	104	None	replace
191	[BUG]  [BUGGY]  int  paru  =  1.0  /  Math.min(delta,  0.2);  [CE]  <identifier>  expected  [FE]              AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  int  paru  =  1.0  /  Math.min(delta,  0.2);  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	int  paru  =  1.0  /  Math.min(delta,  0.2);	  if(paru    >    0.0)    {    int    paru    =    2.2251e-308    /    Math.min(delta,    0.2);    	non-compiled	[CE]  <identifier>  expected	81	None	replace
192	[BUG]  [BUGGY]  int  paru  =  0.5  /  Math.min(delta,  0.2);  [CE]  <identifier>  expected  [FE]                AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  int  paru  =  0.5  /  Math.min(delta,  0.2);  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	int  paru  =  0.5  /  Math.min(delta,  0.2);	  if(paru    >    0.0)    {    int    paru    =    2.2251e-308    /    Math.min(delta,    0.2);    	non-compiled	[CE]  <identifier>  expected	81	None	replace
193	[BUG]  [BUGGY]  int  paru  =  2.0  /  Math.min(delta,  0.2);  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  int  paru  =  2.0  /  Math.min(delta,  0.2);  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	int  paru  =  2.0  /  Math.min(delta,  0.2);	  if(paru    >    0.0)    {    int    paru    =    2.2251e-308    /    Math.min(delta,    0.2);    	non-compiled	[CE]  <identifier>  expected	81	None	replace
194	[BUG]  [BUGGY]  if(delta  >  0.0)  {  if(paru  >  0.0)  {  [CE]  illegal  start  of  expression  [FE]        AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(delta  >  0.0)  {  if(paru  >  0.0)  {  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(delta  >  0.0)  {  if(paru  >  0.0)  {	  if(paru    >    0.0)    {    if(paru    >    0.0)    {    	non-compiled	[CE]  illegal  start  of  expression	78	None	replace
195	[BUG]  [BUGGY]  if(delta  <  =  0.0)  {  if(paru  >  0.0)  {  [CE]  illegal  start  of  expression  [FE]          AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(delta  <  =  0.0)  {  if(paru  >  0.0)  {  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(delta  <  =  0.0)  {  if(paru  >  0.0)  {	  if(paru    >    0.0)    {    if(paru    >    0.0)    {    	non-compiled	[CE]  illegal  start  of  expression	78	None	replace
196	[BUG]  [BUGGY]  if(delta  <  0.0)  {  if(paru  >  0.0)  {  [CE]  illegal  start  of  expression  [FE]            AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(delta  <  0.0)  {  if(paru  >  0.0)  {  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(delta  <  0.0)  {  if(paru  >  0.0)  {	  if(paru    >    0.0)    {    if(paru    >    0.0)    {    	non-compiled	[CE]  illegal  start  of  expression	78	None	replace
197	[BUG]  [BUGGY]  double  paru  =  0.2e-308  /  Math.max(delta,  1.0);  [CE]  <identifier>  expected  [FE]                AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  double  paru  =  0.2e-308  /  Math.max(delta,  1.0);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  paru  =  0.2e-308  /  Math.max(delta,  1.0);	  double    paru    =    0.2e-308    /    Math.max(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	139	None	replace
198	[BUG]  [BUGGY]  double  paru  =  0.2e-308  /  Math.max(delta,  0.5);  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  double  paru  =  0.2e-308  /  Math.max(delta,  0.5);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  paru  =  0.2e-308  /  Math.max(delta,  0.5);	  double    paru    =    0.2e-308    /    Math.max(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	139	None	replace
199	[BUG]  [BUGGY]  double  parl  =  Math.max(work1,  Math.max(paru));  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  double  parl  =  Math.max(work1,  Math.max(paru));  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  parl  =  Math.max(work1,  Math.max(paru));	  double    parl    =    Math.max(work3,    Math.max(work1,    paru));    	non-compiled	[CE]  <identifier>  expected	84	None	replace
200	[BUG]  [BUGGY]  double  parl  =  Math.max(work3,  Math.max(paru,  work3));  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  double  parl  =  Math.max(work3,  Math.max(paru,  work3));  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  parl  =  Math.max(work3,  Math.max(paru,  work3));	  double    parl    =    Math.max(work3,    Math.max(work1,    paru));    	non-compiled	[CE]  <identifier>  expected	84	None	replace
201	[BUG]  [BUGGY]  double  parl  =  Math.max(paru,  Math.max(work1,  work3));  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  double  parl  =  Math.max(paru,  Math.max(work1,  work3));  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  parl  =  Math.max(paru,  Math.max(work1,  work3));	  double    parl    =    Math.max(work3,    Math.max(work1,    paru));    	non-compiled	[CE]  <identifier>  expected	84	None	replace
202	[BUG]  [BUGGY]  double  paru  =  1.0  /  Math.min(delta,  1.0);  [CE]  <identifier>  expected  [FE]              AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  double  paru  =  1.0  /  Math.min(delta,  1.0);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  paru  =  1.0  /  Math.min(delta,  1.0);	  double    paru    =    1.0    /    Math.min(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	74	None	replace
203	[BUG]  [BUGGY]  double  paru  =  1.0  /  Math.min(delta,  0.0);  [CE]  <identifier>  expected  [FE]                AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  double  paru  =  1.0  /  Math.min(delta,  0.0);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  paru  =  1.0  /  Math.min(delta,  0.0);	  double    paru    =    1.0    /    Math.min(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	74	None	replace
204	[BUG]  [BUGGY]  double  parl  =  Math.max(paru,  Math.max(work1,  sum),  work2);  [CE]  <identifier>  expected  [FE]              AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  double  parl  =  Math.max(paru,  Math.max(work1,  sum),  work2);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  parl  =  Math.max(paru,  Math.max(work1,  sum),  work2);	  double    parl    =    Math.max(paru,    Math.max(work1,    work2),    sum);    	non-compiled	[CE]  <identifier>  expected	82	None	replace
205	[BUG]  [BUGGY]  double  parl  =  Math.max(paru,  Math.max(work3,  work2),  sum);  [CE]  <identifier>  expected  [FE]                AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  double  parl  =  Math.max(paru,  Math.max(work3,  work2),  sum);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  parl  =  Math.max(paru,  Math.max(work3,  work2),  sum);	  double    parl    =    Math.max(paru,    Math.max(work1,    work2),    sum);    	non-compiled	[CE]  <identifier>  expected	82	None	replace
206	[BUG]  [BUGGY]  double  parl  =  Math.max(paru,  Math.max(work1,  sum),  work3);  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  double  parl  =  Math.max(paru,  Math.max(work1,  sum),  work3);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  parl  =  Math.max(paru,  Math.max(work1,  sum),  work3);	  double    parl    =    Math.max(paru,    Math.max(work1,    work2),    sum);    	non-compiled	[CE]  <identifier>  expected	82	None	replace
207	[BUG]  [BUGGY]  double  parl  =  Math.max(paru,  Math.min(work1,  work2),  sum);  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  double  parl  =  Math.max(paru,  Math.min(work1,  work2),  sum);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  parl  =  Math.max(paru,  Math.min(work1,  work2),  sum);	  double    parl    =    Math.max(paru,    Math.max(work1,    work2),    sum);    	non-compiled	[CE]  <identifier>  expected	82	None	replace
208	[BUG]  [BUGGY]  paru  =  2.2252e-308  /  Math.max(delta,  0.1);  [CE]  <identifier>  expected  [FE]        AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  paru  =  2.2252e-308  /  Math.max(delta,  0.1);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	paru  =  2.2252e-308  /  Math.max(delta,  0.1);	  paru    =    2.3    /    Math.max(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	151	None	replace
209	[BUG]  [BUGGY]  paru  =  2.3  /  Math.max(delta,  1.0);  [CE]  <identifier>  expected  [FE]          AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  paru  =  2.3  /  Math.max(delta,  1.0);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	paru  =  2.3  /  Math.max(delta,  1.0);	  paru    =    2.3    /    Math.max(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	151	None	replace
210	[BUG]  [BUGGY]  if(paru  >=  0)  {  if(paru  >=  0)  {  [CE]  illegal  start  of  expression  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(paru  >=  0)  {  if(paru  >=  0)  {  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(paru    >=    0)    {    if(paru  >=  0)  {	  	non-compiled	[CE]  illegal  start  of  expression	108	None	add
211	[BUG]  [BUGGY]  if(paru  >=  0)  {  if(paru!=  0)  {  [CE]  illegal  start  of  expression  [FE]      AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(paru  >=  0)  {  if(paru!=  0)  {  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(paru    >=    0)    {    if(paru!=  0)  {	  	non-compiled	[CE]  illegal  start  of  expression	108	None	add
212	[BUG]  [BUGGY]  if(paru  >=  0)  {  if(paru  >>  0)  {  [CE]  illegal  start  of  expression  [FE]        AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(paru  >=  0)  {  if(paru  >>  0)  {  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(paru    >=    0)    {    if(paru  >>  0)  {	  	non-compiled	[CE]  illegal  start  of  expression	108	None	add
213	[BUG]  [BUGGY]  if(paru  >=  0)  {  if(paru  ==  0)  {  [CE]  illegal  start  of  expression  [FE]          AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(paru  >=  0)  {  if(paru  ==  0)  {  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(paru    >=    0)    {    if(paru  ==  0)  {	  	non-compiled	[CE]  illegal  start  of  expression	108	None	add
214	[BUG]  [BUGGY]  if(paru  <  0.0)  {  if(paru  <  0.0)  {  [CE]  illegal  start  of  expression  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(paru  <  0.0)  {  if(paru  <  0.0)  {  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(paru    <    0.0)    {    if(paru  <  0.0)  {	  	non-compiled	[CE]  illegal  start  of  expression	48	None	add
215	[BUG]  [BUGGY]  if(paru  <  0.0)  {  If(paru  <  0.0)  {  [CE]  ';'  expected  [FE]      AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(paru  <  0.0)  {  If(paru  <  0.0)  {  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(paru    <    0.0)    {    If(paru  <  0.0)  {	  	non-compiled	[CE]  ';'  expected	48	None	add
216	[BUG]  [BUGGY]  if(paru  <  0.0)  {  if(paru  >=  0.0)  {  [CE]  illegal  start  of  expression  [FE]        AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(paru  <  0.0)  {  if(paru  >=  0.0)  {  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(paru    <    0.0)    {    if(paru  >=  0.0)  {	  	non-compiled	[CE]  illegal  start  of  expression	48	None	add
217	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    paru  =  2.2252e-308  /  Math.min(delta,  0.1);  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  paru  =  2.2252e-308  /  Math.min(delta,  0.1);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	add	                paru        =        2.2251e-308        /        Math.min(delta,        0.1);        paru    =    2.2252e-308    /    Math.min(delta,    0.1);    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  paru  =  2.2252e-308  /  Math.min(delta,  0.1);	  	compilable	  [FE]  AssertionFailedError  	141	4	add
218	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    paru  =  2.2252e-308  /  Math.min(delta,  0.1);  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  paru  =  2.2252e-308  /  Math.min(delta,  0.1);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    paru  =  2.2252e-308  /  Math.min(delta,  0.1);  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  paru  =  2.2252e-308  /  Math.min(delta,  0.1);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.min(delta,        0.1);        paru    =    2.2252e-308    /    Math.min(delta,    0.1);    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  paru  =  2.2252e-308  /  Math.min(delta,  0.1);	  	compilable	  [FE]  AssertionFailedError  	141	4	add
219	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    paru  =  2.2252e-308  /  Math.min(delta,  0.1);  Paru  =  2.2251e-308  /  Math.min(delta,  0.1);  paru  =  2.2252e-308  /  Math.min(delta,  0.1);  [CE]  cannot  find  symbol  Paru  [FE]      AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    paru  =  2.2252e-308  /  Math.min(delta,  0.1);  Paru  =  2.2251e-308  /  Math.min(delta,  0.1);  paru  =  2.2252e-308  /  Math.min(delta,  0.1);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.min(delta,        0.1);        paru    =    2.2252e-308    /    Math.min(delta,    0.1);    Paru  =  2.2251e-308  /  Math.min(delta,  0.1);  paru  =  2.2252e-308  /  Math.min(delta,  0.1);	  	non-compiled	[CE]  cannot  find  symbol  Paru	141	None	add
220	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    paru  =  2.2252e-308  /  Math.min(delta,  0.1);  paru  =  2.2252e-308  /  Math.min(delta,  0.1);  paru  =  2.2252e-308  /  Math.min(delta,  0.1);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	add	                paru        =        2.2251e-308        /        Math.min(delta,        0.1);        paru    =    2.2252e-308    /    Math.min(delta,    0.1);    paru  =  2.2252e-308  /  Math.min(delta,  0.1);  paru  =  2.2252e-308  /  Math.min(delta,  0.1);	  	compilable	  [FE]  AssertionFailedError  	141	4	add
221	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    paru  =  2.2252e-308  /  Math.min(delta,  0.1);  paru  =  2.2252e-308  /  Math.min(delta,  0.1);  paru  =  2.2252e-308  /  Math.min(delta,  0.1);  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    paru  =  2.2252e-308  /  Math.min(delta,  0.1);  paru  =  2.2252e-308  /  Math.min(delta,  0.1);  paru  =  2.2252e-308  /  Math.min(delta,  0.1);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.min(delta,        0.1);        paru    =    2.2252e-308    /    Math.min(delta,    0.1);    paru  =  2.2252e-308  /  Math.min(delta,  0.1);  paru  =  2.2252e-308  /  Math.min(delta,  0.1);	  	compilable	  [FE]  AssertionFailedError  	141	4	add
222	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    paru  =  2.2252e-308  /  Math.min(delta,  0.1);  paru  =  22251e-308  /  Math.min(delta,  0.1);  paru  =  2.2252e-308  /  Math.min(delta,  0.1);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	add	                paru        =        2.2251e-308        /        Math.min(delta,        0.1);        paru    =    2.2252e-308    /    Math.min(delta,    0.1);    paru  =  22251e-308  /  Math.min(delta,  0.1);  paru  =  2.2252e-308  /  Math.min(delta,  0.1);	  	compilable	  [FE]  AssertionFailedError  	141	4	add
223	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    paru  =  2.2252e-308  /  Math.min(delta,  0.1);  paru  =  22251e-308  /  Math.min(delta,  0.1);  paru  =  2.2252e-308  /  Math.min(delta,  0.1);  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    paru  =  2.2252e-308  /  Math.min(delta,  0.1);  paru  =  22251e-308  /  Math.min(delta,  0.1);  paru  =  2.2252e-308  /  Math.min(delta,  0.1);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.min(delta,        0.1);        paru    =    2.2252e-308    /    Math.min(delta,    0.1);    paru  =  22251e-308  /  Math.min(delta,  0.1);  paru  =  2.2252e-308  /  Math.min(delta,  0.1);	  	compilable	  [FE]  AssertionFailedError  	141	4	add
224	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    paru  =  2.2252e-308  /  Math.min(delta,  0.1);  paru  =  2.0  /  Math.min(delta,  0.1);  paru  =  2.0  /  Math.min(delta,  0.1);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	add	                paru        =        2.2251e-308        /        Math.min(delta,        0.1);        paru    =    2.2252e-308    /    Math.min(delta,    0.1);    paru  =  2.0  /  Math.min(delta,  0.1);  paru  =  2.0  /  Math.min(delta,  0.1);	  	compilable	  [FE]  AssertionFailedError  	141	3	add
225	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    paru  =  2.2252e-308  /  Math.min(delta,  0.1);  paru  =  2.0  /  Math.min(delta,  0.1);  paru  =  2.0  /  Math.min(delta,  0.1);  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    paru  =  2.2252e-308  /  Math.min(delta,  0.1);  paru  =  2.0  /  Math.min(delta,  0.1);  paru  =  2.0  /  Math.min(delta,  0.1);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.min(delta,        0.1);        paru    =    2.2252e-308    /    Math.min(delta,    0.1);    paru  =  2.0  /  Math.min(delta,  0.1);  paru  =  2.0  /  Math.min(delta,  0.1);	  	compilable	  [FE]  AssertionFailedError  	141	3	add
226	[BUG]  [BUGGY]  Integer  parl  =  Math.max(paru,  1.0,  sum);  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  Integer  parl  =  Math.max(paru,  1.0,  sum);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	Integer  parl  =  Math.max(paru,  1.0,  sum);	  Integer    parl    =    Math.max(paru,    0.0,    sum);    	non-compiled	[CE]  <identifier>  expected	28	None	replace
227	[BUG]  [BUGGY]  Integer  parl  =  Math.max(paru,  0,  sum);  [CE]  <identifier>  expected  [FE]                        AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  Integer  parl  =  Math.max(paru,  0,  sum);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	Integer  parl  =  Math.max(paru,  0,  sum);	  Integer    parl    =    Math.max(paru,    0.0,    sum);    	non-compiled	[CE]  <identifier>  expected	28	None	replace
228	[BUG]  [BUGGY]  Integer  parl  =  Math.max(sum,  0.0,  paru);  [CE]  <identifier>  expected  [FE]                          AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  Integer  parl  =  Math.max(sum,  0.0,  paru);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	Integer  parl  =  Math.max(sum,  0.0,  paru);	  Integer    parl    =    Math.max(paru,    0.0,    sum);    	non-compiled	[CE]  <identifier>  expected	28	None	replace
229	[BUG]  [BUGGY]  Integer  parl  =  Math.max(paru,  0.0,  sum  +  1);  [CE]  <identifier>  expected  [FE]                            AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  Integer  parl  =  Math.max(paru,  0.0,  sum  +  1);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	Integer  parl  =  Math.max(paru,  0.0,  sum  +  1);	  Integer    parl    =    Math.max(paru,    0.0,    sum);    	non-compiled	[CE]  <identifier>  expected	28	None	replace
230	[BUG]  [BUGGY]  double  paru  =  0.5  /  Math.max(delta,  1.0);  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  double  paru  =  0.5  /  Math.max(delta,  1.0);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  paru  =  0.5  /  Math.max(delta,  1.0);	  double    paru    =    0.5    /    Math.max(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	103	None	replace
231	[BUG]  [BUGGY]  double  paru  =  0.5  /  Math.max(delta,  0.0);  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  double  paru  =  0.5  /  Math.max(delta,  0.0);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  paru  =  0.5  /  Math.max(delta,  0.0);	  double    paru    =    0.5    /    Math.max(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	103	None	replace
232	[BUG]  [BUGGY]  double  paru  =  0.25  /  Math.max(delta,  0.1);  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  double  paru  =  0.25  /  Math.max(delta,  0.1);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  paru  =  0.25  /  Math.max(delta,  0.1);	  double    paru    =    0.5    /    Math.max(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	103	None	replace
233	[BUG]  [BUGGY]  double  parl  =  Math.max(work2,  Math.max(work1,  paru2));  [CE]  <identifier>  expected  [FE]              AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  double  parl  =  Math.max(work2,  Math.max(work1,  paru2));  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  parl  =  Math.max(work2,  Math.max(work1,  paru2));	  double    parl    =    Math.max(work3,    Math.max(work1,    paru2));    	non-compiled	[CE]  <identifier>  expected	148	None	replace
234	[BUG]  [BUGGY]  double  paru  =  0.2  /  Math.min(delta,  1.0);  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  double  paru  =  0.2  /  Math.min(delta,  1.0);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  paru  =  0.2  /  Math.min(delta,  1.0);	  double    paru    =    0.2    /    Math.min(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	77	None	replace
235	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	add	                paru        =        2.2251e-308        /        Math.min(delta,        0.1);        paru    =    2.2251e-308    /    Math.min(delta,    0.1);    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  paru  =  2.2251e-308  /  Math.min(delta,  0.1);	  	compilable	  [FE]  AssertionFailedError  	34	4	add
236	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.min(delta,        0.1);        paru    =    2.2251e-308    /    Math.min(delta,    0.1);    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  paru  =  2.2251e-308  /  Math.min(delta,  0.1);	  	compilable	  [FE]  AssertionFailedError  	34	4	add
237	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  Paru  =  2.2251e-308  /  Math.min(delta,  0.1);  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  [CE]  cannot  find  symbol  Paru  [FE]      AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  Paru  =  2.2251e-308  /  Math.min(delta,  0.1);  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.min(delta,        0.1);        paru    =    2.2251e-308    /    Math.min(delta,    0.1);    Paru  =  2.2251e-308  /  Math.min(delta,  0.1);  paru  =  2.2251e-308  /  Math.min(delta,  0.1);	  	non-compiled	[CE]  cannot  find  symbol  Paru	34	None	add
238	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  paru  =  22251e-308  /  Math.min(delta,  0.1);  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	add	                paru        =        2.2251e-308        /        Math.min(delta,        0.1);        paru    =    2.2251e-308    /    Math.min(delta,    0.1);    paru  =  22251e-308  /  Math.min(delta,  0.1);  paru  =  2.2251e-308  /  Math.min(delta,  0.1);	  	compilable	  [FE]  AssertionFailedError  	34	4	add
239	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  paru  =  22251e-308  /  Math.min(delta,  0.1);  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  paru  =  22251e-308  /  Math.min(delta,  0.1);  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.min(delta,        0.1);        paru    =    2.2251e-308    /    Math.min(delta,    0.1);    paru  =  22251e-308  /  Math.min(delta,  0.1);  paru  =  2.2251e-308  /  Math.min(delta,  0.1);	  	compilable	  [FE]  AssertionFailedError  	34	4	add
240	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  paru  =  2.2252e-308  /  Math.min(delta,  0.1);  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	add	                paru        =        2.2251e-308        /        Math.min(delta,        0.1);        paru    =    2.2251e-308    /    Math.min(delta,    0.1);    paru  =  2.2252e-308  /  Math.min(delta,  0.1);  paru  =  2.2251e-308  /  Math.min(delta,  0.1);	  	compilable	  [FE]  AssertionFailedError  	34	4	add
241	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  paru  =  2.2252e-308  /  Math.min(delta,  0.1);  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  paru  =  2.2252e-308  /  Math.min(delta,  0.1);  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.min(delta,        0.1);        paru    =    2.2251e-308    /    Math.min(delta,    0.1);    paru  =  2.2252e-308  /  Math.min(delta,  0.1);  paru  =  2.2251e-308  /  Math.min(delta,  0.1);	  	compilable	  [FE]  AssertionFailedError  	34	4	add
242	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  paru  =  2.0  /  Math.min(delta,  0.1);  paru  =  2.0  /  Math.min(delta,  0.1);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	add	                paru        =        2.2251e-308        /        Math.min(delta,        0.1);        paru    =    2.2251e-308    /    Math.min(delta,    0.1);    paru  =  2.0  /  Math.min(delta,  0.1);  paru  =  2.0  /  Math.min(delta,  0.1);	  	compilable	  [FE]  AssertionFailedError  	34	3	add
243	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  paru  =  2.0  /  Math.min(delta,  0.1);  paru  =  2.0  /  Math.min(delta,  0.1);  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  paru  =  2.0  /  Math.min(delta,  0.1);  paru  =  2.0  /  Math.min(delta,  0.1);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.min(delta,        0.1);        paru    =    2.2251e-308    /    Math.min(delta,    0.1);    paru  =  2.0  /  Math.min(delta,  0.1);  paru  =  2.0  /  Math.min(delta,  0.1);	  	compilable	  [FE]  AssertionFailedError  	34	3	add
244	[BUG]  [BUGGY]  double  parl  =  Math.max(work3,  Math.max(work1,  work2),  sum);  [CE]  <identifier>  expected  [FE]              AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  double  parl  =  Math.max(work3,  Math.max(work1,  work2),  sum);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  parl  =  Math.max(work3,  Math.max(work1,  work2),  sum);	  double    parl    =    Math.max(work3,    Math.max(work1,    work2));    	non-compiled	[CE]  <identifier>  expected	114	None	replace
245	[BUG]  [BUGGY]  double  parl  =  Math.max(work2,  Math.max(work1,  work2));  [CE]  <identifier>  expected  [FE]                AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  double  parl  =  Math.max(work2,  Math.max(work1,  work2));  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  parl  =  Math.max(work2,  Math.max(work1,  work2));	  double    parl    =    Math.max(work3,    Math.max(work1,    work2));    	non-compiled	[CE]  <identifier>  expected	114	None	replace
246	[BUG]  [BUGGY]  double  parl  =  Math.max(work3,  Math.max(work1,  work3));  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  double  parl  =  Math.max(work3,  Math.max(work1,  work3));  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  parl  =  Math.max(work3,  Math.max(work1,  work3));	  double    parl    =    Math.max(work3,    Math.max(work1,    work2));    	non-compiled	[CE]  <identifier>  expected	114	None	replace
247	[BUG]  [BUGGY]  double  parl  =  Math.max(work1,  work2);  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  double  parl  =  Math.max(work1,  work2);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  parl  =  Math.max(work1,  work2);	  double    parl    =    Math.max(work3,    Math.max(work1,    work2));    	non-compiled	[CE]  <identifier>  expected	114	None	replace
248	[BUG]  [BUGGY]  double  parl  =  Math.max(paru,  Math.max(work1,  paru));  [CE]  <identifier>  expected  [FE]                AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  double  parl  =  Math.max(paru,  Math.max(work1,  paru));  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  parl  =  Math.max(paru,  Math.max(work1,  paru));	  double    parl    =    Math.max(work2,    Math.max(work1,    paru));    	non-compiled	[CE]  <identifier>  expected	149	None	replace
249	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    paru  =  2.2251e-308  /  Math.min(delta,  0.5);  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	add	                paru        =        2.2251e-308        /        Math.min(delta,        0.5);        paru    =    2.2251e-308    /    Math.min(delta,    0.5);    paru  =  2.2251e-308  /  Math.min(delta,  0.5);  paru  =  2.2251e-308  /  Math.min(delta,  0.5);	  	compilable	  [FE]  AssertionFailedError  	19	4	add
250	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    paru  =  2.2251e-308  /  Math.min(delta,  0.5);  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    paru  =  2.2251e-308  /  Math.min(delta,  0.5);  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.min(delta,        0.5);        paru    =    2.2251e-308    /    Math.min(delta,    0.5);    paru  =  2.2251e-308  /  Math.min(delta,  0.5);  paru  =  2.2251e-308  /  Math.min(delta,  0.5);	  	compilable	  [FE]  AssertionFailedError  	19	4	add
251	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    paru  =  2.2251e-308  /  Math.min(delta,  0.5);  Paru  =  2.2251e-308  /  Math.min(delta,  0.5);  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  [CE]  cannot  find  symbol  Paru  [FE]      AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    paru  =  2.2251e-308  /  Math.min(delta,  0.5);  Paru  =  2.2251e-308  /  Math.min(delta,  0.5);  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.min(delta,        0.5);        paru    =    2.2251e-308    /    Math.min(delta,    0.5);    Paru  =  2.2251e-308  /  Math.min(delta,  0.5);  paru  =  2.2251e-308  /  Math.min(delta,  0.5);	  	non-compiled	[CE]  cannot  find  symbol  Paru	19	None	add
252	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    paru  =  2.2251e-308  /  Math.min(delta,  0.5);  paru  =  3.2251e-308  /  Math.min(delta,  0.5);  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	add	                paru        =        2.2251e-308        /        Math.min(delta,        0.5);        paru    =    2.2251e-308    /    Math.min(delta,    0.5);    paru  =  3.2251e-308  /  Math.min(delta,  0.5);  paru  =  2.2251e-308  /  Math.min(delta,  0.5);	  	compilable	  [FE]  AssertionFailedError  	19	4	add
253	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    paru  =  2.2251e-308  /  Math.min(delta,  0.5);  paru  =  3.2251e-308  /  Math.min(delta,  0.5);  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    paru  =  2.2251e-308  /  Math.min(delta,  0.5);  paru  =  3.2251e-308  /  Math.min(delta,  0.5);  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.min(delta,        0.5);        paru    =    2.2251e-308    /    Math.min(delta,    0.5);    paru  =  3.2251e-308  /  Math.min(delta,  0.5);  paru  =  2.2251e-308  /  Math.min(delta,  0.5);	  	compilable	  [FE]  AssertionFailedError  	19	4	add
254	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    paru  =  2.2251e-308  /  Math.min(delta,  0.5);  paru  =  2.2252e-308  /  Math.min(delta,  0.5);  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	add	                paru        =        2.2251e-308        /        Math.min(delta,        0.5);        paru    =    2.2251e-308    /    Math.min(delta,    0.5);    paru  =  2.2252e-308  /  Math.min(delta,  0.5);  paru  =  2.2251e-308  /  Math.min(delta,  0.5);	  	compilable	  [FE]  AssertionFailedError  	19	4	add
255	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    paru  =  2.2251e-308  /  Math.min(delta,  0.5);  paru  =  2.2252e-308  /  Math.min(delta,  0.5);  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    paru  =  2.2251e-308  /  Math.min(delta,  0.5);  paru  =  2.2252e-308  /  Math.min(delta,  0.5);  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.min(delta,        0.5);        paru    =    2.2251e-308    /    Math.min(delta,    0.5);    paru  =  2.2252e-308  /  Math.min(delta,  0.5);  paru  =  2.2251e-308  /  Math.min(delta,  0.5);	  	compilable	  [FE]  AssertionFailedError  	19	4	add
256	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    paru  =  2.2251e-308  /  Math.min(delta,  0.5);  paru  =  2.0  /  Math.min(delta,  0.5);  paru  =  2.0  /  Math.min(delta,  0.5);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	add	                paru        =        2.2251e-308        /        Math.min(delta,        0.5);        paru    =    2.2251e-308    /    Math.min(delta,    0.5);    paru  =  2.0  /  Math.min(delta,  0.5);  paru  =  2.0  /  Math.min(delta,  0.5);	  	compilable	  [FE]  AssertionFailedError  	19	3	add
257	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    paru  =  2.2251e-308  /  Math.min(delta,  0.5);  paru  =  2.0  /  Math.min(delta,  0.5);  paru  =  2.0  /  Math.min(delta,  0.5);  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    paru  =  2.2251e-308  /  Math.min(delta,  0.5);  paru  =  2.0  /  Math.min(delta,  0.5);  paru  =  2.0  /  Math.min(delta,  0.5);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.min(delta,        0.5);        paru    =    2.2251e-308    /    Math.min(delta,    0.5);    paru  =  2.0  /  Math.min(delta,  0.5);  paru  =  2.0  /  Math.min(delta,  0.5);	  	compilable	  [FE]  AssertionFailedError  	19	3	add
258	[BUG]  [BUGGY]  if(delta  <  =  0.0)  {  if(paru  ==  0.0)  {  [CE]  illegal  start  of  expression  [FE]        AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(delta  <  =  0.0)  {  if(paru  ==  0.0)  {  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(delta  <  =  0.0)  {  if(paru  ==  0.0)  {	  if(paru    ==    0.0)    {    if(paru    ==    0.0)    {    	non-compiled	[CE]  illegal  start  of  expression	98	None	replace
259	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(delta!=  0.0)  {  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	add	if(delta!=  0.0)  {	  if(paru    ==    0.0)    {    if(paru    ==    0.0)    {    	compilable	  [FE]  AssertionFailedError  	98	4	replace
260	[BUG]  [BUGGY]  if(delta!=  0.0)  {  [FE]  AssertionFailedError  [FE]          AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(delta!=  0.0)  {  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(delta!=  0.0)  {	  if(paru    ==    0.0)    {    if(paru    ==    0.0)    {    	compilable	  [FE]  AssertionFailedError  	98	4	replace
261	[BUG]  [BUGGY]  double  paru  =  0.5  /  Math.min(delta,  1.0);  [CE]  <identifier>  expected  [FE]                AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  double  paru  =  0.5  /  Math.min(delta,  1.0);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  paru  =  0.5  /  Math.min(delta,  1.0);	  double    paru    =    0.5    /    Math.min(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	75	None	replace
262	[BUG]  [BUGGY]  double  paru  =  0.5  /  Math.min(delta,  0.0);  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  double  paru  =  0.5  /  Math.min(delta,  0.0);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  paru  =  0.5  /  Math.min(delta,  0.0);	  double    paru    =    0.5    /    Math.min(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	75	None	replace
263	[BUG]  [BUGGY]  if(delta  ==  0.0)  {  if(paru!=  0.0)  {  [CE]  illegal  start  of  expression  [FE]              AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(delta  ==  0.0)  {  if(paru!=  0.0)  {  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(delta  ==  0.0)  {  if(paru!=  0.0)  {	  if(paru    ==    0.0)    {    if(paru!=    0.0)    {    	non-compiled	[CE]  illegal  start  of  expression	101	None	replace
264	[BUG]  [BUGGY]  if(delta  >=  0.0)  {  if(delta  >=  0.0)  {  [CE]  illegal  start  of  expression  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(delta  >=  0.0)  {  if(delta  >=  0.0)  {  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(delta    >=    0.0)    {    if(delta  >=  0.0)  {	  	non-compiled	[CE]  illegal  start  of  expression	5	None	add
265	[BUG]  [BUGGY]  if(delta  >=  0.0)  {  if(delta  >>  0.0)  {  [CE]  illegal  start  of  expression  [FE]      AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(delta  >=  0.0)  {  if(delta  >>  0.0)  {  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(delta    >=    0.0)    {    if(delta  >>  0.0)  {	  	non-compiled	[CE]  illegal  start  of  expression	5	None	add
266	[BUG]  [BUGGY]  if(delta  >=  0.0)  {  if(delta!=  0.0)  {  [CE]  illegal  start  of  expression  [FE]        AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(delta  >=  0.0)  {  if(delta!=  0.0)  {  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(delta    >=    0.0)    {    if(delta!=  0.0)  {	  	non-compiled	[CE]  illegal  start  of  expression	5	None	add
267	[BUG]  [BUGGY]  if(delta  >=  0.0)  {  if(delta  ==  0.0)  {  [CE]  illegal  start  of  expression  [FE]          AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(delta  >=  0.0)  {  if(delta  ==  0.0)  {  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(delta    >=    0.0)    {    if(delta  ==  0.0)  {	  	non-compiled	[CE]  illegal  start  of  expression	5	None	add
268	[BUG]  [BUGGY]  if(delta  >=  0.0)  {  If(paru  >=  0.0)  {  [CE]  ';'  expected  [FE]        AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(delta  >=  0.0)  {  If(paru  >=  0.0)  {  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(delta  >=  0.0)  {  If(paru  >=  0.0)  {	  if(paru    >=    0.0)    {    If(paru    >=    0.0)    {    	non-compiled	[CE]  ';'  expected	138	None	replace
269	[BUG]  [BUGGY]  if(delta  ==  0.0)  {  If(paru  >=  0.0)  {  [CE]  ';'  expected  [FE]          AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(delta  ==  0.0)  {  If(paru  >=  0.0)  {  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(delta  ==  0.0)  {  If(paru  >=  0.0)  {	  if(paru    >=    0.0)    {    If(paru    >=    0.0)    {    	non-compiled	[CE]  ';'  expected	138	None	replace
270	[BUG]  [BUGGY]  if(delta  <  0.0)  {  If(paru  >=  0.0)  {  [CE]  ';'  expected  [FE]            AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(delta  <  0.0)  {  If(paru  >=  0.0)  {  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(delta  <  0.0)  {  If(paru  >=  0.0)  {	  if(paru    >=    0.0)    {    If(paru    >=    0.0)    {    	non-compiled	[CE]  ';'  expected	138	None	replace
271	[BUG]  [BUGGY]  if(delta!=  0.0)  {  If(paru  >=  0.0)  {  [CE]  ';'  expected  [FE]              AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(delta!=  0.0)  {  If(paru  >=  0.0)  {  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(delta!=  0.0)  {  If(paru  >=  0.0)  {	  if(paru    >=    0.0)    {    If(paru    >=    0.0)    {    	non-compiled	[CE]  ';'  expected	138	None	replace
272	[BUG]  [BUGGY]  paru  =  2.2251e-308  /  Math.max(delta,  0.5);  [CE]  <identifier>  expected  [FE]          AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  paru  =  2.2251e-308  /  Math.max(delta,  0.5);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	paru  =  2.2251e-308  /  Math.max(delta,  0.5);	  paru    =    2.8    /    Math.max(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	107	None	replace
273	[BUG]  [BUGGY]  double  dxNorm  =  Math.min(paru,  Math.max(work1,  parl));  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  double  dxNorm  =  Math.min(paru,  Math.max(work1,  parl));  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  dxNorm  =  Math.min(paru,  Math.max(work1,  parl));	  double    dxNorm    =    Math.max(paru,    Math.max(work1,    parl));    	non-compiled	[CE]  <identifier>  expected	156	None	replace
274	[BUG]  [BUGGY]  double  dxNorm  =  Math.max(work3,  Math.max(paru,  parl));  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  double  dxNorm  =  Math.max(work3,  Math.max(paru,  parl));  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  dxNorm  =  Math.max(work3,  Math.max(paru,  parl));	  double    dxNorm    =    Math.max(paru,    Math.max(work1,    parl));    	non-compiled	[CE]  <identifier>  expected	156	None	replace
275	[BUG]  [BUGGY]  double  dxNorm  =  Math.max(paru,  Math.max(work3,  parl));  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  double  dxNorm  =  Math.max(paru,  Math.max(work3,  parl));  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  dxNorm  =  Math.max(paru,  Math.max(work3,  parl));	  double    dxNorm    =    Math.max(paru,    Math.max(work1,    parl));    	non-compiled	[CE]  <identifier>  expected	156	None	replace
276	[BUG]  [BUGGY]  Paru  =  2.2251e-308  /  Math.max(delta,  0.1);  [CE]  <identifier>  expected  [FE]          AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  Paru  =  2.2251e-308  /  Math.max(delta,  0.1);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	Paru  =  2.2251e-308  /  Math.max(delta,  0.1);	          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    Paru    =    2.2251e-308    /    Math.max(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	43	None	replace
277	[BUG]  [BUGGY]  Paru  =  2.0  /  Math.max(delta,  0.1);  [CE]  <identifier>  expected  [FE]            AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  Paru  =  2.0  /  Math.max(delta,  0.1);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	Paru  =  2.0  /  Math.max(delta,  0.1);	          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    Paru    =    2.2251e-308    /    Math.max(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	43	None	replace
278	[BUG]  [BUGGY]  Paru  =  0.5  /  Math.max(delta,  0.1);  [CE]  <identifier>  expected  [FE]              AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  Paru  =  0.5  /  Math.max(delta,  0.1);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	Paru  =  0.5  /  Math.max(delta,  0.1);	          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    Paru    =    2.2251e-308    /    Math.max(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	43	None	replace
279	[BUG]  [BUGGY]  Paru  =  1.0  /  Math.max(delta,  0.1);  [CE]  <identifier>  expected  [FE]                AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  Paru  =  1.0  /  Math.max(delta,  0.1);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	Paru  =  1.0  /  Math.max(delta,  0.1);	          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    Paru    =    2.2251e-308    /    Math.max(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	43	None	replace
280	[BUG]  [BUGGY]  double  paru  =  0.2e-308  /  Math.min(delta,  1.0);  [CE]  <identifier>  expected  [FE]              AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  double  paru  =  0.2e-308  /  Math.min(delta,  1.0);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  paru  =  0.2e-308  /  Math.min(delta,  1.0);	  double    paru    =    0.2e-308    /    Math.min(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	140	None	replace
281	[BUG]  [BUGGY]  double  paru  =  0.2e-308  /  Math.min(delta,  0.5);  [CE]  <identifier>  expected  [FE]                AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  double  paru  =  0.2e-308  /  Math.min(delta,  0.5);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  paru  =  0.2e-308  /  Math.min(delta,  0.5);	  double    paru    =    0.2e-308    /    Math.min(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	140	None	replace
282	[BUG]  [BUGGY]  int  parl  =  permutation[1]  &  0xFFFF;  [CE]  <identifier>  expected  [FE]              AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  int  parl  =  permutation[1]  &  0xFFFF;  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	int  parl  =  permutation[1]  &  0xFFFF;	  int    parl    =    permutation[1];    	non-compiled	[CE]  <identifier>  expected	61	None	replace
283	[BUG]  [BUGGY]  int  parl  =  permutation[2];  [CE]  <identifier>  expected  [FE]                AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  int  parl  =  permutation[2];  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	int  parl  =  permutation[2];	  int    parl    =    permutation[1];    	non-compiled	[CE]  <identifier>  expected	61	None	replace
284	[BUG]  [BUGGY]  int  paru  =  Math.max(paru,  0,  sum);  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  int  paru  =  Math.max(paru,  0,  sum);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	int  paru  =  Math.max(paru,  0,  sum);	  int    paru    =    Math.max(paru,    0.0,    sum);    	non-compiled	[CE]  <identifier>  expected	95	None	replace
285	[BUG]  [BUGGY]  int  paru  =  Math.max(paru,  1.0,  sum);  [CE]  <identifier>  expected  [FE]                        AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  int  paru  =  Math.max(paru,  1.0,  sum);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	int  paru  =  Math.max(paru,  1.0,  sum);	  int    paru    =    Math.max(paru,    0.0,    sum);    	non-compiled	[CE]  <identifier>  expected	95	None	replace
286	[BUG]  [BUGGY]  int  paru  =  Math.max(sum,  0.0,  paru);  [CE]  <identifier>  expected  [FE]                          AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  int  paru  =  Math.max(sum,  0.0,  paru);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	int  paru  =  Math.max(sum,  0.0,  paru);	  int    paru    =    Math.max(paru,    0.0,    sum);    	non-compiled	[CE]  <identifier>  expected	95	None	replace
287	[BUG]  [BUGGY]  int  paru  =  Math.max(paru,  0.5,  sum);  [CE]  <identifier>  expected  [FE]                            AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  int  paru  =  Math.max(paru,  0.5,  sum);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	int  paru  =  Math.max(paru,  0.5,  sum);	  int    paru    =    Math.max(paru,    0.0,    sum);    	non-compiled	[CE]  <identifier>  expected	95	None	replace
288	[BUG]  [BUGGY]  double  paru  =  Math.max(delta,  0.0);  [CE]  <identifier>  expected  [FE]                          AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  double  paru  =  Math.max(delta,  0.0);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  paru  =  Math.max(delta,  0.0);	  double    paru    =    Math.max(paru,    0.0);    	non-compiled	[CE]  <identifier>  expected	97	None	replace
289	[BUG]  [BUGGY]  double  paru  =  Math.max(paru,  1.0);  [CE]  <identifier>  expected  [FE]                            AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  double  paru  =  Math.max(paru,  1.0);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  paru  =  Math.max(paru,  1.0);	  double    paru    =    Math.max(paru,    0.0);    	non-compiled	[CE]  <identifier>  expected	97	None	replace
290	[BUG]  [BUGGY]  double  paru  =  Math.max(paru,  2.0);  [CE]  <identifier>  expected  [FE]                              AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  double  paru  =  Math.max(paru,  2.0);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  paru  =  Math.max(paru,  2.0);	  double    paru    =    Math.max(paru,    0.0);    	non-compiled	[CE]  <identifier>  expected	97	None	replace
291	[BUG]  [BUGGY]  if(paru  <  0)  {  if(paru  <  0)  {  [CE]  illegal  start  of  expression  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(paru  <  0)  {  if(paru  <  0)  {  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(paru    <    0)    {    if(paru  <  0)  {	  	non-compiled	[CE]  illegal  start  of  expression	71	None	add
292	[BUG]  [BUGGY]  if(paru  <  0)  {  If(paru  <  0)  {  [CE]  ';'  expected  [FE]      AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(paru  <  0)  {  If(paru  <  0)  {  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(paru    <    0)    {    If(paru  <  0)  {	  	non-compiled	[CE]  ';'  expected	71	None	add
293	[BUG]  [BUGGY]  if(paru  <  0)  {  if(paru  >=  0)  {  [CE]  illegal  start  of  expression  [FE]        AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(paru  <  0)  {  if(paru  >=  0)  {  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(paru    <    0)    {    if(paru  >=  0)  {	  	non-compiled	[CE]  illegal  start  of  expression	71	None	add
294	[BUG]  [BUGGY]  if(delta  >  0.0  ||  paru  >  1.0)  {  if(delta  >  0.0  ||  paru  >  1.0)  {  [CE]  illegal  start  of  expression  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(delta  >  0.0  ||  paru  >  1.0)  {  if(delta  >  0.0  ||  paru  >  1.0)  {  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(delta    >    0.0    ||    paru    >    1.0)    {    if(delta  >  0.0  ||  paru  >  1.0)  {	  	non-compiled	[CE]  illegal  start  of  expression	143	None	add
295	[BUG]  [BUGGY]  if(delta  >  0.0  ||  paru  >  1.0)  {  If(delta  >  0.0  ||  paru  >  1.0)  {  [CE]  ';'  expected  [FE]      AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(delta  >  0.0  ||  paru  >  1.0)  {  If(delta  >  0.0  ||  paru  >  1.0)  {  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(delta    >    0.0    ||    paru    >    1.0)    {    If(delta  >  0.0  ||  paru  >  1.0)  {	  	non-compiled	[CE]  ';'  expected	143	None	add
296	[BUG]  [BUGGY]  if(delta  >  0.0  ||  paru  >  1.0)  {  int  delta  =  0.0  ||  paru  >  1.0)  {  [CE]  ';'  expected  [FE]        AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(delta  >  0.0  ||  paru  >  1.0)  {  int  delta  =  0.0  ||  paru  >  1.0)  {  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(delta    >    0.0    ||    paru    >    1.0)    {    int  delta  =  0.0  ||  paru  >  1.0)  {	  	non-compiled	[CE]  ';'  expected	143	None	add
297	[BUG]  [BUGGY]  paru  =  2.0  /  Math.min(delta,  0.2);  [CE]  <identifier>  expected  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  paru  =  2.0  /  Math.min(delta,  0.2);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	paru  =  2.0  /  Math.min(delta,  0.2);	          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    paru    =    2.2251e-308    /    Math.min(delta,    0.2);    	non-compiled	[CE]  <identifier>  expected	40	None	replace
298	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	add	                paru        =        2.2251e-308        /        Math.max(delta,        0.1);        if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.max(delta,    0.1);    }    paru  =  2.2251e-308  /  Math.max(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }	  	compilable	  [FE]  AssertionFailedError  	44	4	add
299	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.max(delta,        0.1);        if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.max(delta,    0.1);    }    paru  =  2.2251e-308  /  Math.max(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }	  	compilable	  [FE]  AssertionFailedError  	44	4	add
300	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  [CE]  illegal  start  of  expression  [FE]      AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.max(delta,        0.1);        if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.max(delta,    0.1);    }    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }	  	non-compiled	[CE]  illegal  start  of  expression	44	None	add
301	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	add	                paru        =        2.2251e-308        /        Math.max(delta,        0.1);        if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.max(delta,    0.1);    }    paru  =  2.2251e-308  /  Math.max(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }	  	compilable	  [FE]  AssertionFailedError  	44	4	add
302	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.max(delta,        0.1);        if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.max(delta,    0.1);    }    paru  =  2.2251e-308  /  Math.max(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }	  	compilable	  [FE]  AssertionFailedError  	44	4	add
303	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  Paru  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  [CE]  cannot  find  symbol  [FE]          AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  Paru  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.max(delta,        0.1);        if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.max(delta,    0.1);    }    Paru  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }	  	non-compiled	[CE]  cannot  find  symbol	44	None	add
304	[BUG]  [BUGGY]  double  parl  =  Math.max(paru,  Math.max(delta,  1.0));  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  double  parl  =  Math.max(paru,  Math.max(delta,  1.0));  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  parl  =  Math.max(paru,  Math.max(delta,  1.0));	  double    parl    =    Math.max(paru,    Math.max(delta,    0.1));    	non-compiled	[CE]  <identifier>  expected	32	None	replace
305	[BUG]  [BUGGY]  double  parl  =  Math.max(paru,  Math.max(delta,  0.0));  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  double  parl  =  Math.max(paru,  Math.max(delta,  0.0));  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  parl  =  Math.max(paru,  Math.max(delta,  0.0));	  double    parl    =    Math.max(paru,    Math.max(delta,    0.1));    	non-compiled	[CE]  <identifier>  expected	32	None	replace
306	[BUG]  [BUGGY]  double  parl  =  Math.max(paru,  Math.max(delta,  0.5));  [CE]  <identifier>  expected  [FE]                        AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  double  parl  =  Math.max(paru,  Math.max(delta,  0.5));  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  parl  =  Math.max(paru,  Math.max(delta,  0.5));	  double    parl    =    Math.max(paru,    Math.max(delta,    0.1));    	non-compiled	[CE]  <identifier>  expected	32	None	replace
307	[BUG]  [BUGGY]  double  parl  =  Math.max(paru,  Math.max(delta,  2.0));  [CE]  <identifier>  expected  [FE]                          AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  double  parl  =  Math.max(paru,  Math.max(delta,  2.0));  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  parl  =  Math.max(paru,  Math.max(delta,  2.0));	  double    parl    =    Math.max(paru,    Math.max(delta,    0.1));    	non-compiled	[CE]  <identifier>  expected	32	None	replace
308	[BUG]  [BUGGY]  paru  =  0.5  /  Math.min(delta,  1.0);  [CE]  <identifier>  expected  [FE]          AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  paru  =  0.5  /  Math.min(delta,  1.0);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	paru  =  0.5  /  Math.min(delta,  1.0);	  paru    =    0.5    /    Math.min(delta,    0.5);    	non-compiled	[CE]  <identifier>  expected	16	None	replace
309	[BUG]  [BUGGY]  double  paru  =  0.2  /  Math.max(delta,  1.0);  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  double  paru  =  0.2  /  Math.max(delta,  1.0);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  paru  =  0.2  /  Math.max(delta,  1.0);	  double    paru    =    0.2    /    Math.max(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	105	None	replace
310	[BUG]  [BUGGY]  double  paru  =  0.2  /  Math.max(delta,  0.5);  [CE]  <identifier>  expected  [FE]                        AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  double  paru  =  0.2  /  Math.max(delta,  0.5);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  paru  =  0.2  /  Math.max(delta,  0.5);	  double    paru    =    0.2    /    Math.max(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	105	None	replace
311	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  else  {  paru  =  22251e-308  /  Math.min(delta,  0.5);  }  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	add	                paru        =        2.2251e-308        /        Math.min(delta,        0.5);        if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.5);    }    else    {    paru    =    22251e-308    /    Math.min(delta,    0.5);    }    paru  =  2.2251e-308  /  Math.min(delta,  0.5);	  	compilable	  [FE]  AssertionFailedError  	159	4	add
312	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  else  {  paru  =  22251e-308  /  Math.min(delta,  0.5);  }  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  else  {  paru  =  22251e-308  /  Math.min(delta,  0.5);  }  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.min(delta,        0.5);        if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.5);    }    else    {    paru    =    22251e-308    /    Math.min(delta,    0.5);    }    paru  =  2.2251e-308  /  Math.min(delta,  0.5);	  	compilable	  [FE]  AssertionFailedError  	159	4	add
313	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  else  {  paru  =  22251e-308  /  Math.min(delta,  0.5);  }  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	add	                paru        =        2.2251e-308        /        Math.min(delta,        0.5);        if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.5);    }    else    {    paru    =    22251e-308    /    Math.min(delta,    0.5);    }    paru  =  2.2251e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }	  	compilable	  [FE]  AssertionFailedError  	159	4	add
314	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  else  {  paru  =  22251e-308  /  Math.min(delta,  0.5);  }  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  else  {  paru  =  22251e-308  /  Math.min(delta,  0.5);  }  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.min(delta,        0.5);        if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.5);    }    else    {    paru    =    22251e-308    /    Math.min(delta,    0.5);    }    paru  =  2.2251e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }	  	compilable	  [FE]  AssertionFailedError  	159	4	add
315	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  else  {  paru  =  22251e-308  /  Math.min(delta,  0.5);  }  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  [CE]  illegal  start  of  expression  [FE]        AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  else  {  paru  =  22251e-308  /  Math.min(delta,  0.5);  }  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.min(delta,        0.5);        if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.5);    }    else    {    paru    =    22251e-308    /    Math.min(delta,    0.5);    }    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }	  	non-compiled	[CE]  illegal  start  of  expression	159	None	add
316	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  else  {  paru  =  22251e-308  /  Math.min(delta,  0.5);  }  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  else  {  paru  =  22251e  [CE]  malformed  floating  point  literal  [FE]          AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  else  {  paru  =  22251e-308  /  Math.min(delta,  0.5);  }  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  else  {  paru  =  22251e  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.min(delta,        0.5);        if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.5);    }    else    {    paru    =    22251e-308    /    Math.min(delta,    0.5);    }    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  else  {  paru  =  22251e	  	non-compiled	[CE]  malformed  floating  point  literal	159	None	add
317	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  else  {  paru  =  22251e-308  /  Math.min(delta,  0.5);  }  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  else  {  paru  [CE]  not  a  statement  [FE]            AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  else  {  paru  =  22251e-308  /  Math.min(delta,  0.5);  }  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  else  {  paru  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.min(delta,        0.5);        if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.5);    }    else    {    paru    =    22251e-308    /    Math.min(delta,    0.5);    }    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  else  {  paru	  	non-compiled	[CE]  not  a  statement	159	None	add
318	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(paru  <  0.0  ||  paru  >  2.0)  {  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	add	if(paru  <  0.0  ||  paru  >  2.0)  {	  if(paru    <    0.0)    {    	compilable	  [FE]  AssertionFailedError  	49	3	replace
319	[BUG]  [BUGGY]  if(paru  <  0.0  ||  paru  >  2.0)  {  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(paru  <  0.0  ||  paru  >  2.0)  {  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(paru  <  0.0  ||  paru  >  2.0)  {	  if(paru    <    0.0)    {    	compilable	  [FE]  AssertionFailedError  	49	3	replace
320	[BUG]  [BUGGY]  double  parl  =  Math.max(work1,  Math.max(paru,  work2));  [CE]  <identifier>  expected  [FE]                AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  double  parl  =  Math.max(work1,  Math.max(paru,  work2));  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  parl  =  Math.max(work1,  Math.max(paru,  work2));	  double    parl    =    Math.max(paru,    Math.max(work2,    work1));    	non-compiled	[CE]  <identifier>  expected	115	None	replace
321	[BUG]  [BUGGY]  double  parl  =  Math.max(paru,  Math.max(work1,  work1));  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  double  parl  =  Math.max(paru,  Math.max(work1,  work1));  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  parl  =  Math.max(paru,  Math.max(work1,  work1));	  double    parl    =    Math.max(paru,    Math.max(work2,    work1));    	non-compiled	[CE]  <identifier>  expected	115	None	replace
322	[BUG]  [BUGGY]  double  parl  =  Math.max(paru,  Math.max(work3,  work1));  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  double  parl  =  Math.max(paru,  Math.max(work3,  work1));  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  parl  =  Math.max(paru,  Math.max(work3,  work1));	  double    parl    =    Math.max(paru,    Math.max(work2,    work1));    	non-compiled	[CE]  <identifier>  expected	115	None	replace
323	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    paru  =  2.2251e-308  /  Math.max(delta,  0.1);  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	add	                paru        =        2.2251e-308        /        Math.max(delta,        0.1);        paru    =    2.2251e-308    /    Math.max(delta,    0.1);    paru  =  2.2251e-308  /  Math.max(delta,  0.1);  paru  =  2.2251e-308  /  Math.max(delta,  0.1);	  	compilable	  [FE]  AssertionFailedError  	41	4	add
324	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    paru  =  2.2251e-308  /  Math.max(delta,  0.1);  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    paru  =  2.2251e-308  /  Math.max(delta,  0.1);  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.max(delta,        0.1);        paru    =    2.2251e-308    /    Math.max(delta,    0.1);    paru  =  2.2251e-308  /  Math.max(delta,  0.1);  paru  =  2.2251e-308  /  Math.max(delta,  0.1);	  	compilable	  [FE]  AssertionFailedError  	41	4	add
325	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    paru  =  2.2251e-308  /  Math.max(delta,  0.1);  Paru  =  2.2251e-308  /  Math.max(delta,  0.1);  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  [CE]  cannot  find  symbol  Paru  [FE]      AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    paru  =  2.2251e-308  /  Math.max(delta,  0.1);  Paru  =  2.2251e-308  /  Math.max(delta,  0.1);  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.max(delta,        0.1);        paru    =    2.2251e-308    /    Math.max(delta,    0.1);    Paru  =  2.2251e-308  /  Math.max(delta,  0.1);  paru  =  2.2251e-308  /  Math.max(delta,  0.1);	  	non-compiled	[CE]  cannot  find  symbol  Paru	41	None	add
326	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    paru  =  2.2251e-308  /  Math.max(delta,  0.1);  paru  =  2.2252e-308  /  Math.max(delta,  0.1);  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	add	                paru        =        2.2251e-308        /        Math.max(delta,        0.1);        paru    =    2.2251e-308    /    Math.max(delta,    0.1);    paru  =  2.2252e-308  /  Math.max(delta,  0.1);  paru  =  2.2251e-308  /  Math.max(delta,  0.1);	  	compilable	  [FE]  AssertionFailedError  	41	4	add
327	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    paru  =  2.2251e-308  /  Math.max(delta,  0.1);  paru  =  2.2252e-308  /  Math.max(delta,  0.1);  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    paru  =  2.2251e-308  /  Math.max(delta,  0.1);  paru  =  2.2252e-308  /  Math.max(delta,  0.1);  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.max(delta,        0.1);        paru    =    2.2251e-308    /    Math.max(delta,    0.1);    paru  =  2.2252e-308  /  Math.max(delta,  0.1);  paru  =  2.2251e-308  /  Math.max(delta,  0.1);	  	compilable	  [FE]  AssertionFailedError  	41	4	add
328	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    paru  =  2.2251e-308  /  Math.max(delta,  0.1);  paru  =  3.2251e-308  /  Math.max(delta,  0.1);  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	add	                paru        =        2.2251e-308        /        Math.max(delta,        0.1);        paru    =    2.2251e-308    /    Math.max(delta,    0.1);    paru  =  3.2251e-308  /  Math.max(delta,  0.1);  paru  =  2.2251e-308  /  Math.max(delta,  0.1);	  	compilable	  [FE]  AssertionFailedError  	41	4	add
329	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    paru  =  2.2251e-308  /  Math.max(delta,  0.1);  paru  =  3.2251e-308  /  Math.max(delta,  0.1);  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    paru  =  2.2251e-308  /  Math.max(delta,  0.1);  paru  =  3.2251e-308  /  Math.max(delta,  0.1);  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.max(delta,        0.1);        paru    =    2.2251e-308    /    Math.max(delta,    0.1);    paru  =  3.2251e-308  /  Math.max(delta,  0.1);  paru  =  2.2251e-308  /  Math.max(delta,  0.1);	  	compilable	  [FE]  AssertionFailedError  	41	4	add
330	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    paru  =  2.2251e-308  /  Math.max(delta,  0.1);  paru  =  2.0  /  Math.max(delta,  0.1);  paru  =  2.0  /  Math.max(delta,  0.1);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	add	                paru        =        2.2251e-308        /        Math.max(delta,        0.1);        paru    =    2.2251e-308    /    Math.max(delta,    0.1);    paru  =  2.0  /  Math.max(delta,  0.1);  paru  =  2.0  /  Math.max(delta,  0.1);	  	compilable	  [FE]  AssertionFailedError  	41	3	add
331	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    paru  =  2.2251e-308  /  Math.max(delta,  0.1);  paru  =  2.0  /  Math.max(delta,  0.1);  paru  =  2.0  /  Math.max(delta,  0.1);  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    paru  =  2.2251e-308  /  Math.max(delta,  0.1);  paru  =  2.0  /  Math.max(delta,  0.1);  paru  =  2.0  /  Math.max(delta,  0.1);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.max(delta,        0.1);        paru    =    2.2251e-308    /    Math.max(delta,    0.1);    paru  =  2.0  /  Math.max(delta,  0.1);  paru  =  2.0  /  Math.max(delta,  0.1);	  	compilable	  [FE]  AssertionFailedError  	41	3	add
332	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(delta  <  0.0  ||  paru  >  1.0)  {  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	add	if(delta  <  0.0  ||  paru  >  1.0)  {	  if(delta    >    0.0    ||    paru    >    1.0)    {    	compilable	  [FE]  AssertionFailedError  	144	2	replace
333	[BUG]  [BUGGY]  if(delta  <  0.0  ||  paru  >  1.0)  {  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(delta  <  0.0  ||  paru  >  1.0)  {  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(delta  <  0.0  ||  paru  >  1.0)  {	  if(delta    >    0.0    ||    paru    >    1.0)    {    	compilable	  [FE]  AssertionFailedError  	144	2	replace
334	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(delta  >  0.0  &&  paru  >  1.0)  {  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	add	if(delta  >  0.0  &&  paru  >  1.0)  {	  if(delta    >    0.0    ||    paru    >    1.0)    {    	compilable	  [FE]  AssertionFailedError  	144	2	replace
335	[BUG]  [BUGGY]  if(delta  >  0.0  &&  paru  >  1.0)  {  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(delta  >  0.0  &&  paru  >  1.0)  {  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(delta  >  0.0  &&  paru  >  1.0)  {	  if(delta    >    0.0    ||    paru    >    1.0)    {    	compilable	  [FE]  AssertionFailedError  	144	2	replace
336	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(paru  >  0.0  ||  paru  >  1.0)  {  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	add	if(paru  >  0.0  ||  paru  >  1.0)  {	  if(delta    >    0.0    ||    paru    >    1.0)    {    	compilable	  [FE]  AssertionFailedError  	144	4	replace
337	[BUG]  [BUGGY]  if(paru  >  0.0  ||  paru  >  1.0)  {  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(paru  >  0.0  ||  paru  >  1.0)  {  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(paru  >  0.0  ||  paru  >  1.0)  {	  if(delta    >    0.0    ||    paru    >    1.0)    {    	compilable	  [FE]  AssertionFailedError  	144	4	replace
338	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]                AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(delta  <  0)  {  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	add	if(delta  <  0)  {	  if(delta    <    =    0)    {    	compilable	  [FE]  AssertionFailedError  	73	2	replace
339	[BUG]  [BUGGY]  if(delta  <  0)  {  [FE]  AssertionFailedError  [FE]                AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(delta  <  0)  {  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(delta  <  0)  {	  if(delta    <    =    0)    {    	compilable	  [FE]  AssertionFailedError  	73	2	replace
340	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]                  AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(delta  ==  0)  {  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	add	if(delta  ==  0)  {	  if(delta    <    =    0)    {    	compilable	  [FE]  AssertionFailedError  	73	2	replace
341	[BUG]  [BUGGY]  if(delta  ==  0)  {  [FE]  AssertionFailedError  [FE]                  AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(delta  ==  0)  {  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(delta  ==  0)  {	  if(delta    <    =    0)    {    	compilable	  [FE]  AssertionFailedError  	73	2	replace
342	[BUG]  [BUGGY]  if(param  <  =  0)  {  [CE]  illegal  start  of  expression  [FE]                    AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(param  <  =  0)  {  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(param  <  =  0)  {	  if(delta    <    =    0)    {    	non-compiled	[CE]  illegal  start  of  expression	73	None	replace
343	[BUG]  [BUGGY]  paru  =  2.2e-308  /  Math.max(delta,  1.0);  [CE]  <identifier>  expected  [FE]        AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  paru  =  2.2e-308  /  Math.max(delta,  1.0);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	paru  =  2.2e-308  /  Math.max(delta,  1.0);	  paru    =    2.2e-308    /    Math.max(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	106	None	replace
344	[BUG]  [BUGGY]  paru  =  2.2e-308  /  Math.max(delta,  0.5);  [CE]  <identifier>  expected  [FE]          AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  paru  =  2.2e-308  /  Math.max(delta,  0.5);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	paru  =  2.2e-308  /  Math.max(delta,  0.5);	  paru    =    2.2e-308    /    Math.max(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	106	None	replace
345	[BUG]  [BUGGY]  int  paru  =  1.0  /  Math.max(delta,  0.1);  [CE]  <identifier>  expected  [FE]        AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  int  paru  =  1.0  /  Math.max(delta,  0.1);  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	int  paru  =  1.0  /  Math.max(delta,  0.1);	  if(paru    >    0.0)    {    int    paru    =    2.2251e-308    /    Math.max(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	153	None	replace
346	[BUG]  [BUGGY]  int  paru  =  0.5  /  Math.max(delta,  0.1);  [CE]  <identifier>  expected  [FE]          AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  int  paru  =  0.5  /  Math.max(delta,  0.1);  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	int  paru  =  0.5  /  Math.max(delta,  0.1);	  if(paru    >    0.0)    {    int    paru    =    2.2251e-308    /    Math.max(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	153	None	replace
347	[BUG]  [BUGGY]  int  paru  =  2.0  /  Math.max(delta,  0.1);  [CE]  <identifier>  expected  [FE]            AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  int  paru  =  2.0  /  Math.max(delta,  0.1);  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	int  paru  =  2.0  /  Math.max(delta,  0.1);	  if(paru    >    0.0)    {    int    paru    =    2.2251e-308    /    Math.max(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	153	None	replace
348	[BUG]  [BUGGY]  int  paru  =  0.0  /  Math.max(delta,  0.1);  [CE]  <identifier>  expected  [FE]              AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  int  paru  =  0.0  /  Math.max(delta,  0.1);  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	int  paru  =  0.0  /  Math.max(delta,  0.1);	  if(paru    >    0.0)    {    int    paru    =    2.2251e-308    /    Math.max(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	153	None	replace
349	[BUG]  [BUGGY]  if(param  <  =  0.0)  {  [CE]  illegal  start  of  expression  [FE]            AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(param  <  =  0.0)  {  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(param  <  =  0.0)  {	  if(delta    <    =    0.0)    {    	non-compiled	[CE]  illegal  start  of  expression	66	None	replace
350	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  else  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	add	                paru        =        2.2251e-308        /        Math.min(delta,        0.1);        if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.1);    }    else    {    paru    =    2.2251e-308    /    Math.min(delta,    0.1);    }    paru  =  2.2251e-308  /  Math.min(delta,  0.1);	  	compilable	  [FE]  AssertionFailedError  	133	4	add
351	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  else  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  else  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.min(delta,        0.1);        if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.1);    }    else    {    paru    =    2.2251e-308    /    Math.min(delta,    0.1);    }    paru  =  2.2251e-308  /  Math.min(delta,  0.1);	  	compilable	  [FE]  AssertionFailedError  	133	4	add
352	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  else  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  else  {  paru  =  2.2251e  [CE]  malformed  floating  point  literal  [FE]      AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  else  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  else  {  paru  =  2.2251e  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.min(delta,        0.1);        if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.1);    }    else    {    paru    =    2.2251e-308    /    Math.min(delta,    0.1);    }    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  else  {  paru  =  2.2251e	  	non-compiled	[CE]  malformed  floating  point  literal	133	None	add
353	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  else  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  else  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	add	                paru        =        2.2251e-308        /        Math.min(delta,        0.1);        if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.1);    }    else    {    paru    =    2.2251e-308    /    Math.min(delta,    0.1);    }    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  else  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }	  	compilable	  [FE]  AssertionFailedError  	133	4	add
354	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  else  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  else  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  else  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  else  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.min(delta,        0.1);        if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.1);    }    else    {    paru    =    2.2251e-308    /    Math.min(delta,    0.1);    }    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  else  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }	  	compilable	  [FE]  AssertionFailedError  	133	4	add
355	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  else  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  [CE]  illegal  start  of  expression  [FE]          AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  else  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.min(delta,        0.1);        if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.1);    }    else    {    paru    =    2.2251e-308    /    Math.min(delta,    0.1);    }    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }	  	non-compiled	[CE]  illegal  start  of  expression	133	None	add
356	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  else  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  else  {  paru  =  2.2251e  [CE]  malformed  floating  point  literal  [FE]            AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  else  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  else  {  paru  =  2.2251e  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.min(delta,        0.1);        if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.1);    }    else    {    paru    =    2.2251e-308    /    Math.min(delta,    0.1);    }    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  else  {  paru  =  2.2251e	  	non-compiled	[CE]  malformed  floating  point  literal	133	None	add
357	[BUG]  [BUGGY]  paru  =  0.5  /  Math.min(delta,  0.0);  [CE]  <identifier>  expected  [FE]          AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  paru  =  0.5  /  Math.min(delta,  0.0);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	paru  =  0.5  /  Math.min(delta,  0.0);	  paru    =    0.5    /    Math.min(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	57	None	replace
358	[BUG]  [BUGGY]  paru  =  2.0  /  Math.min(delta,  0.0);  [CE]  <identifier>  expected  [FE]            AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  paru  =  2.0  /  Math.min(delta,  0.0);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	paru  =  2.0  /  Math.min(delta,  0.0);	  paru    =    2.0    /    Math.min(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	58	None	replace
359	[BUG]  [BUGGY]  double  parl  =  Math.max(paru,  Math.max(work2,  parl));  [CE]  <identifier>  expected  [FE]                AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  double  parl  =  Math.max(paru,  Math.max(work2,  parl));  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  parl  =  Math.max(paru,  Math.max(work2,  parl));	  double    parl    =    Math.max(paru,    Math.max(work1,    parl));    	non-compiled	[CE]  <identifier>  expected	155	None	replace
360	[BUG]  [BUGGY]  double  parl  =  Math.max(paru,  Math.max(work3,  parl));  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  double  parl  =  Math.max(paru,  Math.max(work3,  parl));  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  parl  =  Math.max(paru,  Math.max(work3,  parl));	  double    parl    =    Math.max(paru,    Math.max(work1,    parl));    	non-compiled	[CE]  <identifier>  expected	155	None	replace
361	[BUG]  [BUGGY]  double  parl  =  Math.min(paru,  Math.max(work1,  parl));  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  double  parl  =  Math.min(paru,  Math.max(work1,  parl));  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  parl  =  Math.min(paru,  Math.max(work1,  parl));	  double    parl    =    Math.max(paru,    Math.max(work1,    parl));    	non-compiled	[CE]  <identifier>  expected	155	None	replace
362	[BUG]  [BUGGY]  if(delta  ==  0.0)  {  If(paru  ==  0.0)  {  [CE]  ';'  expected  [FE]            AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(delta  ==  0.0)  {  If(paru  ==  0.0)  {  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(delta  ==  0.0)  {  If(paru  ==  0.0)  {	  if(paru    ==    0.0)    {    If(paru    ==    0.0)    {    	non-compiled	[CE]  ';'  expected	100	None	replace
363	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	add	                paru        =        2.2251e-308        /        Math.min(delta,        0.1);        if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.1);    }    if    (paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.1);    }    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }	  	compilable	  [FE]  AssertionFailedError  	131	4	add
364	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.min(delta,        0.1);        if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.1);    }    if    (paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.1);    }    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }	  	compilable	  [FE]  AssertionFailedError  	131	4	add
365	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  [CE]  illegal  start  of  expression  [FE]      AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.min(delta,        0.1);        if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.1);    }    if    (paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.1);    }    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }	  	non-compiled	[CE]  illegal  start  of  expression	131	None	add
366	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	add	                paru        =        2.2251e-308        /        Math.min(delta,        0.1);        if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.1);    }    if    (paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.1);    }    paru  =  2.2251e-308  /  Math.min(delta,  0.1);	  	compilable	  [FE]  AssertionFailedError  	131	4	add
367	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.min(delta,        0.1);        if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.1);    }    if    (paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.1);    }    paru  =  2.2251e-308  /  Math.min(delta,  0.1);	  	compilable	  [FE]  AssertionFailedError  	131	4	add
368	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	add	                paru        =        2.2251e-308        /        Math.min(delta,        0.1);        if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.1);    }    if    (paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.1);    }    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }	  	compilable	  [FE]  AssertionFailedError  	131	4	add
369	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.min(delta,        0.1);        if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.1);    }    if    (paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.1);    }    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }	  	compilable	  [FE]  AssertionFailedError  	131	4	add
370	[BUG]  [BUGGY]  paru  =  2.2e-308  /  Math.min(delta,  1.0);  [CE]  <identifier>  expected  [FE]        AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  paru  =  2.2e-308  /  Math.min(delta,  1.0);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	paru  =  2.2e-308  /  Math.min(delta,  1.0);	  paru    =    2.2e-308    /    Math.min(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	127	None	replace
371	[BUG]  [BUGGY]  int  parl  =  Math.min(params,  0.5);  [CE]  <identifier>  expected  [FE]            AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  int  parl  =  Math.min(params,  0.5);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	int  parl  =  Math.min(params,  0.5);	  int    parl    =    Math.min(params,    0.1);    	non-compiled	[CE]  <identifier>  expected	145	None	replace
372	[BUG]  [BUGGY]  int  parl  =  Math.min(params,  1.0);  [CE]  <identifier>  expected  [FE]              AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  int  parl  =  Math.min(params,  1.0);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	int  parl  =  Math.min(params,  1.0);	  int    parl    =    Math.min(params,    0.1);    	non-compiled	[CE]  <identifier>  expected	145	None	replace
373	[BUG]  [BUGGY]  int  parl  =  Math.min(delta,  0,  0.1);  [CE]  <identifier>  expected  [FE]                AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  int  parl  =  Math.min(delta,  0,  0.1);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	int  parl  =  Math.min(delta,  0,  0.1);	  int    parl    =    Math.min(params,    0.1);    	non-compiled	[CE]  <identifier>  expected	145	None	replace
374	[BUG]  [BUGGY]  int  parl  =  Math.max(delta,  0.1);  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  int  parl  =  Math.max(delta,  0.1);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	int  parl  =  Math.max(delta,  0.1);	  int    parl    =    Math.max(delta,    0.0);    	non-compiled	[CE]  <identifier>  expected	68	None	replace
375	[BUG]  [BUGGY]  int  parl  =  permutation[1]  &  0xfff;  [CE]  <identifier>  expected  [FE]              AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  int  parl  =  permutation[1]  &  0xfff;  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	int  parl  =  permutation[1]  &  0xfff;	  int    parl    =    permutation[1];    	non-compiled	[CE]  <identifier>  expected	61	None	replace
376	[BUG]  [BUGGY]  if(delta  >  0.0)  {  If(paru  >=  0.0)  {  [CE]  ';'  expected  [FE]        AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(delta  >  0.0)  {  If(paru  >=  0.0)  {  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(delta  >  0.0)  {  If(paru  >=  0.0)  {	  if(paru    >=    0.0)    {    If(paru    >=    0.0)    {    	non-compiled	[CE]  ';'  expected	138	None	replace
377	[BUG]  [BUGGY]  if(delta  <  =  0.0)  {  If(paru  >=  0.0)  {  [CE]  illegal  start  of  expression  [FE]          AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(delta  <  =  0.0)  {  If(paru  >=  0.0)  {  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(delta  <  =  0.0)  {  If(paru  >=  0.0)  {	  if(paru    >=    0.0)    {    If(paru    >=    0.0)    {    	non-compiled	[CE]  illegal  start  of  expression	138	None	replace
378	[BUG]  [BUGGY]  double  parl  =  Math.max(work3,  Math.max(work2,  paru));  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  double  parl  =  Math.max(work3,  Math.max(work2,  paru));  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  parl  =  Math.max(work3,  Math.max(work2,  paru));	  double    parl    =    Math.max(work3,    Math.max(work1,    paru));    	non-compiled	[CE]  <identifier>  expected	84	None	replace
379	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  else  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  else  {  paru  =  3.2251e  [CE]  malformed  floating  point  literal  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  else  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  else  {  paru  =  3.2251e  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.min(delta,        0.1);        if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.1);    }    else    {    paru    =    2.2251e-308    /    Math.min(delta,    0.1);    }    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  else  {  paru  =  3.2251e	  	non-compiled	[CE]  malformed  floating  point  literal	133	None	add
380	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  else  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  else  {  paru  =  2.2251  [CE]  ';'  expected  [FE]      AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  else  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  else  {  paru  =  2.2251  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.min(delta,        0.1);        if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.1);    }    else    {    paru    =    2.2251e-308    /    Math.min(delta,    0.1);    }    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  else  {  paru  =  2.2251	  	non-compiled	[CE]  ';'  expected	133	None	add
381	[BUG]  [BUGGY]  double  parl  =  Math.max(paru,  Math.min(work2,  work3));  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  double  parl  =  Math.max(paru,  Math.min(work2,  work3));  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  parl  =  Math.max(paru,  Math.min(work2,  work3));	  double    parl    =    Math.max(paru,    Math.max(work3,    work2));    	non-compiled	[CE]  <identifier>  expected	85	None	replace
382	[BUG]  [BUGGY]  double  parl  =  Math.max(paru,  Math.max(work2,  work3));  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  double  parl  =  Math.max(paru,  Math.max(work2,  work3));  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  parl  =  Math.max(paru,  Math.max(work2,  work3));	  double    parl    =    Math.max(paru,    Math.max(work3,    work2));    	non-compiled	[CE]  <identifier>  expected	85	None	replace
383	[BUG]  [BUGGY]  paru  =  2.8  /  Math.max(paru,  0.1);  [CE]  <identifier>  expected  [FE]          AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  paru  =  2.8  /  Math.max(paru,  0.1);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	paru  =  2.8  /  Math.max(paru,  0.1);	  paru    =    2.8    /    Math.max(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	107	None	replace
384	[BUG]  [BUGGY]  paru  =  2.7  /  Math.max(delta,  0.1);  [CE]  <identifier>  expected  [FE]            AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  paru  =  2.7  /  Math.max(delta,  0.1);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	paru  =  2.7  /  Math.max(delta,  0.1);	  paru    =    2.8    /    Math.max(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	107	None	replace
385	[BUG]  [BUGGY]  if(delta  <  =  0.0)  {  if(paru  >=  0.0)  {  [CE]  illegal  start  of  expression  [FE]              AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(delta  <  =  0.0)  {  if(paru  >=  0.0)  {  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(delta  <  =  0.0)  {  if(paru  >=  0.0)  {	  if(paru    >=    0.0)    {    if(paru    ==    0.0)    {    	non-compiled	[CE]  illegal  start  of  expression	14	None	replace
386	[BUG]  [BUGGY]  if(delta  >=  0.0)  {  if(paru  ==  0.0)  {  [CE]  illegal  start  of  expression  [FE]                AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(delta  >=  0.0)  {  if(paru  ==  0.0)  {  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(delta  >=  0.0)  {  if(paru  ==  0.0)  {	  if(paru    >=    0.0)    {    if(paru    ==    0.0)    {    	non-compiled	[CE]  illegal  start  of  expression	14	None	replace
387	[BUG]  [BUGGY]  double  parl  =  Math.max(work3,  Math.min(work2,  work3));  [CE]  <identifier>  expected  [FE]              AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  double  parl  =  Math.max(work3,  Math.min(work2,  work3));  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  parl  =  Math.max(work3,  Math.min(work2,  work3));	  double    parl    =    Math.max(work3,    Math.max(work1,    paru2));    	non-compiled	[CE]  <identifier>  expected	148	None	replace
388	[BUG]  [BUGGY]  double  parl  =  Math.max(paru,  Math.min(work1,  parl));  [CE]  <identifier>  expected  [FE]                AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  double  parl  =  Math.max(paru,  Math.min(work1,  parl));  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  parl  =  Math.max(paru,  Math.min(work1,  parl));	  double    parl    =    Math.max(paru,    Math.max(work1,    parl));    	non-compiled	[CE]  <identifier>  expected	155	None	replace
389	[BUG]  [BUGGY]  Integer  parl  =  Math.max(paru,  0.01);  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  Integer  parl  =  Math.max(paru,  0.01);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	Integer  parl  =  Math.max(paru,  0.01);	  Integer    parl    =    Math.max(paru,    1.0);    	non-compiled	[CE]  <identifier>  expected	27	None	replace
390	[BUG]  [BUGGY]  if(delta  >=  0.0)  {  If(delta  >=  0.0)  {  [CE]  ';'  expected  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(delta  >=  0.0)  {  If(delta  >=  0.0)  {  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(delta    >=    0.0)    {    If(delta  >=  0.0)  {	  	non-compiled	[CE]  ';'  expected	5	None	add
391	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  [CE]  illegal  start  of  expression  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.max(delta,        0.1);        if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.max(delta,    0.1);    }    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }	  	non-compiled	[CE]  illegal  start  of  expression	44	None	add
392	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	add	                paru        =        2.2251e-308        /        Math.max(delta,        0.1);        if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.max(delta,    0.1);    }    paru  =  2.2251e-308  /  Math.max(delta,  0.1);	  	compilable	  [FE]  AssertionFailedError  	44	4	add
393	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.max(delta,        0.1);        if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.max(delta,    0.1);    }    paru  =  2.2251e-308  /  Math.max(delta,  0.1);	  	compilable	  [FE]  AssertionFailedError  	44	4	add
394	[BUG]  [BUGGY]  double  parl  =  Math.max(parl,  0.0);  [CE]  <identifier>  expected  [FE]              AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  double  parl  =  Math.max(parl,  0.0);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  parl  =  Math.max(parl,  0.0);	  double    parl    =    Math.max(delta,    0.0);    	non-compiled	[CE]  <identifier>  expected	86	None	replace
395	[BUG]  [BUGGY]  paru  =  2.3  /  Math.max(paru,  0.1);  [CE]  <identifier>  expected  [FE]        AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  paru  =  2.3  /  Math.max(paru,  0.1);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	paru  =  2.3  /  Math.max(paru,  0.1);	  paru    =    2.3    /    Math.max(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	151	None	replace
396	[BUG]  [BUGGY]  if(delta  >  0.0)  {  int  delta  =  Math.max(paru,  0.0);  [CE]  illegal  start  of  expression  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(delta  >  0.0)  {  int  delta  =  Math.max(paru,  0.0);  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(delta    >    0.0)    {    int  delta  =  Math.max(paru,  0.0);	  	non-compiled	[CE]  illegal  start  of  expression	9	None	add
397	[BUG]  [BUGGY]  if(delta  >  0.0)  {  int  delta  =  Math.max(delta,  0.0);  [CE]  illegal  start  of  expression  [FE]      AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(delta  >  0.0)  {  int  delta  =  Math.max(delta,  0.0);  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(delta    >    0.0)    {    int  delta  =  Math.max(delta,  0.0);	  	non-compiled	[CE]  illegal  start  of  expression	9	None	add
398	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    paru  =  2.2251e-308  /  Math.max(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	add	                paru        =        2.2251e-308        /        Math.max(delta,        0.1);        paru    =    2.2251e-308    /    Math.max(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }	  	compilable	  [FE]  AssertionFailedError  	41	4	add
399	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    paru  =  2.2251e-308  /  Math.max(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    paru  =  2.2251e-308  /  Math.max(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.max(delta,        0.1);        paru    =    2.2251e-308    /    Math.max(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }	  	compilable	  [FE]  AssertionFailedError  	41	4	add
400	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    paru  =  2.2251e-308  /  Math.max(delta,  0.1);  paru  =  22251e-308  /  Math.max(delta,  0.1);  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	add	                paru        =        2.2251e-308        /        Math.max(delta,        0.1);        paru    =    2.2251e-308    /    Math.max(delta,    0.1);    paru  =  22251e-308  /  Math.max(delta,  0.1);  paru  =  2.2251e-308  /  Math.max(delta,  0.1);	  	compilable	  [FE]  AssertionFailedError  	41	4	add
401	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    paru  =  2.2251e-308  /  Math.max(delta,  0.1);  paru  =  22251e-308  /  Math.max(delta,  0.1);  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    paru  =  2.2251e-308  /  Math.max(delta,  0.1);  paru  =  22251e-308  /  Math.max(delta,  0.1);  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.max(delta,        0.1);        paru    =    2.2251e-308    /    Math.max(delta,    0.1);    paru  =  22251e-308  /  Math.max(delta,  0.1);  paru  =  2.2251e-308  /  Math.max(delta,  0.1);	  	compilable	  [FE]  AssertionFailedError  	41	4	add
402	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    paru  =  2.2251e-308  /  Math.max(delta,  0.1);  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	add	                paru        =        2.2251e-308        /        Math.max(delta,        0.1);        paru    =    2.2251e-308    /    Math.max(delta,    0.1);    paru  =  2.2251e-308  /  Math.max(delta,  0.1);	  	compilable	  [FE]  AssertionFailedError  	41	4	add
403	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    paru  =  2.2251e-308  /  Math.max(delta,  0.1);  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    paru  =  2.2251e-308  /  Math.max(delta,  0.1);  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.max(delta,        0.1);        paru    =    2.2251e-308    /    Math.max(delta,    0.1);    paru  =  2.2251e-308  /  Math.max(delta,  0.1);	  	compilable	  [FE]  AssertionFailedError  	41	4	add
404	[BUG]  [BUGGY]  int  paru  =.2251e-308  /  Math.min(delta,  0.0);  [CE]  <identifier>  expected  [FE]            AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  int  paru  =.2251e-308  /  Math.min(delta,  0.0);  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	int  paru  =.2251e-308  /  Math.min(delta,  0.0);	  if(paru    >    0.0)    {    int    paru    =    2.2251e-308    /    Math.min(delta,    0.0);    	non-compiled	[CE]  <identifier>  expected	80	None	replace
405	[BUG]  [BUGGY]  double  paru  =  2.2252e-308  /  Math.min(delta,  0.1);  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  double  paru  =  2.2252e-308  /  Math.min(delta,  0.1);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  paru  =  2.2252e-308  /  Math.min(delta,  0.1);	  double    paru    =    2.0    /    Math.min(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	76	None	replace
406	[BUG]  [BUGGY]  double  parl  =  Math.max(paru,  Math.max(work1,  work2),  sum  +  1);  [CE]  <identifier>  expected  [FE]              AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  double  parl  =  Math.max(paru,  Math.max(work1,  work2),  sum  +  1);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  parl  =  Math.max(paru,  Math.max(work1,  work2),  sum  +  1);	  double    parl    =    Math.max(paru,    Math.max(work1,    work2),    sum);    	non-compiled	[CE]  <identifier>  expected	82	None	replace
407	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(paru  ==  0.0)  {  paru  =  1.0  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  1.0  /  Math.min(delta,  0.5);  }  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	add	if(paru  ==  0.0)  {  paru  =  1.0  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  1.0  /  Math.min(delta,  0.5);  }	          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.5);    }    	compilable	  [FE]  AssertionFailedError  	23	2	replace
408	[BUG]  [BUGGY]  if(paru  ==  0.0)  {  paru  =  1.0  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  1.0  /  Math.min(delta,  0.5);  }  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(paru  ==  0.0)  {  paru  =  1.0  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  1.0  /  Math.min(delta,  0.5);  }  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(paru  ==  0.0)  {  paru  =  1.0  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  1.0  /  Math.min(delta,  0.5);  }	          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.5);    }    	compilable	  [FE]  AssertionFailedError  	23	2	replace
409	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  [CE]  illegal  start  of  expression  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.min(delta,        0.5);        if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.5);    }    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }	  	non-compiled	[CE]  illegal  start  of  expression	22	None	add
410	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  [CE]  illegal  start  of  expression  [FE]      AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.min(delta,        0.5);        if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.5);    }    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }	  	non-compiled	[CE]  illegal  start  of  expression	22	None	add
411	[BUG]  [BUGGY]  double  parl  =  Math.max(work1,  Math.max(work2));  [CE]  <identifier>  expected  [FE]                AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  double  parl  =  Math.max(work1,  Math.max(work2));  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  parl  =  Math.max(work1,  Math.max(work2));	  double    parl    =    Math.max(work2,    Math.max(work1,    paru));    	non-compiled	[CE]  <identifier>  expected	149	None	replace
412	[BUG]  [BUGGY]  double  parl  =  Math.max(work2,  Math.max(work3,  paru));  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  double  parl  =  Math.max(work2,  Math.max(work3,  paru));  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  parl  =  Math.max(work2,  Math.max(work3,  paru));	  double    parl    =    Math.max(work2,    Math.max(work1,    paru));    	non-compiled	[CE]  <identifier>  expected	149	None	replace
413	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  else  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  [CE]  illegal  start  of  expression  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  else  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.min(delta,        0.5);        if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.5);    }    else    {    paru    =    2.2251e-308    /    Math.min(delta,    0.5);    }    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }	  	non-compiled	[CE]  illegal  start  of  expression	24	None	add
414	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  else  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  [CE]  illegal  start  of  expression  [FE]      AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  else  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.min(delta,        0.5);        if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.5);    }    else    {    paru    =    2.2251e-308    /    Math.min(delta,    0.5);    }    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }	  	non-compiled	[CE]  illegal  start  of  expression	24	None	add
415	[BUG]  [BUGGY]  int  parl  =  Math.max(paru,  0.01);  [CE]  <identifier>  expected  [FE]                AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  int  parl  =  Math.max(paru,  0.01);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	int  parl  =  Math.max(paru,  0.01);	  int    parl    =    Math.max(paru,    0.0);    	non-compiled	[CE]  <identifier>  expected	67	None	replace
416	[BUG]  [BUGGY]  if(delta  <  0.0)  {  int  delta  =  Math.max(delta,  0.0);  [CE]  illegal  start  of  expression  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(delta  <  0.0)  {  int  delta  =  Math.max(delta,  0.0);  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(delta    <    0.0)    {    int  delta  =  Math.max(delta,  0.0);	  	non-compiled	[CE]  illegal  start  of  expression	7	None	add
417	[BUG]  [BUGGY]  if(delta  <  0.0)  {  int  delta  =  Math.max(paru,  0.0);  [CE]  illegal  start  of  expression  [FE]      AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(delta  <  0.0)  {  int  delta  =  Math.max(paru,  0.0);  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(delta    <    0.0)    {    int  delta  =  Math.max(paru,  0.0);	  	non-compiled	[CE]  illegal  start  of  expression	7	None	add
418	[BUG]  [BUGGY]  int  parl  =  Math.max(params,  0.5);  [CE]  <identifier>  expected  [FE]                AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  int  parl  =  Math.max(params,  0.5);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	int  parl  =  Math.max(params,  0.5);	  int    parl    =    Math.max(params,    0.0);    	non-compiled	[CE]  <identifier>  expected	113	None	replace
419	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  [CE]  illegal  start  of  expression  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.min(delta,        0.5);        if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.5);    }    if    (paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.5);    }    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }	  	non-compiled	[CE]  illegal  start  of  expression	111	None	add
420	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    paru  =  2.2251e-308  /  Math.max(delta,  0.0);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  paru  =  2.2251e-308  /  Math.max(delta,  0.0);  }  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	add	                paru        =        2.2251e-308        /        Math.max(delta,        0.1);        paru    =    2.2251e-308    /    Math.max(delta,    0.0);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  paru  =  2.2251e-308  /  Math.max(delta,  0.0);  }	  	compilable	  [FE]  AssertionFailedError  	46	4	add
421	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    paru  =  2.2251e-308  /  Math.max(delta,  0.0);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  paru  =  2.2251e-308  /  Math.max(delta,  0.0);  }  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    paru  =  2.2251e-308  /  Math.max(delta,  0.0);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  paru  =  2.2251e-308  /  Math.max(delta,  0.0);  }  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.max(delta,        0.1);        paru    =    2.2251e-308    /    Math.max(delta,    0.0);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  paru  =  2.2251e-308  /  Math.max(delta,  0.0);  }	  	compilable	  [FE]  AssertionFailedError  	46	4	add
422	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    paru  =  2.2251e-308  /  Math.max(delta,  0.0);  paru  =  22251e-308  /  Math.max(delta,  0.1);  paru  =  2.2251e-308  /  Math.max(delta,  0.0);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	add	                paru        =        2.2251e-308        /        Math.max(delta,        0.1);        paru    =    2.2251e-308    /    Math.max(delta,    0.0);    paru  =  22251e-308  /  Math.max(delta,  0.1);  paru  =  2.2251e-308  /  Math.max(delta,  0.0);	  	compilable	  [FE]  AssertionFailedError  	46	4	add
423	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    paru  =  2.2251e-308  /  Math.max(delta,  0.0);  paru  =  22251e-308  /  Math.max(delta,  0.1);  paru  =  2.2251e-308  /  Math.max(delta,  0.0);  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    paru  =  2.2251e-308  /  Math.max(delta,  0.0);  paru  =  22251e-308  /  Math.max(delta,  0.1);  paru  =  2.2251e-308  /  Math.max(delta,  0.0);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.max(delta,        0.1);        paru    =    2.2251e-308    /    Math.max(delta,    0.0);    paru  =  22251e-308  /  Math.max(delta,  0.1);  paru  =  2.2251e-308  /  Math.max(delta,  0.0);	  	compilable	  [FE]  AssertionFailedError  	46	4	add
424	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    paru  =  2.2251e-308  /  Math.max(delta,  0.0);  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	add	                paru        =        2.2251e-308        /        Math.max(delta,        0.1);        paru    =    2.2251e-308    /    Math.max(delta,    0.0);    paru  =  2.2251e-308  /  Math.max(delta,  0.1);	  	compilable	  [FE]  AssertionFailedError  	46	4	add
425	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    paru  =  2.2251e-308  /  Math.max(delta,  0.0);  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    paru  =  2.2251e-308  /  Math.max(delta,  0.0);  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.max(delta,        0.1);        paru    =    2.2251e-308    /    Math.max(delta,    0.0);    paru  =  2.2251e-308  /  Math.max(delta,  0.1);	  	compilable	  [FE]  AssertionFailedError  	46	4	add
426	[BUG]  [BUGGY]  double  parl  =  Math.max(paru,  0.5,  sum);  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  double  parl  =  Math.max(paru,  0.5,  sum);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  parl  =  Math.max(paru,  0.5,  sum);	  double    parl    =    Math.max(paru,    0.0,    sum);    	non-compiled	[CE]  <identifier>  expected	88	None	replace
427	[BUG]  [BUGGY]  double  parl  =  Math.max(paru,  Math.min(delta,  0.2));  [CE]  <identifier>  expected  [FE]                AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  double  parl  =  Math.max(paru,  Math.min(delta,  0.2));  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  parl  =  Math.max(paru,  Math.min(delta,  0.2));	  double    parl    =    Math.max(paru,    Math.min(delta,    0.1));    	non-compiled	[CE]  <identifier>  expected	30	None	replace
428	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	add	                paru        =        2.2251e-308        /        Math.min(delta,        0.1);        if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.1);    }    paru  =  2.2251e-308  /  Math.min(delta,  0.1);	  	compilable	  [FE]  AssertionFailedError  	37	4	add
429	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.min(delta,        0.1);        if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.1);    }    paru  =  2.2251e-308  /  Math.min(delta,  0.1);	  	compilable	  [FE]  AssertionFailedError  	37	4	add
430	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  if(paru  ==  0)  {  paru  =  3.2251e-308  /  Math.min(delta,  0.1);  }  [CE]  illegal  start  of  expression  [FE]      AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  if(paru  ==  0)  {  paru  =  3.2251e-308  /  Math.min(delta,  0.1);  }  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.min(delta,        0.1);        if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.1);    }    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  if(paru  ==  0)  {  paru  =  3.2251e-308  /  Math.min(delta,  0.1);  }	  	non-compiled	[CE]  illegal  start  of  expression	37	None	add
431	[BUG]  [BUGGY]  if(paru  >=  0)  {  If(paru  >=  0)  {  [CE]  ';'  expected  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(paru  >=  0)  {  If(paru  >=  0)  {  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(paru    >=    0)    {    If(paru  >=  0)  {	  	non-compiled	[CE]  ';'  expected	108	None	add
432	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    paru  =  2.2252e-308  /  Math.min(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  paru  =  2.2252e-308  /  Math.min(delta,  0.1);  }  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	add	                paru        =        2.2251e-308        /        Math.min(delta,        0.1);        paru    =    2.2252e-308    /    Math.min(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  paru  =  2.2252e-308  /  Math.min(delta,  0.1);  }	  	compilable	  [FE]  AssertionFailedError  	141	4	add
433	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    paru  =  2.2252e-308  /  Math.min(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  paru  =  2.2252e-308  /  Math.min(delta,  0.1);  }  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    paru  =  2.2252e-308  /  Math.min(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  paru  =  2.2252e-308  /  Math.min(delta,  0.1);  }  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.min(delta,        0.1);        paru    =    2.2252e-308    /    Math.min(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  paru  =  2.2252e-308  /  Math.min(delta,  0.1);  }	  	compilable	  [FE]  AssertionFailedError  	141	4	add
434	[BUG]  [BUGGY]  double  paru  =  2.0  /  Math.max(parl,  0.1);  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  double  paru  =  2.0  /  Math.max(parl,  0.1);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  paru  =  2.0  /  Math.max(parl,  0.1);	  double    paru    =    2.0    /    Math.max(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	104	None	replace
435	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	add	                paru        =        2.2251e-308        /        Math.min(delta,        0.1);        if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.1);    }    if    (paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.1);    }    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }	  	compilable	  [FE]  AssertionFailedError  	131	4	add
436	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.min(delta,        0.1);        if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.1);    }    if    (paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.1);    }    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }	  	compilable	  [FE]  AssertionFailedError  	131	4	add
437	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  if(paru  ==  0)  {  paru  =  3.2251e-308  /  Math.min(delta,  0.1);  }  [CE]  illegal  start  of  expression  [FE]      AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  if(paru  ==  0)  {  paru  =  3.2251e-308  /  Math.min(delta,  0.1);  }  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.min(delta,        0.1);        if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.1);    }    if    (paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.1);    }    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  if(paru  ==  0)  {  paru  =  3.2251e-308  /  Math.min(delta,  0.1);  }	  	non-compiled	[CE]  illegal  start  of  expression	131	None	add
438	[BUG]  [BUGGY]  if(delta  ==  0.0)  {  if(paru  ==  0.0)  {  [CE]  illegal  start  of  expression  [FE]        AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(delta  ==  0.0)  {  if(paru  ==  0.0)  {  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(delta  ==  0.0)  {  if(paru  ==  0.0)  {	  if(paru    ==    0.0)    {    if(paru    ==    0.0)    {    	non-compiled	[CE]  illegal  start  of  expression	98	None	replace
439	[BUG]  [BUGGY]  if(delta!=  0.0)  {  if(paru  ==  0.0)  {  [CE]  illegal  start  of  expression  [FE]          AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(delta!=  0.0)  {  if(paru  ==  0.0)  {  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(delta!=  0.0)  {  if(paru  ==  0.0)  {	  if(paru    ==    0.0)    {    if(paru    ==    0.0)    {    	non-compiled	[CE]  illegal  start  of  expression	98	None	replace
440	[BUG]  [BUGGY]  int  parl  =  Math.max(param,  0.5);  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  int  parl  =  Math.max(param,  0.5);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	int  parl  =  Math.max(param,  0.5);	  int    parl    =    Math.max(param,    1.0);    	non-compiled	[CE]  <identifier>  expected	92	None	replace
441	[BUG]  [BUGGY]  paru  =  2.7  /  Math.min(delta,  0.1);  [CE]  <identifier>  expected  [FE]          AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  paru  =  2.7  /  Math.min(delta,  0.1);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	paru  =  2.7  /  Math.min(delta,  0.1);	  paru    =    2.8    /    Math.min(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	128	None	replace
442	[BUG]  [BUGGY]  paru  =  2.3  /  Math.min(delta,  0.5);  [CE]  <identifier>  expected  [FE]        AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  paru  =  2.3  /  Math.min(delta,  0.5);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	paru  =  2.3  /  Math.min(delta,  0.5);	  paru    =    2.3    /    Math.min(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	157	None	replace
443	[BUG]  [BUGGY]  int  parl  =  permutation[1]  &  1;  [CE]  <identifier>  expected  [FE]            AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  int  parl  =  permutation[1]  &  1;  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	int  parl  =  permutation[1]  &  1;	  int    parl    =    permutation[0]    &    1;    	non-compiled	[CE]  <identifier>  expected	129	None	replace
444	[BUG]  [BUGGY]  double  parl  =  Math.max(work3,  Math.max(paru,  0));  [CE]  <identifier>  expected  [FE]                AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  double  parl  =  Math.max(work3,  Math.max(paru,  0));  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  parl  =  Math.max(work3,  Math.max(paru,  0));	  double    parl    =    Math.max(work3,    Math.max(paru,    work1));    	non-compiled	[CE]  <identifier>  expected	83	None	replace
445	[BUG]  [BUGGY]  if(delta  >  0.0  ||  paru  >  1.0)  {  if(delta  >  0.0  ||  paru  >  1.1)  {  [CE]  illegal  start  of  expression  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(delta  >  0.0  ||  paru  >  1.0)  {  if(delta  >  0.0  ||  paru  >  1.1)  {  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(delta    >    0.0    ||    paru    >    1.0)    {    if(delta  >  0.0  ||  paru  >  1.1)  {	  	non-compiled	[CE]  illegal  start  of  expression	143	None	add
446	[BUG]  [BUGGY]  if(delta  >  0.0  ||  paru  >  1.0)  {  int  delta  =  Math.max(delta,  0.0);  [CE]  illegal  start  of  expression  [FE]      AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(delta  >  0.0  ||  paru  >  1.0)  {  int  delta  =  Math.max(delta,  0.0);  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(delta    >    0.0    ||    paru    >    1.0)    {    int  delta  =  Math.max(delta,  0.0);	  	non-compiled	[CE]  illegal  start  of  expression	143	None	add
447	[BUG]  [BUGGY]  if(delta  ==  0.0)  {  int  delta  =  Math.max(delta,  0.0);  [CE]  illegal  start  of  expression  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(delta  ==  0.0)  {  int  delta  =  Math.max(delta,  0.0);  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(delta    ==    0.0)    {    int  delta  =  Math.max(delta,  0.0);	  	non-compiled	[CE]  illegal  start  of  expression	64	None	add
448	[BUG]  [BUGGY]  if(delta  ==  0.0)  {  int  delta  =  Math.max(paru,  0.0);  [CE]  illegal  start  of  expression  [FE]      AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(delta  ==  0.0)  {  int  delta  =  Math.max(paru,  0.0);  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(delta    ==    0.0)    {    int  delta  =  Math.max(paru,  0.0);	  	non-compiled	[CE]  illegal  start  of  expression	64	None	add
449	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	add	                paru        =        2.2251e-308        /        Math.min(delta,        0.1);        paru    =    2.2251e-308    /    Math.min(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }	  	compilable	  [FE]  AssertionFailedError  	34	4	add
450	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.min(delta,        0.1);        paru    =    2.2251e-308    /    Math.min(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }	  	compilable	  [FE]  AssertionFailedError  	34	4	add
451	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	add	                paru        =        2.2251e-308        /        Math.min(delta,        0.1);        paru    =    2.2251e-308    /    Math.min(delta,    0.1);    paru  =  2.2251e-308  /  Math.min(delta,  0.1);	  	compilable	  [FE]  AssertionFailedError  	34	4	add
452	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.min(delta,        0.1);        paru    =    2.2251e-308    /    Math.min(delta,    0.1);    paru  =  2.2251e-308  /  Math.min(delta,  0.1);	  	compilable	  [FE]  AssertionFailedError  	34	4	add
453	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  else  {  paru  =  22251e-308  /  Math.min(delta,  0.5);  }  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  else  {  paru  =  2.2251e  [CE]  malformed  floating  point  literal  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  else  {  paru  =  22251e-308  /  Math.min(delta,  0.5);  }  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  else  {  paru  =  2.2251e  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.min(delta,        0.5);        if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.5);    }    else    {    paru    =    22251e-308    /    Math.min(delta,    0.5);    }    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  else  {  paru  =  2.2251e	  	non-compiled	[CE]  malformed  floating  point  literal	159	None	add
454	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  else  {  paru  =  22251e-308  /  Math.min(delta,  0.5);  }  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  [CE]  illegal  start  of  expression  [FE]      AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  else  {  paru  =  22251e-308  /  Math.min(delta,  0.5);  }  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.min(delta,        0.5);        if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.5);    }    else    {    paru    =    22251e-308    /    Math.min(delta,    0.5);    }    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }	  	non-compiled	[CE]  illegal  start  of  expression	159	None	add
455	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  else  {  paru  =  22251e-308  /  Math.min(delta,  0.5);  }  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  [CE]  illegal  start  of  expression  [FE]        AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  else  {  paru  =  22251e-308  /  Math.min(delta,  0.5);  }  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.min(delta,        0.5);        if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.5);    }    else    {    paru    =    22251e-308    /    Math.min(delta,    0.5);    }    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }	  	non-compiled	[CE]  illegal  start  of  expression	159	None	add
456	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(paru  ==  0)  {  paru  =  0.5e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  0.5e-308  /  Math.min(delta,  0.5);  }  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	add	if(paru  ==  0)  {  paru  =  0.5e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  0.5e-308  /  Math.min(delta,  0.5);  }	          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.5);    }    if    (paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.5);    }    	compilable	  [FE]  AssertionFailedError  	112	2	replace
457	[BUG]  [BUGGY]  if(paru  ==  0)  {  paru  =  0.5e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  0.5e-308  /  Math.min(delta,  0.5);  }  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(paru  ==  0)  {  paru  =  0.5e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  0.5e-308  /  Math.min(delta,  0.5);  }  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(paru  ==  0)  {  paru  =  0.5e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  0.5e-308  /  Math.min(delta,  0.5);  }	          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.5);    }    if    (paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.5);    }    	compilable	  [FE]  AssertionFailedError  	112	2	replace
458	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(paru  ==  0)  {  paru  =  1.0  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  1.0  /  Math.min(delta,  0.5);  }  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	add	if(paru  ==  0)  {  paru  =  1.0  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  1.0  /  Math.min(delta,  0.5);  }	          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.5);    }    if    (paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.5);    }    	compilable	  [FE]  AssertionFailedError  	112	2	replace
459	[BUG]  [BUGGY]  if(paru  ==  0)  {  paru  =  1.0  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  1.0  /  Math.min(delta,  0.5);  }  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(paru  ==  0)  {  paru  =  1.0  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  1.0  /  Math.min(delta,  0.5);  }  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(paru  ==  0)  {  paru  =  1.0  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  1.0  /  Math.min(delta,  0.5);  }	          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.5);    }    if    (paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.5);    }    	compilable	  [FE]  AssertionFailedError  	112	2	replace
460	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(paru  ==  0)  {  paru  =  1.0  /  Math.min(delta,  0.1);  if(paru  ==  0)  {  paru  =  1.0  /  Math.min(delta,  0.5);  }  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	add	if(paru  ==  0)  {  paru  =  1.0  /  Math.min(delta,  0.1);  if(paru  ==  0)  {  paru  =  1.0  /  Math.min(delta,  0.5);  }	          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.5);    }    if    (paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.5);    }    	compilable	  [FE]  AssertionFailedError  	112	2	replace
461	[BUG]  [BUGGY]  if(paru  ==  0)  {  paru  =  1.0  /  Math.min(delta,  0.1);  if(paru  ==  0)  {  paru  =  1.0  /  Math.min(delta,  0.5);  }  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(paru  ==  0)  {  paru  =  1.0  /  Math.min(delta,  0.1);  if(paru  ==  0)  {  paru  =  1.0  /  Math.min(delta,  0.5);  }  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(paru  ==  0)  {  paru  =  1.0  /  Math.min(delta,  0.1);  if(paru  ==  0)  {  paru  =  1.0  /  Math.min(delta,  0.5);  }	          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.5);    }    if    (paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.5);    }    	compilable	  [FE]  AssertionFailedError  	112	2	replace
462	[BUG]  [BUGGY]  int  paru  =.2251e-308  /  Math.min(delta,  0.1);  [CE]  <identifier>  expected  [FE]        AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  int  paru  =.2251e-308  /  Math.min(delta,  0.1);  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	int  paru  =.2251e-308  /  Math.min(delta,  0.1);	  if(paru    ==    0.0)    {    int    paru    =    2.2251e-308    /    Math.min(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	116	None	replace
463	[BUG]  [BUGGY]  if(paru  ==  0)  {  paru  =  0.5e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  0.5e-308  /  Math.min(delta,  0.5);  }  else  {  paru  =  0.5e  [CE]  malformed  floating  point  literal  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(paru  ==  0)  {  paru  =  0.5e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  0.5e-308  /  Math.min(delta,  0.5);  }  else  {  paru  =  0.5e  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(paru  ==  0)  {  paru  =  0.5e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  0.5e-308  /  Math.min(delta,  0.5);  }  else  {  paru  =  0.5e	          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.5);    }    else    {    paru    =    2.2251e-308    /    Math.min(delta,    0.5);    }    	non-compiled	[CE]  malformed  floating  point  literal	25	None	replace
464	[BUG]  [BUGGY]  if(paru  ==  0)  {  paru  =  0.5e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  0.5e-308  /  Math.min(delta,  0.5);  }  else  {  paru  =  0.5  [CE]  ';'  expected  [FE]      AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(paru  ==  0)  {  paru  =  0.5e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  0.5e-308  /  Math.min(delta,  0.5);  }  else  {  paru  =  0.5  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(paru  ==  0)  {  paru  =  0.5e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  0.5e-308  /  Math.min(delta,  0.5);  }  else  {  paru  =  0.5	          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.5);    }    else    {    paru    =    2.2251e-308    /    Math.min(delta,    0.5);    }    	non-compiled	[CE]  ';'  expected	25	None	replace
465	[BUG]  [BUGGY]  int  parl  =  diag[0]  -  1;  [CE]  <identifier>  expected  [FE]            AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  int  parl  =  diag[0]  -  1;  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	int  parl  =  diag[0]  -  1;	  int    parl    =    diag[0];    	non-compiled	[CE]  <identifier>  expected	154	None	replace
466	[BUG]  [BUGGY]  Integer  parl  =  Math.max(paru,  0.5,  sum);  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  Integer  parl  =  Math.max(paru,  0.5,  sum);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	Integer  parl  =  Math.max(paru,  0.5,  sum);	  Integer    parl    =    Math.max(paru,    0.0,    sum);    	non-compiled	[CE]  <identifier>  expected	28	None	replace
467	[BUG]  [BUGGY]  int  parl  =  permutation[0]  *  1;  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  int  parl  =  permutation[0]  *  1;  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	int  parl  =  permutation[0]  *  1;	  int    parl    =    permutation[0]    +    1;    	non-compiled	[CE]  <identifier>  expected	63	None	replace
468	[BUG]  [BUGGY]  double  dxNorm  =  Math.max(work3,  Math.max(work1,  parl));  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  double  dxNorm  =  Math.max(work3,  Math.max(work1,  parl));  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  dxNorm  =  Math.max(work3,  Math.max(work1,  parl));	  double    dxNorm    =    Math.max(paru,    Math.max(work1,    parl));    	non-compiled	[CE]  <identifier>  expected	156	None	replace
469	[BUG]  [BUGGY]  double  dxNorm  =  Math.max(paru,  Math.min(work1,  parl));  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  double  dxNorm  =  Math.max(paru,  Math.min(work1,  parl));  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  dxNorm  =  Math.max(paru,  Math.min(work1,  parl));	  double    dxNorm    =    Math.max(paru,    Math.max(work1,    parl));    	non-compiled	[CE]  <identifier>  expected	156	None	replace
470	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  [CE]  illegal  start  of  expression  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.max(delta,        0.1);        if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.max(delta,    0.1);    }    if    (paru    ==    0)    {    paru    =    2.2251e-308    /    Math.max(delta,    0.1);    }    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }	  	non-compiled	[CE]  illegal  start  of  expression	123	None	add
471	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    paru  =  2.2251e-308  /  Math.min(delta,  0.2);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  paru  =  2.2251e-308  /  Math.min(delta,  0.2);  }  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	add	                paru        =        2.2251e-308        /        Math.min(delta,        0.1);        paru    =    2.2251e-308    /    Math.min(delta,    0.2);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  paru  =  2.2251e-308  /  Math.min(delta,  0.2);  }	  	compilable	  [FE]  AssertionFailedError  	39	4	add
472	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    paru  =  2.2251e-308  /  Math.min(delta,  0.2);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  paru  =  2.2251e-308  /  Math.min(delta,  0.2);  }  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    paru  =  2.2251e-308  /  Math.min(delta,  0.2);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  paru  =  2.2251e-308  /  Math.min(delta,  0.2);  }  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.min(delta,        0.1);        paru    =    2.2251e-308    /    Math.min(delta,    0.2);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  paru  =  2.2251e-308  /  Math.min(delta,  0.2);  }	  	compilable	  [FE]  AssertionFailedError  	39	4	add
473	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    paru  =  2.2251e-308  /  Math.min(delta,  0.2);  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	add	                paru        =        2.2251e-308        /        Math.min(delta,        0.1);        paru    =    2.2251e-308    /    Math.min(delta,    0.2);    paru  =  2.2251e-308  /  Math.min(delta,  0.1);	  	compilable	  [FE]  AssertionFailedError  	39	4	add
474	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    paru  =  2.2251e-308  /  Math.min(delta,  0.2);  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    paru  =  2.2251e-308  /  Math.min(delta,  0.2);  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.min(delta,        0.1);        paru    =    2.2251e-308    /    Math.min(delta,    0.2);    paru  =  2.2251e-308  /  Math.min(delta,  0.1);	  	compilable	  [FE]  AssertionFailedError  	39	4	add
475	[BUG]  [BUGGY]  int  paru  =  1.0  /  Math.min(delta,  1.0);  [CE]  <identifier>  expected  [FE]            AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  int  paru  =  1.0  /  Math.min(delta,  1.0);  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	int  paru  =  1.0  /  Math.min(delta,  1.0);	  if(paru    ==    0.0)    {    int    paru    =    2.2251e-308    /    Math.min(delta,    0.2);    	non-compiled	[CE]  <identifier>  expected	118	None	replace
476	[BUG]  [BUGGY]  if(pj  >  0.0)  {  [CE]  cannot  find  symbol  pj  [FE]        AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(pj  >  0.0)  {  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(pj  >  0.0)  {	  if(param    >    0.0)    {    	non-compiled	[CE]  cannot  find  symbol  pj	120	None	replace
477	[BUG]  [BUGGY]  int  paru  =  Math.max(paru,  0.01);  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  int  paru  =  Math.max(paru,  0.01);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	int  paru  =  Math.max(paru,  0.01);	  int    paru    =    Math.max(paru,    0.5);    	non-compiled	[CE]  <identifier>  expected	121	None	replace
478	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  else  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  [CE]  illegal  start  of  expression  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  else  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.max(delta,        0.1);        if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.max(delta,    0.1);    }    else    {    paru    =    2.2251e-308    /    Math.max(delta,    0.1);    }    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }	  	non-compiled	[CE]  illegal  start  of  expression	125	None	add
479	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(paru  ==  0)  {  paru  =  1.0  /  Math.max(delta,  0.1);  if(paru  ==  0)  {  paru  =  1.0  /  Math.max(delta,  0.1);  }  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	add	if(paru  ==  0)  {  paru  =  1.0  /  Math.max(delta,  0.1);  if(paru  ==  0)  {  paru  =  1.0  /  Math.max(delta,  0.1);  }	          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.max(delta,    0.1);    }    if    (paru    ==    0)    {    paru    =    2.2251e-308    /    Math.max(delta,    0.1);    }    	compilable	  [FE]  AssertionFailedError  	124	2	replace
480	[BUG]  [BUGGY]  if(paru  ==  0)  {  paru  =  1.0  /  Math.max(delta,  0.1);  if(paru  ==  0)  {  paru  =  1.0  /  Math.max(delta,  0.1);  }  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(paru  ==  0)  {  paru  =  1.0  /  Math.max(delta,  0.1);  if(paru  ==  0)  {  paru  =  1.0  /  Math.max(delta,  0.1);  }  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(paru  ==  0)  {  paru  =  1.0  /  Math.max(delta,  0.1);  if(paru  ==  0)  {  paru  =  1.0  /  Math.max(delta,  0.1);  }	          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.max(delta,    0.1);    }    if    (paru    ==    0)    {    paru    =    2.2251e-308    /    Math.max(delta,    0.1);    }    	compilable	  [FE]  AssertionFailedError  	124	2	replace
481	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(gNorm  ==  0.0)  {  paru  =  1.0  /  Math.max(delta,  0.1);  if(paru  ==  0)  {  paru  =  1.0  /  Math.max(delta,  0.1);  }  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	add	if(gNorm  ==  0.0)  {  paru  =  1.0  /  Math.max(delta,  0.1);  if(paru  ==  0)  {  paru  =  1.0  /  Math.max(delta,  0.1);  }	          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.max(delta,    0.1);    }    if    (paru    ==    0)    {    paru    =    2.2251e-308    /    Math.max(delta,    0.1);    }    	compilable	  [FE]  AssertionFailedError  	124	2	replace
482	[BUG]  [BUGGY]  if(gNorm  ==  0.0)  {  paru  =  1.0  /  Math.max(delta,  0.1);  if(paru  ==  0)  {  paru  =  1.0  /  Math.max(delta,  0.1);  }  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(gNorm  ==  0.0)  {  paru  =  1.0  /  Math.max(delta,  0.1);  if(paru  ==  0)  {  paru  =  1.0  /  Math.max(delta,  0.1);  }  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(gNorm  ==  0.0)  {  paru  =  1.0  /  Math.max(delta,  0.1);  if(paru  ==  0)  {  paru  =  1.0  /  Math.max(delta,  0.1);  }	          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.max(delta,    0.1);    }    if    (paru    ==    0)    {    paru    =    2.2251e-308    /    Math.max(delta,    0.1);    }    	compilable	  [FE]  AssertionFailedError  	124	2	replace
483	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(paru  ==  0)  {  paru  =  1.0  /  Math.max(delta,  0.1);  if(paru  ==  0)  {  paru  =  1.0  /  Math.min(delta,  0.1);  }  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	add	if(paru  ==  0)  {  paru  =  1.0  /  Math.max(delta,  0.1);  if(paru  ==  0)  {  paru  =  1.0  /  Math.min(delta,  0.1);  }	          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.max(delta,    0.1);    }    if    (paru    ==    0)    {    paru    =    2.2251e-308    /    Math.max(delta,    0.1);    }    	compilable	  [FE]  AssertionFailedError  	124	2	replace
484	[BUG]  [BUGGY]  if(paru  ==  0)  {  paru  =  1.0  /  Math.max(delta,  0.1);  if(paru  ==  0)  {  paru  =  1.0  /  Math.min(delta,  0.1);  }  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(paru  ==  0)  {  paru  =  1.0  /  Math.max(delta,  0.1);  if(paru  ==  0)  {  paru  =  1.0  /  Math.min(delta,  0.1);  }  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(paru  ==  0)  {  paru  =  1.0  /  Math.max(delta,  0.1);  if(paru  ==  0)  {  paru  =  1.0  /  Math.min(delta,  0.1);  }	          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.max(delta,    0.1);    }    if    (paru    ==    0)    {    paru    =    2.2251e-308    /    Math.max(delta,    0.1);    }    	compilable	  [FE]  AssertionFailedError  	124	2	replace
485	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(paru  ==  0)  {  paru  =  1.0  /  Math.max(delta,  0.0);  if(paru  ==  0)  {  paru  =  1.0  /  Math.max(delta,  0.1);  }  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	add	if(paru  ==  0)  {  paru  =  1.0  /  Math.max(delta,  0.0);  if(paru  ==  0)  {  paru  =  1.0  /  Math.max(delta,  0.1);  }	          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.max(delta,    0.1);    }    if    (paru    ==    0)    {    paru    =    2.2251e-308    /    Math.max(delta,    0.1);    }    	compilable	  [FE]  AssertionFailedError  	124	2	replace
486	[BUG]  [BUGGY]  if(paru  ==  0)  {  paru  =  1.0  /  Math.max(delta,  0.0);  if(paru  ==  0)  {  paru  =  1.0  /  Math.max(delta,  0.1);  }  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(paru  ==  0)  {  paru  =  1.0  /  Math.max(delta,  0.0);  if(paru  ==  0)  {  paru  =  1.0  /  Math.max(delta,  0.1);  }  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(paru  ==  0)  {  paru  =  1.0  /  Math.max(delta,  0.0);  if(paru  ==  0)  {  paru  =  1.0  /  Math.max(delta,  0.1);  }	          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.max(delta,    0.1);    }    if    (paru    ==    0)    {    paru    =    2.2251e-308    /    Math.max(delta,    0.1);    }    	compilable	  [FE]  AssertionFailedError  	124	2	replace
487	[BUG]  [BUGGY]  double  parl  =  Math.max(paru,  0.01);  [CE]  <identifier>  expected  [FE]              AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  double  parl  =  Math.max(paru,  0.01);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  parl  =  Math.max(paru,  0.01);	  double    parl    =    Math.max(paru,    0.5);    	non-compiled	[CE]  <identifier>  expected	110	None	replace
488	[BUG]  [BUGGY]  double  paru  =  0.5  /  Math.min(delta,  0.5);  [CE]  <identifier>  expected  [FE]                AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  double  paru  =  0.5  /  Math.min(delta,  0.5);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  paru  =  0.5  /  Math.min(delta,  0.5);	  double    paru    =    0.5    /    Math.min(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	75	None	replace
489	[BUG]  [BUGGY]  paru  =  1.0  /  Math.min(delta,  0.1);  Paru  =  1.0  /  Math.min(delta,  0.1);  [CE]  <identifier>  expected  [FE]          AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  paru  =  1.0  /  Math.min(delta,  0.1);  Paru  =  1.0  /  Math.min(delta,  0.1);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	paru  =  1.0  /  Math.min(delta,  0.1);  Paru  =  1.0  /  Math.min(delta,  0.1);	          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    Paru    =    2.2251e-308    /    Math.min(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	36	None	replace
490	[BUG]  [BUGGY]  Paru  =  2.2e-308  /  Math.min(delta,  0.1);  [CE]  <identifier>  expected  [FE]            AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  Paru  =  2.2e-308  /  Math.min(delta,  0.1);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	Paru  =  2.2e-308  /  Math.min(delta,  0.1);	          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    Paru    =    2.2251e-308    /    Math.min(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	36	None	replace
491	[BUG]  [BUGGY]  paru  =  0.5  /  Math.min(delta,  0.1);  paru  =  0.5  /  Math.min(delta,  0.2);  [CE]  <identifier>  expected  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  paru  =  0.5  /  Math.min(delta,  0.1);  paru  =  0.5  /  Math.min(delta,  0.2);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	paru  =  0.5  /  Math.min(delta,  0.1);  paru  =  0.5  /  Math.min(delta,  0.2);	          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    paru    =    2.2251e-308    /    Math.min(delta,    0.2);    	non-compiled	[CE]  <identifier>  expected	40	None	replace
492	[BUG]  [BUGGY]  paru  =  1.0  /  Math.min(delta,  0.1);  paru  =  1.0  /  Math.min(delta,  0.2);  [CE]  <identifier>  expected  [FE]      AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  paru  =  1.0  /  Math.min(delta,  0.1);  paru  =  1.0  /  Math.min(delta,  0.2);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	paru  =  1.0  /  Math.min(delta,  0.1);  paru  =  1.0  /  Math.min(delta,  0.2);	          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    paru    =    2.2251e-308    /    Math.min(delta,    0.2);    	non-compiled	[CE]  <identifier>  expected	40	None	replace
493	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(paru  ==  0)  {  paru  =  0.2e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  0.2e-308  /  Math.min(delta,  0.5);  }  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	add	if(paru  ==  0)  {  paru  =  0.2e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  0.2e-308  /  Math.min(delta,  0.5);  }	          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.5);    }    else    {    paru    =    22251e-308    /    Math.min(delta,    0.5);    }    	compilable	  [FE]  AssertionFailedError  	160	2	replace
494	[BUG]  [BUGGY]  if(paru  ==  0)  {  paru  =  0.2e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  0.2e-308  /  Math.min(delta,  0.5);  }  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(paru  ==  0)  {  paru  =  0.2e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  0.2e-308  /  Math.min(delta,  0.5);  }  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(paru  ==  0)  {  paru  =  0.2e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  0.2e-308  /  Math.min(delta,  0.5);  }	          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.5);    }    else    {    paru    =    22251e-308    /    Math.min(delta,    0.5);    }    	compilable	  [FE]  AssertionFailedError  	160	2	replace
495	[BUG]  [BUGGY]  if(paru  ==  0)  {  paru  =  1.0  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  1.0  /  Math.min(delta,  0.5);  }  else  {  paru  =  1.0  /  Math.min(delta  [CE]  ')'  expected  [FE]      AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(paru  ==  0)  {  paru  =  1.0  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  1.0  /  Math.min(delta,  0.5);  }  else  {  paru  =  1.0  /  Math.min(delta  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(paru  ==  0)  {  paru  =  1.0  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  1.0  /  Math.min(delta,  0.5);  }  else  {  paru  =  1.0  /  Math.min(delta	          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.5);    }    else    {    paru    =    22251e-308    /    Math.min(delta,    0.5);    }    	non-compiled	[CE]  ')'  expected	160	None	replace
496	[BUG]  [BUGGY]  if(paru  >  0)  {  int  paru  =  2.2251e-308  /  Math.min(delta,  0.0);  [CE]  illegal  start  of  expression  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(paru  >  0)  {  int  paru  =  2.2251e-308  /  Math.min(delta,  0.0);  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(paru    >    0)    {    int  paru  =  2.2251e-308  /  Math.min(delta,  0.0);	  	non-compiled	[CE]  illegal  start  of  expression	146	None	add
497	[BUG]  [BUGGY]  if(delta  <  =  0.0)  {  If(paru  ==  0.0)  {  [CE]  illegal  start  of  expression  [FE]            AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(delta  <  =  0.0)  {  If(paru  ==  0.0)  {  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(delta  <  =  0.0)  {  If(paru  ==  0.0)  {	  if(paru    ==    0.0)    {    If(paru    ==    0.0)    {    	non-compiled	[CE]  illegal  start  of  expression	100	None	replace
498	[BUG]  [BUGGY]  if(paru  <  0.0)  {  If(paru  >  0.0)  {  [CE]  ';'  expected  [FE]              AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(paru  <  0.0)  {  If(paru  >  0.0)  {  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(paru  <  0.0)  {  If(paru  >  0.0)  {	  if(paru    ==    0.0)    {    If(paru    ==    0.0)    {    	non-compiled	[CE]  ';'  expected	100	None	replace
499	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(paru  ==  0)  {  paru  =  1.0  /  Math.min(delta,  0.1);  if(paru  ==  0)  {  paru  =  1.0  /  Math.min(delta,  0.1);  }  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	add	if(paru  ==  0)  {  paru  =  1.0  /  Math.min(delta,  0.1);  if(paru  ==  0)  {  paru  =  1.0  /  Math.min(delta,  0.1);  }	          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.1);    }    if    (paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.1);    }    	compilable	  [FE]  AssertionFailedError  	132	2	replace
500	[BUG]  [BUGGY]  if(paru  ==  0)  {  paru  =  1.0  /  Math.min(delta,  0.1);  if(paru  ==  0)  {  paru  =  1.0  /  Math.min(delta,  0.1);  }  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(paru  ==  0)  {  paru  =  1.0  /  Math.min(delta,  0.1);  if(paru  ==  0)  {  paru  =  1.0  /  Math.min(delta,  0.1);  }  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(paru  ==  0)  {  paru  =  1.0  /  Math.min(delta,  0.1);  if(paru  ==  0)  {  paru  =  1.0  /  Math.min(delta,  0.1);  }	          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.1);    }    if    (paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.1);    }    	compilable	  [FE]  AssertionFailedError  	132	2	replace
501	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(paru  ==  0)  {  paru  =  1.0  /  Math.min(delta,  0.0);  if(paru  ==  0)  {  paru  =  1.0  /  Math.min(delta,  0.1);  }  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	add	if(paru  ==  0)  {  paru  =  1.0  /  Math.min(delta,  0.0);  if(paru  ==  0)  {  paru  =  1.0  /  Math.min(delta,  0.1);  }	          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.1);    }    if    (paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.1);    }    	compilable	  [FE]  AssertionFailedError  	132	2	replace
502	[BUG]  [BUGGY]  if(paru  ==  0)  {  paru  =  1.0  /  Math.min(delta,  0.0);  if(paru  ==  0)  {  paru  =  1.0  /  Math.min(delta,  0.1);  }  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(paru  ==  0)  {  paru  =  1.0  /  Math.min(delta,  0.0);  if(paru  ==  0)  {  paru  =  1.0  /  Math.min(delta,  0.1);  }  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(paru  ==  0)  {  paru  =  1.0  /  Math.min(delta,  0.0);  if(paru  ==  0)  {  paru  =  1.0  /  Math.min(delta,  0.1);  }	          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.1);    }    if    (paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.1);    }    	compilable	  [FE]  AssertionFailedError  	132	2	replace
503	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(paru  ==  0)  {  paru  =  1.0  /  Math.min(delta,  0.1);  if(paru  ==  0)  {  paru  =  1.0  /  Math.min(delta,  0.0);  }  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	add	if(paru  ==  0)  {  paru  =  1.0  /  Math.min(delta,  0.1);  if(paru  ==  0)  {  paru  =  1.0  /  Math.min(delta,  0.0);  }	          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.1);    }    if    (paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.1);    }    	compilable	  [FE]  AssertionFailedError  	132	2	replace
504	[BUG]  [BUGGY]  if(paru  ==  0)  {  paru  =  1.0  /  Math.min(delta,  0.1);  if(paru  ==  0)  {  paru  =  1.0  /  Math.min(delta,  0.0);  }  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(paru  ==  0)  {  paru  =  1.0  /  Math.min(delta,  0.1);  if(paru  ==  0)  {  paru  =  1.0  /  Math.min(delta,  0.0);  }  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(paru  ==  0)  {  paru  =  1.0  /  Math.min(delta,  0.1);  if(paru  ==  0)  {  paru  =  1.0  /  Math.min(delta,  0.0);  }	          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.1);    }    if    (paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.1);    }    	compilable	  [FE]  AssertionFailedError  	132	2	replace
505	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(paru  ==  0)  {  paru  =  1.0  /  Math.min(delta,  0.1);  if(paru  ==  0)  {  paru  =  1.0  -  1.0  /  Math.min(delta,  0.1);  }  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	add	if(paru  ==  0)  {  paru  =  1.0  /  Math.min(delta,  0.1);  if(paru  ==  0)  {  paru  =  1.0  -  1.0  /  Math.min(delta,  0.1);  }	          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.1);    }    if    (paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.1);    }    	compilable	  [FE]  AssertionFailedError  	132	2	replace
506	[BUG]  [BUGGY]  if(paru  ==  0)  {  paru  =  1.0  /  Math.min(delta,  0.1);  if(paru  ==  0)  {  paru  =  1.0  -  1.0  /  Math.min(delta,  0.1);  }  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(paru  ==  0)  {  paru  =  1.0  /  Math.min(delta,  0.1);  if(paru  ==  0)  {  paru  =  1.0  -  1.0  /  Math.min(delta,  0.1);  }  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(paru  ==  0)  {  paru  =  1.0  /  Math.min(delta,  0.1);  if(paru  ==  0)  {  paru  =  1.0  -  1.0  /  Math.min(delta,  0.1);  }	          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.1);    }    if    (paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.1);    }    	compilable	  [FE]  AssertionFailedError  	132	2	replace
507	[BUG]  [BUGGY]  int  parl  =  Math.max(parmutation,  1.0);  [CE]  <identifier>  expected  [FE]                        AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  int  parl  =  Math.max(parmutation,  1.0);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	int  parl  =  Math.max(parmutation,  1.0);	  int    parl    =    Math.max(permutation,    1.0);    	non-compiled	[CE]  <identifier>  expected	93	None	replace
508	[BUG]  [BUGGY]  paru  =  0.2  /  Math.max(paru,  0.1);  [CE]  <identifier>  expected  [FE]              AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  paru  =  0.2  /  Math.max(paru,  0.1);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	paru  =  0.2  /  Math.max(paru,  0.1);	  paru    =    0.2    /    Math.max(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	4	None	replace
509	[BUG]  [BUGGY]  Paru  =  2.7  /  Math.max(delta,  0.1);  [CE]  <identifier>  expected  [FE]          AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  Paru  =  2.7  /  Math.max(delta,  0.1);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	Paru  =  2.7  /  Math.max(delta,  0.1);	          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    Paru    =    2.2251e-308    /    Math.max(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	43	None	replace
510	[BUG]  [BUGGY]  Paru  =  2.2e-308  /  Math.max(delta,  0.1);  [CE]  <identifier>  expected  [FE]            AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  Paru  =  2.2e-308  /  Math.max(delta,  0.1);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	Paru  =  2.2e-308  /  Math.max(delta,  0.1);	          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    Paru    =    2.2251e-308    /    Math.max(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	43	None	replace
511	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    paru  =  2.2251e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	add	                paru        =        2.2251e-308        /        Math.min(delta,        0.5);        paru    =    2.2251e-308    /    Math.min(delta,    0.5);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }	  	compilable	  [FE]  AssertionFailedError  	19	4	add
512	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    paru  =  2.2251e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    paru  =  2.2251e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.min(delta,        0.5);        paru    =    2.2251e-308    /    Math.min(delta,    0.5);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }	  	compilable	  [FE]  AssertionFailedError  	19	4	add
513	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    paru  =  2.2251e-308  /  Math.min(delta,  0.5);  paru  =  22251e-308  /  Math.min(delta,  0.5);  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	add	                paru        =        2.2251e-308        /        Math.min(delta,        0.5);        paru    =    2.2251e-308    /    Math.min(delta,    0.5);    paru  =  22251e-308  /  Math.min(delta,  0.5);  paru  =  2.2251e-308  /  Math.min(delta,  0.5);	  	compilable	  [FE]  AssertionFailedError  	19	4	add
514	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    paru  =  2.2251e-308  /  Math.min(delta,  0.5);  paru  =  22251e-308  /  Math.min(delta,  0.5);  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    paru  =  2.2251e-308  /  Math.min(delta,  0.5);  paru  =  22251e-308  /  Math.min(delta,  0.5);  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.min(delta,        0.5);        paru    =    2.2251e-308    /    Math.min(delta,    0.5);    paru  =  22251e-308  /  Math.min(delta,  0.5);  paru  =  2.2251e-308  /  Math.min(delta,  0.5);	  	compilable	  [FE]  AssertionFailedError  	19	4	add
515	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    paru  =  2.2251e-308  /  Math.min(delta,  0.5);  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	add	                paru        =        2.2251e-308        /        Math.min(delta,        0.5);        paru    =    2.2251e-308    /    Math.min(delta,    0.5);    paru  =  2.2251e-308  /  Math.min(delta,  0.5);	  	compilable	  [FE]  AssertionFailedError  	19	4	add
516	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    paru  =  2.2251e-308  /  Math.min(delta,  0.5);  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    paru  =  2.2251e-308  /  Math.min(delta,  0.5);  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.min(delta,        0.5);        paru    =    2.2251e-308    /    Math.min(delta,    0.5);    paru  =  2.2251e-308  /  Math.min(delta,  0.5);	  	compilable	  [FE]  AssertionFailedError  	19	4	add
517	[BUG]  [BUGGY]  int  parl  =  Math.max(parmutation,  0.0);  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  int  parl  =  Math.max(parmutation,  0.0);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	int  parl  =  Math.max(parmutation,  0.0);	  int    parl    =    Math.max(permutation,    0.0);    	non-compiled	[CE]  <identifier>  expected	70	None	replace
518	[BUG]  [BUGGY]  Integer  parl  =  Math.max(parl,  0.0);  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  Integer  parl  =  Math.max(parl,  0.0);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	Integer  parl  =  Math.max(parl,  0.0);	  Integer    parl    =    Math.max(delta,    0.0);    	non-compiled	[CE]  <identifier>  expected	26	None	replace
519	[BUG]  [BUGGY]  Integer  parl  =  Math.max(params,  0.0);  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  Integer  parl  =  Math.max(params,  0.0);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	Integer  parl  =  Math.max(params,  0.0);	  Integer    parl    =    Math.max(delta,    0.0);    	non-compiled	[CE]  <identifier>  expected	26	None	replace
520	[BUG]  [BUGGY]  if(paru  ==  0)  {  paru  =  1.0  /  Math.min(delta,  0.1);  if(paru  ==  0)  {  paru  =  1.0  /  Math.min(delta,  0.1);  }  else  {  paru  =  1.0  /  Math.min(delta,  [CE]  ')'  expected  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(paru  ==  0)  {  paru  =  1.0  /  Math.min(delta,  0.1);  if(paru  ==  0)  {  paru  =  1.0  /  Math.min(delta,  0.1);  }  else  {  paru  =  1.0  /  Math.min(delta,  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(paru  ==  0)  {  paru  =  1.0  /  Math.min(delta,  0.1);  if(paru  ==  0)  {  paru  =  1.0  /  Math.min(delta,  0.1);  }  else  {  paru  =  1.0  /  Math.min(delta,	          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.1);    }    else    {    paru    =    2.2251e-308    /    Math.min(delta,    0.1);    }    	non-compiled	[CE]  ')'  expected	134	None	replace
521	[BUG]  [BUGGY]  if(paru  ==  0)  {  paru  =  1.0  /  Math.min(delta,  0.1);  if(paru  ==  0)  {  paru  =  1.0  /  Math.min(delta,  0.1);  }  else  {  paru  =  1.0  /  Math.min(delta  [CE]  ')'  expected  [FE]      AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(paru  ==  0)  {  paru  =  1.0  /  Math.min(delta,  0.1);  if(paru  ==  0)  {  paru  =  1.0  /  Math.min(delta,  0.1);  }  else  {  paru  =  1.0  /  Math.min(delta  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(paru  ==  0)  {  paru  =  1.0  /  Math.min(delta,  0.1);  if(paru  ==  0)  {  paru  =  1.0  /  Math.min(delta,  0.1);  }  else  {  paru  =  1.0  /  Math.min(delta	          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.1);    }    else    {    paru    =    2.2251e-308    /    Math.min(delta,    0.1);    }    	non-compiled	[CE]  ')'  expected	134	None	replace
522	[BUG]  [BUGGY]  int  paru  =.2251e-308  /  Math.max(delta,  0.1);  [CE]  <identifier>  expected  [FE]        AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  int  paru  =.2251e-308  /  Math.max(delta,  0.1);  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	int  paru  =.2251e-308  /  Math.max(delta,  0.1);	  if(paru    >    0.0)    {    int    paru    =    2.2251e-308    /    Math.max(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	153	None	replace
523	[BUG]  [BUGGY]  double  paru  =  0.5  /  Math.max(parl,  0.1);  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  double  paru  =  0.5  /  Math.max(parl,  0.1);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  paru  =  0.5  /  Math.max(parl,  0.1);	  double    paru    =    0.5    /    Math.max(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	103	None	replace
524	[BUG]  [BUGGY]  Paru  =  1.0  /  Math.min(delta,  0.5);  [CE]  <identifier>  expected  [FE]          AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  Paru  =  1.0  /  Math.min(delta,  0.5);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	Paru  =  1.0  /  Math.min(delta,  0.5);	          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    Paru    =    2.2251e-308    /    Math.min(delta,    0.5);    	non-compiled	[CE]  <identifier>  expected	21	None	replace
525	[BUG]  [BUGGY]  Paru  =  2.7  /  Math.min(delta,  0.5);  [CE]  <identifier>  expected  [FE]            AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  Paru  =  2.7  /  Math.min(delta,  0.5);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	Paru  =  2.7  /  Math.min(delta,  0.5);	          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    Paru    =    2.2251e-308    /    Math.min(delta,    0.5);    	non-compiled	[CE]  <identifier>  expected	21	None	replace
526	[BUG]  [BUGGY]  if(delta  >  0.0)  {  int  delta  =  Math.max(paru,  Math.max(delta,  0.0));  [CE]  illegal  start  of  expression  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(delta  >  0.0)  {  int  delta  =  Math.max(paru,  Math.max(delta,  0.0));  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(delta    >    0.0)    {    int  delta  =  Math.max(paru,  Math.max(delta,  0.0));	  	non-compiled	[CE]  illegal  start  of  expression	9	None	add
527	[BUG]  [BUGGY]  if(delta  >  0.0)  {  int  delta  =  Math.max(paru,  Math.max(lmPar,  parl));  [CE]  illegal  start  of  expression  [FE]      AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(delta  >  0.0)  {  int  delta  =  Math.max(paru,  Math.max(lmPar,  parl));  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(delta    >    0.0)    {    int  delta  =  Math.max(paru,  Math.max(lmPar,  parl));	  	non-compiled	[CE]  illegal  start  of  expression	9	None	add
528	[BUG]  [BUGGY]  if(delta  >  0.0)  {  int  delta  =  Math.max(paru,  Math.max(delta,  0.1));  [CE]  illegal  start  of  expression  [FE]        AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(delta  >  0.0)  {  int  delta  =  Math.max(paru,  Math.max(delta,  0.1));  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(delta    >    0.0)    {    int  delta  =  Math.max(paru,  Math.max(delta,  0.1));	  	non-compiled	[CE]  illegal  start  of  expression	9	None	add
529	[BUG]  [BUGGY]  if(delta  ==  0.0)  {  if(delta  ==  0.00)  {  [CE]  illegal  start  of  expression  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(delta  ==  0.0)  {  if(delta  ==  0.00)  {  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(delta    ==    0.0)    {    if(delta  ==  0.00)  {	  	non-compiled	[CE]  illegal  start  of  expression	64	None	add
530	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(dxNorm  ==  0.0)  {  paru  =  1.0  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  1.0  /  Math.min(delta,  0.5);  }  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	add	if(dxNorm  ==  0.0)  {  paru  =  1.0  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  1.0  /  Math.min(delta,  0.5);  }	          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.5);    }    if    (paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.5);    }    	compilable	  [FE]  AssertionFailedError  	112	2	replace
531	[BUG]  [BUGGY]  if(dxNorm  ==  0.0)  {  paru  =  1.0  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  1.0  /  Math.min(delta,  0.5);  }  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(dxNorm  ==  0.0)  {  paru  =  1.0  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  1.0  /  Math.min(delta,  0.5);  }  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(dxNorm  ==  0.0)  {  paru  =  1.0  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  1.0  /  Math.min(delta,  0.5);  }	          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.5);    }    if    (paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.5);    }    	compilable	  [FE]  AssertionFailedError  	112	2	replace
532	[BUG]  [BUGGY]  Integer  parl  =  Math.max(paru,  0.1);  [CE]  <identifier>  expected  [FE]                        AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  Integer  parl  =  Math.max(paru,  0.1);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	Integer  parl  =  Math.max(paru,  0.1);	  Integer    parl    =    Math.max(paru,    2.0);    	non-compiled	[CE]  <identifier>  expected	29	None	replace
533	[BUG]  [BUGGY]  int  paru  =  Math.max(paru,  0.1,  sum);  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  int  paru  =  Math.max(paru,  0.1,  sum);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	int  paru  =  Math.max(paru,  0.1,  sum);	  int    paru    =    Math.max(paru,    0.0,    sum);    	non-compiled	[CE]  <identifier>  expected	95	None	replace
534	[BUG]  [BUGGY]  double  paru  =  2.0  /  Math.max(paru,  0.1);  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  double  paru  =  2.0  /  Math.max(paru,  0.1);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  paru  =  2.0  /  Math.max(paru,  0.1);	  double    paru    =    2.0    /    Math.max(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	104	None	replace
535	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  paru  =  0.2e-308  /  Math.min(delta,  0.1);  paru  =  0.5e-308  /  Math.min(delta,  0.1);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	add	                paru        =        2.2251e-308        /        Math.min(delta,        0.1);        paru    =    2.2251e-308    /    Math.min(delta,    0.1);    paru  =  0.2e-308  /  Math.min(delta,  0.1);  paru  =  0.5e-308  /  Math.min(delta,  0.1);	  	compilable	  [FE]  AssertionFailedError  	34	4	add
536	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  paru  =  0.2e-308  /  Math.min(delta,  0.1);  paru  =  0.5e-308  /  Math.min(delta,  0.1);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  paru  =  0.2e-308  /  Math.min(delta,  0.1);  paru  =  0.5e-308  /  Math.min(delta,  0.1);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.min(delta,        0.1);        paru    =    2.2251e-308    /    Math.min(delta,    0.1);    paru  =  0.2e-308  /  Math.min(delta,  0.1);  paru  =  0.5e-308  /  Math.min(delta,  0.1);	  	compilable	  [FE]  AssertionFailedError  	34	4	add
537	[BUG]  [BUGGY]  if(paru  >  0.0)  {  If(paru  >=  0.0)  {  [CE]  ';'  expected  [FE]        AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(paru  >  0.0)  {  If(paru  >=  0.0)  {  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(paru  >  0.0)  {  If(paru  >=  0.0)  {	  if(paru    >=    0.0)    {    If(paru    >=    0.0)    {    	non-compiled	[CE]  ';'  expected	138	None	replace
538	[BUG]  [BUGGY]  if(paru  <  =  0.0)  {  If(paru  >=  0.0)  {  [CE]  illegal  start  of  expression  [FE]          AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(paru  <  =  0.0)  {  If(paru  >=  0.0)  {  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(paru  <  =  0.0)  {  If(paru  >=  0.0)  {	  if(paru    >=    0.0)    {    If(paru    >=    0.0)    {    	non-compiled	[CE]  illegal  start  of  expression	138	None	replace
539	[BUG]  [BUGGY]  double  parl  =  Math.max(parl,  1.0);  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  double  parl  =  Math.max(parl,  1.0);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  parl  =  Math.max(parl,  1.0);	  double    parl    =    Math.min(delta,    1.0);    	non-compiled	[CE]  <identifier>  expected	54	None	replace
540	[BUG]  [BUGGY]  double  parl  =  Math.max(parl,  1.0)/  Math.min(delta,  1.0);  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  double  parl  =  Math.max(parl,  1.0)/  Math.min(delta,  1.0);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  parl  =  Math.max(parl,  1.0)/  Math.min(delta,  1.0);	  double    parl    =    Math.min(delta,    1.0);    	non-compiled	[CE]  <identifier>  expected	54	None	replace
541	[BUG]  [BUGGY]  paru  =  0.0  /  Math.max(delta,  0.0);  [CE]  <identifier>  expected  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  paru  =  0.0  /  Math.max(delta,  0.0);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	paru  =  0.0  /  Math.max(delta,  0.0);	          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    paru    =    2.2251e-308    /    Math.max(delta,    0.0);    	non-compiled	[CE]  <identifier>  expected	47	None	replace
542	[BUG]  [BUGGY]  paru  =  0.5  /  Math.min(delta,  0.1);  Paru  =  0.5  /  Math.min(delta,  0.1);  [CE]  <identifier>  expected  [FE]          AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  paru  =  0.5  /  Math.min(delta,  0.1);  Paru  =  0.5  /  Math.min(delta,  0.1);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	paru  =  0.5  /  Math.min(delta,  0.1);  Paru  =  0.5  /  Math.min(delta,  0.1);	          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    Paru    =    2.2251e-308    /    Math.min(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	36	None	replace
543	[BUG]  [BUGGY]  int  parl  =  Math.min(delta,  0.01);  [CE]  <identifier>  expected  [FE]            AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  int  parl  =  Math.min(delta,  0.01);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	int  parl  =  Math.min(delta,  0.01);	  int    parl    =    Math.min(params,    0.1);    	non-compiled	[CE]  <identifier>  expected	145	None	replace
544	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    paru  =  2.2251e-308  /  Math.min(delta,  0.5);  paru  =  0.5e-308  /  Math.min(delta,  0.5);  paru  =  0.5e-308  /  Math.min(delta,  0.5);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	add	                paru        =        2.2251e-308        /        Math.min(delta,        0.5);        paru    =    2.2251e-308    /    Math.min(delta,    0.5);    paru  =  0.5e-308  /  Math.min(delta,  0.5);  paru  =  0.5e-308  /  Math.min(delta,  0.5);	  	compilable	  [FE]  AssertionFailedError  	19	4	add
545	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    paru  =  2.2251e-308  /  Math.min(delta,  0.5);  paru  =  0.5e-308  /  Math.min(delta,  0.5);  paru  =  0.5e-308  /  Math.min(delta,  0.5);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    paru  =  2.2251e-308  /  Math.min(delta,  0.5);  paru  =  0.5e-308  /  Math.min(delta,  0.5);  paru  =  0.5e-308  /  Math.min(delta,  0.5);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.min(delta,        0.5);        paru    =    2.2251e-308    /    Math.min(delta,    0.5);    paru  =  0.5e-308  /  Math.min(delta,  0.5);  paru  =  0.5e-308  /  Math.min(delta,  0.5);	  	compilable	  [FE]  AssertionFailedError  	19	4	add
546	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    paru  =  2.2251e-308  /  Math.min(delta,  0.5);  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  paru  =  2.2252e-308  /  Math.min(delta,  0.5);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	add	                paru        =        2.2251e-308        /        Math.min(delta,        0.5);        paru    =    2.2251e-308    /    Math.min(delta,    0.5);    paru  =  2.2251e-308  /  Math.min(delta,  0.5);  paru  =  2.2252e-308  /  Math.min(delta,  0.5);	  	compilable	  [FE]  AssertionFailedError  	19	4	add
547	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    paru  =  2.2251e-308  /  Math.min(delta,  0.5);  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  paru  =  2.2252e-308  /  Math.min(delta,  0.5);  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    paru  =  2.2251e-308  /  Math.min(delta,  0.5);  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  paru  =  2.2252e-308  /  Math.min(delta,  0.5);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.min(delta,        0.5);        paru    =    2.2251e-308    /    Math.min(delta,    0.5);    paru  =  2.2251e-308  /  Math.min(delta,  0.5);  paru  =  2.2252e-308  /  Math.min(delta,  0.5);	  	compilable	  [FE]  AssertionFailedError  	19	4	add
548	[BUG]  [BUGGY]  double  parl  =  Math.max(work3,  Math.max(paru,  parl));  [CE]  <identifier>  expected  [FE]                AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  double  parl  =  Math.max(work3,  Math.max(paru,  parl));  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  parl  =  Math.max(work3,  Math.max(paru,  parl));	  double    parl    =    Math.max(paru,    Math.max(work1,    parl));    	non-compiled	[CE]  <identifier>  expected	155	None	replace
549	[BUG]  [BUGGY]  paru  =  0.5  /  Math.max(paru,  0.5);  [CE]  <identifier>  expected  [FE]          AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  paru  =  0.5  /  Math.max(paru,  0.5);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	paru  =  0.5  /  Math.max(paru,  0.5);	  paru    =    0.5    /    Math.min(delta,    0.5);    	non-compiled	[CE]  <identifier>  expected	16	None	replace
550	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  if(paru  <  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  [CE]  illegal  start  of  expression  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  if(paru  <  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.min(delta,        0.1);        if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.1);    }    if    (paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.1);    }    if(paru  <  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }	  	non-compiled	[CE]  illegal  start  of  expression	131	None	add
551	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  if(paru  ==  0)  {  paru  =  2.2251e  [CE]  malformed  floating  point  literal  [FE]      AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  if(paru  ==  0)  {  paru  =  2.2251e  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.min(delta,        0.1);        if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.1);    }    if    (paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.1);    }    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  if(paru  ==  0)  {  paru  =  2.2251e	  	non-compiled	[CE]  malformed  floating  point  literal	131	None	add
552	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  if(paru  ==  0)  {  paru  =  2.2251e  [CE]  malformed  floating  point  literal  [FE]        AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  if(paru  ==  0)  {  paru  =  2.2251e  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.min(delta,        0.1);        if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.1);    }    if    (paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.1);    }    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  if(paru  ==  0)  {  paru  =  2.2251e	  	non-compiled	[CE]  malformed  floating  point  literal	131	None	add
553	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    paru  =  2.2251e-308  /  Math.max(delta,  0.0);  paru  =  0.2e-308  /  Math.max(delta,  0.1);  paru  =  0.5e-308  /  Math.max(delta,  0.0);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	add	                paru        =        2.2251e-308        /        Math.max(delta,        0.1);        paru    =    2.2251e-308    /    Math.max(delta,    0.0);    paru  =  0.2e-308  /  Math.max(delta,  0.1);  paru  =  0.5e-308  /  Math.max(delta,  0.0);	  	compilable	  [FE]  AssertionFailedError  	46	4	add
554	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    paru  =  2.2251e-308  /  Math.max(delta,  0.0);  paru  =  0.2e-308  /  Math.max(delta,  0.1);  paru  =  0.5e-308  /  Math.max(delta,  0.0);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    paru  =  2.2251e-308  /  Math.max(delta,  0.0);  paru  =  0.2e-308  /  Math.max(delta,  0.1);  paru  =  0.5e-308  /  Math.max(delta,  0.0);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.max(delta,        0.1);        paru    =    2.2251e-308    /    Math.max(delta,    0.0);    paru  =  0.2e-308  /  Math.max(delta,  0.1);  paru  =  0.5e-308  /  Math.max(delta,  0.0);	  	compilable	  [FE]  AssertionFailedError  	46	4	add
555	[BUG]  [BUGGY]  int  paru  =  Math.max(delta,  0.5);  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  int  paru  =  Math.max(delta,  0.5);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	int  paru  =  Math.max(delta,  0.5);	  int    paru    =    Math.max(paru,    0.5);    	non-compiled	[CE]  <identifier>  expected	121	None	replace
556	[BUG]  [BUGGY]  double  parl  =  Math.max(work3,  Math.max(work2,  work3));  [CE]  <identifier>  expected  [FE]              AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  double  parl  =  Math.max(work3,  Math.max(work2,  work3));  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  parl  =  Math.max(work3,  Math.max(work2,  work3));	  double    parl    =    Math.max(work3,    Math.max(work1,    paru2));    	non-compiled	[CE]  <identifier>  expected	148	None	replace
557	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  else  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  else  {  paru  =  2.2251e-308  /  Math.min(delta  [CE]  ')'  expected  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  else  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  else  {  paru  =  2.2251e-308  /  Math.min(delta  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.min(delta,        0.5);        if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.5);    }    else    {    paru    =    2.2251e-308    /    Math.min(delta,    0.5);    }    paru  =  2.2251e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  else  {  paru  =  2.2251e-308  /  Math.min(delta	  	non-compiled	[CE]  ')'  expected	24	None	add
558	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  else  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  else  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	add	                paru        =        2.2251e-308        /        Math.min(delta,        0.5);        if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.5);    }    else    {    paru    =    2.2251e-308    /    Math.min(delta,    0.5);    }    paru  =  2.2251e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  else  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }	  	compilable	  [FE]  AssertionFailedError  	24	4	add
559	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  else  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  else  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  else  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  else  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.min(delta,        0.5);        if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.5);    }    else    {    paru    =    2.2251e-308    /    Math.min(delta,    0.5);    }    paru  =  2.2251e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  else  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }	  	compilable	  [FE]  AssertionFailedError  	24	4	add
560	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  else  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  else  {  paru  =  2.2251e-308  /  Math.min(delta,  [CE]  illegal  start  of  expression  [FE]        AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  else  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  else  {  paru  =  2.2251e-308  /  Math.min(delta,  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.min(delta,        0.5);        if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.5);    }    else    {    paru    =    2.2251e-308    /    Math.min(delta,    0.5);    }    paru  =  2.2251e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  else  {  paru  =  2.2251e-308  /  Math.min(delta,	  	non-compiled	[CE]  illegal  start  of  expression	24	None	add
561	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  else  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  else  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5  [CE]  ')'  expected  [FE]          AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  else  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  else  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.min(delta,        0.5);        if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.5);    }    else    {    paru    =    2.2251e-308    /    Math.min(delta,    0.5);    }    paru  =  2.2251e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  else  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5	  	non-compiled	[CE]  ')'  expected	24	None	add
562	[BUG]  [BUGGY]  int  parl  =  diag[0]  &  0xFFFF;  [CE]  <identifier>  expected  [FE]            AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  int  parl  =  diag[0]  &  0xFFFF;  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	int  parl  =  diag[0]  &  0xFFFF;	  int    parl    =    diag[0];    	non-compiled	[CE]  <identifier>  expected	154	None	replace
563	[BUG]  [BUGGY]  paru  =  1.0  /  Math.min(delta,  0.1);  if(paru  ==  0)  {  paru  =  1.0  /  Math.min(delta,  0.1);  }  else  {  paru  =  1.0  /  Math.min(delta,  0.1);  }  [CE]  <identifier>  expected  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  paru  =  1.0  /  Math.min(delta,  0.1);  if(paru  ==  0)  {  paru  =  1.0  /  Math.min(delta,  0.1);  }  else  {  paru  =  1.0  /  Math.min(delta,  0.1);  }  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	paru  =  1.0  /  Math.min(delta,  0.1);  if(paru  ==  0)  {  paru  =  1.0  /  Math.min(delta,  0.1);  }  else  {  paru  =  1.0  /  Math.min(delta,  0.1);  }	          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.1);    }    else    {    paru    =    2.2251e-308    /    Math.min(delta,    0.1);    }    	non-compiled	[CE]  <identifier>  expected	134	None	replace
564	[BUG]  [BUGGY]  paru  =  0.5  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  0.5  /  Math.min(delta,  0.5);  }  else  {  paru  =  0.5  /  Math.min(delta,  0.5);  }  [CE]  <identifier>  expected  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  paru  =  0.5  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  0.5  /  Math.min(delta,  0.5);  }  else  {  paru  =  0.5  /  Math.min(delta,  0.5);  }  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	paru  =  0.5  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  0.5  /  Math.min(delta,  0.5);  }  else  {  paru  =  0.5  /  Math.min(delta,  0.5);  }	          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.5);    }    else    {    paru    =    2.2251e-308    /    Math.min(delta,    0.5);    }    	non-compiled	[CE]  <identifier>  expected	25	None	replace
565	[BUG]  [BUGGY]  paru  =  1.0  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  1.0  /  Math.min(delta,  0.5);  }  else  {  paru  =  1.0  /  Math.min(delta,  0.5);  }  [CE]  <identifier>  expected  [FE]      AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  paru  =  1.0  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  1.0  /  Math.min(delta,  0.5);  }  else  {  paru  =  1.0  /  Math.min(delta,  0.5);  }  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	paru  =  1.0  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  1.0  /  Math.min(delta,  0.5);  }  else  {  paru  =  1.0  /  Math.min(delta,  0.5);  }	          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.5);    }    else    {    paru    =    2.2251e-308    /    Math.min(delta,    0.5);    }    	non-compiled	[CE]  <identifier>  expected	25	None	replace
566	[BUG]  [BUGGY]  paru  =  2.2e-308  /  Math.max(paru,  0.1);  [CE]  <identifier>  expected  [FE]        AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  paru  =  2.2e-308  /  Math.max(paru,  0.1);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	paru  =  2.2e-308  /  Math.max(paru,  0.1);	  paru    =    2.2e-308    /    Math.max(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	106	None	replace
567	[BUG]  [BUGGY]  Integer  parl  =  Math.max(paru,  10.0);  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  Integer  parl  =  Math.max(paru,  10.0);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	Integer  parl  =  Math.max(paru,  10.0);	  Integer    parl    =    Math.max(paru,    1.0);    	non-compiled	[CE]  <identifier>  expected	27	None	replace
568	[BUG]  [BUGGY]  double  parl  =  Math.max(work1,  work3);  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  double  parl  =  Math.max(work1,  work3);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  parl  =  Math.max(work1,  work3);	  double    parl    =    Math.max(work3,    Math.max(work1,    paru));    	non-compiled	[CE]  <identifier>  expected	84	None	replace
569	[BUG]  [BUGGY]  int  parl  =  Math.max(paru,  10.0);  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  int  parl  =  Math.max(paru,  10.0);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	int  parl  =  Math.max(paru,  10.0);	  int    parl    =    Math.max(paru,    1.0);    	non-compiled	[CE]  <identifier>  expected	90	None	replace
570	[BUG]  [BUGGY]  paru  =  0.5  /  Math.min(paru,  0.1);  [CE]  <identifier>  expected  [FE]          AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  paru  =  0.5  /  Math.min(paru,  0.1);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	paru  =  0.5  /  Math.min(paru,  0.1);	  paru    =    0.5    /    Math.min(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	57	None	replace
571	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  if(paru  >=  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  [CE]  illegal  start  of  expression  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  if(paru  >=  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.max(delta,        0.1);        if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.max(delta,    0.1);    }    if(paru  >=  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }	  	non-compiled	[CE]  illegal  start  of  expression	44	None	add
572	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  if(paru  <  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  [CE]  illegal  start  of  expression  [FE]      AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  if(paru  <  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.max(delta,        0.1);        if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.max(delta,    0.1);    }    if(paru  <  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }	  	non-compiled	[CE]  illegal  start  of  expression	44	None	add
573	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  [CE]  illegal  start  of  expression  [FE]        AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.max(delta,        0.1);        if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.max(delta,    0.1);    }    paru  =  2.2251e-308  /  Math.max(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);	  	non-compiled	[CE]  illegal  start  of  expression	44	None	add
574	[BUG]  [BUGGY]  double  parl  =  Math.max(params,  0.0);  [CE]  <identifier>  expected  [FE]              AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  double  parl  =  Math.max(params,  0.0);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  parl  =  Math.max(params,  0.0);	  double    parl    =    Math.max(delta,    0.0);    	non-compiled	[CE]  <identifier>  expected	86	None	replace
575	[BUG]  [BUGGY]  paru  =  1.0  /  Math.max(delta,  0.1);  Paru  =  1.0  /  Math.max(delta,  0.1);  [CE]  <identifier>  expected  [FE]          AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  paru  =  1.0  /  Math.max(delta,  0.1);  Paru  =  1.0  /  Math.max(delta,  0.1);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	paru  =  1.0  /  Math.max(delta,  0.1);  Paru  =  1.0  /  Math.max(delta,  0.1);	          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    Paru    =    2.2251e-308    /    Math.max(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	43	None	replace
576	[BUG]  [BUGGY]  paru  =  0.5  /  Math.max(delta,  0.1);  Paru  =  0.5  /  Math.max(delta,  0.1);  [CE]  <identifier>  expected  [FE]            AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  paru  =  0.5  /  Math.max(delta,  0.1);  Paru  =  0.5  /  Math.max(delta,  0.1);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	paru  =  0.5  /  Math.max(delta,  0.1);  Paru  =  0.5  /  Math.max(delta,  0.1);	          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    Paru    =    2.2251e-308    /    Math.max(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	43	None	replace
577	[BUG]  [BUGGY]  paru  =  1.0  /  Math.max(paru,  0.0);  [CE]  <identifier>  expected  [FE]        AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  paru  =  1.0  /  Math.max(paru,  0.0);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	paru  =  1.0  /  Math.max(paru,  0.0);	  paru    =    1.0    /    Math.min(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	56	None	replace
578	[BUG]  [BUGGY]  paru  =  1.0  /  Math.min(paru,  0.1);  [CE]  <identifier>  expected  [FE]          AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  paru  =  1.0  /  Math.min(paru,  0.1);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	paru  =  1.0  /  Math.min(paru,  0.1);	  paru    =    1.0    /    Math.min(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	56	None	replace
579	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  if(paru  <  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  [CE]  illegal  start  of  expression  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  if(paru  <  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.min(delta,        0.1);        if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.1);    }    if(paru  <  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }	  	non-compiled	[CE]  illegal  start  of  expression	37	None	add
580	[BUG]  [BUGGY]  double  paru  =  Math.max(delta,  0.1);  [CE]  <identifier>  expected  [FE]                          AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  double  paru  =  Math.max(delta,  0.1);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  paru  =  Math.max(delta,  0.1);	  double    paru    =    Math.max(paru,    0.0);    	non-compiled	[CE]  <identifier>  expected	97	None	replace
581	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(parl  >  0.0)  {  paru  =  1.0  /  Math.max(delta,  0.1);  if(paru  ==  0)  {  paru  =  1.0  /  Math.max(delta,  0.1);  }  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	add	if(parl  >  0.0)  {  paru  =  1.0  /  Math.max(delta,  0.1);  if(paru  ==  0)  {  paru  =  1.0  /  Math.max(delta,  0.1);  }	          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.max(delta,    0.1);    }    if    (paru    ==    0)    {    paru    =    2.2251e-308    /    Math.max(delta,    0.1);    }    	compilable	  [FE]  AssertionFailedError  	124	4	replace
582	[BUG]  [BUGGY]  if(parl  >  0.0)  {  paru  =  1.0  /  Math.max(delta,  0.1);  if(paru  ==  0)  {  paru  =  1.0  /  Math.max(delta,  0.1);  }  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(parl  >  0.0)  {  paru  =  1.0  /  Math.max(delta,  0.1);  if(paru  ==  0)  {  paru  =  1.0  /  Math.max(delta,  0.1);  }  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(parl  >  0.0)  {  paru  =  1.0  /  Math.max(delta,  0.1);  if(paru  ==  0)  {  paru  =  1.0  /  Math.max(delta,  0.1);  }	          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.max(delta,    0.1);    }    if    (paru    ==    0)    {    paru    =    2.2251e-308    /    Math.max(delta,    0.1);    }    	compilable	  [FE]  AssertionFailedError  	124	4	replace
583	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(dxNorm  ==  0.0)  {  paru  =  1.0  /  Math.max(delta,  0.1);  if(paru  ==  0)  {  paru  =  1.0  /  Math.max(delta,  0.1);  }  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	add	if(dxNorm  ==  0.0)  {  paru  =  1.0  /  Math.max(delta,  0.1);  if(paru  ==  0)  {  paru  =  1.0  /  Math.max(delta,  0.1);  }	          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.max(delta,    0.1);    }    if    (paru    ==    0)    {    paru    =    2.2251e-308    /    Math.max(delta,    0.1);    }    	compilable	  [FE]  AssertionFailedError  	124	2	replace
584	[BUG]  [BUGGY]  if(dxNorm  ==  0.0)  {  paru  =  1.0  /  Math.max(delta,  0.1);  if(paru  ==  0)  {  paru  =  1.0  /  Math.max(delta,  0.1);  }  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(dxNorm  ==  0.0)  {  paru  =  1.0  /  Math.max(delta,  0.1);  if(paru  ==  0)  {  paru  =  1.0  /  Math.max(delta,  0.1);  }  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(dxNorm  ==  0.0)  {  paru  =  1.0  /  Math.max(delta,  0.1);  if(paru  ==  0)  {  paru  =  1.0  /  Math.max(delta,  0.1);  }	          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.max(delta,    0.1);    }    if    (paru    ==    0)    {    paru    =    2.2251e-308    /    Math.max(delta,    0.1);    }    	compilable	  [FE]  AssertionFailedError  	124	2	replace
585	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(dxNorm!=  0.0)  {  paru  =  1.0  /  Math.max(delta,  0.1);  if(paru  ==  0)  {  paru  =  1.0  /  Math.max(delta,  0.1);  }  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	add	if(dxNorm!=  0.0)  {  paru  =  1.0  /  Math.max(delta,  0.1);  if(paru  ==  0)  {  paru  =  1.0  /  Math.max(delta,  0.1);  }	          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.max(delta,    0.1);    }    if    (paru    ==    0)    {    paru    =    2.2251e-308    /    Math.max(delta,    0.1);    }    	compilable	  [FE]  AssertionFailedError  	124	4	replace
586	[BUG]  [BUGGY]  if(dxNorm!=  0.0)  {  paru  =  1.0  /  Math.max(delta,  0.1);  if(paru  ==  0)  {  paru  =  1.0  /  Math.max(delta,  0.1);  }  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(dxNorm!=  0.0)  {  paru  =  1.0  /  Math.max(delta,  0.1);  if(paru  ==  0)  {  paru  =  1.0  /  Math.max(delta,  0.1);  }  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(dxNorm!=  0.0)  {  paru  =  1.0  /  Math.max(delta,  0.1);  if(paru  ==  0)  {  paru  =  1.0  /  Math.max(delta,  0.1);  }	          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.max(delta,    0.1);    }    if    (paru    ==    0)    {    paru    =    2.2251e-308    /    Math.max(delta,    0.1);    }    	compilable	  [FE]  AssertionFailedError  	124	4	replace
587	[BUG]  [BUGGY]  if(paru  <  0.0)  {  int  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  [CE]  illegal  start  of  expression  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(paru  <  0.0)  {  int  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(paru    <    0.0)    {    int  paru  =  2.2251e-308  /  Math.min(delta,  0.1);	  	non-compiled	[CE]  illegal  start  of  expression	48	None	add
588	[BUG]  [BUGGY]  if(paru  <  0.0)  {  int  paru  =  2.2251e-308  /  Math.min(delta,  0.0);  [CE]  illegal  start  of  expression  [FE]      AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(paru  <  0.0)  {  int  paru  =  2.2251e-308  /  Math.min(delta,  0.0);  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(paru    <    0.0)    {    int  paru  =  2.2251e-308  /  Math.min(delta,  0.0);	  	non-compiled	[CE]  illegal  start  of  expression	48	None	add
589	[BUG]  [BUGGY]  if(paru  <  0.0)  {  int  paru  =  2.2251e-308  /  Math.min(delta,  0.2);  [CE]  illegal  start  of  expression  [FE]        AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(paru  <  0.0)  {  int  paru  =  2.2251e-308  /  Math.min(delta,  0.2);  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(paru    <    0.0)    {    int  paru  =  2.2251e-308  /  Math.min(delta,  0.2);	  	non-compiled	[CE]  illegal  start  of  expression	48	None	add
590	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	add	                paru        =        2.2251e-308        /        Math.max(delta,        0.1);        if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.max(delta,    0.1);    }    if    (paru    ==    0)    {    paru    =    2.2251e-308    /    Math.max(delta,    0.1);    }    paru  =  2.2251e-308  /  Math.max(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }	  	compilable	  [FE]  AssertionFailedError  	123	4	add
591	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.max(delta,        0.1);        if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.max(delta,    0.1);    }    if    (paru    ==    0)    {    paru    =    2.2251e-308    /    Math.max(delta,    0.1);    }    paru  =  2.2251e-308  /  Math.max(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }	  	compilable	  [FE]  AssertionFailedError  	123	4	add
592	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  if(paru  <  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  [CE]  illegal  start  of  expression  [FE]      AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  if(paru  <  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.max(delta,        0.1);        if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.max(delta,    0.1);    }    if    (paru    ==    0)    {    paru    =    2.2251e-308    /    Math.max(delta,    0.1);    }    if(paru  <  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }	  	non-compiled	[CE]  illegal  start  of  expression	123	None	add
593	[BUG]  [BUGGY]  if(delta  <  =  0.0  ||  paru  >  1.0)  {  [CE]  illegal  start  of  expression  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(delta  <  =  0.0  ||  paru  >  1.0)  {  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(delta  <  =  0.0  ||  paru  >  1.0)  {	  if(delta    >    0.0    ||    paru    >    1.0)    {    	non-compiled	[CE]  illegal  start  of  expression	144	None	replace
594	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(delta  <  1.0  ||  paru  >  1.0)  {  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	add	if(delta  <  1.0  ||  paru  >  1.0)  {	  if(delta    >    0.0    ||    paru    >    1.0)    {    	compilable	  [FE]  AssertionFailedError  	144	3	replace
595	[BUG]  [BUGGY]  if(delta  <  1.0  ||  paru  >  1.0)  {  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(delta  <  1.0  ||  paru  >  1.0)  {  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(delta  <  1.0  ||  paru  >  1.0)  {	  if(delta    >    0.0    ||    paru    >    1.0)    {    	compilable	  [FE]  AssertionFailedError  	144	3	replace
596	[BUG]  [BUGGY]  int  parl  =  work3[1];  [CE]  <identifier>  expected  [FE]              AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  int  parl  =  work3[1];  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	int  parl  =  work3[1];	  int    parl    =    permutation[1];    	non-compiled	[CE]  <identifier>  expected	61	None	replace
597	[BUG]  [BUGGY]  int  parl  =  permutation[1]  &  0xff;  [CE]  <identifier>  expected  [FE]                AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  int  parl  =  permutation[1]  &  0xff;  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	int  parl  =  permutation[1]  &  0xff;	  int    parl    =    permutation[1];    	non-compiled	[CE]  <identifier>  expected	61	None	replace
598	[BUG]  [BUGGY]  Integer  parl  =  Math.max(paru,  0.1,  sum);  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  Integer  parl  =  Math.max(paru,  0.1,  sum);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	Integer  parl  =  Math.max(paru,  0.1,  sum);	  Integer    parl    =    Math.max(paru,    0.0,    sum);    	non-compiled	[CE]  <identifier>  expected	28	None	replace
599	[BUG]  [BUGGY]  int  parl  =  Math.min(delta,  0,  1.0);  [CE]  <identifier>  expected  [FE]              AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  int  parl  =  Math.min(delta,  0,  1.0);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	int  parl  =  Math.min(delta,  0,  1.0);	  int    parl    =    Math.min(paru,    0,    0.1);    	non-compiled	[CE]  <identifier>  expected	51	None	replace
600	[BUG]  [BUGGY]  int  parl  =  Math.min(delta,  0,  0.5);  [CE]  <identifier>  expected  [FE]                AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  int  parl  =  Math.min(delta,  0,  0.5);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	int  parl  =  Math.min(delta,  0,  0.5);	  int    parl    =    Math.min(paru,    0,    0.1);    	non-compiled	[CE]  <identifier>  expected	51	None	replace
601	[BUG]  [BUGGY]  double  dxNorm  =  Math.max(work1,  parl);  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  double  dxNorm  =  Math.max(work1,  parl);  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  dxNorm  =  Math.max(work1,  parl);	  double    dxNorm    =    Math.max(paru,    Math.max(work1,    parl));    	non-compiled	[CE]  <identifier>  expected	156	None	replace
602	[BUG]  [BUGGY]  if(paru  ==  0.0)  {  int  paru  =  1.0  /  Math.min(delta,  0.2);  [CE]  variable  paru  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]            AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(paru  ==  0.0)  {  int  paru  =  1.0  /  Math.min(delta,  0.2);  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(paru  ==  0.0)  {  int  paru  =  1.0  /  Math.min(delta,  0.2);	  if(paru    ==    0.0)    {    int    paru    =    2.2251e-308    /    Math.min(delta,    0.2);    	non-compiled	[CE]  variable  paru  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	118	None	replace
603	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  else  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  else  {  paru  =  2.2251e-308  /  Math.min(delta,  [CE]  illegal  start  of  expression  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  else  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  else  {  paru  =  2.2251e-308  /  Math.min(delta,  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.min(delta,        0.1);        if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.1);    }    else    {    paru    =    2.2251e-308    /    Math.min(delta,    0.1);    }    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  else  {  paru  =  2.2251e-308  /  Math.min(delta,	  	non-compiled	[CE]  illegal  start  of  expression	133	None	add
604	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  else  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  else  {  paru  =  2.2251e-308  /  Math.min(delta  [CE]  ')'  expected  [FE]      AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  else  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  else  {  paru  =  2.2251e-308  /  Math.min(delta  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.min(delta,        0.1);        if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.1);    }    else    {    paru    =    2.2251e-308    /    Math.min(delta,    0.1);    }    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  else  {  paru  =  2.2251e-308  /  Math.min(delta	  	non-compiled	[CE]  ')'  expected	133	None	add
605	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  else  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  else  {  paru  =  2.2251e-308  /  Math.min(delt  [CE]  ')'  expected  [FE]        AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  else  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  else  {  paru  =  2.2251e-308  /  Math.min(delt  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.min(delta,        0.1);        if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.1);    }    else    {    paru    =    2.2251e-308    /    Math.min(delta,    0.1);    }    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  else  {  paru  =  2.2251e-308  /  Math.min(delt	  	non-compiled	[CE]  ')'  expected	133	None	add
606	[BUG]  [BUGGY]  paru  =  1.0  /  Math.min(delta,  1.0);  paru  =  1.0  /  Math.min(delta,  1.0);  [CE]  <identifier>  expected  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  paru  =  1.0  /  Math.min(delta,  1.0);  paru  =  1.0  /  Math.min(delta,  1.0);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	paru  =  1.0  /  Math.min(delta,  1.0);  paru  =  1.0  /  Math.min(delta,  1.0);	          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    paru    =    2.2251e-308    /    Math.min(delta,    0.5);    	non-compiled	[CE]  <identifier>  expected	20	None	replace
607	[BUG]  [BUGGY]  double  paru  =  0.2  /  Math.max(parl,  0.1);  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  double  paru  =  0.2  /  Math.max(parl,  0.1);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  paru  =  0.2  /  Math.max(parl,  0.1);	  double    paru    =    0.2    /    Math.max(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	105	None	replace
608	[BUG]  [BUGGY]  int  parl  =  Math.max(parl,  Math.min(delta,  0.5));  [CE]  <identifier>  expected  [FE]            AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  int  parl  =  Math.max(parl,  Math.min(delta,  0.5));  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	int  parl  =  Math.max(parl,  Math.min(delta,  0.5));	  int    parl    =    Math.min(delta,    0.5);    	non-compiled	[CE]  <identifier>  expected	119	None	replace
609	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    paru  =  2.2251e-308  /  Math.max(delta,  0.1);  paru  =  0.2e-308  /  Math.max(delta,  0.1);  paru  =  0.5e-308  /  Math.max(delta,  0.1);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	add	                paru        =        2.2251e-308        /        Math.max(delta,        0.1);        paru    =    2.2251e-308    /    Math.max(delta,    0.1);    paru  =  0.2e-308  /  Math.max(delta,  0.1);  paru  =  0.5e-308  /  Math.max(delta,  0.1);	  	compilable	  [FE]  AssertionFailedError  	41	4	add
610	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    paru  =  2.2251e-308  /  Math.max(delta,  0.1);  paru  =  0.2e-308  /  Math.max(delta,  0.1);  paru  =  0.5e-308  /  Math.max(delta,  0.1);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    paru  =  2.2251e-308  /  Math.max(delta,  0.1);  paru  =  0.2e-308  /  Math.max(delta,  0.1);  paru  =  0.5e-308  /  Math.max(delta,  0.1);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.max(delta,        0.1);        paru    =    2.2251e-308    /    Math.max(delta,    0.1);    paru  =  0.2e-308  /  Math.max(delta,  0.1);  paru  =  0.5e-308  /  Math.max(delta,  0.1);	  	compilable	  [FE]  AssertionFailedError  	41	4	add
611	[BUG]  [BUGGY]  if(paru  >  0)  {  int  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  [CE]  illegal  start  of  expression  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(paru  >  0)  {  int  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(paru    >    0)    {    int  paru  =  2.2251e-308  /  Math.max(delta,  0.1);	  	non-compiled	[CE]  illegal  start  of  expression	146	None	add
612	[BUG]  [BUGGY]  paru  =  1.0  /  Math.max(paru,  0.5);  [CE]  <identifier>  expected  [FE]        AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  paru  =  1.0  /  Math.max(paru,  0.5);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	paru  =  1.0  /  Math.max(paru,  0.5);	  paru    =    1.0    /    Math.min(delta,    0.5);    	non-compiled	[CE]  <identifier>  expected	15	None	replace
613	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  else  {  paru  =  22251e-308  /  Math.min(delta,  0.5);  }  if(paru  <  0)  {  paru  =  22251e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  22251e-308  /  Math.min(delta,  0.5);  }  else  {  paru  =  22251e  [CE]  malformed  floating  point  literal  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  else  {  paru  =  22251e-308  /  Math.min(delta,  0.5);  }  if(paru  <  0)  {  paru  =  22251e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  22251e-308  /  Math.min(delta,  0.5);  }  else  {  paru  =  22251e  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.min(delta,        0.5);        if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.5);    }    else    {    paru    =    22251e-308    /    Math.min(delta,    0.5);    }    if(paru  <  0)  {  paru  =  22251e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  22251e-308  /  Math.min(delta,  0.5);  }  else  {  paru  =  22251e	  	non-compiled	[CE]  malformed  floating  point  literal	159	None	add
614	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  else  {  paru  =  22251e-308  /  Math.min(delta,  0.5);  }  if(paru  <  0)  {  paru  =  22251e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  else  {  paru  =  22251e  [CE]  malformed  floating  point  literal  [FE]      AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  else  {  paru  =  22251e-308  /  Math.min(delta,  0.5);  }  if(paru  <  0)  {  paru  =  22251e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  else  {  paru  =  22251e  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.min(delta,        0.5);        if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.5);    }    else    {    paru    =    22251e-308    /    Math.min(delta,    0.5);    }    if(paru  <  0)  {  paru  =  22251e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  else  {  paru  =  22251e	  	non-compiled	[CE]  malformed  floating  point  literal	159	None	add
615	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  else  {  paru  =  22251e-308  /  Math.min(delta,  0.5);  }  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  else  {  paru  =  22251e-308  /  Math.min(delta  [CE]  ')'  expected  [FE]        AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  else  {  paru  =  22251e-308  /  Math.min(delta,  0.5);  }  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  else  {  paru  =  22251e-308  /  Math.min(delta  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.min(delta,        0.5);        if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.5);    }    else    {    paru    =    22251e-308    /    Math.min(delta,    0.5);    }    paru  =  2.2251e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  else  {  paru  =  22251e-308  /  Math.min(delta	  	non-compiled	[CE]  ')'  expected	159	None	add
616	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  if(paru  >=  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  [CE]  illegal  start  of  expression  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  if(paru  >=  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.min(delta,        0.5);        if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.5);    }    if(paru  >=  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }	  	non-compiled	[CE]  illegal  start  of  expression	22	None	add
617	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  if(paru  ==  0)  {  paru  =  2.0e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  2.0e-308  /  Math.min(delta,  0.5);  }  [CE]  illegal  start  of  expression  [FE]      AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  if(paru  ==  0)  {  paru  =  2.0e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  2.0e-308  /  Math.min(delta,  0.5);  }  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.min(delta,        0.5);        if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.5);    }    if(paru  ==  0)  {  paru  =  2.0e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  2.0e-308  /  Math.min(delta,  0.5);  }	  	non-compiled	[CE]  illegal  start  of  expression	22	None	add
618	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  if(paru  >=  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  [CE]  illegal  start  of  expression  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  if(paru  >=  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.min(delta,        0.5);        if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.5);    }    if    (paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.5);    }    if(paru  >=  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }	  	non-compiled	[CE]  illegal  start  of  expression	111	None	add
619	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  if(paru  <  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  [CE]  illegal  start  of  expression  [FE]      AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  if(paru  <  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.min(delta,        0.5);        if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.5);    }    if    (paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.5);    }    if(paru  <  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }	  	non-compiled	[CE]  illegal  start  of  expression	111	None	add
620	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  if(paru  ==  0)  {  paru  =  2.2251e  [CE]  malformed  floating  point  literal  [FE]        AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.5);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  if(paru  ==  0)  {  paru  =  2.2251e  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.min(delta,        0.5);        if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.5);    }    if    (paru    ==    0)    {    paru    =    2.2251e-308    /    Math.min(delta,    0.5);    }    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  if(paru  ==  0)  {  paru  =  2.2251e	  	non-compiled	[CE]  malformed  floating  point  literal	111	None	add
621	[BUG]  [BUGGY]  if(paru  >  0.0)  {  int  paru  =  1.0  /  Math.min(delta,  0.2);  [CE]  variable  paru  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]              AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(paru  >  0.0)  {  int  paru  =  1.0  /  Math.min(delta,  0.2);  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(paru  >  0.0)  {  int  paru  =  1.0  /  Math.min(delta,  0.2);	  if(paru    >    0.0)    {    int    paru    =    2.2251e-308    /    Math.min(delta,    0.2);    	non-compiled	[CE]  variable  paru  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	81	None	replace
622	[BUG]  [BUGGY]  double  parl  =  Math.max(paru,  0.1,  sum);  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  double  parl  =  Math.max(paru,  0.1,  sum);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  parl  =  Math.max(paru,  0.1,  sum);	  double    parl    =    Math.max(paru,    0.0,    sum);    	non-compiled	[CE]  <identifier>  expected	88	None	replace
623	[BUG]  [BUGGY]  paru  =  1.0  /  Math.max(delta,  0.1);  if(paru  ==  0)  {  paru  =  1.0  /  Math.max(delta,  0.1);  }  else  {  paru  =  1.0  /  Math.max(delta,  0.1);  }  [CE]  <identifier>  expected  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  paru  =  1.0  /  Math.max(delta,  0.1);  if(paru  ==  0)  {  paru  =  1.0  /  Math.max(delta,  0.1);  }  else  {  paru  =  1.0  /  Math.max(delta,  0.1);  }  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	paru  =  1.0  /  Math.max(delta,  0.1);  if(paru  ==  0)  {  paru  =  1.0  /  Math.max(delta,  0.1);  }  else  {  paru  =  1.0  /  Math.max(delta,  0.1);  }	          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.max(delta,    0.1);    }    else    {    paru    =    2.2251e-308    /    Math.max(delta,    0.1);    }    	non-compiled	[CE]  <identifier>  expected	126	None	replace
624	[BUG]  [BUGGY]  if(paru  >  0.0)  {  int  paru  =  1.0  /  Math.max(delta,  0.1);  [CE]  variable  paru  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]        AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(paru  >  0.0)  {  int  paru  =  1.0  /  Math.max(delta,  0.1);  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(paru  >  0.0)  {  int  paru  =  1.0  /  Math.max(delta,  0.1);	  if(paru    >    0.0)    {    int    paru    =    2.2251e-308    /    Math.max(delta,    0.1);    	non-compiled	[CE]  variable  paru  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	153	None	replace
625	[BUG]  [BUGGY]  int  paru  =.252e-308  /  Math.max(delta,  0.1);  [CE]  <identifier>  expected  [FE]          AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  int  paru  =.252e-308  /  Math.max(delta,  0.1);  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	int  paru  =.252e-308  /  Math.max(delta,  0.1);	  if(paru    >    0.0)    {    int    paru    =    2.2251e-308    /    Math.max(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	153	None	replace
626	[BUG]  [BUGGY]  double  paru  =  1.0  /  Math.max(paru,  0.1);  [CE]  <identifier>  expected  [FE]                AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  double  paru  =  1.0  /  Math.max(paru,  0.1);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  paru  =  1.0  /  Math.max(paru,  0.1);	  double    paru    =    1.0    /    Math.max(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	102	None	replace
627	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(paru  <  2)  {  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	add	if(paru  <  2)  {	  if(paru    <    0)    {    	compilable	  [FE]  AssertionFailedError  	72	4	replace
628	[BUG]  [BUGGY]  if(paru  <  2)  {  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(paru  <  2)  {  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(paru  <  2)  {	  if(paru    <    0)    {    	compilable	  [FE]  AssertionFailedError  	72	4	replace
629	[BUG]  [BUGGY]  if(paru  ==  0.0)  {  int  paru  =  1.0  /  Math.min(delta,  0.1);  [CE]  variable  paru  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]        AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(paru  ==  0.0)  {  int  paru  =  1.0  /  Math.min(delta,  0.1);  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(paru  ==  0.0)  {  int  paru  =  1.0  /  Math.min(delta,  0.1);	  if(paru    ==    0.0)    {    int    paru    =    2.2251e-308    /    Math.min(delta,    0.1);    	non-compiled	[CE]  variable  paru  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	116	None	replace
630	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    paru  =  2.2251e-308  /  Math.min(delta,  0.2);  paru  =  0.2e-308  /  Math.min(delta,  0.1);  paru  =  2.2251e-308  /  Math.min(delta,  0.2);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	add	                paru        =        2.2251e-308        /        Math.min(delta,        0.1);        paru    =    2.2251e-308    /    Math.min(delta,    0.2);    paru  =  0.2e-308  /  Math.min(delta,  0.1);  paru  =  2.2251e-308  /  Math.min(delta,  0.2);	  	compilable	  [FE]  AssertionFailedError  	39	4	add
631	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    paru  =  2.2251e-308  /  Math.min(delta,  0.2);  paru  =  0.2e-308  /  Math.min(delta,  0.1);  paru  =  2.2251e-308  /  Math.min(delta,  0.2);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    paru  =  2.2251e-308  /  Math.min(delta,  0.2);  paru  =  0.2e-308  /  Math.min(delta,  0.1);  paru  =  2.2251e-308  /  Math.min(delta,  0.2);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.min(delta,        0.1);        paru    =    2.2251e-308    /    Math.min(delta,    0.2);    paru  =  0.2e-308  /  Math.min(delta,  0.1);  paru  =  2.2251e-308  /  Math.min(delta,  0.2);	  	compilable	  [FE]  AssertionFailedError  	39	4	add
632	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    paru  =  2.2251e-308  /  Math.min(delta,  0.2);  paru  =  0.2e-308  /  Math.min(delta,  0.1);  paru  =  2.0e-308  /  Math.min(delta,  0.2);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	add	                paru        =        2.2251e-308        /        Math.min(delta,        0.1);        paru    =    2.2251e-308    /    Math.min(delta,    0.2);    paru  =  0.2e-308  /  Math.min(delta,  0.1);  paru  =  2.0e-308  /  Math.min(delta,  0.2);	  	compilable	  [FE]  AssertionFailedError  	39	4	add
633	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    paru  =  2.2251e-308  /  Math.min(delta,  0.2);  paru  =  0.2e-308  /  Math.min(delta,  0.1);  paru  =  2.0e-308  /  Math.min(delta,  0.2);  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.min(delta,    0.1);    paru  =  2.2251e-308  /  Math.min(delta,  0.2);  paru  =  0.2e-308  /  Math.min(delta,  0.1);  paru  =  2.0e-308  /  Math.min(delta,  0.2);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.min(delta,        0.1);        paru    =    2.2251e-308    /    Math.min(delta,    0.2);    paru  =  0.2e-308  /  Math.min(delta,  0.1);  paru  =  2.0e-308  /  Math.min(delta,  0.2);	  	compilable	  [FE]  AssertionFailedError  	39	4	add
634	[BUG]  [BUGGY]  if(paru  >  0.0)  {  int  paru  =  1.0  /  Math.min(delta,  0.1);  [CE]  variable  paru  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]          AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(paru  >  0.0)  {  int  paru  =  1.0  /  Math.min(delta,  0.1);  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(paru  >  0.0)  {  int  paru  =  1.0  /  Math.min(delta,  0.1);	  if(paru    >    0.0)    {    int    paru    =    2.2251e-308    /    Math.min(delta,    0.1);    	non-compiled	[CE]  variable  paru  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	79	None	replace
635	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  else  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  if(paru  <  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  else  {  paru  =  2.2251e  [CE]  malformed  floating  point  literal  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  else  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  if(paru  <  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  else  {  paru  =  2.2251e  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.max(delta,        0.1);        if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.max(delta,    0.1);    }    else    {    paru    =    2.2251e-308    /    Math.max(delta,    0.1);    }    if(paru  <  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  else  {  paru  =  2.2251e	  	non-compiled	[CE]  malformed  floating  point  literal	125	None	add
636	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  else  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  else  {  paru  =  2.2251e-308  /  Math.max(delta,  [CE]  illegal  start  of  expression  [FE]      AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  else  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  else  {  paru  =  2.2251e-308  /  Math.max(delta,  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.max(delta,        0.1);        if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.max(delta,    0.1);    }    else    {    paru    =    2.2251e-308    /    Math.max(delta,    0.1);    }    paru  =  2.2251e-308  /  Math.max(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  else  {  paru  =  2.2251e-308  /  Math.max(delta,	  	non-compiled	[CE]  illegal  start  of  expression	125	None	add
637	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  else  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  else  {  paru  =  2.2251e-308  /  Math.max(delta,  [CE]  illegal  start  of  expression  [FE]        AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  else  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  else  {  paru  =  2.2251e-308  /  Math.max(delta,  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.max(delta,        0.1);        if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.max(delta,    0.1);    }    else    {    paru    =    2.2251e-308    /    Math.max(delta,    0.1);    }    paru  =  2.2251e-308  /  Math.max(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  else  {  paru  =  2.2251e-308  /  Math.max(delta,	  	non-compiled	[CE]  illegal  start  of  expression	125	None	add
638	[BUG]  [BUGGY]          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  else  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  if(paru  <  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  else  {  paru  =  2.2251e  [CE]  malformed  floating  point  literal  [FE]          AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]          paru    =    2.2251e-308    /    Math.max(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  else  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  if(paru  <  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  else  {  paru  =  2.2251e  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	                paru        =        2.2251e-308        /        Math.max(delta,        0.1);        if(paru    ==    0)    {    paru    =    2.2251e-308    /    Math.max(delta,    0.1);    }    else    {    paru    =    2.2251e-308    /    Math.max(delta,    0.1);    }    if(paru  <  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  else  {  paru  =  2.2251e	  	non-compiled	[CE]  malformed  floating  point  literal	125	None	add
639	[BUG]  [BUGGY]  if(paru  >  0.0)  {  int  paru  =  1.0  /  Math.min(delta,  0.0);  [CE]  variable  paru  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]            AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(paru  >  0.0)  {  int  paru  =  1.0  /  Math.min(delta,  0.0);  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(paru  >  0.0)  {  int  paru  =  1.0  /  Math.min(delta,  0.0);	  if(paru    >    0.0)    {    int    paru    =    2.2251e-308    /    Math.min(delta,    0.0);    	non-compiled	[CE]  variable  paru  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	80	None	replace
640	[BUG]  [BUGGY]  if(paru  ==  0.0)  {  int  paru  =  1.0  /  Math.min(delta,  0.0);  [CE]  variable  paru  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]          AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(paru  ==  0.0)  {  int  paru  =  1.0  /  Math.min(delta,  0.0);  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(paru  ==  0.0)  {  int  paru  =  1.0  /  Math.min(delta,  0.0);	  if(paru    ==    0.0)    {    int    paru    =    2.2251e-308    /    Math.min(delta,    0.0);    	non-compiled	[CE]  variable  paru  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	117	None	replace
641	[BUG]  [BUGGY]  int  paru  =  Math.max(param,  0.0);  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  int  paru  =  Math.max(param,  0.0);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	int  paru  =  Math.max(param,  0.0);	  int    paru    =    Math.max(delta,    0.0);    	non-compiled	[CE]  <identifier>  expected	94	None	replace
642	[BUG]  [BUGGY]  double  paru  =  1.0  /  Math.max(parl,  0.0);  [CE]  <identifier>  expected  [FE]              AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  double  paru  =  1.0  /  Math.max(parl,  0.0);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  paru  =  1.0  /  Math.max(parl,  0.0);	  double    paru    =    1.0    /    Math.min(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	74	None	replace
643	[BUG]  [BUGGY]  double  paru  =  1.0  /  Math.max(parl,  1.0);  [CE]  <identifier>  expected  [FE]                AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  double  paru  =  1.0  /  Math.max(parl,  1.0);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  paru  =  1.0  /  Math.max(parl,  1.0);	  double    paru    =    1.0    /    Math.min(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	74	None	replace
644	[BUG]  [BUGGY]  Integer  parl  =  Math.min(delta,  0.0);  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  Integer  parl  =  Math.min(delta,  0.0);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	Integer  parl  =  Math.min(delta,  0.0);	  Integer    parl    =    Math.max(delta,    0.0);    	non-compiled	[CE]  <identifier>  expected	26	None	replace
645	[BUG]  [BUGGY]  if(paru  <  =  0.0)  {  If(paru  ==  0.0)  {  [CE]  illegal  start  of  expression  [FE]            AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(paru  <  =  0.0)  {  If(paru  ==  0.0)  {  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(paru  <  =  0.0)  {  If(paru  ==  0.0)  {	  if(paru    ==    0.0)    {    If(paru    ==    0.0)    {    	non-compiled	[CE]  illegal  start  of  expression	100	None	replace
646	[BUG]  [BUGGY]  if(dxNorm  ==  0.0)  {  If(paru  ==  0.0)  {  [CE]  ';'  expected  [FE]              AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(dxNorm  ==  0.0)  {  If(paru  ==  0.0)  {  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(dxNorm  ==  0.0)  {  If(paru  ==  0.0)  {	  if(paru    ==    0.0)    {    If(paru    ==    0.0)    {    	non-compiled	[CE]  ';'  expected	100	None	replace
647	[BUG]  [BUGGY]  if(paru  <  0.0)  {  If(paru  ==  0.0)  {  [CE]  ';'  expected  [FE]                AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(paru  <  0.0)  {  If(paru  ==  0.0)  {  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(paru  <  0.0)  {  If(paru  ==  0.0)  {	  if(paru    ==    0.0)    {    If(paru    ==    0.0)    {    	non-compiled	[CE]  ';'  expected	100	None	replace
648	[BUG]  [BUGGY]  paru  =  0.5  /  Math.max(param,  0.1);  [CE]  <identifier>  expected  [FE]          AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  paru  =  0.5  /  Math.max(param,  0.1);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	paru  =  0.5  /  Math.max(param,  0.1);	  paru    =    0.5    /    Math.max(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	2	None	replace
649	[BUG]  [BUGGY]  int  parl  =  Math.max(param,  10.0);  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  int  parl  =  Math.max(param,  10.0);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	int  parl  =  Math.max(param,  10.0);	  int    parl    =    Math.max(param,    1.0);    	non-compiled	[CE]  <identifier>  expected	92	None	replace
650	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(paru  <  0.0  ||  paru  >  1.0)  {  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	add	if(paru  <  0.0  ||  paru  >  1.0)  {	  if(paru    <    0.0)    {    	compilable	  [FE]  AssertionFailedError  	49	2	replace
651	[BUG]  [BUGGY]  if(paru  <  0.0  ||  paru  >  1.0)  {  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  if(paru  <  0.0  ||  paru  >  1.0)  {  [BUGGY]        paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(paru  <  0.0  ||  paru  >  1.0)  {	  if(paru    <    0.0)    {    	compilable	  [FE]  AssertionFailedError  	49	2	replace
652	[BUG]  [BUGGY]  double  parl  =  Math.max(parl,  Math.min(delta,  0.1));  [CE]  <identifier>  expected  [FE]                AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  double  parl  =  Math.max(parl,  Math.min(delta,  0.1));  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  parl  =  Math.max(parl,  Math.min(delta,  0.1));	  double    parl    =    Math.min(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	52	None	replace
653	[BUG]  [BUGGY]  double  parl  =  Math.max(parl,  Math.min(delta,  1.0));  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  double  parl  =  Math.max(parl,  Math.min(delta,  1.0));  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  parl  =  Math.max(parl,  Math.min(delta,  1.0));	  double    parl    =    Math.min(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	52	None	replace
654	[BUG]  [BUGGY]  double  parl  =  Math.min(parl,  0.1);  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;      [BUGGY]  double  parl  =  Math.min(parl,  0.1);  [BUGGY]      if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  parl  =  Math.min(parl,  0.1);	  double    parl    =    Math.min(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	52	None	replace
