bugid	buggy	buggy_class	suspiciousness	buggy_line	endbuggycode	original_failing_test_number	action	patch	original_buggy	execution_result	diagnosis	previous_bug_id	new_failing_test_number	this_action
1	[BUG]  [BUGGY]  double  s  =(work3[pj]  -  sum)/  work1[pj]  *  s;  [CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]                AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  double  s  =(work3[pj]  -  sum)/  work1[pj]  *  s;  [BUGGY]    sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	replace	double  s  =(work3[pj]  -  sum)/  work1[pj]  *  s;	      double    s    =(work3[pj]    -    sum)/    diagR[pj]    *    s;    	non-compiled	[CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	26	None	replace
2	[BUG]  [BUGGY]  double  s  =(work3[pj]  -  sum)/  work2[pj]  *  s;  [CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]                  AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  double  s  =(work3[pj]  -  sum)/  work2[pj]  *  s;  [BUGGY]    sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	replace	double  s  =(work3[pj]  -  sum)/  work2[pj]  *  s;	      double    s    =(work3[pj]    -    sum)/    diagR[pj]    *    s;    	non-compiled	[CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	26	None	replace
3	[BUG]  [BUGGY]  double  s  =(work3[pj]  -  sum)/  diagR[pj]  *  sum;  [CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]                    AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  double  s  =(work3[pj]  -  sum)/  diagR[pj]  *  sum;  [BUGGY]    sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	replace	double  s  =(work3[pj]  -  sum)/  diagR[pj]  *  sum;	      double    s    =(work3[pj]    -    sum)/    diagR[pj]    *    s;    	non-compiled	[CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	26	None	replace
4	[BUG]  [BUGGY]  double  s  =(work3[pj]  -  sum)/  work1.length  *  diagR[pj]  *  s;  [CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]                      AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  double  s  =(work3[pj]  -  sum)/  work1.length  *  diagR[pj]  *  s;  [BUGGY]    sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	replace	double  s  =(work3[pj]  -  sum)/  work1.length  *  diagR[pj]  *  s;	      double    s    =(work3[pj]    -    sum)/    diagR[pj]    *    s;    	non-compiled	[CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	26	None	replace
5	[BUG]  [BUGGY]  sum2  +=  work1  *  s;  [CE]  bad  operand  types  for  binary  operator  '*'  [FE]        AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  sum2  +=  work1  *  s;  [BUGGY]    }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	replace	sum2  +=  work1  *  s;	  sum2    +=    s    *    work3;    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '*'	7	None	replace
6	[BUG]  [BUGGY]  sum2  +=  work3  *  s;  [CE]  bad  operand  types  for  binary  operator  '*'  [FE]          AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  sum2  +=  work3  *  s;  [BUGGY]    }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	replace	sum2  +=  work3  *  s;	  sum2    +=    s    *    work3;    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '*'	7	None	replace
7	[BUG]  [BUGGY]  sum2  +=  work1[s]  *  s;  [CE]  possible  loss  of  precision  [FE]            AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  sum2  +=  work1[s]  *  s;  [BUGGY]    }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	replace	sum2  +=  work1[s]  *  s;	  sum2    +=    s    *    work3;    	non-compiled	[CE]  possible  loss  of  precision	7	None	replace
8	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]              AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  sum2  +=  work1.length  *  s;  [BUGGY]    }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	add	sum2  +=  work1.length  *  s;	  sum2    +=    s    *    work3;    	compilable	  [FE]  AssertionFailedError  	7	12	replace
9	[BUG]  [BUGGY]  sum2  +=  work1.length  *  s;  [FE]  AssertionFailedError  [FE]              AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  sum2  +=  work1.length  *  s;  [BUGGY]    }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	replace	sum2  +=  work1.length  *  s;	  sum2    +=    s    *    work3;    	compilable	  [FE]  AssertionFailedError  	7	12	replace
10	[BUG]  [BUGGY]  double  s  =(work1[j]  -  sum)/  work3[pj];  [CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]                AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  double  s  =(work1[j]  -  sum)/  work3[pj];  [BUGGY]    sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	replace	double  s  =(work1[j]  -  sum)/  work3[pj];	      double    s    =(work1[j]    -    sum)/    work2[pj];    	non-compiled	[CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	6	None	replace
11	[BUG]  [BUGGY]  double  s  =(work1[pj]  -  sum)/  work2[pj];  [CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]                  AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  double  s  =(work1[pj]  -  sum)/  work2[pj];  [BUGGY]    sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	replace	double  s  =(work1[pj]  -  sum)/  work2[pj];	      double    s    =(work1[j]    -    sum)/    work2[pj];    	non-compiled	[CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	6	None	replace
12	[BUG]  [BUGGY]  double  s  =(work3[j]  -  sum)/  work2[pj];  [CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]              AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  double  s  =(work3[j]  -  sum)/  work2[pj];  [BUGGY]    sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	replace	double  s  =(work3[j]  -  sum)/  work2[pj];	      double    s    =(work3[j]    -    sum)/    diagR[pj];    	non-compiled	[CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	25	None	replace
13	[BUG]  [BUGGY]  double  s  =(work2[j]  -  sum)/  diagR[pj];  [CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]                AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  double  s  =(work2[j]  -  sum)/  diagR[pj];  [BUGGY]    sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	replace	double  s  =(work2[j]  -  sum)/  diagR[pj];	      double    s    =(work3[j]    -    sum)/    diagR[pj];    	non-compiled	[CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	25	None	replace
14	[BUG]  [BUGGY]  double  s  =(work1[pj]  -  work1[pj])/  work3[pj];  [CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]            AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  double  s  =(work1[pj]  -  work1[pj])/  work3[pj];  [BUGGY]    sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	replace	double  s  =(work1[pj]  -  work1[pj])/  work3[pj];	      double    s    =(work3[pj]    -    work1[pj])/    diagR[pj];    	non-compiled	[CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	24	None	replace
15	[BUG]  [BUGGY]  double  s  =(work1[pj]  -  work3[pj])/  diagR[pj];  [CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]              AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  double  s  =(work1[pj]  -  work3[pj])/  diagR[pj];  [BUGGY]    sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	replace	double  s  =(work1[pj]  -  work3[pj])/  diagR[pj];	      double    s    =(work3[pj]    -    work1[pj])/    diagR[pj];    	non-compiled	[CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	24	None	replace
16	[BUG]  [BUGGY]  double  s  =(work1[pj]  -  work2[pj])/  diagR[pj];  [CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]                AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  double  s  =(work1[pj]  -  work2[pj])/  diagR[pj];  [BUGGY]    sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	replace	double  s  =(work1[pj]  -  work2[pj])/  diagR[pj];	      double    s    =(work3[pj]    -    work1[pj])/    diagR[pj];    	non-compiled	[CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	24	None	replace
17	[BUG]  [BUGGY]  double  s  =(work1[pj]  -  work1[pj])/  diagR[pj];  [CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]                  AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  double  s  =(work1[pj]  -  work1[pj])/  diagR[pj];  [BUGGY]    sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	replace	double  s  =(work1[pj]  -  work1[pj])/  diagR[pj];	      double    s    =(work3[pj]    -    work1[pj])/    diagR[pj];    	non-compiled	[CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	24	None	replace
18	[BUG]  [BUGGY]  sum2  +=  diagR  *  s;  [CE]  bad  operand  types  for  binary  operator  '*'  [FE]        AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  sum2  +=  diagR  *  s;  [BUGGY]    }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	replace	sum2  +=  diagR  *  s;	  sum2    +=    s    *    diagR;    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '*'	18	None	replace
19	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  sum2  +=  s  *  diagR[j];  [BUGGY]    }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	add	sum2  +=  s  *  diagR[j];	  sum2    +=    s    *    diagR;    	compilable	  [FE]  AssertionFailedError  	18	12	replace
20	[BUG]  [BUGGY]  sum2  +=  s  *  diagR[j];  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  sum2  +=  s  *  diagR[j];  [BUGGY]    }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	replace	sum2  +=  s  *  diagR[j];	  sum2    +=    s    *    diagR;    	compilable	  [FE]  AssertionFailedError  	18	12	replace
21	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  sum2  +=  s  *  work1.length;  [BUGGY]    }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	add	sum2  +=  s  *  work1.length;	  sum2    +=    s    *    s.length;    	compilable	  [FE]  AssertionFailedError  	8	12	replace
22	[BUG]  [BUGGY]  sum2  +=  s  *  work1.length;  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  sum2  +=  s  *  work1.length;  [BUGGY]    }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	replace	sum2  +=  s  *  work1.length;	  sum2    +=    s    *    s.length;    	compilable	  [FE]  AssertionFailedError  	8	12	replace
23	[BUG]  [BUGGY]  sum2  +=  s  *  s2.length;  [CE]  cannot  find  symbol  s2  [FE]            AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  sum2  +=  s  *  s2.length;  [BUGGY]    }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	replace	sum2  +=  s  *  s2.length;	  sum2    +=    s    *    s.length;    	non-compiled	[CE]  cannot  find  symbol  s2	8	None	replace
24	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]              AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  sum2  +=  s  *  work2.length;  [BUGGY]    }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	add	sum2  +=  s  *  work2.length;	  sum2    +=    s    *    s.length;    	compilable	  [FE]  AssertionFailedError  	8	12	replace
25	[BUG]  [BUGGY]  sum2  +=  s  *  work2.length;  [FE]  AssertionFailedError  [FE]              AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  sum2  +=  s  *  work2.length;  [BUGGY]    }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	replace	sum2  +=  s  *  work2.length;	  sum2    +=    s    *    s.length;    	compilable	  [FE]  AssertionFailedError  	8	12	replace
26	[BUG]  [BUGGY]  double  s  =  Math.abs(sum);  [CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]        AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  double  s  =  Math.abs(sum);  [BUGGY]    sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	replace	double  s  =  Math.abs(sum);	      double    s    =    Math.abs(s);    	non-compiled	[CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	12	None	replace
27	[BUG]  [BUGGY]  double  s  =  Math.abs(sum2);  [CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]          AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  double  s  =  Math.abs(sum2);  [BUGGY]    sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	replace	double  s  =  Math.abs(sum2);	      double    s    =    Math.abs(s);    	non-compiled	[CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	12	None	replace
28	[BUG]  [BUGGY]  double  s  =  Math.abs(diagR[pj]);  [CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]            AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  double  s  =  Math.abs(diagR[pj]);  [BUGGY]    sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	replace	double  s  =  Math.abs(diagR[pj]);	      double    s    =    Math.abs(s);    	non-compiled	[CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	12	None	replace
29	[BUG]  [BUGGY]  double  s  =(work1[pj]  -  work1)/  diagR[pj];  [CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]          AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  double  s  =(work1[pj]  -  work1)/  diagR[pj];  [BUGGY]    sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	replace	double  s  =(work1[pj]  -  work1)/  diagR[pj];	      double    s    =(work3[pj]    -    work1)/    diagR[pj];    	non-compiled	[CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	23	None	replace
30	[BUG]  [BUGGY]  double  s  =(work2[pj]  -  work1)/  diagR[pj];  [CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]            AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  double  s  =(work2[pj]  -  work1)/  diagR[pj];  [BUGGY]    sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	replace	double  s  =(work2[pj]  -  work1)/  diagR[pj];	      double    s    =(work3[pj]    -    work1)/    diagR[pj];    	non-compiled	[CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	23	None	replace
31	[BUG]  [BUGGY]  double  s  =(work3[pj]  -  work1)/  jacobian[pj];  [CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]              AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  double  s  =(work3[pj]  -  work1)/  jacobian[pj];  [BUGGY]    sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	replace	double  s  =(work3[pj]  -  work1)/  jacobian[pj];	      double    s    =(work3[pj]    -    work1)/    diagR[pj];    	non-compiled	[CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	23	None	replace
32	[BUG]  [BUGGY]  double  s  =(work1[j]  -  sum)/  jacobian[pj];  [CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]          AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  double  s  =(work1[j]  -  sum)/  jacobian[pj];  [BUGGY]    sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	replace	double  s  =(work1[j]  -  sum)/  jacobian[pj];	      double    s    =(work1[j]    -    sum)/    diagR[pj];    	non-compiled	[CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	2	None	replace
33	[BUG]  [BUGGY]  double  s  =  Math.min(sum2,  work3.length);  [CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]              AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  double  s  =  Math.min(sum2,  work3.length);  [BUGGY]    sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	replace	double  s  =  Math.min(sum2,  work3.length);	      double    s    =    Math.min(sum,    work2.length);    	non-compiled	[CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	16	None	replace
34	[BUG]  [BUGGY]  double  s  =  Math.min(sum,  work1.length);  [CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]                AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  double  s  =  Math.min(sum,  work1.length);  [BUGGY]    sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	replace	double  s  =  Math.min(sum,  work1.length);	      double    s    =    Math.min(sum,    work2.length);    	non-compiled	[CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	16	None	replace
35	[BUG]  [BUGGY]  double  s  =  Math.min(sum,  work2,  work3);  [CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]                  AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  double  s  =  Math.min(sum,  work2,  work3);  [BUGGY]    sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	replace	double  s  =  Math.min(sum,  work2,  work3);	      double    s    =    Math.min(sum,    work2.length);    	non-compiled	[CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	16	None	replace
36	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]      s  =  Math.abs(s);  s  =  Math.abs(s);  [BUGGY]    sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	add	        s    =    Math.abs(s);    s  =  Math.abs(s);	  	compilable	  [FE]  AssertionFailedError  	13	2	add
37	[BUG]  [BUGGY]      s  =  Math.abs(s);  s  =  Math.abs(s);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]      s  =  Math.abs(s);  s  =  Math.abs(s);  [BUGGY]    sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	replace	        s    =    Math.abs(s);    s  =  Math.abs(s);	  	compilable	  [FE]  AssertionFailedError  	13	2	add
38	[BUG]  [BUGGY]      s  =  Math.abs(s);  int  s  =  Math.abs(s);  [CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]      AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]      s  =  Math.abs(s);  int  s  =  Math.abs(s);  [BUGGY]    sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	replace	        s    =    Math.abs(s);    int  s  =  Math.abs(s);	  	non-compiled	[CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	13	None	add
39	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]      s  =  Math.abs(s);  parl  =  Math.abs(s);  [BUGGY]    sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	add	        s    =    Math.abs(s);    parl  =  Math.abs(s);	  	compilable	  [FE]  AssertionFailedError  	13	2	add
40	[BUG]  [BUGGY]      s  =  Math.abs(s);  parl  =  Math.abs(s);  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]      s  =  Math.abs(s);  parl  =  Math.abs(s);  [BUGGY]    sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	replace	        s    =    Math.abs(s);    parl  =  Math.abs(s);	  	compilable	  [FE]  AssertionFailedError  	13	2	add
41	[BUG]  [BUGGY]      s  =  Math.abs(s);  s  =  Math.abs(s));  [CE]  ';'  expected  [FE]          AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]      s  =  Math.abs(s);  s  =  Math.abs(s));  [BUGGY]    sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	replace	        s    =    Math.abs(s);    s  =  Math.abs(s));	  	non-compiled	[CE]  ';'  expected	13	None	add
42	[BUG]  [BUGGY]      s  =  Math.abs(s);  (s  =  Math.abs(s);  [CE]  ')'  expected  [FE]            AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]      s  =  Math.abs(s);  (s  =  Math.abs(s);  [BUGGY]    sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	replace	        s    =    Math.abs(s);    (s  =  Math.abs(s);	  	non-compiled	[CE]  ')'  expected	13	None	add
43	[BUG]  [BUGGY]  double  s  =  Math.pow(10,  sum);  [CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]                AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  double  s  =  Math.pow(10,  sum);  [BUGGY]    sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	replace	double  s  =  Math.pow(10,  sum);	      double    s    =    Math.pow(0,    sum);    	non-compiled	[CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	17	None	replace
44	[BUG]  [BUGGY]  double  s  =  Math.pow(1,  sum);  [CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]                  AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  double  s  =  Math.pow(1,  sum);  [BUGGY]    sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	replace	double  s  =  Math.pow(1,  sum);	      double    s    =    Math.pow(0,    sum);    	non-compiled	[CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	17	None	replace
45	[BUG]  [BUGGY]  double  s  =  Math.pow(2,  sum);  [CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]                    AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  double  s  =  Math.pow(2,  sum);  [BUGGY]    sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	replace	double  s  =  Math.pow(2,  sum);	      double    s    =    Math.pow(0,    sum);    	non-compiled	[CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	17	None	replace
46	[BUG]  [BUGGY]  double  s  =  Math.pow(0,  sum  +  1);  [CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]                      AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  double  s  =  Math.pow(0,  sum  +  1);  [BUGGY]    sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	replace	double  s  =  Math.pow(0,  sum  +  1);	      double    s    =    Math.pow(0,    sum);    	non-compiled	[CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	17	None	replace
47	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  sum2  +=  s  *  work1[pj];  [BUGGY]    }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	add	sum2  +=  s  *  work1[pj];	  sum2    +=    s    *    diagR[pj];    	compilable	  [FE]  AssertionFailedError  	21	2	replace
48	[BUG]  [BUGGY]  sum2  +=  s  *  work1[pj];  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  sum2  +=  s  *  work1[pj];  [BUGGY]    }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	replace	sum2  +=  s  *  work1[pj];	  sum2    +=    s    *    diagR[pj];    	compilable	  [FE]  AssertionFailedError  	21	2	replace
49	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  sum2  +=  work1[pj]  *  diagR[pj];  [BUGGY]    }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	add	sum2  +=  work1[pj]  *  diagR[pj];	  sum2    +=    s    *    diagR[pj];    	compilable	  [FE]  AssertionFailedError  	21	12	replace
50	[BUG]  [BUGGY]  sum2  +=  work1[pj]  *  diagR[pj];  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  sum2  +=  work1[pj]  *  diagR[pj];  [BUGGY]    }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	replace	sum2  +=  work1[pj]  *  diagR[pj];	  sum2    +=    s    *    diagR[pj];    	compilable	  [FE]  AssertionFailedError  	21	12	replace
51	[BUG]  [BUGGY]  sum2  +=  work3  *  diagR[pj];  [CE]  bad  operand  types  for  binary  operator  '*'  [FE]        AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  sum2  +=  work3  *  diagR[pj];  [BUGGY]    }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	replace	sum2  +=  work3  *  diagR[pj];	  sum2    +=    s    *    diagR[pj];    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '*'	21	None	replace
52	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  sum2  +=  s  *  work3[pj];  [BUGGY]    }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	add	sum2  +=  s  *  work3[pj];	  sum2    +=    s    *    diagR[pj];    	compilable	  [FE]  AssertionFailedError  	21	13	replace
53	[BUG]  [BUGGY]  sum2  +=  s  *  work3[pj];  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  sum2  +=  s  *  work3[pj];  [BUGGY]    }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	replace	sum2  +=  s  *  work3[pj];	  sum2    +=    s    *    diagR[pj];    	compilable	  [FE]  AssertionFailedError  	21	13	replace
54	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  sum2  +=  s  *  diagR[pj];  sum2  +=  s  *  diagR[pj];  [BUGGY]    }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	add	sum2    +=    s    *    diagR[pj];    sum2  +=  s  *  diagR[pj];	  	compilable	  [FE]  AssertionFailedError  	20	4	add
55	[BUG]  [BUGGY]  sum2  +=  s  *  diagR[pj];  sum2  +=  s  *  diagR[pj];  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  sum2  +=  s  *  diagR[pj];  sum2  +=  s  *  diagR[pj];  [BUGGY]    }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	replace	sum2    +=    s    *    diagR[pj];    sum2  +=  s  *  diagR[pj];	  	compilable	  [FE]  AssertionFailedError  	20	4	add
56	[BUG]  [BUGGY]  sum2  +=  s  *  diagR[pj];  Sum2  +=  s  *  diagR[pj];  [CE]  cannot  find  symbol  Sum2  [FE]      AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  sum2  +=  s  *  diagR[pj];  Sum2  +=  s  *  diagR[pj];  [BUGGY]    }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	replace	sum2    +=    s    *    diagR[pj];    Sum2  +=  s  *  diagR[pj];	  	non-compiled	[CE]  cannot  find  symbol  Sum2	20	None	add
57	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  sum2  +=  s  *  diagR[pj];  sum2  -=  s  *  diagR[pj];  [BUGGY]    }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	add	sum2    +=    s    *    diagR[pj];    sum2  -=  s  *  diagR[pj];	  	compilable	  [FE]  AssertionFailedError  	20	2	add
58	[BUG]  [BUGGY]  sum2  +=  s  *  diagR[pj];  sum2  -=  s  *  diagR[pj];  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  sum2  +=  s  *  diagR[pj];  sum2  -=  s  *  diagR[pj];  [BUGGY]    }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	replace	sum2    +=    s    *    diagR[pj];    sum2  -=  s  *  diagR[pj];	  	compilable	  [FE]  AssertionFailedError  	20	2	add
59	[BUG]  [BUGGY]  sum2  +=  s  *  diagR[pj];  sum2  +=  s  *  diagr[pj];  [CE]  cannot  find  symbol  diagr  [FE]          AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  sum2  +=  s  *  diagR[pj];  sum2  +=  s  *  diagr[pj];  [BUGGY]    }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	replace	sum2    +=    s    *    diagR[pj];    sum2  +=  s  *  diagr[pj];	  	non-compiled	[CE]  cannot  find  symbol  diagr	20	None	add
60	[BUG]  [BUGGY]  sum2  +=  s  *  diagR[pj];  total2  +=  s  *  diagR[pj];  [CE]  cannot  find  symbol  total2  [FE]            AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  sum2  +=  s  *  diagR[pj];  total2  +=  s  *  diagR[pj];  [BUGGY]    }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	replace	sum2    +=    s    *    diagR[pj];    total2  +=  s  *  diagR[pj];	  	non-compiled	[CE]  cannot  find  symbol  total2	20	None	add
61	[BUG]  [BUGGY]  double  s  =(work1[pj]  -  sum)/  diagR[pj];  [CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]        AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  double  s  =(work1[pj]  -  sum)/  diagR[pj];  [BUGGY]    sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	replace	double  s  =(work1[pj]  -  sum)/  diagR[pj];	      double    s    =(work1[i]    -    sum)/    diagR[pj];    	non-compiled	[CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	1	None	replace
62	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  s  =  Math.abs(s  +  1);  [BUGGY]    sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	add	s  =  Math.abs(s  +  1);	      s    =    Math.abs(s);    	compilable	  [FE]  AssertionFailedError  	14	13	replace
63	[BUG]  [BUGGY]  s  =  Math.abs(s  +  1);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  s  =  Math.abs(s  +  1);  [BUGGY]    sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	replace	s  =  Math.abs(s  +  1);	      s    =    Math.abs(s);    	compilable	  [FE]  AssertionFailedError  	14	13	replace
64	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  s  =  Math.abs(s  *  sum);  [BUGGY]    sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	add	s  =  Math.abs(s  *  sum);	      s    =    Math.abs(s);    	compilable	  [FE]  AssertionFailedError  	14	13	replace
65	[BUG]  [BUGGY]  s  =  Math.abs(s  *  sum);  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  s  =  Math.abs(s  *  sum);  [BUGGY]    sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	replace	s  =  Math.abs(s  *  sum);	      s    =    Math.abs(s);    	compilable	  [FE]  AssertionFailedError  	14	13	replace
66	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  s  =  Math.abs(sum);  [BUGGY]    sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	add	s  =  Math.abs(sum);	      s    =    Math.abs(s);    	compilable	  [FE]  AssertionFailedError  	14	13	replace
67	[BUG]  [BUGGY]  s  =  Math.abs(sum);  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  s  =  Math.abs(sum);  [BUGGY]    sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	replace	s  =  Math.abs(sum);	      s    =    Math.abs(s);    	compilable	  [FE]  AssertionFailedError  	14	13	replace
68	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]      sum  +=  s  *  s;  sum  +=  s  *  s;  [BUGGY]    sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	add	        sum    +=    s    *    s;    sum  +=  s  *  s;	  	compilable	  [FE]  AssertionFailedError  	3	2	add
69	[BUG]  [BUGGY]      sum  +=  s  *  s;  sum  +=  s  *  s;  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]      sum  +=  s  *  s;  sum  +=  s  *  s;  [BUGGY]    sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	replace	        sum    +=    s    *    s;    sum  +=  s  *  s;	  	compilable	  [FE]  AssertionFailedError  	3	2	add
70	[BUG]  [BUGGY]      sum  +=  s  *  s;  Sum  +=  s  *  s;  [CE]  cannot  find  symbol  Sum  [FE]      AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]      sum  +=  s  *  s;  Sum  +=  s  *  s;  [BUGGY]    sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	replace	        sum    +=    s    *    s;    Sum  +=  s  *  s;	  	non-compiled	[CE]  cannot  find  symbol  Sum	3	None	add
71	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]      sum  +=  s  *  s;  sum  -=  s  *  s;  [BUGGY]    sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	add	        sum    +=    s    *    s;    sum  -=  s  *  s;	  	compilable	  [FE]  AssertionFailedError  	3	2	add
72	[BUG]  [BUGGY]      sum  +=  s  *  s;  sum  -=  s  *  s;  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]      sum  +=  s  *  s;  sum  -=  s  *  s;  [BUGGY]    sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	replace	        sum    +=    s    *    s;    sum  -=  s  *  s;	  	compilable	  [FE]  AssertionFailedError  	3	2	add
73	[BUG]  [BUGGY]      sum  +=  s  *  s;  sum  +=  s  *  s);  [CE]  ';'  expected  [FE]          AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]      sum  +=  s  *  s;  sum  +=  s  *  s);  [BUGGY]    sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	replace	        sum    +=    s    *    s;    sum  +=  s  *  s);	  	non-compiled	[CE]  ';'  expected	3	None	add
74	[BUG]  [BUGGY]      sum  +=  s  *  s;  total  +=  s  *  s;  [CE]  cannot  find  symbol  total  [FE]            AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]      sum  +=  s  *  s;  total  +=  s  *  s;  [BUGGY]    sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	replace	        sum    +=    s    *    s;    total  +=  s  *  s;	  	non-compiled	[CE]  cannot  find  symbol  total	3	None	add
75	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  sum2  -=  s  *  s;  sum2  -=  s  *  s;  [BUGGY]    }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	add	sum2    -=    s    *    s;    sum2  -=  s  *  s;	  	compilable	  [FE]  AssertionFailedError  	9	12	add
76	[BUG]  [BUGGY]  sum2  -=  s  *  s;  sum2  -=  s  *  s;  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  sum2  -=  s  *  s;  sum2  -=  s  *  s;  [BUGGY]    }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	replace	sum2    -=    s    *    s;    sum2  -=  s  *  s;	  	compilable	  [FE]  AssertionFailedError  	9	12	add
77	[BUG]  [BUGGY]  sum2  -=  s  *  s;  Sum2  -=  s  *  s;  [CE]  cannot  find  symbol  Sum2  [FE]      AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  sum2  -=  s  *  s;  Sum2  -=  s  *  s;  [BUGGY]    }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	replace	sum2    -=    s    *    s;    Sum2  -=  s  *  s;	  	non-compiled	[CE]  cannot  find  symbol  Sum2	9	None	add
78	[BUG]  [BUGGY]  sum2  -=  s  *  s;  sum2  -=  s  *  s);  [CE]  ';'  expected  [FE]        AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  sum2  -=  s  *  s;  sum2  -=  s  *  s);  [BUGGY]    }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	replace	sum2    -=    s    *    s;    sum2  -=  s  *  s);	  	non-compiled	[CE]  ';'  expected	9	None	add
79	[BUG]  [BUGGY]  sum2  -=  s  *  s;  sum2  -=  s  *  s.length;  [CE]  double  cannot  be  dereferenced  [FE]          AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  sum2  -=  s  *  s;  sum2  -=  s  *  s.length;  [BUGGY]    }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	replace	sum2    -=    s    *    s;    sum2  -=  s  *  s.length;	  	non-compiled	[CE]  double  cannot  be  dereferenced	9	None	add
80	[BUG]  [BUGGY]  double  s  =(work1[i]  -  sum)/  work3[pj];  [CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]              AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  double  s  =(work1[i]  -  sum)/  work3[pj];  [BUGGY]    sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	replace	double  s  =(work1[i]  -  sum)/  work3[pj];	      double    s    =(work1[i]    -    sum)/    work2[pj];    	non-compiled	[CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	5	None	replace
81	[BUG]  [BUGGY]  sum  +=  s  *  s.length;  [CE]  double  cannot  be  dereferenced  [FE]    AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  sum  +=  s  *  s.length;  [BUGGY]    sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	replace	sum  +=  s  *  s.length;	      sum    +=    s    *    s;    	non-compiled	[CE]  double  cannot  be  dereferenced	4	None	replace
82	[BUG]  [BUGGY]  sum  +=  s  *  work3;  [CE]  bad  operand  types  for  binary  operator  '*'  [FE]      AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  sum  +=  s  *  work3;  [BUGGY]    sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	replace	sum  +=  s  *  work3;	      sum    +=    s    *    s;    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '*'	4	None	replace
83	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  sum  +=  s  *  diagR.length;  [BUGGY]    sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	add	sum  +=  s  *  diagR.length;	      sum    +=    s    *    s;    	compilable	  [FE]  AssertionFailedError  	4	13	replace
84	[BUG]  [BUGGY]  sum  +=  s  *  diagR.length;  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  sum  +=  s  *  diagR.length;  [BUGGY]    sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	replace	sum  +=  s  *  diagR.length;	      sum    +=    s    *    s;    	compilable	  [FE]  AssertionFailedError  	4	13	replace
85	[BUG]  [BUGGY]  double  s  =(work2[pj]  -  sum)/  diagR[pj];  [CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]        AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  double  s  =(work2[pj]  -  sum)/  diagR[pj];  [BUGGY]    sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	replace	double  s  =(work2[pj]  -  sum)/  diagR[pj];	      double    s    =(work3[pj]    -    sum)/    diagR[pj];    	non-compiled	[CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	22	None	replace
86	[BUG]  [BUGGY]  double  s  =(work3[pj]  -  sum)/  work2[pj];  [CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]          AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  double  s  =(work3[pj]  -  sum)/  work2[pj];  [BUGGY]    sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	replace	double  s  =(work3[pj]  -  sum)/  work2[pj];	      double    s    =(work3[pj]    -    sum)/    diagR[pj];    	non-compiled	[CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	22	None	replace
87	[BUG]  [BUGGY]  double  s  =(work3[pj]  -  sum)/  jacobian[pj];  [CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]            AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  double  s  =(work3[pj]  -  sum)/  jacobian[pj];  [BUGGY]    sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	replace	double  s  =(work3[pj]  -  sum)/  jacobian[pj];	      double    s    =(work3[pj]    -    sum)/    diagR[pj];    	non-compiled	[CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	22	None	replace
88	[BUG]  [BUGGY]  sum2  -=  work1  *  s;  [CE]  bad  operand  types  for  binary  operator  '*'  [FE]          AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  sum2  -=  work1  *  s;  [BUGGY]    }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	replace	sum2  -=  work1  *  s;	  sum2    -=    s    *    work3;    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '*'	19	None	replace
89	[BUG]  [BUGGY]  sum2  -=  work1[s]  *  s;  [CE]  possible  loss  of  precision  [FE]            AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  sum2  -=  work1[s]  *  s;  [BUGGY]    }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	replace	sum2  -=  work1[s]  *  s;	  sum2    -=    s    *    work3;    	non-compiled	[CE]  possible  loss  of  precision	19	None	replace
90	[BUG]  [BUGGY]  sum2  -=  work3  *  s;  [CE]  bad  operand  types  for  binary  operator  '*'  [FE]              AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  sum2  -=  work3  *  s;  [BUGGY]    }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	replace	sum2  -=  work3  *  s;	  sum2    -=    s    *    work3;    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '*'	19	None	replace
91	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]                AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  sum2  -=  work1.length  *  s;  [BUGGY]    }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	add	sum2  -=  work1.length  *  s;	  sum2    -=    s    *    work3;    	compilable	  [FE]  AssertionFailedError  	19	12	replace
92	[BUG]  [BUGGY]  sum2  -=  work1.length  *  s;  [FE]  AssertionFailedError  [FE]                AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  sum2  -=  work1.length  *  s;  [BUGGY]    }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	replace	sum2  -=  work1.length  *  s;	  sum2    -=    s    *    work3;    	compilable	  [FE]  AssertionFailedError  	19	12	replace
93	[BUG]  [BUGGY]  double  s  =  Math.min(sum,  work2,  work3.length);  [CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]            AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  double  s  =  Math.min(sum,  work2,  work3.length);  [BUGGY]    sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	replace	double  s  =  Math.min(sum,  work2,  work3.length);	      double    s    =    Math.min(sum,    work3.length);    	non-compiled	[CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	15	None	replace
94	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  sum2  -=  s  *  sum;  [BUGGY]    }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	add	sum2  -=  s  *  sum;	  sum2    -=    s    *    s;    	compilable	  [FE]  AssertionFailedError  	10	12	replace
95	[BUG]  [BUGGY]  sum2  -=  s  *  sum;  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  sum2  -=  s  *  sum;  [BUGGY]    }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	replace	sum2  -=  s  *  sum;	  sum2    -=    s    *    s;    	compilable	  [FE]  AssertionFailedError  	10	12	replace
96	[BUG]  [BUGGY]  sum2  -=  s  *  work1;  [CE]  bad  operand  types  for  binary  operator  '*'  [FE]      AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  sum2  -=  s  *  work1;  [BUGGY]    }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	replace	sum2  -=  s  *  work1;	  sum2    -=    s    *    s;    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '*'	10	None	replace
97	[BUG]  [BUGGY]  sum2  -=  s  *  total;  [CE]  cannot  find  symbol  total  [FE]        AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  sum2  -=  s  *  total;  [BUGGY]    }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	replace	sum2  -=  s  *  total;	  sum2    -=    s    *    s;    	non-compiled	[CE]  cannot  find  symbol  total	10	None	replace
98	[BUG]  [BUGGY]      s  =  Math.abs(s);  S  =  Math.abs(s);  [CE]  cannot  find  symbol  S  [FE]    AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]      s  =  Math.abs(s);  S  =  Math.abs(s);  [BUGGY]    sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	replace	        s    =    Math.abs(s);    S  =  Math.abs(s);	  	non-compiled	[CE]  cannot  find  symbol  S	13	None	add
99	[BUG]  [BUGGY]  double  s  =  Math.abs(solvedCols);  [CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]        AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  double  s  =  Math.abs(solvedCols);  [BUGGY]    sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	replace	double  s  =  Math.abs(solvedCols);	      double    s    =    Math.abs(s);    	non-compiled	[CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	12	None	replace
100	[BUG]  [BUGGY]  double  s  =  Math.abs(diagR);  [CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]          AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  double  s  =  Math.abs(diagR);  [BUGGY]    sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	replace	double  s  =  Math.abs(diagR);	      double    s    =    Math.abs(s);    	non-compiled	[CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	12	None	replace
101	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  sum2  +=  s  *  diagR[0];  [BUGGY]    }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	add	sum2  +=  s  *  diagR[0];	  sum2    +=    s    *    diagR;    	compilable	  [FE]  AssertionFailedError  	18	11	replace
102	[BUG]  [BUGGY]  sum2  +=  s  *  diagR[0];  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  sum2  +=  s  *  diagR[0];  [BUGGY]    }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	replace	sum2  +=  s  *  diagR[0];	  sum2    +=    s    *    diagR;    	compilable	  [FE]  AssertionFailedError  	18	11	replace
103	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  sum2  +=  s  *  work3.length;  [BUGGY]    }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	add	sum2  +=  s  *  work3.length;	  sum2    +=    s    *    s.length;    	compilable	  [FE]  AssertionFailedError  	8	12	replace
104	[BUG]  [BUGGY]  sum2  +=  s  *  work3.length;  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  sum2  +=  s  *  work3.length;  [BUGGY]    }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	replace	sum2  +=  s  *  work3.length;	  sum2    +=    s    *    s.length;    	compilable	  [FE]  AssertionFailedError  	8	12	replace
105	[BUG]  [BUGGY]  sum2  -=  s  *  s;  total2  -=  s  *  s;  [CE]  cannot  find  symbol  total2  [FE]    AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  sum2  -=  s  *  s;  total2  -=  s  *  s;  [BUGGY]    }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	replace	sum2    -=    s    *    s;    total2  -=  s  *  s;	  	non-compiled	[CE]  cannot  find  symbol  total2	9	None	add
106	[BUG]  [BUGGY]  sum2  -=  s  *  s;  amount2  -=  s  *  s;  [CE]  cannot  find  symbol  amount2  [FE]      AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  sum2  -=  s  *  s;  amount2  -=  s  *  s;  [BUGGY]    }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	replace	sum2    -=    s    *    s;    amount2  -=  s  *  s;	  	non-compiled	[CE]  cannot  find  symbol  amount2	9	None	add
107	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  sum2  +=  diagR[pj];  [BUGGY]    }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	add	sum2  +=  diagR[pj];	  sum2    +=    s    *    diagR[pj];    	compilable	  [FE]  AssertionFailedError  	21	13	replace
108	[BUG]  [BUGGY]  sum2  +=  diagR[pj];  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  sum2  +=  diagR[pj];  [BUGGY]    }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	replace	sum2  +=  diagR[pj];	  sum2    +=    s    *    diagR[pj];    	compilable	  [FE]  AssertionFailedError  	21	13	replace
109	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  s  =  Math.abs(s  +  sum);  [BUGGY]    sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	add	s  =  Math.abs(s  +  sum);	      s    =    Math.abs(s);    	compilable	  [FE]  AssertionFailedError  	14	13	replace
110	[BUG]  [BUGGY]  s  =  Math.abs(s  +  sum);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  s  =  Math.abs(s  +  sum);  [BUGGY]    sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	replace	s  =  Math.abs(s  +  sum);	      s    =    Math.abs(s);    	compilable	  [FE]  AssertionFailedError  	14	13	replace
111	[BUG]  [BUGGY]  double  s  =(work2[i]  -  sum)/  work1[pj];  [CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]              AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  double  s  =(work2[i]  -  sum)/  work1[pj];  [BUGGY]    sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	replace	double  s  =(work2[i]  -  sum)/  work1[pj];	      double    s    =(work1[i]    -    sum)/    work2[pj];    	non-compiled	[CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	5	None	replace
112	[BUG]  [BUGGY]  double  s  =(work1[pj]  -  sum)/  jacobian[pj];  [CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]          AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  double  s  =(work1[pj]  -  sum)/  jacobian[pj];  [BUGGY]    sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	replace	double  s  =(work1[pj]  -  sum)/  jacobian[pj];	      double    s    =(work1[j]    -    sum)/    diagR[pj];    	non-compiled	[CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	2	None	replace
113	[BUG]  [BUGGY]  sum2  +=  s  *  diagR[pj];  sum1  +=  s  *  diagR[pj];  [CE]  cannot  find  symbol  sum1  [FE]    AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  sum2  +=  s  *  diagR[pj];  sum1  +=  s  *  diagR[pj];  [BUGGY]    }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	replace	sum2    +=    s    *    diagR[pj];    sum1  +=  s  *  diagR[pj];	  	non-compiled	[CE]  cannot  find  symbol  sum1	20	None	add
114	[BUG]  [BUGGY]  sum  +=  s  *  diagR;  [CE]  bad  operand  types  for  binary  operator  '*'  [FE]    AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  sum  +=  s  *  diagR;  [BUGGY]    sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	replace	sum  +=  s  *  diagR;	      sum    +=    s    *    s;    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '*'	4	None	replace
115	[BUG]  [BUGGY]  sum  +=  s  *  qy;  [CE]  bad  operand  types  for  binary  operator  '*'  [FE]      AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  sum  +=  s  *  qy;  [BUGGY]    sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	replace	sum  +=  s  *  qy;	      sum    +=    s    *    s;    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '*'	4	None	replace
116	[BUG]  [BUGGY]  double  s  =(work3[pj]  -  sum)/  diagR[pj]  *  jacobian[pj];  [CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]                AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  double  s  =(work3[pj]  -  sum)/  diagR[pj]  *  jacobian[pj];  [BUGGY]    sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	replace	double  s  =(work3[pj]  -  sum)/  diagR[pj]  *  jacobian[pj];	      double    s    =(work3[pj]    -    sum)/    diagR[pj]    *    s;    	non-compiled	[CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	26	None	replace
117	[BUG]  [BUGGY]  double  s  =(work3[pj]  -  sum)/  diagR[pj]  *  work2;  [CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]                  AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  double  s  =(work3[pj]  -  sum)/  diagR[pj]  *  work2;  [BUGGY]    sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	replace	double  s  =(work3[pj]  -  sum)/  diagR[pj]  *  work2;	      double    s    =(work3[pj]    -    sum)/    diagR[pj]    *    s;    	non-compiled	[CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	26	None	replace
118	[BUG]  [BUGGY]  sum2  -=  work1.length  *  work3;  [CE]  bad  operand  types  for  binary  operator  '*'  [FE]          AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  sum2  -=  work1.length  *  work3;  [BUGGY]    }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	replace	sum2  -=  work1.length  *  work3;	  sum2    -=    s    *    work3;    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '*'	19	None	replace
119	[BUG]  [BUGGY]  sum2  -=  work1,  s  *  work3;  [CE]  ';'  expected  [FE]            AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  sum2  -=  work1,  s  *  work3;  [BUGGY]    }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	replace	sum2  -=  work1,  s  *  work3;	  sum2    -=    s    *    work3;    	non-compiled	[CE]  ';'  expected	19	None	replace
120	[BUG]  [BUGGY]  double  s  =  Math.min(work3,  sum);  [CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]            AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  double  s  =  Math.min(work3,  sum);  [BUGGY]    sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	replace	double  s  =  Math.min(work3,  sum);	      double    s    =    Math.min(sum,    work3.length);    	non-compiled	[CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	15	None	replace
121	[BUG]  [BUGGY]  double  s  =  Math.min(work1,  work3.length);  [CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]              AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  double  s  =  Math.min(work1,  work3.length);  [BUGGY]    sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	replace	double  s  =  Math.min(work1,  work3.length);	      double    s    =    Math.min(sum,    work3.length);    	non-compiled	[CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	15	None	replace
122	[BUG]  [BUGGY]  sum2  -=  s  *  diagR;  [CE]  bad  operand  types  for  binary  operator  '*'  [FE]    AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  sum2  -=  s  *  diagR;  [BUGGY]    }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	replace	sum2  -=  s  *  diagR;	  sum2    -=    s    *    s;    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '*'	10	None	replace
123	[BUG]  [BUGGY]  double  s  =(work1[i]  -  sum)/  jacobian[pj];  [CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]        AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  double  s  =(work1[i]  -  sum)/  jacobian[pj];  [BUGGY]    sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	replace	double  s  =(work1[i]  -  sum)/  jacobian[pj];	      double    s    =(work1[i]    -    sum)/    diagR[pj];    	non-compiled	[CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	1	None	replace
124	[BUG]  [BUGGY]  double  s  =(work2[pj]  -  work1[pj])/  diagR[pj];  [CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]            AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  double  s  =(work2[pj]  -  work1[pj])/  diagR[pj];  [BUGGY]    sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	replace	double  s  =(work2[pj]  -  work1[pj])/  diagR[pj];	      double    s    =(work3[pj]    -    work1[pj])/    diagR[pj];    	non-compiled	[CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	24	None	replace
125	[BUG]  [BUGGY]  double  s  =(work3[pj]  -  work2[pj])/  diagR[pj];  [CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]              AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  double  s  =(work3[pj]  -  work2[pj])/  diagR[pj];  [BUGGY]    sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	replace	double  s  =(work3[pj]  -  work2[pj])/  diagR[pj];	      double    s    =(work3[pj]    -    work1[pj])/    diagR[pj];    	non-compiled	[CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	24	None	replace
126	[BUG]  [BUGGY]  double  s  =(work3[j]  -  sum)/  jacobian[pj];  [CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]              AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  double  s  =(work3[j]  -  sum)/  jacobian[pj];  [BUGGY]    sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	replace	double  s  =(work3[j]  -  sum)/  jacobian[pj];	      double    s    =(work3[j]    -    sum)/    diagR[pj];    	non-compiled	[CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	25	None	replace
127	[BUG]  [BUGGY]  double  s  =  Math.min(work2,  sum);  [CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]              AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  double  s  =  Math.min(work2,  sum);  [BUGGY]    sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	replace	double  s  =  Math.min(work2,  sum);	      double    s    =    Math.min(sum,    work2.length);    	non-compiled	[CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	16	None	replace
128	[BUG]  [BUGGY]  double  s  =  Math.min(sum2,  work2.length);  [CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]                AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  double  s  =  Math.min(sum2,  work2.length);  [BUGGY]    sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	replace	double  s  =  Math.min(sum2,  work2.length);	      double    s    =    Math.min(sum,    work2.length);    	non-compiled	[CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	16	None	replace
129	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  sum2  +=  work2.length  *  s;  [BUGGY]    }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	add	sum2  +=  work2.length  *  s;	  sum2    +=    s    *    work3;    	compilable	  [FE]  AssertionFailedError  	7	12	replace
130	[BUG]  [BUGGY]  sum2  +=  work2.length  *  s;  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  sum2  +=  work2.length  *  s;  [BUGGY]    }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	replace	sum2  +=  work2.length  *  s;	  sum2    +=    s    *    work3;    	compilable	  [FE]  AssertionFailedError  	7	12	replace
131	[BUG]  [BUGGY]  double  s  =(work2[j]  -  sum)/  work1[pj];  [CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]                AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  double  s  =(work2[j]  -  sum)/  work1[pj];  [BUGGY]    sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	replace	double  s  =(work2[j]  -  sum)/  work1[pj];	      double    s    =(work1[j]    -    sum)/    work2[pj];    	non-compiled	[CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	6	None	replace
132	[BUG]  [BUGGY]  double  s  =  Math.min(work3.length,  sum);  [CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]            AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  double  s  =  Math.min(work3.length,  sum);  [BUGGY]    sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	replace	double  s  =  Math.min(work3.length,  sum);	      double    s    =    Math.min(sum,    work3.length);    	non-compiled	[CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	15	None	replace
133	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  sum2  +=  s  *  work2[pj];  [BUGGY]    }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	add	sum2  +=  s  *  work2[pj];	  sum2    +=    s    *    diagR[pj];    	compilable	  [FE]  AssertionFailedError  	21	13	replace
134	[BUG]  [BUGGY]  sum2  +=  s  *  work2[pj];  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  sum2  +=  s  *  work2[pj];  [BUGGY]    }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	replace	sum2  +=  s  *  work2[pj];	  sum2    +=    s    *    diagR[pj];    	compilable	  [FE]  AssertionFailedError  	21	13	replace
135	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  sum  +=  s  *  diagR[pj];  [BUGGY]    sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	add	sum  +=  s  *  diagR[pj];	      sum    +=    s    *    s;    	compilable	  [FE]  AssertionFailedError  	4	13	replace
136	[BUG]  [BUGGY]  sum  +=  s  *  diagR[pj];  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  sum  +=  s  *  diagR[pj];  [BUGGY]    sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	replace	sum  +=  s  *  diagR[pj];	      sum    +=    s    *    s;    	compilable	  [FE]  AssertionFailedError  	4	13	replace
137	[BUG]  [BUGGY]  double  s  =(work3[pj]  -  work2)/  diagR[pj];  [CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]          AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  double  s  =(work3[pj]  -  work2)/  diagR[pj];  [BUGGY]    sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	replace	double  s  =(work3[pj]  -  work2)/  diagR[pj];	      double    s    =(work3[pj]    -    work1)/    diagR[pj];    	non-compiled	[CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	23	None	replace
138	[BUG]  [BUGGY]  double  s  =(work3[pj]  -  work3)/  diagR[pj];  [CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]            AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  double  s  =(work3[pj]  -  work3)/  diagR[pj];  [BUGGY]    sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	replace	double  s  =(work3[pj]  -  work3)/  diagR[pj];	      double    s    =(work3[pj]    -    work1)/    diagR[pj];    	non-compiled	[CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	23	None	replace
139	[BUG]  [BUGGY]  double  s  =(work2[pj]  -  sum)/  work1[i];  [CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]              AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  double  s  =(work2[pj]  -  sum)/  work1[i];  [BUGGY]    sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	replace	double  s  =(work2[pj]  -  sum)/  work1[i];	      double    s    =(work1[i]    -    sum)/    work2[pj];    	non-compiled	[CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	5	None	replace
140	[BUG]  [BUGGY]      s  =  Math.abs(s);  s  =  Math.abs(s);  }  s  =  Math.abs(s);  [CE]  <identifier>  expected  [FE]    AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]      s  =  Math.abs(s);  s  =  Math.abs(s);  }  s  =  Math.abs(s);  [BUGGY]    sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	replace	        s    =    Math.abs(s);    s  =  Math.abs(s);  }  s  =  Math.abs(s);	  	non-compiled	[CE]  <identifier>  expected	13	None	add
141	[BUG]  [BUGGY]      s  =  Math.abs(s);  s  =  Math.abs(s);  System.arraycopy(s,  0,  s  *  s);  [CE]  method  arraycopy  in  class  System  cannot  be  applied  to  given  types;  [FE]      AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]      s  =  Math.abs(s);  s  =  Math.abs(s);  System.arraycopy(s,  0,  s  *  s);  [BUGGY]    sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	replace	        s    =    Math.abs(s);    s  =  Math.abs(s);  System.arraycopy(s,  0,  s  *  s);	  	non-compiled	[CE]  method  arraycopy  in  class  System  cannot  be  applied  to  given  types;	13	None	add
142	[BUG]  [BUGGY]      s  =  Math.abs(s);  s  =  Math.abs(s);  }  else  {  sum  +=  s  *  s;  }  [CE]  'else'  without  'if'  [FE]        AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]      s  =  Math.abs(s);  s  =  Math.abs(s);  }  else  {  sum  +=  s  *  s;  }  [BUGGY]    sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	replace	        s    =    Math.abs(s);    s  =  Math.abs(s);  }  else  {  sum  +=  s  *  s;  }	  	non-compiled	[CE]  'else'  without  'if'	13	None	add
143	[BUG]  [BUGGY]  sum2  -=  s  *  s;  sum2  -=  s  *  s;  }  [CE]  <identifier>  expected  [FE]    AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  sum2  -=  s  *  s;  sum2  -=  s  *  s;  }  [BUGGY]    }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	replace	sum2    -=    s    *    s;    sum2  -=  s  *  s;  }	  	non-compiled	[CE]  <identifier>  expected	9	None	add
144	[BUG]  [BUGGY]  sum2  +=  s  *  diagR[pj];  sum2  +=  s  *  diagR[pj].;  [CE]  <identifier>  expected  [FE]    AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  sum2  +=  s  *  diagR[pj];  sum2  +=  s  *  diagR[pj].;  [BUGGY]    }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	replace	sum2    +=    s    *    diagR[pj];    sum2  +=  s  *  diagR[pj].;	  	non-compiled	[CE]  <identifier>  expected	20	None	add
145	[BUG]  [BUGGY]  sum2  +=  s  *  diagR[pj];  total  +=  s  *  diagR[pj];  [CE]  cannot  find  symbol  total  [FE]      AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  sum2  +=  s  *  diagR[pj];  total  +=  s  *  diagR[pj];  [BUGGY]    }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	replace	sum2    +=    s    *    diagR[pj];    total  +=  s  *  diagR[pj];	  	non-compiled	[CE]  cannot  find  symbol  total	20	None	add
146	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  s  =  Math.abs(s  *  s);  [BUGGY]    sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	add	s  =  Math.abs(s  *  s);	      s    =    Math.abs(s);    	compilable	  [FE]  AssertionFailedError  	14	13	replace
147	[BUG]  [BUGGY]  s  =  Math.abs(s  *  s);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  s  =  Math.abs(s  *  s);  [BUGGY]    sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	replace	s  =  Math.abs(s  *  s);	      s    =    Math.abs(s);    	compilable	  [FE]  AssertionFailedError  	14	13	replace
148	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  sum2  -=  work1[pj]  *  s;  [BUGGY]    }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	add	sum2  -=  work1[pj]  *  s;	  sum2    -=    s    *    work3;    	compilable	  [FE]  AssertionFailedError  	19	12	replace
149	[BUG]  [BUGGY]  sum2  -=  work1[pj]  *  s;  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  sum2  -=  work1[pj]  *  s;  [BUGGY]    }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	replace	sum2  -=  work1[pj]  *  s;	  sum2    -=    s    *    work3;    	compilable	  [FE]  AssertionFailedError  	19	12	replace
150	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  sum2  +=  s  *  diagR.length;  [BUGGY]    }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	add	sum2  +=  s  *  diagR.length;	  sum2    +=    s    *    diagR;    	compilable	  [FE]  AssertionFailedError  	18	12	replace
151	[BUG]  [BUGGY]  sum2  +=  s  *  diagR.length;  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  sum2  +=  s  *  diagR.length;  [BUGGY]    }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	replace	sum2  +=  s  *  diagR.length;	  sum2    +=    s    *    diagR;    	compilable	  [FE]  AssertionFailedError  	18	12	replace
152	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]      sum  +=  s  *  s;  sum  /=  s  *  s;  [BUGGY]    sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	add	        sum    +=    s    *    s;    sum  /=  s  *  s;	  	compilable	  [FE]  AssertionFailedError  	3	2	add
153	[BUG]  [BUGGY]      sum  +=  s  *  s;  sum  /=  s  *  s;  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]      sum  +=  s  *  s;  sum  /=  s  *  s;  [BUGGY]    sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	replace	        sum    +=    s    *    s;    sum  /=  s  *  s;	  	compilable	  [FE]  AssertionFailedError  	3	2	add
154	[BUG]  [BUGGY]  double  s  =(work1[pj]  -  sum)/  workR[pj];  [CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]        AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  double  s  =(work1[pj]  -  sum)/  workR[pj];  [BUGGY]    sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	replace	double  s  =(work1[pj]  -  sum)/  workR[pj];	      double    s    =(work1[i]    -    sum)/    diagR[pj];    	non-compiled	[CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	1	None	replace
155	[BUG]  [BUGGY]  double  s  =  Math.pow(0,  sum  -  1);  [CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]                AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  double  s  =  Math.pow(0,  sum  -  1);  [BUGGY]    sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	replace	double  s  =  Math.pow(0,  sum  -  1);	      double    s    =    Math.pow(0,    sum);    	non-compiled	[CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	17	None	replace
156	[BUG]  [BUGGY]  double  s  =  Math.min(work3,  sum2.length);  [CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]              AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  double  s  =  Math.min(work3,  sum2.length);  [BUGGY]    sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	replace	double  s  =  Math.min(work3,  sum2.length);	      double    s    =    Math.min(sum,    work2.length);    	non-compiled	[CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	16	None	replace
157	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  sum2  +=  work3.length  *  s;  [BUGGY]    }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	add	sum2  +=  work3.length  *  s;	  sum2    +=    s    *    work3;    	compilable	  [FE]  AssertionFailedError  	7	12	replace
158	[BUG]  [BUGGY]  sum2  +=  work3.length  *  s;  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  sum2  +=  work3.length  *  s;  [BUGGY]    }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	replace	sum2  +=  work3.length  *  s;	  sum2    +=    s    *    work3;    	compilable	  [FE]  AssertionFailedError  	7	12	replace
159	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  sum2  -=  s  *  s  +  1;  [BUGGY]    }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	add	sum2  -=  s  *  s  +  1;	  sum2    -=    s    *    s;    	compilable	  [FE]  AssertionFailedError  	10	12	replace
160	[BUG]  [BUGGY]  sum2  -=  s  *  s  +  1;  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  sum2  -=  s  *  s  +  1;  [BUGGY]    }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	replace	sum2  -=  s  *  s  +  1;	  sum2    -=    s    *    s;    	compilable	  [FE]  AssertionFailedError  	10	12	replace
161	[BUG]  [BUGGY]  sum2  -=  s  *  s.length;  [CE]  double  cannot  be  dereferenced  [FE]      AssertionFailedError    [CONTEXT]    }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;    [BUGGY]  sum2  -=  s  *  s.length;  [BUGGY]    }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	543	543	2	replace	sum2  -=  s  *  s.length;	  sum2    -=    s    *    s;    	non-compiled	[CE]  double  cannot  be  dereferenced	10	None	replace
