bugid	buggy	buggy_class	suspiciousness	buggy_line	endbuggycode	original_failing_test_number	action	patch	original_buggy	execution_result	diagnosis	previous_bug_id	new_failing_test_number	this_action
1	[BUG]  [BUGGY]  tmpVec=  new  VectorialPointValuePair(previousCost,  cost,  solvedCols);  [CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double,double,int)  [FE]            AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  tmpVec=  new  VectorialPointValuePair(previousCost,  cost,  solvedCols);  [BUGGY]      residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	tmpVec=  new  VectorialPointValuePair(previousCost,  cost,  solvedCols);	  tmpVec=    new    VectorialPointValuePair(previousCost,    cost,    solveCols);    	non-compiled	[CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double,double,int)	65	None	replace
2	[BUG]  [BUGGY]  tmpVec=  new  VectorialPointValuePair(previousCost,  previousCost,  cost);  [CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double,double,double)  [FE]              AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  tmpVec=  new  VectorialPointValuePair(previousCost,  previousCost,  cost);  [BUGGY]      residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	tmpVec=  new  VectorialPointValuePair(previousCost,  previousCost,  cost);	  tmpVec=    new    VectorialPointValuePair(previousCost,    cost,    solveCols);    	non-compiled	[CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double,double,double)	65	None	replace
3	[BUG]  [BUGGY]  tmpVec=  new  VectorialPointValuePair(previousCost,  previousCost,  residuals);  [CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double,double,double[])  [FE]                AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  tmpVec=  new  VectorialPointValuePair(previousCost,  previousCost,  residuals);  [BUGGY]      residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	tmpVec=  new  VectorialPointValuePair(previousCost,  previousCost,  residuals);	  tmpVec=    new    VectorialPointValuePair(previousCost,    cost,    solveCols);    	non-compiled	[CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double,double,double[])	65	None	replace
4	[BUG]  [BUGGY]  tmpVec=  new  VectorialPointValuePair(previousCost,  previousCost,  solvedCols);  [CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double,double,int)  [FE]                  AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  tmpVec=  new  VectorialPointValuePair(previousCost,  previousCost,  solvedCols);  [BUGGY]      residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	tmpVec=  new  VectorialPointValuePair(previousCost,  previousCost,  solvedCols);	  tmpVec=    new    VectorialPointValuePair(previousCost,    cost,    solveCols);    	non-compiled	[CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double,double,int)	65	None	replace
5	[BUG]  [BUGGY]  tmpVec  =  previousCost[j];  [CE]  cannot  find  symbol  j  [FE]            AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  tmpVec  =  previousCost[j];  [BUGGY]      tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	tmpVec  =  previousCost[j];	  tmpVec    =    cost[j];    	non-compiled	[CE]  cannot  find  symbol  j	61	None	replace
6	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]            ArrayIndexOutOfBoundsException      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  tmpVec=  oldX;  tmpVec=  oldRes;  [BUGGY]      residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	add	tmpVec=  oldX;  tmpVec=  oldRes;	  tmpVec=    oldX;    tmpVec=    oldY;    	compilable	  [FE]  AssertionFailedError  	9	10	replace
7	[BUG]  [BUGGY]  tmpVec=  oldX;  tmpVec=  oldRes;  [FE]  AssertionFailedError  [FE]            ArrayIndexOutOfBoundsException      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  tmpVec=  oldX;  tmpVec=  oldRes;  [BUGGY]      residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	tmpVec=  oldX;  tmpVec=  oldRes;	  tmpVec=    oldX;    tmpVec=    oldY;    	compilable	  [FE]  AssertionFailedError  	9	10	replace
8	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]              ArrayIndexOutOfBoundsException      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  tmpVec=  oldRes;  [BUGGY]      residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	add	tmpVec=  oldRes;	  tmpVec=    oldX;    tmpVec=    oldY;    	compilable	  [FE]  AssertionFailedError  	9	10	replace
9	[BUG]  [BUGGY]  tmpVec=  oldRes;  [FE]  AssertionFailedError  [FE]              ArrayIndexOutOfBoundsException      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  tmpVec=  oldRes;  [BUGGY]      residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	tmpVec=  oldRes;	  tmpVec=    oldX;    tmpVec=    oldY;    	compilable	  [FE]  AssertionFailedError  	9	10	replace
10	[BUG]  [BUGGY]  [FE]  ArrayIndexOutOfBoundsException  [FE]                ArrayIndexOutOfBoundsException      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  tmpVec=  oldX;  tmpVec=  tmpVec;  [BUGGY]      residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	add	tmpVec=  oldX;  tmpVec=  tmpVec;	  tmpVec=    oldX;    tmpVec=    oldY;    	compilable	  [FE]  ArrayIndexOutOfBoundsException  	9	12	replace
11	[BUG]  [BUGGY]  tmpVec=  oldX;  tmpVec=  tmpVec;  [FE]  ArrayIndexOutOfBoundsException  [FE]                ArrayIndexOutOfBoundsException      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  tmpVec=  oldX;  tmpVec=  tmpVec;  [BUGGY]      residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	tmpVec=  oldX;  tmpVec=  tmpVec;	  tmpVec=    oldX;    tmpVec=    oldY;    	compilable	  [FE]  ArrayIndexOutOfBoundsException  	9	12	replace
12	[BUG]  [BUGGY]  Preconditions.checkState(results!=  oldX);  [CE]  cannot  find  symbol  results  [FE]                AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  Preconditions.checkState(results!=  oldX);  [BUGGY]      tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	Preconditions.checkState(results!=  oldX);	  Preconditions.checkState(results!=    oldRes);    	non-compiled	[CE]  cannot  find  symbol  results	35	None	replace
13	[BUG]  [BUGGY]  Preconditions.checkState(results!=  tmpVec);  [CE]  cannot  find  symbol  results  [FE]                  AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  Preconditions.checkState(results!=  tmpVec);  [BUGGY]      tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	Preconditions.checkState(results!=  tmpVec);	  Preconditions.checkState(results!=    oldRes);    	non-compiled	[CE]  cannot  find  symbol  results	35	None	replace
14	[BUG]  [BUGGY]  Preconditions.checkNotNull(resultVec);  [CE]  cannot  find  symbol  resultVec  [FE]                AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  Preconditions.checkNotNull(resultVec);  [BUGGY]      tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	Preconditions.checkNotNull(resultVec);	  Preconditions.checkNotNull(result);    	non-compiled	[CE]  cannot  find  symbol  resultVec	4	None	replace
15	[BUG]  [BUGGY]  Preconditions.checkState(oldRes  >=  tmpVec);  [CE]  bad  operand  types  for  binary  operator  '>='  [FE]                  AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  Preconditions.checkState(oldRes  >=  tmpVec);  [BUGGY]      tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	Preconditions.checkState(oldRes  >=  tmpVec);	  Preconditions.checkState(oldRes!=    tmpVec);    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '>='	56	None	replace
16	[BUG]  [BUGGY]  Preconditions.checkState(oldRes  ==  tmpVec);  [CE]  cannot  find  symbol  Preconditions  [FE]                    AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  Preconditions.checkState(oldRes  ==  tmpVec);  [BUGGY]      tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	Preconditions.checkState(oldRes  ==  tmpVec);	  Preconditions.checkState(oldRes!=    tmpVec);    	non-compiled	[CE]  cannot  find  symbol  Preconditions	56	None	replace
17	[BUG]  [BUGGY]  tmpVec=  new  VectorialPointValuePair(j,  previousCost);  [CE]  cannot  find  symbol  j  [FE]            AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  tmpVec=  new  VectorialPointValuePair(j,  previousCost);  [BUGGY]      residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	tmpVec=  new  VectorialPointValuePair(j,  previousCost);	  tmpVec=    new    VectorialPointValuePair(lastX,    previousCost);    	non-compiled	[CE]  cannot  find  symbol  j	64	None	replace
18	[BUG]  [BUGGY]  tmpVec=  new  VectorialPointValuePair(previousCost,  preRed);  [CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double,double)  [FE]              AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  tmpVec=  new  VectorialPointValuePair(previousCost,  preRed);  [BUGGY]      residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	tmpVec=  new  VectorialPointValuePair(previousCost,  preRed);	  tmpVec=    new    VectorialPointValuePair(lastX,    previousCost);    	non-compiled	[CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double,double)	64	None	replace
19	[BUG]  [BUGGY]  tmpVec=  new  VectorialPointValuePair(previousCost,  previousCost);  [CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double,double)  [FE]                AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  tmpVec=  new  VectorialPointValuePair(previousCost,  previousCost);  [BUGGY]      residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	tmpVec=  new  VectorialPointValuePair(previousCost,  previousCost);	  tmpVec=    new    VectorialPointValuePair(lastX,    previousCost);    	non-compiled	[CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double,double)	64	None	replace
20	[BUG]  [BUGGY]  int  tmpVec=  oldX;  [CE]  variable  tmpVec  is  already  defined  in  method  doOptimize()  [FE]          ArrayIndexOutOfBoundsException      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  int  tmpVec=  oldX;  [BUGGY]      residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	int  tmpVec=  oldX;	  tmpVec=    oldX;    int    tmpVec=    oldX;    	non-compiled	[CE]  variable  tmpVec  is  already  defined  in  method  doOptimize()	8	None	replace
21	[BUG]  [BUGGY]  Preconditions.checkState(j  ==  oldX[pj]);  [CE]  cannot  find  symbol  j  [FE]                      AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  Preconditions.checkState(j  ==  oldX[pj]);  [BUGGY]      tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	Preconditions.checkState(j  ==  oldX[pj]);	  Preconditions.checkState(pj    ==    oldX[pj]);    	non-compiled	[CE]  cannot  find  symbol  j	42	None	replace
22	[BUG]  [BUGGY]  Preconditions.checkState(oldRes  ==  oldX[point]);  [CE]  incompatible  types  [FE]                        AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  Preconditions.checkState(oldRes  ==  oldX[point]);  [BUGGY]      tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	Preconditions.checkState(oldRes  ==  oldX[point]);	  Preconditions.checkState(pj    ==    oldX[pj]);    	non-compiled	[CE]  incompatible  types	42	None	replace
23	[BUG]  [BUGGY]  Preconditions.checkState(oldRes!=  oldX);  [CE]  cannot  find  symbol  Preconditions  [FE]                AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  Preconditions.checkState(oldRes!=  oldX);  [BUGGY]      tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	Preconditions.checkState(oldRes!=  oldX);	  Preconditions.checkState(oldRes!=    oldRes);    	non-compiled	[CE]  cannot  find  symbol  Preconditions	55	None	replace
24	[BUG]  [BUGGY]  Preconditions.checkState(j  >  0);  [CE]  cannot  find  symbol  j  [FE]                AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  Preconditions.checkState(j  >  0);  [BUGGY]      tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	Preconditions.checkState(j  >  0);	  Preconditions.checkState(pj    >    0);    	non-compiled	[CE]  cannot  find  symbol  j	30	None	replace
25	[BUG]  [BUGGY]  Preconditions.checkState(i  >  0);  [CE]  cannot  find  symbol  i  [FE]                  AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  Preconditions.checkState(i  >  0);  [BUGGY]      tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	Preconditions.checkState(i  >  0);	  Preconditions.checkState(pj    >    0);    	non-compiled	[CE]  cannot  find  symbol  i	30	None	replace
26	[BUG]  [BUGGY]  Preconditions.checkState(results  <  0);  [CE]  cannot  find  symbol  results  [FE]              AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  Preconditions.checkState(results  <  0);  [BUGGY]      tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	Preconditions.checkState(results  <  0);	  Preconditions.checkState(results    >    0);    	non-compiled	[CE]  cannot  find  symbol  results	29	None	replace
27	[BUG]  [BUGGY]  Preconditions.checkState(results  ==  0);  [CE]  cannot  find  symbol  results  [FE]                AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  Preconditions.checkState(results  ==  0);  [BUGGY]      tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	Preconditions.checkState(results  ==  0);	  Preconditions.checkState(results    >    0);    	non-compiled	[CE]  cannot  find  symbol  results	29	None	replace
28	[BUG]  [BUGGY]  Preconditions.checkState(results!=  0);  [CE]  cannot  find  symbol  results  [FE]                  AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  Preconditions.checkState(results!=  0);  [BUGGY]      tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	Preconditions.checkState(results!=  0);	  Preconditions.checkState(results    >    0);    	non-compiled	[CE]  cannot  find  symbol  results	29	None	replace
29	[BUG]  [BUGGY]  tmpVec=  new  VectorialPointValuePair(permutation);  [CE]  no  suitable  constructor  found  for  VectorialPointValuePair(int[])  [FE]                AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  tmpVec=  new  VectorialPointValuePair(permutation);  [BUGGY]      residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	tmpVec=  new  VectorialPointValuePair(permutation);	  tmpVec=    new    VectorialPointValuePair(pj);    	non-compiled	[CE]  no  suitable  constructor  found  for  VectorialPointValuePair(int[])	34	None	replace
30	[BUG]  [BUGGY]  tmpVec=  new  VectorialPointValuePair(pj,  preRed);  [CE]  cannot  find  symbol  pj  [FE]            AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  tmpVec=  new  VectorialPointValuePair(pj,  preRed);  [BUGGY]      residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	tmpVec=  new  VectorialPointValuePair(pj,  preRed);	  tmpVec=    new    VectorialPointValuePair(pj,    previousCost);    	non-compiled	[CE]  cannot  find  symbol  pj	44	None	replace
31	[BUG]  [BUGGY]  tmpVec  =  oldX[p];  [CE]  cannot  find  symbol  p  [FE]                  AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  tmpVec  =  oldX[p];  [BUGGY]      tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	tmpVec  =  oldX[p];	  tmpVec    =    oldX[point];    	non-compiled	[CE]  cannot  find  symbol  p	51	None	replace
32	[BUG]  [BUGGY]  tmpVec  =  oldX.previousCost;  [CE]  cannot  find  symbol  previousCost  [FE]                AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  tmpVec  =  oldX.previousCost;  [BUGGY]      tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	tmpVec  =  oldX.previousCost;	  tmpVec    =    previousCost.previousCost;    	non-compiled	[CE]  cannot  find  symbol  previousCost	11	None	replace
33	[BUG]  [BUGGY]  tmpVec  =  permutation[0]  +  1;  [CE]  incompatible  types  [FE]                AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  tmpVec  =  permutation[0]  +  1;  [BUGGY]      tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	tmpVec  =  permutation[0]  +  1;	  tmpVec    =    permutation[0];    	non-compiled	[CE]  incompatible  types	24	None	replace
34	[BUG]  [BUGGY]  tmpVec  =  permutation[0]  +  point[pj];  [CE]  cannot  find  symbol  pj  [FE]                  AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  tmpVec  =  permutation[0]  +  point[pj];  [BUGGY]      tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	tmpVec  =  permutation[0]  +  point[pj];	  tmpVec    =    permutation[0];    	non-compiled	[CE]  cannot  find  symbol  pj	24	None	replace
35	[BUG]  [BUGGY]  Preconditions.checkNotNull(results,  tmpVec);  [CE]  cannot  find  symbol  results  [FE]              AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  Preconditions.checkNotNull(results,  tmpVec);  [BUGGY]      tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	Preconditions.checkNotNull(results,  tmpVec);	  Preconditions.checkNotNull(results);    	non-compiled	[CE]  cannot  find  symbol  results	3	None	replace
36	[BUG]  [BUGGY]  Preconditions.checkNotNull(results,  firstIteration);  [CE]  cannot  find  symbol  results  [FE]                AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  Preconditions.checkNotNull(results,  firstIteration);  [BUGGY]      tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	Preconditions.checkNotNull(results,  firstIteration);	  Preconditions.checkNotNull(results);    	non-compiled	[CE]  cannot  find  symbol  results	3	None	replace
37	[BUG]  [BUGGY]  Preconditions.checkState(results!=  null);  [CE]  cannot  find  symbol  results  [FE]                  AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  Preconditions.checkState(results!=  null);  [BUGGY]      tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	Preconditions.checkState(results!=  null);	  Preconditions.checkNotNull(results);    	non-compiled	[CE]  cannot  find  symbol  results	3	None	replace
38	[BUG]  [BUGGY]  Preconditions.checkState(oldRes  ==  oldX);  [CE]  cannot  find  symbol  Preconditions  [FE]                    AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  Preconditions.checkState(oldRes  ==  oldX);  [BUGGY]      tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	Preconditions.checkState(oldRes  ==  oldX);	  Preconditions.checkState(remainings    ==    oldX);    	non-compiled	[CE]  cannot  find  symbol  Preconditions	15	None	replace
39	[BUG]  [BUGGY]  tmpVec=  new  VectorialPointValuePair(results,  cost);  [CE]  cannot  find  symbol  results  [FE]            AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  tmpVec=  new  VectorialPointValuePair(results,  cost);  [BUGGY]      residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	tmpVec=  new  VectorialPointValuePair(results,  cost);	  tmpVec=    new    VectorialPointValuePair(results);    	non-compiled	[CE]  cannot  find  symbol  results	32	None	replace
40	[BUG]  [BUGGY]  tmpVec=  new  VectorialPointValuePair(results,  point);  [CE]  cannot  find  symbol  results  [FE]              AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  tmpVec=  new  VectorialPointValuePair(results,  point);  [BUGGY]      residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	tmpVec=  new  VectorialPointValuePair(results,  point);	  tmpVec=    new    VectorialPointValuePair(results);    	non-compiled	[CE]  cannot  find  symbol  results	32	None	replace
41	[BUG]  [BUGGY]  Preconditions.checkState(results  ==  oldX[pj],  tmpVec);  [CE]  cannot  find  symbol  results  [FE]                    AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  Preconditions.checkState(results  ==  oldX[pj],  tmpVec);  [BUGGY]      tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	Preconditions.checkState(results  ==  oldX[pj],  tmpVec);	  Preconditions.checkState(results    ==    oldX[pj]);    	non-compiled	[CE]  cannot  find  symbol  results	41	None	replace
42	[BUG]  [BUGGY]  Preconditions.checkState(results!=  oldX[pj]);  [CE]  cannot  find  symbol  results  [FE]                      AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  Preconditions.checkState(results!=  oldX[pj]);  [BUGGY]      tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	Preconditions.checkState(results!=  oldX[pj]);	  Preconditions.checkState(results    ==    oldX[pj]);    	non-compiled	[CE]  cannot  find  symbol  results	41	None	replace
43	[BUG]  [BUGGY]  tmpVec=  new  VectorialPointValuePair(previousCost,  oldX,  point);  [CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double,double[],double[])  [FE]                AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  tmpVec=  new  VectorialPointValuePair(previousCost,  oldX,  point);  [BUGGY]      residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	tmpVec=  new  VectorialPointValuePair(previousCost,  oldX,  point);	  tmpVec=    new    VectorialPointValuePair(previousCost,    point);    	non-compiled	[CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double,double[],double[])	60	None	replace
44	[BUG]  [BUGGY]  tmpVec=  new  VectorialPointValuePair(previousCost,  point,  residuals);  [CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double,double[],double[])  [FE]                  AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  tmpVec=  new  VectorialPointValuePair(previousCost,  point,  residuals);  [BUGGY]      residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	tmpVec=  new  VectorialPointValuePair(previousCost,  point,  residuals);	  tmpVec=    new    VectorialPointValuePair(previousCost,    point);    	non-compiled	[CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double,double[],double[])	60	None	replace
45	[BUG]  [BUGGY]  tmpVec=  new  VectorialPointValuePair(previousCost,  permutation,  cost);  [CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double,int[],double)  [FE]              AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  tmpVec=  new  VectorialPointValuePair(previousCost,  permutation,  cost);  [BUGGY]      residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	tmpVec=  new  VectorialPointValuePair(previousCost,  permutation,  cost);	  tmpVec=    new    VectorialPointValuePair(period,    previousCost,    cost);    	non-compiled	[CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double,int[],double)	26	None	replace
46	[BUG]  [BUGGY]  tmpVec=  new  VectorialPointValuePair(permutation,  previousCost,  cost);  [CE]  no  suitable  constructor  found  for  VectorialPointValuePair(int[],double,double)  [FE]                AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  tmpVec=  new  VectorialPointValuePair(permutation,  previousCost,  cost);  [BUGGY]      residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	tmpVec=  new  VectorialPointValuePair(permutation,  previousCost,  cost);	  tmpVec=    new    VectorialPointValuePair(period,    previousCost,    cost);    	non-compiled	[CE]  no  suitable  constructor  found  for  VectorialPointValuePair(int[],double,double)	26	None	replace
47	[BUG]  [BUGGY]  tmpVec  =  oldRes[oldX];  [CE]  incompatible  types  [FE]                    AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  tmpVec  =  oldRes[oldX];  [BUGGY]      tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	tmpVec  =  oldRes[oldX];	  tmpVec    =    oldX[oldRes];    	non-compiled	[CE]  incompatible  types	52	None	replace
48	[BUG]  [BUGGY]  tmpVec  =  oldRes[oldRes];  [CE]  incompatible  types  [FE]                      AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  tmpVec  =  oldRes[oldRes];  [BUGGY]      tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	tmpVec  =  oldRes[oldRes];	  tmpVec    =    oldX[oldRes];    	non-compiled	[CE]  incompatible  types	52	None	replace
49	[BUG]  [BUGGY]  tmpVec  =  oldX[oldRes]  +  cost;  [CE]  incompatible  types  [FE]                        AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  tmpVec  =  oldX[oldRes]  +  cost;  [BUGGY]      tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	tmpVec  =  oldX[oldRes]  +  cost;	  tmpVec    =    oldX[oldRes];    	non-compiled	[CE]  incompatible  types	52	None	replace
50	[BUG]  [BUGGY]  tmpVec  =  permutation[j]  +  2;  [CE]  cannot  find  symbol  j  [FE]              AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  tmpVec  =  permutation[j]  +  2;  [BUGGY]      tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	tmpVec  =  permutation[j]  +  2;	  tmpVec    =    permutation[j]    +    1;    	non-compiled	[CE]  cannot  find  symbol  j	23	None	replace
51	[BUG]  [BUGGY]  tmpVec  =  permutation[pj]  +  1;  [CE]  cannot  find  symbol  pj  [FE]                AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  tmpVec  =  permutation[pj]  +  1;  [BUGGY]      tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	tmpVec  =  permutation[pj]  +  1;	  tmpVec    =    permutation[j]    +    1;    	non-compiled	[CE]  cannot  find  symbol  pj	23	None	replace
52	[BUG]  [BUGGY]  tmpVec  =  permutation[j]  +  3;  [CE]  cannot  find  symbol  j  [FE]                  AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  tmpVec  =  permutation[j]  +  3;  [BUGGY]      tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	tmpVec  =  permutation[j]  +  3;	  tmpVec    =    permutation[j]    +    1;    	non-compiled	[CE]  cannot  find  symbol  j	23	None	replace
53	[BUG]  [BUGGY]  tmpVec=  new  VectorialPointValuePair(j,  previousCost,  cost);  [CE]  cannot  find  symbol  j  [FE]              AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  tmpVec=  new  VectorialPointValuePair(j,  previousCost,  cost);  [BUGGY]      residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	tmpVec=  new  VectorialPointValuePair(j,  previousCost,  cost);	  tmpVec=    new    VectorialPointValuePair(lastX,    previousCost,    cost);    	non-compiled	[CE]  cannot  find  symbol  j	59	None	replace
54	[BUG]  [BUGGY]  tmpVec=  new  double[resistance];  [CE]  cannot  find  symbol  resistance  [FE]                    AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  tmpVec=  new  double[resistance];  [BUGGY]      residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	tmpVec=  new  double[resistance];	  tmpVec=    new    double[point];    	non-compiled	[CE]  cannot  find  symbol  resistance	38	None	replace
55	[BUG]  [BUGGY]  Preconditions.checkState(results  ==  tmpVec);  [CE]  cannot  find  symbol  results  [FE]              AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  Preconditions.checkState(results  ==  tmpVec);  [BUGGY]      tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	Preconditions.checkState(results  ==  tmpVec);	  Preconditions.checkState(results    ==    oldRes);    	non-compiled	[CE]  cannot  find  symbol  results	12	None	replace
56	[BUG]  [BUGGY]  Preconditions.checkState(oldRes!=  oldX[point]);  [CE]  incompatible  types  [FE]                    AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  Preconditions.checkState(oldRes!=  oldX[point]);  [BUGGY]      tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	Preconditions.checkState(oldRes!=  oldX[point]);	  Preconditions.checkState(oldRes!=    oldX[pj]);    	non-compiled	[CE]  incompatible  types	54	None	replace
57	[BUG]  [BUGGY]  Preconditions.checkState(oldRes!=  oldX[j]);  [CE]  cannot  find  symbol  j  [FE]                      AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  Preconditions.checkState(oldRes!=  oldX[j]);  [BUGGY]      tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	Preconditions.checkState(oldRes!=  oldX[j]);	  Preconditions.checkState(oldRes!=    oldX[pj]);    	non-compiled	[CE]  cannot  find  symbol  j	54	None	replace
58	[BUG]  [BUGGY]  Preconditions.checkState(oldRes  >=  oldX[point]);  [CE]  incompatible  types  [FE]                        AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  Preconditions.checkState(oldRes  >=  oldX[point]);  [BUGGY]      tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	Preconditions.checkState(oldRes  >=  oldX[point]);	  Preconditions.checkState(oldRes!=    oldX[pj]);    	non-compiled	[CE]  incompatible  types	54	None	replace
59	[BUG]  [BUGGY]  Preconditions.checkState(remainings  >  0);  [CE]  cannot  find  symbol  remainings  [FE]              AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  Preconditions.checkState(remainings  >  0);  [BUGGY]      tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	Preconditions.checkState(remainings  >  0);	  Preconditions.checkState(relatives    >    0);    	non-compiled	[CE]  cannot  find  symbol  remainings	47	None	replace
60	[BUG]  [BUGGY]  Preconditions.checkState(relatives  <  0);  [CE]  cannot  find  symbol  relatives  [FE]                AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  Preconditions.checkState(relatives  <  0);  [BUGGY]      tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	Preconditions.checkState(relatives  <  0);	  Preconditions.checkState(relatives    >    0);    	non-compiled	[CE]  cannot  find  symbol  relatives	47	None	replace
61	[BUG]  [BUGGY]  tmpVec=  new  VectorialPointValuePair(pr,  previousCost);  [CE]  cannot  find  symbol  pr  [FE]            AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  tmpVec=  new  VectorialPointValuePair(pr,  previousCost);  [BUGGY]      residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	tmpVec=  new  VectorialPointValuePair(pr,  previousCost);	  tmpVec=    new    VectorialPointValuePair(point,    previousCost);    	non-compiled	[CE]  cannot  find  symbol  pr	57	None	replace
62	[BUG]  [BUGGY]  tmpVec=  new  VectorialPointValuePair(point,  preRed,  previousCost);  [CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double[],double,double)  [FE]              AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  tmpVec=  new  VectorialPointValuePair(point,  preRed,  previousCost);  [BUGGY]      residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	tmpVec=  new  VectorialPointValuePair(point,  preRed,  previousCost);	  tmpVec=    new    VectorialPointValuePair(point,    previousCost);    	non-compiled	[CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double[],double,double)	57	None	replace
63	[BUG]  [BUGGY]  Preconditions.checkState(oldRes  <  0);  [CE]  bad  operand  types  for  binary  operator  '<'  [FE]                  AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  Preconditions.checkState(oldRes  <  0);  [BUGGY]      tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	Preconditions.checkState(oldRes  <  0);	  Preconditions.checkState(oldRes    >    0);    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '<'	31	None	replace
64	[BUG]  [BUGGY]  Preconditions.checkState(oldRes!=  0);  [CE]  incomparable  types:  double[]  and  int  [FE]                    AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  Preconditions.checkState(oldRes!=  0);  [BUGGY]      tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	Preconditions.checkState(oldRes!=  0);	  Preconditions.checkState(oldRes    >    0);    	non-compiled	[CE]  incomparable  types:  double[]  and  int	31	None	replace
65	[BUG]  [BUGGY]  Preconditions.checkState(oldRes  ==  0);  [CE]  incomparable  types:  double[]  and  int  [FE]                      AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  Preconditions.checkState(oldRes  ==  0);  [BUGGY]      tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	Preconditions.checkState(oldRes  ==  0);	  Preconditions.checkState(oldRes    >    0);    	non-compiled	[CE]  incomparable  types:  double[]  and  int	31	None	replace
66	[BUG]  [BUGGY]  Preconditions.checkState(oldRes  >=  0);  [CE]  bad  operand  types  for  binary  operator  '>='  [FE]                        AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  Preconditions.checkState(oldRes  >=  0);  [BUGGY]      tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	Preconditions.checkState(oldRes  >=  0);	  Preconditions.checkState(oldRes    >    0);    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '>='	31	None	replace
67	[BUG]  [BUGGY]  tmpVec  =  oldX  +  1;  [CE]  bad  operand  types  for  binary  operator  '+'  [FE]                AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  tmpVec  =  oldX  +  1;  [BUGGY]      tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	tmpVec  =  oldX  +  1;	  tmpVec    =    preRed    +    1;    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '+'	40	None	replace
68	[BUG]  [BUGGY]  tmpVec  =  preRed  +  2;  [CE]  incompatible  types  [FE]                  AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  tmpVec  =  preRed  +  2;  [BUGGY]      tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	tmpVec  =  preRed  +  2;	  tmpVec    =    preRed    +    1;    	non-compiled	[CE]  incompatible  types	40	None	replace
69	[BUG]  [BUGGY]  Preconditions.checkState(oldX!=  null);  [CE]  cannot  find  symbol  Preconditions  [FE]            AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  Preconditions.checkState(oldX!=  null);  [BUGGY]      tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	Preconditions.checkState(oldX!=  null);	  Preconditions.checkNotNull(oldX);    	non-compiled	[CE]  cannot  find  symbol  Preconditions	66	None	replace
70	[BUG]  [BUGGY]  tmpVec  =  preRed.cloneTree();  [CE]  double  cannot  be  dereferenced  [FE]              AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  tmpVec  =  preRed.cloneTree();  [BUGGY]      tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	tmpVec  =  preRed.cloneTree();	  tmpVec    =    previousCost.cloneTree();    	non-compiled	[CE]  double  cannot  be  dereferenced	10	None	replace
71	[BUG]  [BUGGY]  tmpVec  =  prevCost.cloneTree();  [CE]  cannot  find  symbol  prevCost  [FE]                AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  tmpVec  =  prevCost.cloneTree();  [BUGGY]      tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	tmpVec  =  prevCost.cloneTree();	  tmpVec    =    previousCost.cloneTree();    	non-compiled	[CE]  cannot  find  symbol  prevCost	10	None	replace
72	[BUG]  [BUGGY]  tmpVec  =  cost.cloneTree();  [CE]  double  cannot  be  dereferenced  [FE]                  AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  tmpVec  =  cost.cloneTree();  [BUGGY]      tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	tmpVec  =  cost.cloneTree();	  tmpVec    =    previousCost.cloneTree();    	non-compiled	[CE]  double  cannot  be  dereferenced	10	None	replace
73	[BUG]  [BUGGY]  Preconditions.checkState(oldX!=  residuals);  [CE]  cannot  find  symbol  Preconditions  [FE]                  AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  Preconditions.checkState(oldX!=  residuals);  [BUGGY]      tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	Preconditions.checkState(oldX!=  residuals);	  Preconditions.checkState(remainings!=    oldX);    	non-compiled	[CE]  cannot  find  symbol  Preconditions	36	None	replace
74	[BUG]  [BUGGY]  Preconditions.checkState(oldRes  ==  oldX[j]);  [CE]  cannot  find  symbol  j  [FE]                        AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  Preconditions.checkState(oldRes  ==  oldX[j]);  [BUGGY]      tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	Preconditions.checkState(oldRes  ==  oldX[j]);	  Preconditions.checkState(oldRes    ==    oldX[pj]);    	non-compiled	[CE]  cannot  find  symbol  j	43	None	replace
75	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  tmpVec=    oldX;    tmpVec=  oldX;  tmpVec=  oldX;  tmpVec=  oldX;  [BUGGY]      residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	add	tmpVec=        oldX;        tmpVec=    oldX;    tmpVec=  oldX;  tmpVec=  oldX;	  	compilable	  [FE]  AssertionFailedError  	6	2	add
76	[BUG]  [BUGGY]  tmpVec=    oldX;    tmpVec=  oldX;  tmpVec=  oldX;  tmpVec=  oldX;  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  tmpVec=    oldX;    tmpVec=  oldX;  tmpVec=  oldX;  tmpVec=  oldX;  [BUGGY]      residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	tmpVec=        oldX;        tmpVec=    oldX;    tmpVec=  oldX;  tmpVec=  oldX;	  	compilable	  [FE]  AssertionFailedError  	6	2	add
77	[BUG]  [BUGGY]  tmpVec=    oldX;    tmpVec=  oldX;  tmpVec=  oldY;  tmpVec=  oldY;  [CE]  cannot  find  symbol  oldY  [FE]      AssertionFailedError    [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  tmpVec=    oldX;    tmpVec=  oldX;  tmpVec=  oldY;  tmpVec=  oldY;  [BUGGY]      residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	tmpVec=        oldX;        tmpVec=    oldX;    tmpVec=  oldY;  tmpVec=  oldY;	  	non-compiled	[CE]  cannot  find  symbol  oldY	6	None	add
78	[BUG]  [BUGGY]  Preconditions.checkNotNull(pj);  [CE]  cannot  find  symbol  pj  [FE]            AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  Preconditions.checkNotNull(pj);  [BUGGY]      tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	Preconditions.checkNotNull(pj);	  Preconditions.checkNotNull(remainings);    	non-compiled	[CE]  cannot  find  symbol  pj	2	None	replace
79	[BUG]  [BUGGY]  Preconditions.checkState(remainings!=  previousCost);  [CE]  cannot  find  symbol  remainings  [FE]              AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  Preconditions.checkState(remainings!=  previousCost);  [BUGGY]      tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	Preconditions.checkState(remainings!=  previousCost);	  Preconditions.checkNotNull(previousCost);    	non-compiled	[CE]  cannot  find  symbol  remainings	67	None	replace
80	[BUG]  [BUGGY]  Preconditions.checkState(remainings  ==  previousCost);  [CE]  cannot  find  symbol  remainings  [FE]                AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  Preconditions.checkState(remainings  ==  previousCost);  [BUGGY]      tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	Preconditions.checkState(remainings  ==  previousCost);	  Preconditions.checkNotNull(previousCost);    	non-compiled	[CE]  cannot  find  symbol  remainings	67	None	replace
81	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    ArrayIndexOutOfBoundsException    [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  tmpVec=  point;  tmpVec=  point;  [BUGGY]      residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	add	tmpVec=    point;    tmpVec=  point;	  	compilable	  [FE]  AssertionFailedError  	20	2	add
82	[BUG]  [BUGGY]  tmpVec=  point;  tmpVec=  point;  [FE]  AssertionFailedError  [FE]    ArrayIndexOutOfBoundsException    [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  tmpVec=  point;  tmpVec=  point;  [BUGGY]      residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	tmpVec=    point;    tmpVec=  point;	  	compilable	  [FE]  AssertionFailedError  	20	2	add
83	[BUG]  [BUGGY]  tmpVec=  point;  ((  VectorialPointValuePair)point).doubleValue();  tmpVec=  point;  [CE]  inconvertible  types  [FE]      ArrayIndexOutOfBoundsException    [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  tmpVec=  point;  ((  VectorialPointValuePair)point).doubleValue();  tmpVec=  point;  [BUGGY]      residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	tmpVec=    point;    ((  VectorialPointValuePair)point).doubleValue();  tmpVec=  point;	  	non-compiled	[CE]  inconvertible  types	20	None	add
84	[BUG]  [BUGGY]  tmpVec=  point;  ((  VectorialPointValuePair)point).setIndex(results);  [CE]  cannot  find  symbol  results  [FE]        ArrayIndexOutOfBoundsException    [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  tmpVec=  point;  ((  VectorialPointValuePair)point).setIndex(results);  [BUGGY]      residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	tmpVec=    point;    ((  VectorialPointValuePair)point).setIndex(results);	  	non-compiled	[CE]  cannot  find  symbol  results	20	None	add
85	[BUG]  [BUGGY]  tmpVec=  point;  int  tmpVec=  point;  [CE]  variable  tmpVec  is  already  defined  in  method  doOptimize()  [FE]          ArrayIndexOutOfBoundsException    [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  tmpVec=  point;  int  tmpVec=  point;  [BUGGY]      residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	tmpVec=    point;    int  tmpVec=  point;	  	non-compiled	[CE]  variable  tmpVec  is  already  defined  in  method  doOptimize()	20	None	add
86	[BUG]  [BUGGY]  tmpVec  =  point[pj];  [CE]  cannot  find  symbol  pj  [FE]            AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  tmpVec  =  point[pj];  [BUGGY]      tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	tmpVec  =  point[pj];	  tmpVec    =    permutation[pj];    	non-compiled	[CE]  cannot  find  symbol  pj	22	None	replace
87	[BUG]  [BUGGY]  tmpVec=  new  VectorialPointValuePair(point,  cost);  [CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double[],double)  [FE]            AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  tmpVec=  new  VectorialPointValuePair(point,  cost);  [BUGGY]      residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	tmpVec=  new  VectorialPointValuePair(point,  cost);	  tmpVec=    new    VectorialPointValuePair(point);    	non-compiled	[CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double[],double)	46	None	replace
88	[BUG]  [BUGGY]  tmpVec=  new  VectorialPointValuePair(pj,  point);  [CE]  cannot  find  symbol  pj  [FE]              AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  tmpVec=  new  VectorialPointValuePair(pj,  point);  [BUGGY]      residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	tmpVec=  new  VectorialPointValuePair(pj,  point);	  tmpVec=    new    VectorialPointValuePair(point);    	non-compiled	[CE]  cannot  find  symbol  pj	46	None	replace
89	[BUG]  [BUGGY]  Preconditions.checkNotNull(results,  oldX);  [CE]  cannot  find  symbol  results  [FE]                  AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  Preconditions.checkNotNull(results,  oldX);  [BUGGY]      tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	Preconditions.checkNotNull(results,  oldX);	  Preconditions.checkNotNull(results,    point);    	non-compiled	[CE]  cannot  find  symbol  results	5	None	replace
90	[BUG]  [BUGGY]  Preconditions.checkNotNull(results,  oldRes);  [CE]  cannot  find  symbol  results  [FE]                    AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  Preconditions.checkNotNull(results,  oldRes);  [BUGGY]      tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	Preconditions.checkNotNull(results,  oldRes);	  Preconditions.checkNotNull(results,    point);    	non-compiled	[CE]  cannot  find  symbol  results	5	None	replace
91	[BUG]  [BUGGY]  Preconditions.checkNotNull(results,  pj);  [CE]  cannot  find  symbol  results  [FE]                      AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  Preconditions.checkNotNull(results,  pj);  [BUGGY]      tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	Preconditions.checkNotNull(results,  pj);	  Preconditions.checkNotNull(results,    point);    	non-compiled	[CE]  cannot  find  symbol  results	5	None	replace
92	[BUG]  [BUGGY]  tmpVec  =  previousCost  +  2;  [CE]  incompatible  types  [FE]              AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  tmpVec  =  previousCost  +  2;  [BUGGY]      tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	tmpVec  =  previousCost  +  2;	  tmpVec    =    previousCost    +    1;    	non-compiled	[CE]  incompatible  types	63	None	replace
93	[BUG]  [BUGGY]  Preconditions.checkState(oldRes!=  preRed);  [CE]  incomparable  types:  double[]  and  double  [FE]                AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  Preconditions.checkState(oldRes!=  preRed);  [BUGGY]      tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	Preconditions.checkState(oldRes!=  preRed);	  Preconditions.checkState(oldRes!=    previousCost);    	non-compiled	[CE]  incomparable  types:  double[]  and  double	62	None	replace
94	[BUG]  [BUGGY]  Preconditions.checkState(previousCost!=  oldRes);  [CE]  incomparable  types:  double  and  double[]  [FE]                  AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  Preconditions.checkState(previousCost!=  oldRes);  [BUGGY]      tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	Preconditions.checkState(previousCost!=  oldRes);	  Preconditions.checkState(oldRes!=    previousCost);    	non-compiled	[CE]  incomparable  types:  double  and  double[]	62	None	replace
95	[BUG]  [BUGGY]  Preconditions.checkState(oldRes!=  previousCost,  cost);  [CE]  incomparable  types:  double[]  and  double  [FE]                    AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  Preconditions.checkState(oldRes!=  previousCost,  cost);  [BUGGY]      tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	Preconditions.checkState(oldRes!=  previousCost,  cost);	  Preconditions.checkState(oldRes!=    previousCost);    	non-compiled	[CE]  incomparable  types:  double[]  and  double	62	None	replace
96	[BUG]  [BUGGY]  tmpVec=  new  VectorialPointValuePair(previousCost,  permutation);  [CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double,int[])  [FE]              AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  tmpVec=  new  VectorialPointValuePair(previousCost,  permutation);  [BUGGY]      residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	tmpVec=  new  VectorialPointValuePair(previousCost,  permutation);	  tmpVec=    new    VectorialPointValuePair(period,    previousCost);    	non-compiled	[CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double,int[])	45	None	replace
97	[BUG]  [BUGGY]  tmpVec=  new  VectorialPointValuePair(period,  preRed);  [CE]  cannot  find  symbol  period  [FE]                AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  tmpVec=  new  VectorialPointValuePair(period,  preRed);  [BUGGY]      residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	tmpVec=  new  VectorialPointValuePair(period,  preRed);	  tmpVec=    new    VectorialPointValuePair(period,    previousCost);    	non-compiled	[CE]  cannot  find  symbol  period	45	None	replace
98	[BUG]  [BUGGY]  tmpVec=  new  VectorialPointValuePair(previousCost,  oldX,  point,  cost);  [CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double,double[],double[],double)  [FE]            AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  tmpVec=  new  VectorialPointValuePair(previousCost,  oldX,  point,  cost);  [BUGGY]      residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	tmpVec=  new  VectorialPointValuePair(previousCost,  oldX,  point,  cost);	  tmpVec=    new    VectorialPointValuePair(previousCost,    point,    cost);    	non-compiled	[CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double,double[],double[],double)	25	None	replace
99	[BUG]  [BUGGY]  tmpVec=  new  VectorialPointValuePair(previousCost,  preRed,  point,  cost);  [CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double,double,double[],double)  [FE]              AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  tmpVec=  new  VectorialPointValuePair(previousCost,  preRed,  point,  cost);  [BUGGY]      residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	tmpVec=  new  VectorialPointValuePair(previousCost,  preRed,  point,  cost);	  tmpVec=    new    VectorialPointValuePair(previousCost,    point,    cost);    	non-compiled	[CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double,double,double[],double)	25	None	replace
100	[BUG]  [BUGGY]  tmpVec=  new  VectorialPointValuePair(previousCost,  previousCost,  point,  cost);  [CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double,double,double[],double)  [FE]                AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  tmpVec=  new  VectorialPointValuePair(previousCost,  previousCost,  point,  cost);  [BUGGY]      residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	tmpVec=  new  VectorialPointValuePair(previousCost,  previousCost,  point,  cost);	  tmpVec=    new    VectorialPointValuePair(previousCost,    point,    cost);    	non-compiled	[CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double,double,double[],double)	25	None	replace
101	[BUG]  [BUGGY]  tmpVec=  new  VectorialPointValuePair(previousCost,  point,  preRed,  cost);  [CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double,double[],double,double)  [FE]                  AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  tmpVec=  new  VectorialPointValuePair(previousCost,  point,  preRed,  cost);  [BUGGY]      residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	tmpVec=  new  VectorialPointValuePair(previousCost,  point,  preRed,  cost);	  tmpVec=    new    VectorialPointValuePair(previousCost,    point,    cost);    	non-compiled	[CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double,double[],double,double)	25	None	replace
102	[BUG]  [BUGGY]  tmpVec=  new  VectorialPointValuePair(pj,  preRed,  cost);  [CE]  cannot  find  symbol  pj  [FE]                  AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  tmpVec=  new  VectorialPointValuePair(pj,  preRed,  cost);  [BUGGY]      residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	tmpVec=  new  VectorialPointValuePair(pj,  preRed,  cost);	  tmpVec=    new    VectorialPointValuePair(pj,    previousCost,    cost);    	non-compiled	[CE]  cannot  find  symbol  pj	28	None	replace
103	[BUG]  [BUGGY]  tmpVec=  new  VectorialPointValuePair(previousCost,  preRed,  point);  [CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double,double,double[])  [FE]                AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  tmpVec=  new  VectorialPointValuePair(previousCost,  preRed,  point);  [BUGGY]      residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	tmpVec=  new  VectorialPointValuePair(previousCost,  preRed,  point);	  tmpVec=    new    VectorialPointValuePair(previousCost,    preRed,    cost);    	non-compiled	[CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double,double,double[])	27	None	replace
104	[BUG]  [BUGGY]  tmpVec=  new  VectorialPointValuePair(previousCost,  cost,  preRed);  [CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double,double,double)  [FE]                  AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  tmpVec=  new  VectorialPointValuePair(previousCost,  cost,  preRed);  [BUGGY]      residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	tmpVec=  new  VectorialPointValuePair(previousCost,  cost,  preRed);	  tmpVec=    new    VectorialPointValuePair(previousCost,    preRed,    cost);    	non-compiled	[CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double,double,double)	27	None	replace
105	[BUG]  [BUGGY]  tmpVec=  new  VectorialPointValuePair(previousCost,  preRed,  cost,  solvedCols);  [CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double,double,double,int)  [FE]                    AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  tmpVec=  new  VectorialPointValuePair(previousCost,  preRed,  cost,  solvedCols);  [BUGGY]      residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	tmpVec=  new  VectorialPointValuePair(previousCost,  preRed,  cost,  solvedCols);	  tmpVec=    new    VectorialPointValuePair(previousCost,    preRed,    cost);    	non-compiled	[CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double,double,double,int)	27	None	replace
106	[BUG]  [BUGGY]  tmpVec  =  permutation[p];  [CE]  cannot  find  symbol  p  [FE]            AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  tmpVec  =  permutation[p];  [BUGGY]      tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	tmpVec  =  permutation[p];	  tmpVec    =    permutation[point];    	non-compiled	[CE]  cannot  find  symbol  p	53	None	replace
107	[BUG]  [BUGGY]  tmpVec  =  permutation[point]  +  1;  [CE]  incompatible  types  [FE]              AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  tmpVec  =  permutation[point]  +  1;  [BUGGY]      tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	tmpVec  =  permutation[point]  +  1;	  tmpVec    =    permutation[point];    	non-compiled	[CE]  incompatible  types	53	None	replace
108	[BUG]  [BUGGY]  Preconditions.checkState(results  ==  oldX,  residuals);  [CE]  cannot  find  symbol  results  [FE]              AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  Preconditions.checkState(results  ==  oldX,  residuals);  [BUGGY]      tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	Preconditions.checkState(results  ==  oldX,  residuals);	  Preconditions.checkState(results    ==    oldX);    	non-compiled	[CE]  cannot  find  symbol  results	50	None	replace
109	[BUG]  [BUGGY]  Preconditions.checkState(results  ==  oldX,  tmpVec);  [CE]  cannot  find  symbol  results  [FE]                AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  Preconditions.checkState(results  ==  oldX,  tmpVec);  [BUGGY]      tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	Preconditions.checkState(results  ==  oldX,  tmpVec);	  Preconditions.checkState(results    ==    oldX);    	non-compiled	[CE]  cannot  find  symbol  results	50	None	replace
110	[BUG]  [BUGGY]  tmpVec=  oldX;  tmpVec=  oldVec;  [CE]  cannot  find  symbol  oldVec  [FE]    AssertionFailedError    [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  tmpVec=  oldX;  tmpVec=  oldVec;  [BUGGY]      residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	tmpVec=  oldX;  tmpVec=  oldVec;	  tmpVec=    oldX;    tmpVec=    oldX;    	non-compiled	[CE]  cannot  find  symbol  oldVec	7	None	replace
111	[BUG]  [BUGGY]  tmpVec=  oldX;  tmpVec=  new  double[pj];  [CE]  cannot  find  symbol  pj  [FE]      AssertionFailedError    [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  tmpVec=  oldX;  tmpVec=  new  double[pj];  [BUGGY]      residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	tmpVec=  oldX;  tmpVec=  new  double[pj];	  tmpVec=    oldX;    tmpVec=    oldX;    	non-compiled	[CE]  cannot  find  symbol  pj	7	None	replace
112	[BUG]  [BUGGY]  [FE]  ArrayIndexOutOfBoundsException  [FE]        AssertionFailedError    [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  tmpVec=  oldRes;  tmpVec=  oldX;  [BUGGY]      residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	add	tmpVec=  oldRes;  tmpVec=  oldX;	  tmpVec=    oldX;    tmpVec=    oldX;    	compilable	  [FE]  ArrayIndexOutOfBoundsException  	7	12	replace
113	[BUG]  [BUGGY]  tmpVec=  oldRes;  tmpVec=  oldX;  [FE]  ArrayIndexOutOfBoundsException  [FE]        AssertionFailedError    [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  tmpVec=  oldRes;  tmpVec=  oldX;  [BUGGY]      residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	tmpVec=  oldRes;  tmpVec=  oldX;	  tmpVec=    oldX;    tmpVec=    oldX;    	compilable	  [FE]  ArrayIndexOutOfBoundsException  	7	12	replace
114	[BUG]  [BUGGY]  Preconditions.checkState(relatives!=  oldX);  [CE]  cannot  find  symbol  relatives  [FE]                  AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  Preconditions.checkState(relatives!=  oldX);  [BUGGY]      tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	Preconditions.checkState(relatives!=  oldX);	  Preconditions.checkState(remainings!=    oldX);    	non-compiled	[CE]  cannot  find  symbol  relatives	36	None	replace
115	[BUG]  [BUGGY]  Preconditions.checkState(oldRes  ==  point[pj]);  [CE]  cannot  find  symbol  pj  [FE]                        AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  Preconditions.checkState(oldRes  ==  point[pj]);  [BUGGY]      tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	Preconditions.checkState(oldRes  ==  point[pj]);	  Preconditions.checkState(oldRes    ==    oldX[pj]);    	non-compiled	[CE]  cannot  find  symbol  pj	43	None	replace
116	[BUG]  [BUGGY]  tmpVec=  new  VectorialPointValuePair(last,  previousCost);  [CE]  cannot  find  symbol  last  [FE]              AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  tmpVec=  new  VectorialPointValuePair(last,  previousCost);  [BUGGY]      residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	tmpVec=  new  VectorialPointValuePair(last,  previousCost);	  tmpVec=    new    VectorialPointValuePair(period,    previousCost);    	non-compiled	[CE]  cannot  find  symbol  last	45	None	replace
117	[BUG]  [BUGGY]  Preconditions.checkState(oldRes!=  pj);  [CE]  cannot  find  symbol  pj  [FE]                AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  Preconditions.checkState(oldRes!=  pj);  [BUGGY]      tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	Preconditions.checkState(oldRes!=  pj);	  Preconditions.checkState(oldRes!=    oldRes);    	non-compiled	[CE]  cannot  find  symbol  pj	55	None	replace
118	[BUG]  [BUGGY]  tmpVec  =  point[permutation];  [CE]  incompatible  types  [FE]            AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  tmpVec  =  point[permutation];  [BUGGY]      tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	tmpVec  =  point[permutation];	  tmpVec    =    permutation[point];    	non-compiled	[CE]  incompatible  types	53	None	replace
119	[BUG]  [BUGGY]  tmpVec  =  permutation[point]  +  point;  [CE]  incompatible  types  [FE]              AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  tmpVec  =  permutation[point]  +  point;  [BUGGY]      tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	tmpVec  =  permutation[point]  +  point;	  tmpVec    =    permutation[point];    	non-compiled	[CE]  incompatible  types	53	None	replace
120	[BUG]  [BUGGY]  tmpVec  =  oldRes[point];  [CE]  incompatible  types  [FE]                    AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  tmpVec  =  oldRes[point];  [BUGGY]      tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	tmpVec  =  oldRes[point];	  tmpVec    =    oldRes[pj];    	non-compiled	[CE]  incompatible  types	17	None	replace
121	[BUG]  [BUGGY]  tmpVec  =  permutation[1];  [CE]  incompatible  types  [FE]                AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  tmpVec  =  permutation[1];  [BUGGY]      tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	tmpVec  =  permutation[1];	  tmpVec    =    permutation[0];    	non-compiled	[CE]  incompatible  types	24	None	replace
122	[BUG]  [BUGGY]  tmpVec=  new  VectorialPointValuePair(previousCost,  pj);  [CE]  cannot  find  symbol  pj  [FE]            AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  tmpVec=  new  VectorialPointValuePair(previousCost,  pj);  [BUGGY]      residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	tmpVec=  new  VectorialPointValuePair(previousCost,  pj);	  tmpVec=    new    VectorialPointValuePair(lastX,    previousCost);    	non-compiled	[CE]  cannot  find  symbol  pj	64	None	replace
123	[BUG]  [BUGGY]  tmpVec=  new  VectorialPointValuePair(point,  value);  [CE]  cannot  find  symbol  value  [FE]            AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  tmpVec=  new  VectorialPointValuePair(point,  value);  [BUGGY]      residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	tmpVec=  new  VectorialPointValuePair(point,  value);	  tmpVec=    new    VectorialPointValuePair(point);    	non-compiled	[CE]  cannot  find  symbol  value	46	None	replace
124	[BUG]  [BUGGY]  tmpVec=  new  VectorialPointValuePair(point,  prev);  [CE]  cannot  find  symbol  prev  [FE]              AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  tmpVec=  new  VectorialPointValuePair(point,  prev);  [BUGGY]      residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	tmpVec=  new  VectorialPointValuePair(point,  prev);	  tmpVec=    new    VectorialPointValuePair(point);    	non-compiled	[CE]  cannot  find  symbol  prev	46	None	replace
125	[BUG]  [BUGGY]  Preconditions.checkState(oldRes!=  result);  [CE]  cannot  find  symbol  result  [FE]              AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  Preconditions.checkState(oldRes!=  result);  [BUGGY]      tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	Preconditions.checkState(oldRes!=  result);	  Preconditions.checkState(results    ==    oldRes);    	non-compiled	[CE]  cannot  find  symbol  result	12	None	replace
126	[BUG]  [BUGGY]  tmpVec=    oldX;    tmpVec=  oldX;  tmpVec=  oldX;  tmpVec=  oldY;  [CE]  cannot  find  symbol  oldY  [FE]    AssertionFailedError    [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  tmpVec=    oldX;    tmpVec=  oldX;  tmpVec=  oldX;  tmpVec=  oldY;  [BUGGY]      residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	tmpVec=        oldX;        tmpVec=    oldX;    tmpVec=  oldX;  tmpVec=  oldY;	  	non-compiled	[CE]  cannot  find  symbol  oldY	6	None	add
127	[BUG]  [BUGGY]  Preconditions.checkNotNull(previousCost,  cost);  [CE]  cannot  find  symbol  Preconditions  [FE]              AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  Preconditions.checkNotNull(previousCost,  cost);  [BUGGY]      tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	Preconditions.checkNotNull(previousCost,  cost);	  Preconditions.checkNotNull(previousCost);    	non-compiled	[CE]  cannot  find  symbol  Preconditions	67	None	replace
128	[BUG]  [BUGGY]  tmpVec=  oldX;  tmpVec=  new  Double(pj);  [CE]  cannot  find  symbol  pj  [FE]            ArrayIndexOutOfBoundsException      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  tmpVec=  oldX;  tmpVec=  new  Double(pj);  [BUGGY]      residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	tmpVec=  oldX;  tmpVec=  new  Double(pj);	  tmpVec=    oldX;    tmpVec=    oldY;    	non-compiled	[CE]  cannot  find  symbol  pj	9	None	replace
129	[BUG]  [BUGGY]  tmpVec=  new  VectorialPointValuePair(pj,  cost);  [CE]  cannot  find  symbol  pj  [FE]            AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  tmpVec=  new  VectorialPointValuePair(pj,  cost);  [BUGGY]      residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	tmpVec=  new  VectorialPointValuePair(pj,  cost);	  tmpVec=    new    VectorialPointValuePair(pj,    previousCost);    	non-compiled	[CE]  cannot  find  symbol  pj	44	None	replace
130	[BUG]  [BUGGY]  tmpVec=  point;  ((  VectorialPointValuePair)point).setIndexOutOfBounds(true);  [CE]  inconvertible  types  [FE]    ArrayIndexOutOfBoundsException    [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  tmpVec=  point;  ((  VectorialPointValuePair)point).setIndexOutOfBounds(true);  [BUGGY]      residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	tmpVec=    point;    ((  VectorialPointValuePair)point).setIndexOutOfBounds(true);	  	non-compiled	[CE]  inconvertible  types	20	None	add
131	[BUG]  [BUGGY]  tmpVec=  point;  ((  VectorialPointValuePair)point).setVec(  tmpVec);  [CE]  inconvertible  types  [FE]      ArrayIndexOutOfBoundsException    [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  tmpVec=  point;  ((  VectorialPointValuePair)point).setVec(  tmpVec);  [BUGGY]      residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	tmpVec=    point;    ((  VectorialPointValuePair)point).setVec(  tmpVec);	  	non-compiled	[CE]  inconvertible  types	20	None	add
132	[BUG]  [BUGGY]  tmpVec=  point;  ((  VectorialPointValuePair)point).setIndexOutOfBounds(tmpVec);  [CE]  inconvertible  types  [FE]        ArrayIndexOutOfBoundsException    [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  tmpVec=  point;  ((  VectorialPointValuePair)point).setIndexOutOfBounds(tmpVec);  [BUGGY]      residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	tmpVec=    point;    ((  VectorialPointValuePair)point).setIndexOutOfBounds(tmpVec);	  	non-compiled	[CE]  inconvertible  types	20	None	add
133	[BUG]  [BUGGY]  tmpVec=  point;  ((  VectorialPointValuePair)point).setIndex(relativeTolerance);  [CE]  cannot  find  symbol  relativeTolerance  [FE]          ArrayIndexOutOfBoundsException    [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  tmpVec=  point;  ((  VectorialPointValuePair)point).setIndex(relativeTolerance);  [BUGGY]      residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	tmpVec=    point;    ((  VectorialPointValuePair)point).setIndex(relativeTolerance);	  	non-compiled	[CE]  cannot  find  symbol  relativeTolerance	20	None	add
134	[BUG]  [BUGGY]  tmpVec=  new  VectorialPointValuePair(point,  oldX,  previousCost);  [CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double[],double[],double)  [FE]            AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  tmpVec=  new  VectorialPointValuePair(point,  oldX,  previousCost);  [BUGGY]      residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	tmpVec=  new  VectorialPointValuePair(point,  oldX,  previousCost);	  tmpVec=    new    VectorialPointValuePair(point,    previousCost);    	non-compiled	[CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double[],double[],double)	57	None	replace
135	[BUG]  [BUGGY]  Preconditions.checkState(pj  ==  oldX[point]);  [CE]  cannot  find  symbol  pj  [FE]                      AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  Preconditions.checkState(pj  ==  oldX[point]);  [BUGGY]      tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	Preconditions.checkState(pj  ==  oldX[point]);	  Preconditions.checkState(pj    ==    oldX[pj]);    	non-compiled	[CE]  cannot  find  symbol  pj	42	None	replace
136	[BUG]  [BUGGY]  tmpVec=  new  double[reasitives];  [CE]  cannot  find  symbol  reasitives  [FE]                  AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  tmpVec=  new  double[reasitives];  [BUGGY]      residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	tmpVec=  new  double[reasitives];	  tmpVec=    new    double[results];    	non-compiled	[CE]  cannot  find  symbol  reasitives	48	None	replace
137	[BUG]  [BUGGY]  tmpVec  =  cost[pj];  [CE]  cannot  find  symbol  pj  [FE]            AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  tmpVec  =  cost[pj];  [BUGGY]      tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	tmpVec  =  cost[pj];	  tmpVec    =    cost[j];    	non-compiled	[CE]  cannot  find  symbol  pj	61	None	replace
138	[BUG]  [BUGGY]  Preconditions.checkState(oldRes!=  point[pj]);  [CE]  cannot  find  symbol  pj  [FE]                    AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  Preconditions.checkState(oldRes!=  point[pj]);  [BUGGY]      tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	Preconditions.checkState(oldRes!=  point[pj]);	  Preconditions.checkState(oldRes!=    oldX[pj]);    	non-compiled	[CE]  cannot  find  symbol  pj	54	None	replace
139	[BUG]  [BUGGY]  tmpVec=  point.length;  [CE]  incompatible  types  [FE]    ArrayIndexOutOfBoundsException    [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  tmpVec=  point.length;  [BUGGY]      residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	tmpVec=  point.length;	  tmpVec=    point;    	non-compiled	[CE]  incompatible  types	21	None	replace
140	[BUG]  [BUGGY]  tmpVec=  new  VectorialPointValuePair(point,  preRed,  cost);  [CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double[],double,double)  [FE]            AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  tmpVec=  new  VectorialPointValuePair(point,  preRed,  cost);  [BUGGY]      residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	tmpVec=  new  VectorialPointValuePair(point,  preRed,  cost);	  tmpVec=    new    VectorialPointValuePair(previousCost,    point,    cost);    	non-compiled	[CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double[],double,double)	25	None	replace
141	[BUG]  [BUGGY]  tmpVec=  new  VectorialPointValuePair(previousCost,  cost,  point);  [CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double,double,double[])  [FE]              AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  tmpVec=  new  VectorialPointValuePair(previousCost,  cost,  point);  [BUGGY]      residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	tmpVec=  new  VectorialPointValuePair(previousCost,  cost,  point);	  tmpVec=    new    VectorialPointValuePair(previousCost,    point,    cost);    	non-compiled	[CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double,double,double[])	25	None	replace
142	[BUG]  [BUGGY]  tmpVec  =  currentCost.cloneTree();  [CE]  cannot  find  symbol  currentCost  [FE]              AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  tmpVec  =  currentCost.cloneTree();  [BUGGY]      tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	tmpVec  =  currentCost.cloneTree();	  tmpVec    =    previousCost.cloneTree();    	non-compiled	[CE]  cannot  find  symbol  currentCost	10	None	replace
143	[BUG]  [BUGGY]  tmpVec=  new  double[remainders];  [CE]  cannot  find  symbol  remainders  [FE]                  AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  tmpVec=  new  double[remainders];  [BUGGY]      residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	tmpVec=  new  double[remainders];	  tmpVec=    new    double[res];    	non-compiled	[CE]  cannot  find  symbol  remainders	37	None	replace
144	[BUG]  [BUGGY]  tmpVec=  new  VectorialPointValuePair(j);  [CE]  cannot  find  symbol  j  [FE]                AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  tmpVec=  new  VectorialPointValuePair(j);  [BUGGY]      residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	tmpVec=  new  VectorialPointValuePair(j);	  tmpVec=    new    VectorialPointValuePair(pj);    	non-compiled	[CE]  cannot  find  symbol  j	34	None	replace
145	[BUG]  [BUGGY]  tmpVec=  new  VectorialPointValuePair(oldX);  [CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double[])  [FE]                  AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  tmpVec=  new  VectorialPointValuePair(oldX);  [BUGGY]      residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	tmpVec=  new  VectorialPointValuePair(oldX);	  tmpVec=    new    VectorialPointValuePair(pj);    	non-compiled	[CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double[])	34	None	replace
146	[BUG]  [BUGGY]  tmpVec=  new  VectorialPointValuePair(previousCost,  cost,  fixedCols);  [CE]  cannot  find  symbol  fixedCols  [FE]            AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  tmpVec=  new  VectorialPointValuePair(previousCost,  cost,  fixedCols);  [BUGGY]      residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	tmpVec=  new  VectorialPointValuePair(previousCost,  cost,  fixedCols);	  tmpVec=    new    VectorialPointValuePair(previousCost,    cost,    solveCols);    	non-compiled	[CE]  cannot  find  symbol  fixedCols	65	None	replace
147	[BUG]  [BUGGY]  tmpVec=  new  VectorialPointValuePair(previous);  [CE]  no  suitable  constructor  found  for  VectorialPointValuePair(VectorialPointValuePair)  [FE]              AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  tmpVec=  new  VectorialPointValuePair(previous);  [BUGGY]      residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	tmpVec=  new  VectorialPointValuePair(previous);	  tmpVec=    new    VectorialPointValuePair(remainings);    	non-compiled	[CE]  no  suitable  constructor  found  for  VectorialPointValuePair(VectorialPointValuePair)	33	None	replace
148	[BUG]  [BUGGY]  tmpVec=  new  VectorialPointValuePair(rect);  [CE]  cannot  find  symbol  rect  [FE]                AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  tmpVec=  new  VectorialPointValuePair(rect);  [BUGGY]      residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	tmpVec=  new  VectorialPointValuePair(rect);	  tmpVec=    new    VectorialPointValuePair(remainings);    	non-compiled	[CE]  cannot  find  symbol  rect	33	None	replace
149	[BUG]  [BUGGY]  tmpVec=  new  double[result];  [CE]  cannot  find  symbol  result  [FE]                    AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  tmpVec=  new  double[result];  [BUGGY]      residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	tmpVec=  new  double[result];	  tmpVec=    new    double[point];    	non-compiled	[CE]  cannot  find  symbol  result	38	None	replace
150	[BUG]  [BUGGY]  tmpVec  =  prevCost.previousCost;  [CE]  cannot  find  symbol  prevCost  [FE]                AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  tmpVec  =  prevCost.previousCost;  [BUGGY]      tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	tmpVec  =  prevCost.previousCost;	  tmpVec    =    previousCost.previousCost;    	non-compiled	[CE]  cannot  find  symbol  prevCost	11	None	replace
151	[BUG]  [BUGGY]  tmpVec  =  prev.previousCost;  [CE]  cannot  find  symbol  prev  [FE]                  AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  tmpVec  =  prev.previousCost;  [BUGGY]      tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	tmpVec  =  prev.previousCost;	  tmpVec    =    previousCost.previousCost;    	non-compiled	[CE]  cannot  find  symbol  prev	11	None	replace
152	[BUG]  [BUGGY]  Preconditions.checkState(oldRes!=  pr);  [CE]  cannot  find  symbol  pr  [FE]                AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  Preconditions.checkState(oldRes!=  pr);  [BUGGY]      tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	Preconditions.checkState(oldRes!=  pr);	  Preconditions.checkState(oldRes!=    previousCost);    	non-compiled	[CE]  cannot  find  symbol  pr	62	None	replace
153	[BUG]  [BUGGY]  tmpVec=  new  VectorialPointValuePair(point,  cost,  previousCost);  [CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double[],double,double)  [FE]            AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  tmpVec=  new  VectorialPointValuePair(point,  cost,  previousCost);  [BUGGY]      residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	tmpVec=  new  VectorialPointValuePair(point,  cost,  previousCost);	  tmpVec=    new    VectorialPointValuePair(point,    previousCost,    cost);    	non-compiled	[CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double[],double,double)	58	None	replace
154	[BUG]  [BUGGY]  tmpVec=  new  VectorialPointValuePair(point,  oldX,  previousCost,  cost);  [CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double[],double[],double,double)  [FE]              AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  tmpVec=  new  VectorialPointValuePair(point,  oldX,  previousCost,  cost);  [BUGGY]      residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	tmpVec=  new  VectorialPointValuePair(point,  oldX,  previousCost,  cost);	  tmpVec=    new    VectorialPointValuePair(point,    previousCost,    cost);    	non-compiled	[CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double[],double[],double,double)	58	None	replace
155	[BUG]  [BUGGY]  tmpVec=  new  VectorialPointValuePair(point,  preRed,  previousCost,  cost);  [CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double[],double,double,double)  [FE]                AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  tmpVec=  new  VectorialPointValuePair(point,  preRed,  previousCost,  cost);  [BUGGY]      residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	tmpVec=  new  VectorialPointValuePair(point,  preRed,  previousCost,  cost);	  tmpVec=    new    VectorialPointValuePair(point,    previousCost,    cost);    	non-compiled	[CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double[],double,double,double)	58	None	replace
156	[BUG]  [BUGGY]  Preconditions.checkState(oldRes!=  null);  [CE]  cannot  find  symbol  Preconditions  [FE]            AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  Preconditions.checkState(oldRes!=  null);  [BUGGY]      tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	Preconditions.checkState(oldRes!=  null);	  Preconditions.checkNotNull(oldRes);    	non-compiled	[CE]  cannot  find  symbol  Preconditions	49	None	replace
157	[BUG]  [BUGGY]  tmpVec=  new  VectorialPointValuePair(point,  preRed);  [CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double[],double)  [FE]                AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  tmpVec=  new  VectorialPointValuePair(point,  preRed);  [BUGGY]      residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	tmpVec=  new  VectorialPointValuePair(point,  preRed);	  tmpVec=    new    VectorialPointValuePair(previousCost,    point);    	non-compiled	[CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double[],double)	60	None	replace
158	[BUG]  [BUGGY]  Preconditions.checkState(tmpVec  >  0);  [CE]  bad  operand  types  for  binary  operator  '>'  [FE]              AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  Preconditions.checkState(tmpVec  >  0);  [BUGGY]      tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	Preconditions.checkState(tmpVec  >  0);	  Preconditions.checkState(results    >    0);    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '>'	29	None	replace
159	[BUG]  [BUGGY]  tmpVec  =  oldX[0];  [CE]  incompatible  types  [FE]                AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  tmpVec  =  oldX[0];  [BUGGY]      tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	tmpVec  =  oldX[0];	  tmpVec    =    permutation[0];    	non-compiled	[CE]  incompatible  types	24	None	replace
160	[BUG]  [BUGGY]  tmpVec  =  point[0];  [CE]  incompatible  types  [FE]                  AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  tmpVec  =  point[0];  [BUGGY]      tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	tmpVec  =  point[0];	  tmpVec    =    permutation[0];    	non-compiled	[CE]  incompatible  types	24	None	replace
161	[BUG]  [BUGGY]  Preconditions.checkState(result  >  0);  [CE]  cannot  find  symbol  result  [FE]                AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  Preconditions.checkState(result  >  0);  [BUGGY]      tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	Preconditions.checkState(result  >  0);	  Preconditions.checkState(pj    >    0);    	non-compiled	[CE]  cannot  find  symbol  result	30	None	replace
162	[BUG]  [BUGGY]  tmpVec=  new  VectorialPointValuePair(period,  cost);  [CE]  cannot  find  symbol  period  [FE]              AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  tmpVec=  new  VectorialPointValuePair(period,  cost);  [BUGGY]      residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	tmpVec=  new  VectorialPointValuePair(period,  cost);	  tmpVec=    new    VectorialPointValuePair(period,    previousCost);    	non-compiled	[CE]  cannot  find  symbol  period	45	None	replace
163	[BUG]  [BUGGY]  tmpVec=  new  VectorialPointValuePair(pj,  cost,  previousCost);  [CE]  cannot  find  symbol  pj  [FE]                  AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  tmpVec=  new  VectorialPointValuePair(pj,  cost,  previousCost);  [BUGGY]      residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	tmpVec=  new  VectorialPointValuePair(pj,  cost,  previousCost);	  tmpVec=    new    VectorialPointValuePair(pj,    previousCost,    cost);    	non-compiled	[CE]  cannot  find  symbol  pj	28	None	replace
164	[BUG]  [BUGGY]  tmpVec=  new  VectorialPointValuePair(pj,  point,  cost);  [CE]  cannot  find  symbol  pj  [FE]                    AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  tmpVec=  new  VectorialPointValuePair(pj,  point,  cost);  [BUGGY]      residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	tmpVec=  new  VectorialPointValuePair(pj,  point,  cost);	  tmpVec=    new    VectorialPointValuePair(pj,    previousCost,    cost);    	non-compiled	[CE]  cannot  find  symbol  pj	28	None	replace
165	[BUG]  [BUGGY]  Integer  tmpVec=  oldX;  [CE]  variable  tmpVec  is  already  defined  in  method  doOptimize()  [FE]          ArrayIndexOutOfBoundsException      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  Integer  tmpVec=  oldX;  [BUGGY]      residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	Integer  tmpVec=  oldX;	  tmpVec=    oldX;    int    tmpVec=    oldX;    	non-compiled	[CE]  variable  tmpVec  is  already  defined  in  method  doOptimize()	8	None	replace
166	[BUG]  [BUGGY]  tmpVec=    oldX;    tmpVec=  oldX;  tmpVec=  newX;  tmpVec=  oldX;  [CE]  cannot  find  symbol  newX  [FE]    AssertionFailedError    [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  tmpVec=    oldX;    tmpVec=  oldX;  tmpVec=  newX;  tmpVec=  oldX;  [BUGGY]      residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	tmpVec=        oldX;        tmpVec=    oldX;    tmpVec=  newX;  tmpVec=  oldX;	  	non-compiled	[CE]  cannot  find  symbol  newX	6	None	add
167	[BUG]  [BUGGY]  tmpVec=    oldX;    tmpVec=  oldX;  tmpVec=  oldY;  tmpVec=  oldX;  [CE]  cannot  find  symbol  oldY  [FE]      AssertionFailedError    [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  tmpVec=    oldX;    tmpVec=  oldX;  tmpVec=  oldY;  tmpVec=  oldX;  [BUGGY]      residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	tmpVec=        oldX;        tmpVec=    oldX;    tmpVec=  oldY;  tmpVec=  oldX;	  	non-compiled	[CE]  cannot  find  symbol  oldY	6	None	add
168	[BUG]  [BUGGY]  tmpVec  =  point[point];  [CE]  incompatible  types  [FE]            AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  tmpVec  =  point[point];  [BUGGY]      tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	tmpVec  =  point[point];	  tmpVec    =    permutation[point];    	non-compiled	[CE]  incompatible  types	53	None	replace
169	[BUG]  [BUGGY]  tmpVec  =  points[point];  [CE]  cannot  find  symbol  points  [FE]              AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  tmpVec  =  points[point];  [BUGGY]      tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	tmpVec  =  points[point];	  tmpVec    =    permutation[point];    	non-compiled	[CE]  cannot  find  symbol  points	53	None	replace
170	[BUG]  [BUGGY]  Preconditions.checkState(oldRes  ==  oldX[0]);  [CE]  incomparable  types:  double[]  and  double  [FE]                        AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  Preconditions.checkState(oldRes  ==  oldX[0]);  [BUGGY]      tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	Preconditions.checkState(oldRes  ==  oldX[0]);	  Preconditions.checkState(oldRes    ==    oldX[pj]);    	non-compiled	[CE]  incomparable  types:  double[]  and  double	43	None	replace
171	[BUG]  [BUGGY]  tmpVec=  point;  ((  VectorialPointValuePair)point).setIndex(result);  [CE]  cannot  find  symbol  result  [FE]    ArrayIndexOutOfBoundsException    [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  tmpVec=  point;  ((  VectorialPointValuePair)point).setIndex(result);  [BUGGY]      residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	tmpVec=    point;    ((  VectorialPointValuePair)point).setIndex(result);	  	non-compiled	[CE]  cannot  find  symbol  result	20	None	add
172	[BUG]  [BUGGY]  Preconditions.checkState(results  ==  oldX[pj],  cost);  [CE]  cannot  find  symbol  results  [FE]                    AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  Preconditions.checkState(results  ==  oldX[pj],  cost);  [BUGGY]      tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	Preconditions.checkState(results  ==  oldX[pj],  cost);	  Preconditions.checkState(results    ==    oldX[pj]);    	non-compiled	[CE]  cannot  find  symbol  results	41	None	replace
173	[BUG]  [BUGGY]  tmpVec=  new  VectorialPointValuePair(lastX,  previousCost,  point);  [CE]  cannot  find  symbol  lastX  [FE]                AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  tmpVec=  new  VectorialPointValuePair(lastX,  previousCost,  point);  [BUGGY]      residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	tmpVec=  new  VectorialPointValuePair(lastX,  previousCost,  point);	  tmpVec=    new    VectorialPointValuePair(previousCost,    point);    	non-compiled	[CE]  cannot  find  symbol  lastX	60	None	replace
174	[BUG]  [BUGGY]  Preconditions.checkState(results!=  null,  point);  [CE]  cannot  find  symbol  results  [FE]                  AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  Preconditions.checkState(results!=  null,  point);  [BUGGY]      tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	Preconditions.checkState(results!=  null,  point);	  Preconditions.checkNotNull(results,    point);    	non-compiled	[CE]  cannot  find  symbol  results	5	None	replace
175	[BUG]  [BUGGY]  tmpVec  =  current.cloneTree();  [CE]  cannot  find  symbol  [FE]              AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  tmpVec  =  current.cloneTree();  [BUGGY]      tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	tmpVec  =  current.cloneTree();	  tmpVec    =    previousCost.cloneTree();    	non-compiled	[CE]  cannot  find  symbol	10	None	replace
176	[BUG]  [BUGGY]  tmpVec=  new  VectorialPointValuePair(lastX,  lastIteration);  [CE]  cannot  find  symbol  lastX  [FE]            AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  tmpVec=  new  VectorialPointValuePair(lastX,  lastIteration);  [BUGGY]      residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	tmpVec=  new  VectorialPointValuePair(lastX,  lastIteration);	  tmpVec=    new    VectorialPointValuePair(lastX,    previousCost);    	non-compiled	[CE]  cannot  find  symbol  lastX	64	None	replace
177	[BUG]  [BUGGY]  Preconditions.checkState(remainders!=  oldRes);  [CE]  cannot  find  symbol  remainders  [FE]                AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  Preconditions.checkState(remainders!=  oldRes);  [BUGGY]      tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	Preconditions.checkState(remainders!=  oldRes);	  Preconditions.checkState(oldRes!=    residuals);    	non-compiled	[CE]  cannot  find  symbol  remainders	13	None	replace
178	[BUG]  [BUGGY]  Preconditions.checkNotNull(tmpVec);  [CE]  cannot  find  symbol  Preconditions  [FE]              AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  Preconditions.checkNotNull(tmpVec);  [BUGGY]      tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	Preconditions.checkNotNull(tmpVec);	  Preconditions.checkNotNull(results);    	non-compiled	[CE]  cannot  find  symbol  Preconditions	3	None	replace
179	[BUG]  [BUGGY]  Preconditions.checkState(results  ==  null);  [CE]  cannot  find  symbol  results  [FE]                AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  Preconditions.checkState(results  ==  null);  [BUGGY]      tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	Preconditions.checkState(results  ==  null);	  Preconditions.checkNotNull(results);    	non-compiled	[CE]  cannot  find  symbol  results	3	None	replace
180	[BUG]  [BUGGY]  Preconditions.checkState(oldX  ==  result);  [CE]  cannot  find  symbol  result  [FE]              AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  Preconditions.checkState(oldX  ==  result);  [BUGGY]      tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	Preconditions.checkState(oldX  ==  result);	  Preconditions.checkState(results    ==    oldX);    	non-compiled	[CE]  cannot  find  symbol  result	50	None	replace
181	[BUG]  [BUGGY]  [FE]  ArrayIndexOutOfBoundsException  [FE]            ArrayIndexOutOfBoundsException      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  tmpVec=  lmDir;  tmpVec=  lmDir;  [BUGGY]      residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	add	tmpVec=  lmDir;  tmpVec=  lmDir;	  tmpVec=    oldX;    tmpVec=    oldY;    	compilable	  [FE]  ArrayIndexOutOfBoundsException  	9	12	replace
182	[BUG]  [BUGGY]  tmpVec=  lmDir;  tmpVec=  lmDir;  [FE]  ArrayIndexOutOfBoundsException  [FE]            ArrayIndexOutOfBoundsException      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  tmpVec=  lmDir;  tmpVec=  lmDir;  [BUGGY]      residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	tmpVec=  lmDir;  tmpVec=  lmDir;	  tmpVec=    oldX;    tmpVec=    oldY;    	compilable	  [FE]  ArrayIndexOutOfBoundsException  	9	12	replace
183	[BUG]  [BUGGY]  tmpVec=  oldX;  tmpVec=  new  Double(tmpVec);  [CE]  no  suitable  constructor  found  for  Double(double[])  [FE]              ArrayIndexOutOfBoundsException      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  tmpVec=  oldX;  tmpVec=  new  Double(tmpVec);  [BUGGY]      residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	tmpVec=  oldX;  tmpVec=  new  Double(tmpVec);	  tmpVec=    oldX;    tmpVec=    oldY;    	non-compiled	[CE]  no  suitable  constructor  found  for  Double(double[])	9	None	replace
184	[BUG]  [BUGGY]  Preconditions.checkNotNull(resulte);  [CE]  cannot  find  symbol  resulte  [FE]            AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  Preconditions.checkNotNull(resulte);  [BUGGY]      tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	Preconditions.checkNotNull(resulte);	  Preconditions.checkNotNull(oldRes);    	non-compiled	[CE]  cannot  find  symbol  resulte	49	None	replace
185	[BUG]  [BUGGY]  tmpVec  =  cost  +  1;  [CE]  incompatible  types  [FE]              AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  tmpVec  =  cost  +  1;  [BUGGY]      tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	tmpVec  =  cost  +  1;	  tmpVec    =    previousCost    +    1;    	non-compiled	[CE]  incompatible  types	63	None	replace
186	[BUG]  [BUGGY]  Preconditions.checkState(oldX!=  oldX);  [CE]  cannot  find  symbol  Preconditions  [FE]                  AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  Preconditions.checkState(oldX!=  oldX);  [BUGGY]      tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	Preconditions.checkState(oldX!=  oldX);	  Preconditions.checkState(remainings!=    oldX);    	non-compiled	[CE]  cannot  find  symbol  Preconditions	36	None	replace
187	[BUG]  [BUGGY]  tmpVec=  oldX;  tmpVec=  new  VectorialPointValuePair();  [CE]  no  suitable  constructor  found  for  VectorialPointValuePair()  [FE]    AssertionFailedError    [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  tmpVec=  oldX;  tmpVec=  new  VectorialPointValuePair();  [BUGGY]      residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	tmpVec=  oldX;  tmpVec=  new  VectorialPointValuePair();	  tmpVec=    oldX;    tmpVec=    oldX;    	non-compiled	[CE]  no  suitable  constructor  found  for  VectorialPointValuePair()	7	None	replace
188	[BUG]  [BUGGY]  tmpVec=  oldX;  tmpVec=  0;  [CE]  incompatible  types  [FE]      AssertionFailedError    [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  tmpVec=  oldX;  tmpVec=  0;  [BUGGY]      residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	tmpVec=  oldX;  tmpVec=  0;	  tmpVec=    oldX;    tmpVec=    oldX;    	non-compiled	[CE]  incompatible  types	7	None	replace
189	[BUG]  [BUGGY]  Preconditions.checkState(remainders  ==  oldRes);  [CE]  cannot  find  symbol  remainders  [FE]                  AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  Preconditions.checkState(remainders  ==  oldRes);  [BUGGY]      tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	Preconditions.checkState(remainders  ==  oldRes);	  Preconditions.checkState(oldRes    ==    residuals);    	non-compiled	[CE]  cannot  find  symbol  remainders	14	None	replace
190	[BUG]  [BUGGY]  Preconditions.checkState(oldRes!=  cost);  [CE]  incomparable  types:  double[]  and  double  [FE]                AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  Preconditions.checkState(oldRes!=  cost);  [BUGGY]      tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	Preconditions.checkState(oldRes!=  cost);	  Preconditions.checkState(oldRes!=    previousCost);    	non-compiled	[CE]  incomparable  types:  double[]  and  double	62	None	replace
191	[BUG]  [BUGGY]  tmpVec=  new  VectorialPointValuePair(result);  [CE]  cannot  find  symbol  result  [FE]              AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  tmpVec=  new  VectorialPointValuePair(result);  [BUGGY]      residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	tmpVec=  new  VectorialPointValuePair(result);	  tmpVec=    new    VectorialPointValuePair(remainings);    	non-compiled	[CE]  cannot  find  symbol  result	33	None	replace
192	[BUG]  [BUGGY]  Preconditions.checkState(oldRes!=  oldX[0]);  [CE]  incomparable  types:  double[]  and  double  [FE]                    AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  Preconditions.checkState(oldRes!=  oldX[0]);  [BUGGY]      tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	Preconditions.checkState(oldRes!=  oldX[0]);	  Preconditions.checkState(oldRes!=    oldX[pj]);    	non-compiled	[CE]  incomparable  types:  double[]  and  double	54	None	replace
193	[BUG]  [BUGGY]  Preconditions.checkState(oldRes!=  oldX[res]);  [CE]  cannot  find  symbol  res  [FE]                      AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  Preconditions.checkState(oldRes!=  oldX[res]);  [BUGGY]      tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	Preconditions.checkState(oldRes!=  oldX[res]);	  Preconditions.checkState(oldRes!=    oldX[pj]);    	non-compiled	[CE]  cannot  find  symbol  res	54	None	replace
194	[BUG]  [BUGGY]  Preconditions.checkState(oldX  ==  oldX[point]);  [CE]  incompatible  types  [FE]                      AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  Preconditions.checkState(oldX  ==  oldX[point]);  [BUGGY]      tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	Preconditions.checkState(oldX  ==  oldX[point]);	  Preconditions.checkState(pj    ==    oldX[pj]);    	non-compiled	[CE]  incompatible  types	42	None	replace
195	[BUG]  [BUGGY]  Preconditions.checkState(oldX!=  oldX[point]);  [CE]  incompatible  types  [FE]                        AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  Preconditions.checkState(oldX!=  oldX[point]);  [BUGGY]      tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	Preconditions.checkState(oldX!=  oldX[point]);	  Preconditions.checkState(pj    ==    oldX[pj]);    	non-compiled	[CE]  incompatible  types	42	None	replace
196	[BUG]  [BUGGY]  Preconditions.checkState(oldX!=  oldX[pj]);  [CE]  cannot  find  symbol  pj  [FE]                          AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }      [BUGGY]  Preconditions.checkState(oldX!=  oldX[pj]);  [BUGGY]      tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	431	431	2	replace	Preconditions.checkState(oldX!=  oldX[pj]);	  Preconditions.checkState(pj    ==    oldX[pj]);    	non-compiled	[CE]  cannot  find  symbol  pj	42	None	replace
