bugid	buggy	buggy_class	suspiciousness	buggy_line	endbuggycode	original_failing_test_number	action	patch	original_buggy	execution_result	diagnosis	previous_bug_id	new_failing_test_number	this_action
1	[BUG]  [BUGGY]    double  parl  =  0;  [CE]  variable  parl  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]    AssertionFailedError  [CONTEXT]  double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;  [BUGGY]    double  parl  =  0;  [BUGGY]  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	    double  parl  =  0;		non-compiled	[CE]  variable  parl  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	44	None	add
2	[BUG]  [BUGGY]    double  parl  =  0;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  diag[j]  =  work1[j]  /  dxNorm;  }  [CE]  ']'  expected  [FE]      AssertionFailedError  [CONTEXT]  double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;  [BUGGY]    double  parl  =  0;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  diag[j]  =  work1[j]  /  dxNorm;  }  [BUGGY]  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	    double  parl  =  0;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  diag[j]  =  work1[j]  /  dxNorm;  }		non-compiled	[CE]  ']'  expected	44	None	add
3	[BUG]  [BUGGY]    double  parl  =  0;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  diag[j]  =  work1[j]  *  Math.PI  /  dxNorm;  }  [CE]  ']'  expected  [FE]        AssertionFailedError  [CONTEXT]  double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;  [BUGGY]    double  parl  =  0;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  diag[j]  =  work1[j]  *  Math.PI  /  dxNorm;  }  [BUGGY]  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	    double  parl  =  0;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  diag[j]  =  work1[j]  *  Math.PI  /  dxNorm;  }		non-compiled	[CE]  ']'  expected	44	None	add
4	[BUG]  [BUGGY]    double  parl  =  0;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  diag[j]  =  work1[j]  /  dxNorm;  [CE]  ']'  expected  [FE]          AssertionFailedError  [CONTEXT]  double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;  [BUGGY]    double  parl  =  0;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  diag[j]  =  work1[j]  /  dxNorm;  [BUGGY]  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	    double  parl  =  0;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  diag[j]  =  work1[j]  /  dxNorm;		non-compiled	[CE]  ']'  expected	44	None	add
5	[BUG]  [BUGGY]    double  parl  =  0;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  diag[j]  =  work1[j]  *  dxNorm  /  dxNorm;  }  [CE]  ']'  expected  [FE]            AssertionFailedError  [CONTEXT]  double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;  [BUGGY]    double  parl  =  0;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  diag[j]  =  work1[j]  *  dxNorm  /  dxNorm;  }  [BUGGY]  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	    double  parl  =  0;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  diag[j]  =  work1[j]  *  dxNorm  /  dxNorm;  }		non-compiled	[CE]  ']'  expected	44	None	add
6	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError  [CONTEXT]  double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;  [BUGGY]  double  parl  =  1;  [BUGGY]  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	add	double  parl  =  1;	double  parl  =  0;  	compilable	  [FE]  AssertionFailedError  	43	2	replace
7	[BUG]  [BUGGY]  double  parl  =  1;  [FE]  AssertionFailedError  [FE]    AssertionFailedError  [CONTEXT]  double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;  [BUGGY]  double  parl  =  1;  [BUGGY]  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  1;	double  parl  =  0;  	compilable	  [FE]  AssertionFailedError  	43	2	replace
8	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError  [CONTEXT]  double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;  [BUGGY]  double  parl  =  0.0;  [BUGGY]  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	add	double  parl  =  0.0;	double  parl  =  0;  	compilable	  [FE]  AssertionFailedError  	43	2	replace
9	[BUG]  [BUGGY]  double  parl  =  0.0;  [FE]  AssertionFailedError  [FE]      AssertionFailedError  [CONTEXT]  double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;  [BUGGY]  double  parl  =  0.0;  [BUGGY]  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  0.0;	double  parl  =  0;  	compilable	  [FE]  AssertionFailedError  	43	2	replace
10	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError  [CONTEXT]  double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;  [BUGGY]  double  parl  =  1.0;  [BUGGY]  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	add	double  parl  =  1.0;	double  parl  =  0;  	compilable	  [FE]  AssertionFailedError  	43	2	replace
11	[BUG]  [BUGGY]  double  parl  =  1.0;  [FE]  AssertionFailedError  [FE]        AssertionFailedError  [CONTEXT]  double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;  [BUGGY]  double  parl  =  1.0;  [BUGGY]  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  1.0;	double  parl  =  0;  	compilable	  [FE]  AssertionFailedError  	43	2	replace
12	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError  [CONTEXT]  double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;  [BUGGY]    double  solvedCols  =  0;  [BUGGY]  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	add	    double  solvedCols  =  0;		compilable	  [FE]  AssertionFailedError  	44	13	add
13	[BUG]  [BUGGY]    double  solvedCols  =  0;  [FE]  AssertionFailedError  [FE]    AssertionFailedError  [CONTEXT]  double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;  [BUGGY]    double  solvedCols  =  0;  [BUGGY]  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	    double  solvedCols  =  0;		compilable	  [FE]  AssertionFailedError  	44	13	add
14	[BUG]  [BUGGY]    double  sPar  =  Math.abs(dxNorm  -  lmPar);  [CE]  variable  sPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]      AssertionFailedError  [CONTEXT]  double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;  [BUGGY]    double  sPar  =  Math.abs(dxNorm  -  lmPar);  [BUGGY]  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	    double  sPar  =  Math.abs(dxNorm  -  lmPar);		non-compiled	[CE]  variable  sPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	44	None	add
15	[BUG]  [BUGGY]    double  sPar  =  Math.abs(dxNorm  -  delta);  [CE]  variable  sPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]        AssertionFailedError  [CONTEXT]  double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;  [BUGGY]    double  sPar  =  Math.abs(dxNorm  -  delta);  [BUGGY]  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	    double  sPar  =  Math.abs(dxNorm  -  delta);		non-compiled	[CE]  variable  sPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	44	None	add
16	[BUG]  [BUGGY]    double  sPar  =  Math.abs(lmPar);  [CE]  variable  sPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]          AssertionFailedError  [CONTEXT]  double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;  [BUGGY]    double  sPar  =  Math.abs(lmPar);  [BUGGY]  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	    double  sPar  =  Math.abs(lmPar);		non-compiled	[CE]  variable  sPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	44	None	add
17	[BUG]  [BUGGY]    double  sPar  =  0;  [CE]  variable  sPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]            AssertionFailedError  [CONTEXT]  double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;  [BUGGY]    double  sPar  =  0;  [BUGGY]  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	    double  sPar  =  0;		non-compiled	[CE]  variable  sPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	44	None	add
18	[BUG]  [BUGGY]    double  sPar  =  Math.abs(dxNorm  -  fp);  [CE]  variable  sPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]    AssertionFailedError  [CONTEXT]  double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;  [BUGGY]    double  sPar  =  Math.abs(dxNorm  -  fp);  [BUGGY]  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	    double  sPar  =  Math.abs(dxNorm  -  fp);		non-compiled	[CE]  variable  sPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	44	None	add
19	[BUG]  [BUGGY]    double  sPar  =  Math.abs(dxNorm  *  Math.abs(lmPar));  [CE]  variable  sPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]      AssertionFailedError  [CONTEXT]  double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;  [BUGGY]    double  sPar  =  Math.abs(dxNorm  *  Math.abs(lmPar));  [BUGGY]  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	    double  sPar  =  Math.abs(dxNorm  *  Math.abs(lmPar));		non-compiled	[CE]  variable  sPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	44	None	add
20	[BUG]  [BUGGY]    double  sPar  =  Math.abs(dxNorm  *  Math.abs(fp));  [CE]  variable  sPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]        AssertionFailedError  [CONTEXT]  double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;  [BUGGY]    double  sPar  =  Math.abs(dxNorm  *  Math.abs(fp));  [BUGGY]  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	    double  sPar  =  Math.abs(dxNorm  *  Math.abs(fp));		non-compiled	[CE]  variable  sPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	44	None	add
