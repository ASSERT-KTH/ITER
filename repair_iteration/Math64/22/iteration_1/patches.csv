bugid	buggy	buggy_class	suspiciousness	buggy_line	endbuggycode	original_failing_test_number	action	patch	original_buggy	execution_result	diagnosis	previous_bug_id	new_failing_test_number	this_action
1	[BUG]  [BUGGY]  double  sPar  =  Math.abs(lmPar  *  dxNorm);  [CE]  cannot  find  symbol  parl  [FE]          AssertionFailedError    [CONTEXT]    double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;    [BUGGY]  double  sPar  =  Math.abs(lmPar  *  dxNorm);  [BUGGY]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  sPar  =  Math.abs(lmPar  *  dxNorm);	      double    sPar    =    Math.abs(dxNorm    *    Math.abs(lmPar));    	non-compiled	[CE]  cannot  find  symbol  parl	19	None	replace
2	[BUG]  [BUGGY]  double  sPar  =  Math.abs(fp  *  Math.abs(lmPar));  [CE]  cannot  find  symbol  parl  [FE]            AssertionFailedError    [CONTEXT]    double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;    [BUGGY]  double  sPar  =  Math.abs(fp  *  Math.abs(lmPar));  [BUGGY]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  sPar  =  Math.abs(fp  *  Math.abs(lmPar));	      double    sPar    =    Math.abs(dxNorm    *    Math.abs(lmPar));    	non-compiled	[CE]  cannot  find  symbol  parl	19	None	replace
3	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]              AssertionFailedError    [CONTEXT]    double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;    [BUGGY]  double  parl  =  Math.abs(dxNorm  *  Math.abs(fp));  [BUGGY]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	add	double  parl  =  Math.abs(dxNorm  *  Math.abs(fp));	      double    sPar    =    Math.abs(dxNorm    *    Math.abs(lmPar));    	compilable	  [FE]  AssertionFailedError  	19	4	replace
4	[BUG]  [BUGGY]  double  parl  =  Math.abs(dxNorm  *  Math.abs(fp));  [FE]  AssertionFailedError  [FE]              AssertionFailedError    [CONTEXT]    double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;    [BUGGY]  double  parl  =  Math.abs(dxNorm  *  Math.abs(fp));  [BUGGY]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  Math.abs(dxNorm  *  Math.abs(fp));	      double    sPar    =    Math.abs(dxNorm    *    Math.abs(lmPar));    	compilable	  [FE]  AssertionFailedError  	19	4	replace
5	[BUG]  [BUGGY]  double  parl  =  1;  double  parl  =  1;  [CE]  variable  parl  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]    AssertionFailedError    [CONTEXT]    double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;    [BUGGY]  double  parl  =  1;  double  parl  =  1;  [BUGGY]    if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double    parl    =    1;    double  parl  =  1;	  	non-compiled	[CE]  variable  parl  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	6	None	add
6	[BUG]  [BUGGY]  double  parl  =  1;  Double  parl  =  1;  [CE]  variable  parl  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]      AssertionFailedError    [CONTEXT]    double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;    [BUGGY]  double  parl  =  1;  Double  parl  =  1;  [BUGGY]    if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double    parl    =    1;    Double  parl  =  1;	  	non-compiled	[CE]  variable  parl  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	6	None	add
7	[BUG]  [BUGGY]  double  parl  =  1;  int  parl  =  1;  [CE]  variable  parl  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]        AssertionFailedError    [CONTEXT]    double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;    [BUGGY]  double  parl  =  1;  int  parl  =  1;  [BUGGY]    if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double    parl    =    1;    int  parl  =  1;	  	non-compiled	[CE]  variable  parl  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	6	None	add
8	[BUG]  [BUGGY]  double  parl  =  1;  double  pl  =  1;  [CE]  variable  parl  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]          AssertionFailedError    [CONTEXT]    double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;    [BUGGY]  double  parl  =  1;  double  pl  =  1;  [BUGGY]    if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double    parl    =    1;    double  pl  =  1;	  	non-compiled	[CE]  variable  parl  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	6	None	add
9	[BUG]  [BUGGY]  double  parl  =  1;  Math  parl  =  1;  [CE]  variable  parl  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]            AssertionFailedError    [CONTEXT]    double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;    [BUGGY]  double  parl  =  1;  Math  parl  =  1;  [BUGGY]    if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double    parl    =    1;    Math  parl  =  1;	  	non-compiled	[CE]  variable  parl  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	6	None	add
10	[BUG]  [BUGGY]  double  sPar  =  Math.abs(lmPar  -  dxNorm);  [CE]  cannot  find  symbol  parl  [FE]          AssertionFailedError    [CONTEXT]    double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;    [BUGGY]  double  sPar  =  Math.abs(lmPar  -  dxNorm);  [BUGGY]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  sPar  =  Math.abs(lmPar  -  dxNorm);	      double    sPar    =    Math.abs(dxNorm    -    lmPar);    	non-compiled	[CE]  cannot  find  symbol  parl	14	None	replace
11	[BUG]  [BUGGY]  double  sPar  =  Math.abs(lmPar  dxNorm  -  dxNorm);  [CE]  ')'  expected  [FE]            AssertionFailedError    [CONTEXT]    double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;    [BUGGY]  double  sPar  =  Math.abs(lmPar  dxNorm  -  dxNorm);  [BUGGY]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  sPar  =  Math.abs(lmPar  dxNorm  -  dxNorm);	      double    sPar    =    Math.abs(dxNorm    -    lmPar);    	non-compiled	[CE]  ')'  expected	14	None	replace
12	[BUG]  [BUGGY]  double  sPar  =  Math.abs(fp  -  lmPar);  [CE]  cannot  find  symbol  parl  [FE]              AssertionFailedError    [CONTEXT]    double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;    [BUGGY]  double  sPar  =  Math.abs(fp  -  lmPar);  [BUGGY]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  sPar  =  Math.abs(fp  -  lmPar);	      double    sPar    =    Math.abs(dxNorm    -    lmPar);    	non-compiled	[CE]  cannot  find  symbol  parl	14	None	replace
13	[BUG]  [BUGGY]  double  parl  =  0;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  diag[j]  =  work1[j]  *  dxNorm  /  delta;  }  [CE]  ']'  expected  [FE]                AssertionFailedError    [CONTEXT]    double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;    [BUGGY]  double  parl  =  0;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  diag[j]  =  work1[j]  *  dxNorm  /  delta;  }  [BUGGY]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  0;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  diag[j]  =  work1[j]  *  dxNorm  /  delta;  }	      double    parl    =    0;    for(int    j    =    0;    j    <    solvedCols;    ++j)    {    int    diag[j]    =    work1[j]    *    dxNorm    /    dxNorm;    }    	non-compiled	[CE]  ']'  expected	5	None	replace
14	[BUG]  [BUGGY]  double  parl  =  0.0;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  diag[j]  =  work1[j]  *  dxNorm  /  dxNorm;  }  [CE]  ']'  expected  [FE]                  AssertionFailedError    [CONTEXT]    double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;    [BUGGY]  double  parl  =  0.0;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  diag[j]  =  work1[j]  *  dxNorm  /  dxNorm;  }  [BUGGY]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  0.0;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  diag[j]  =  work1[j]  *  dxNorm  /  dxNorm;  }	      double    parl    =    0;    for(int    j    =    0;    j    <    solvedCols;    ++j)    {    int    diag[j]    =    work1[j]    *    dxNorm    /    dxNorm;    }    	non-compiled	[CE]  ']'  expected	5	None	replace
15	[BUG]  [BUGGY]  double  parl  =  0;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  diag[j]  =  work2[j]  *  dxNorm  /  dxNorm;  }  [CE]  ']'  expected  [FE]                    AssertionFailedError    [CONTEXT]    double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;    [BUGGY]  double  parl  =  0;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  diag[j]  =  work2[j]  *  dxNorm  /  dxNorm;  }  [BUGGY]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  0;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  diag[j]  =  work2[j]  *  dxNorm  /  dxNorm;  }	      double    parl    =    0;    for(int    j    =    0;    j    <    solvedCols;    ++j)    {    int    diag[j]    =    work1[j]    *    dxNorm    /    dxNorm;    }    	non-compiled	[CE]  ']'  expected	5	None	replace
16	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;    [BUGGY]  double  parl  =  0.5;  [BUGGY]    if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	add	double  parl  =  0.5;	  double    parl    =    0.0;    	compilable	  [FE]  AssertionFailedError  	9	2	replace
17	[BUG]  [BUGGY]  double  parl  =  0.5;  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;    [BUGGY]  double  parl  =  0.5;  [BUGGY]    if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  0.5;	  double    parl    =    0.0;    	compilable	  [FE]  AssertionFailedError  	9	2	replace
18	[BUG]  [BUGGY]  double  parl  =  0.0;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  diag[j]  =  work1[j]  /  dxNorm;  }  [CE]  ']'  expected  [FE]          AssertionFailedError    [CONTEXT]    double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;    [BUGGY]  double  parl  =  0.0;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  diag[j]  =  work1[j]  /  dxNorm;  }  [BUGGY]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  0.0;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  diag[j]  =  work1[j]  /  dxNorm;  }	      double    parl    =    0;    for(int    j    =    0;    j    <    solvedCols;    ++j)    {    int    diag[j]    =    work1[j]    /    dxNorm;    }    	non-compiled	[CE]  ']'  expected	2	None	replace
19	[BUG]  [BUGGY]  double  parl  =  0;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  diag[j]  =  work1[j]  /  delta;  }  [CE]  ']'  expected  [FE]            AssertionFailedError    [CONTEXT]    double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;    [BUGGY]  double  parl  =  0;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  diag[j]  =  work1[j]  /  delta;  }  [BUGGY]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  0;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  diag[j]  =  work1[j]  /  delta;  }	      double    parl    =    0;    for(int    j    =    0;    j    <    solvedCols;    ++j)    {    int    diag[j]    =    work1[j]    /    dxNorm;    }    	non-compiled	[CE]  ']'  expected	2	None	replace
20	[BUG]  [BUGGY]  double  parl  =  0;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  diag[j]  =  work2[j]  /  dxNorm;  }  [CE]  ']'  expected  [FE]              AssertionFailedError    [CONTEXT]    double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;    [BUGGY]  double  parl  =  0;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  diag[j]  =  work2[j]  /  dxNorm;  }  [BUGGY]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  0;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  diag[j]  =  work2[j]  /  dxNorm;  }	      double    parl    =    0;    for(int    j    =    0;    j    <    solvedCols;    ++j)    {    int    diag[j]    =    work1[j]    /    dxNorm;    }    	non-compiled	[CE]  ']'  expected	2	None	replace
21	[BUG]  [BUGGY]  double  solvedCols  =  1;  [CE]  cannot  find  symbol  parl  [FE]    AssertionFailedError    [CONTEXT]    double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;    [BUGGY]  double  solvedCols  =  1;  [BUGGY]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  solvedCols  =  1;	      double    solvedCols    =    0;    	non-compiled	[CE]  cannot  find  symbol  parl	13	None	replace
22	[BUG]  [BUGGY]  double  solvedCols  =  0.0;  [CE]  cannot  find  symbol  parl  [FE]      AssertionFailedError    [CONTEXT]    double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;    [BUGGY]  double  solvedCols  =  0.0;  [BUGGY]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  solvedCols  =  0.0;	      double    solvedCols    =    0;    	non-compiled	[CE]  cannot  find  symbol  parl	13	None	replace
23	[BUG]  [BUGGY]  double  solvedCols  =  1.0;  [CE]  cannot  find  symbol  parl  [FE]        AssertionFailedError    [CONTEXT]    double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;    [BUGGY]  double  solvedCols  =  1.0;  [BUGGY]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  solvedCols  =  1.0;	      double    solvedCols    =    0;    	non-compiled	[CE]  cannot  find  symbol  parl	13	None	replace
24	[BUG]  [BUGGY]  double  parl  =  0.0;  double  parl  =  0.0;  [CE]  variable  parl  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]    AssertionFailedError    [CONTEXT]    double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;    [BUGGY]  double  parl  =  0.0;  double  parl  =  0.0;  [BUGGY]    if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double    parl    =    0.0;    double  parl  =  0.0;	  	non-compiled	[CE]  variable  parl  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	8	None	add
25	[BUG]  [BUGGY]  double  parl  =  0.0;  if(rank  ==  0.0)  {  for(int  i  =  0;  i  <  dxNorm;  ++i)  {  double  parl  =  0.0;  }  [CE]  illegal  start  of  expression  [FE]      AssertionFailedError    [CONTEXT]    double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;    [BUGGY]  double  parl  =  0.0;  if(rank  ==  0.0)  {  for(int  i  =  0;  i  <  dxNorm;  ++i)  {  double  parl  =  0.0;  }  [BUGGY]    if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double    parl    =    0.0;    if(rank  ==  0.0)  {  for(int  i  =  0;  i  <  dxNorm;  ++i)  {  double  parl  =  0.0;  }	  	non-compiled	[CE]  illegal  start  of  expression	8	None	add
26	[BUG]  [BUGGY]  double  parl  =  0.0;  if(rank  ==  0.0)  {  for(int  j  =  0;  j  <  dxNorm;  ++j)  {  sum2  =  0.0;  }  [CE]  illegal  start  of  expression  [FE]        AssertionFailedError    [CONTEXT]    double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;    [BUGGY]  double  parl  =  0.0;  if(rank  ==  0.0)  {  for(int  j  =  0;  j  <  dxNorm;  ++j)  {  sum2  =  0.0;  }  [BUGGY]    if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double    parl    =    0.0;    if(rank  ==  0.0)  {  for(int  j  =  0;  j  <  dxNorm;  ++j)  {  sum2  =  0.0;  }	  	non-compiled	[CE]  illegal  start  of  expression	8	None	add
27	[BUG]  [BUGGY]  double  parl  =  0.0;  Double  parl  =  0.0;  [CE]  variable  parl  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]          AssertionFailedError    [CONTEXT]    double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;    [BUGGY]  double  parl  =  0.0;  Double  parl  =  0.0;  [BUGGY]    if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double    parl    =    0.0;    Double  parl  =  0.0;	  	non-compiled	[CE]  variable  parl  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	8	None	add
28	[BUG]  [BUGGY]  double  parl  =  0.0;  if(rank  ==  0.0)  {  for(int  i  =  0;  i  <  dxNorm;  ++i)  {  sum2  +=  Math.pow(10.0,  dxNorm);  }  [CE]  illegal  start  of  expression  [FE]            AssertionFailedError    [CONTEXT]    double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;    [BUGGY]  double  parl  =  0.0;  if(rank  ==  0.0)  {  for(int  i  =  0;  i  <  dxNorm;  ++i)  {  sum2  +=  Math.pow(10.0,  dxNorm);  }  [BUGGY]    if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double    parl    =    0.0;    if(rank  ==  0.0)  {  for(int  i  =  0;  i  <  dxNorm;  ++i)  {  sum2  +=  Math.pow(10.0,  dxNorm);  }	  	non-compiled	[CE]  illegal  start  of  expression	8	None	add
29	[BUG]  [BUGGY]  double  parl  =  1.0;  double  parl  =  1.0;  [CE]  variable  parl  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]    AssertionFailedError    [CONTEXT]    double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;    [BUGGY]  double  parl  =  1.0;  double  parl  =  1.0;  [BUGGY]    if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double    parl    =    1.0;    double  parl  =  1.0;	  	non-compiled	[CE]  variable  parl  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	10	None	add
30	[BUG]  [BUGGY]  double  parl  =  1.0;  Double  parl  =  1.0;  [CE]  variable  parl  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]      AssertionFailedError    [CONTEXT]    double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;    [BUGGY]  double  parl  =  1.0;  Double  parl  =  1.0;  [BUGGY]    if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double    parl    =    1.0;    Double  parl  =  1.0;	  	non-compiled	[CE]  variable  parl  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	10	None	add
31	[BUG]  [BUGGY]  double  parl  =  1.0;  int  parl  =  1.0;  [CE]  variable  parl  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]        AssertionFailedError    [CONTEXT]    double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;    [BUGGY]  double  parl  =  1.0;  int  parl  =  1.0;  [BUGGY]    if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double    parl    =    1.0;    int  parl  =  1.0;	  	non-compiled	[CE]  variable  parl  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	10	None	add
32	[BUG]  [BUGGY]  double  parl  =  1.0;  dk  =  1.0;  [CE]  cannot  find  symbol  dk  [FE]          AssertionFailedError    [CONTEXT]    double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;    [BUGGY]  double  parl  =  1.0;  dk  =  1.0;  [BUGGY]    if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double    parl    =    1.0;    dk  =  1.0;	  	non-compiled	[CE]  cannot  find  symbol  dk	10	None	add
33	[BUG]  [BUGGY]  double  sPar  =  Math.abs(fp  -  dxNorm);  [CE]  cannot  find  symbol  parl  [FE]        AssertionFailedError    [CONTEXT]    double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;    [BUGGY]  double  sPar  =  Math.abs(fp  -  dxNorm);  [BUGGY]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  sPar  =  Math.abs(fp  -  dxNorm);	      double    sPar    =    Math.abs(dxNorm    -    fp);    	non-compiled	[CE]  cannot  find  symbol  parl	18	None	replace
34	[BUG]  [BUGGY]  double  sPar  =  Math.abs(lmPar  -  fp);  [CE]  cannot  find  symbol  parl  [FE]          AssertionFailedError    [CONTEXT]    double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;    [BUGGY]  double  sPar  =  Math.abs(lmPar  -  fp);  [BUGGY]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  sPar  =  Math.abs(lmPar  -  fp);	      double    sPar    =    Math.abs(dxNorm    -    fp);    	non-compiled	[CE]  cannot  find  symbol  parl	18	None	replace
35	[BUG]  [BUGGY]  double  sPar  =  Math.abs(dxNorm  *  fp);  [CE]  cannot  find  symbol  parl  [FE]            AssertionFailedError    [CONTEXT]    double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;    [BUGGY]  double  sPar  =  Math.abs(dxNorm  *  fp);  [BUGGY]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  sPar  =  Math.abs(dxNorm  *  fp);	      double    sPar    =    Math.abs(dxNorm    -    fp);    	non-compiled	[CE]  cannot  find  symbol  parl	18	None	replace
36	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;    [BUGGY]  double  parl  =  2;  [BUGGY]    if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	add	double  parl  =  2;	  double    parl    =    1;    	compilable	  [FE]  AssertionFailedError  	7	2	replace
37	[BUG]  [BUGGY]  double  parl  =  2;  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;    [BUGGY]  double  parl  =  2;  [BUGGY]    if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  2;	  double    parl    =    1;    	compilable	  [FE]  AssertionFailedError  	7	2	replace
38	[BUG]  [BUGGY]  double  sPar  =  1;  [CE]  cannot  find  symbol  parl  [FE]                AssertionFailedError    [CONTEXT]    double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;    [BUGGY]  double  sPar  =  1;  [BUGGY]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  sPar  =  1;	      double    sPar    =    0;    	non-compiled	[CE]  cannot  find  symbol  parl	17	None	replace
39	[BUG]  [BUGGY]  double  lmPar  =  0;  [CE]  cannot  find  symbol  parl  [FE]                  AssertionFailedError    [CONTEXT]    double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;    [BUGGY]  double  lmPar  =  0;  [BUGGY]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  lmPar  =  0;	      double    sPar    =    0;    	non-compiled	[CE]  cannot  find  symbol  parl	17	None	replace
40	[BUG]  [BUGGY]  double  sPar  =  Math.abs(lmPar  *  Math.abs(fp));  [CE]  cannot  find  symbol  parl  [FE]            AssertionFailedError    [CONTEXT]    double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;    [BUGGY]  double  sPar  =  Math.abs(lmPar  *  Math.abs(fp));  [BUGGY]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  sPar  =  Math.abs(lmPar  *  Math.abs(fp));	      double    sPar    =    Math.abs(dxNorm    *    Math.abs(fp));    	non-compiled	[CE]  cannot  find  symbol  parl	20	None	replace
41	[BUG]  [BUGGY]  double  sPar  =  Math.abs(dxNorm  *  Math.abs(delta));  [CE]  cannot  find  symbol  parl  [FE]              AssertionFailedError    [CONTEXT]    double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;    [BUGGY]  double  sPar  =  Math.abs(dxNorm  *  Math.abs(delta));  [BUGGY]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  sPar  =  Math.abs(dxNorm  *  Math.abs(delta));	      double    sPar    =    Math.abs(dxNorm    *    Math.abs(fp));    	non-compiled	[CE]  cannot  find  symbol  parl	20	None	replace
42	[BUG]  [BUGGY]  double  sPar  =  Math.abs(fp  *  Math.abs(dxNorm));  [CE]  cannot  find  symbol  parl  [FE]                AssertionFailedError    [CONTEXT]    double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;    [BUGGY]  double  sPar  =  Math.abs(fp  *  Math.abs(dxNorm));  [BUGGY]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  sPar  =  Math.abs(fp  *  Math.abs(dxNorm));	      double    sPar    =    Math.abs(dxNorm    *    Math.abs(fp));    	non-compiled	[CE]  cannot  find  symbol  parl	20	None	replace
43	[BUG]  [BUGGY]  double  sPar  =  Math.abs(fp  *  dxNorm);  [CE]  cannot  find  symbol  parl  [FE]                  AssertionFailedError    [CONTEXT]    double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;    [BUGGY]  double  sPar  =  Math.abs(fp  *  dxNorm);  [BUGGY]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  sPar  =  Math.abs(fp  *  dxNorm);	      double    sPar    =    Math.abs(dxNorm    *    Math.abs(fp));    	non-compiled	[CE]  cannot  find  symbol  parl	20	None	replace
44	[BUG]  [BUGGY]  double  sPar  =  Math.abs(fp);  [CE]  cannot  find  symbol  parl  [FE]              AssertionFailedError    [CONTEXT]    double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;    [BUGGY]  double  sPar  =  Math.abs(fp);  [BUGGY]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  sPar  =  Math.abs(fp);	      double    sPar    =    Math.abs(lmPar);    	non-compiled	[CE]  cannot  find  symbol  parl	16	None	replace
45	[BUG]  [BUGGY]  double  sPar  =  Math.abs(lmPar,  sum2);  [CE]  no  suitable  method  found  for  abs(double,double)  [FE]                AssertionFailedError    [CONTEXT]    double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;    [BUGGY]  double  sPar  =  Math.abs(lmPar,  sum2);  [BUGGY]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  sPar  =  Math.abs(lmPar,  sum2);	      double    sPar    =    Math.abs(lmPar);    	non-compiled	[CE]  no  suitable  method  found  for  abs(double,double)	16	None	replace
46	[BUG]  [BUGGY]  double  sPar  =  Math.abs(dxNorm);  [CE]  cannot  find  symbol  parl  [FE]                  AssertionFailedError    [CONTEXT]    double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;    [BUGGY]  double  sPar  =  Math.abs(dxNorm);  [BUGGY]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  sPar  =  Math.abs(dxNorm);	      double    sPar    =    Math.abs(lmPar);    	non-compiled	[CE]  cannot  find  symbol  parl	16	None	replace
47	[BUG]  [BUGGY]  double  sPar  =  Math.abs(sum2);  [CE]  cannot  find  symbol  parl  [FE]                    AssertionFailedError    [CONTEXT]    double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;    [BUGGY]  double  sPar  =  Math.abs(sum2);  [BUGGY]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  sPar  =  Math.abs(sum2);	      double    sPar    =    Math.abs(lmPar);    	non-compiled	[CE]  cannot  find  symbol  parl	16	None	replace
48	[BUG]  [BUGGY]      double  solvedCols  =  0;  double  solvedCols  =  0;  [CE]  variable  solvedCols  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]    AssertionFailedError    [CONTEXT]    double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;    [BUGGY]      double  solvedCols  =  0;  double  solvedCols  =  0;  [BUGGY]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	        double    solvedCols    =    0;    double  solvedCols  =  0;	  	non-compiled	[CE]  variable  solvedCols  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	12	None	add
49	[BUG]  [BUGGY]      double  solvedCols  =  0;  Double  solvedCols  =  0;  [CE]  variable  solvedCols  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]      AssertionFailedError    [CONTEXT]    double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;    [BUGGY]      double  solvedCols  =  0;  Double  solvedCols  =  0;  [BUGGY]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	        double    solvedCols    =    0;    Double  solvedCols  =  0;	  	non-compiled	[CE]  variable  solvedCols  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	12	None	add
50	[BUG]  [BUGGY]      double  solvedCols  =  0;  int  solvedCols  =  0;  [CE]  variable  solvedCols  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]        AssertionFailedError    [CONTEXT]    double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;    [BUGGY]      double  solvedCols  =  0;  int  solvedCols  =  0;  [BUGGY]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	        double    solvedCols    =    0;    int  solvedCols  =  0;	  	non-compiled	[CE]  variable  solvedCols  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	12	None	add
51	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]    double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;    [BUGGY]      double  solvedCols  =  0;  double  solveCols  =  0;  [BUGGY]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	add	        double    solvedCols    =    0;    double  solveCols  =  0;	  	compilable	  [FE]  AssertionFailedError  	12	13	add
52	[BUG]  [BUGGY]      double  solvedCols  =  0;  double  solveCols  =  0;  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]    double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;    [BUGGY]      double  solvedCols  =  0;  double  solveCols  =  0;  [BUGGY]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	        double    solvedCols    =    0;    double  solveCols  =  0;	  	compilable	  [FE]  AssertionFailedError  	12	13	add
53	[BUG]  [BUGGY]  double  parl  =  0;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  diag[j]  =  work2[j]  /  dxNorm;  [CE]  ']'  expected  [FE]              AssertionFailedError    [CONTEXT]    double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;    [BUGGY]  double  parl  =  0;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  diag[j]  =  work2[j]  /  dxNorm;  [BUGGY]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  0;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  diag[j]  =  work2[j]  /  dxNorm;	      double    parl    =    0;    for(int    j    =    0;    j    <    solvedCols;    ++j)    {    int    diag[j]    =    work1[j]    /    dxNorm;    	non-compiled	[CE]  ']'  expected	4	None	replace
54	[BUG]  [BUGGY]  double  parl  =  0;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  diag[j]  =  work1[j]  *  dxNorm;  [CE]  ']'  expected  [FE]                AssertionFailedError    [CONTEXT]    double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;    [BUGGY]  double  parl  =  0;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  diag[j]  =  work1[j]  *  dxNorm;  [BUGGY]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  0;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  diag[j]  =  work1[j]  *  dxNorm;	      double    parl    =    0;    for(int    j    =    0;    j    <    solvedCols;    ++j)    {    int    diag[j]    =    work1[j]    /    dxNorm;    	non-compiled	[CE]  ']'  expected	4	None	replace
55	[BUG]  [BUGGY]  double  sPar  =  Math.abs(lmPar  -  delta);  [CE]  cannot  find  symbol  parl  [FE]            AssertionFailedError    [CONTEXT]    double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;    [BUGGY]  double  sPar  =  Math.abs(lmPar  -  delta);  [BUGGY]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  sPar  =  Math.abs(lmPar  -  delta);	      double    sPar    =    Math.abs(dxNorm    -    delta);    	non-compiled	[CE]  cannot  find  symbol  parl	15	None	replace
56	[BUG]  [BUGGY]  double  sPar  =  Math.abs(delta  -  dxNorm);  [CE]  cannot  find  symbol  parl  [FE]              AssertionFailedError    [CONTEXT]    double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;    [BUGGY]  double  sPar  =  Math.abs(delta  -  dxNorm);  [BUGGY]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  sPar  =  Math.abs(delta  -  dxNorm);	      double    sPar    =    Math.abs(dxNorm    -    delta);    	non-compiled	[CE]  cannot  find  symbol  parl	15	None	replace
57	[BUG]  [BUGGY]  double  parl  =  0.0;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  diag[j]  =  work1[j]  *  Math.PI  /  dxNorm;  }  [CE]  ']'  expected  [FE]            AssertionFailedError    [CONTEXT]    double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;    [BUGGY]  double  parl  =  0.0;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  diag[j]  =  work1[j]  *  Math.PI  /  dxNorm;  }  [BUGGY]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  0.0;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  diag[j]  =  work1[j]  *  Math.PI  /  dxNorm;  }	      double    parl    =    0;    for(int    j    =    0;    j    <    solvedCols;    ++j)    {    int    diag[j]    =    work1[j]    *    Math.PI    /    dxNorm;    }    	non-compiled	[CE]  ']'  expected	3	None	replace
58	[BUG]  [BUGGY]  double  parl  =  0;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  diag[j]  =  work1[j]  *  Math.PI  /  delta;  }  [CE]  ']'  expected  [FE]              AssertionFailedError    [CONTEXT]    double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;    [BUGGY]  double  parl  =  0;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  diag[j]  =  work1[j]  *  Math.PI  /  delta;  }  [BUGGY]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  0;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  diag[j]  =  work1[j]  *  Math.PI  /  delta;  }	      double    parl    =    0;    for(int    j    =    0;    j    <    solvedCols;    ++j)    {    int    diag[j]    =    work1[j]    *    Math.PI    /    dxNorm;    }    	non-compiled	[CE]  ']'  expected	3	None	replace
59	[BUG]  [BUGGY]  double  parl  =  0;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  diag[j]  =  work2[j]  *  Math.PI  /  dxNorm;  }  [CE]  ']'  expected  [FE]                AssertionFailedError    [CONTEXT]    double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;    [BUGGY]  double  parl  =  0;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  diag[j]  =  work2[j]  *  Math.PI  /  dxNorm;  }  [BUGGY]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  0;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  diag[j]  =  work2[j]  *  Math.PI  /  dxNorm;  }	      double    parl    =    0;    for(int    j    =    0;    j    <    solvedCols;    ++j)    {    int    diag[j]    =    work1[j]    *    Math.PI    /    dxNorm;    }    	non-compiled	[CE]  ']'  expected	3	None	replace
60	[BUG]  [BUGGY]  double  solvedCols  =  2;  [CE]  cannot  find  symbol  parl  [FE]    AssertionFailedError    [CONTEXT]    double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;    [BUGGY]  double  solvedCols  =  2;  [BUGGY]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  solvedCols  =  2;	      double    solvedCols    =    0;    	non-compiled	[CE]  cannot  find  symbol  parl	13	None	replace
61	[BUG]  [BUGGY]  double  sPar  =  Math.abs(qy);  [CE]  no  suitable  method  found  for  abs(double[])  [FE]              AssertionFailedError    [CONTEXT]    double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;    [BUGGY]  double  sPar  =  Math.abs(qy);  [BUGGY]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  sPar  =  Math.abs(qy);	      double    sPar    =    Math.abs(lmPar);    	non-compiled	[CE]  no  suitable  method  found  for  abs(double[])	16	None	replace
62	[BUG]  [BUGGY]  double  sPar  =  Math.abs(tmp  *  Math.abs(lmPar));  [CE]  cannot  find  symbol  tmp  [FE]          AssertionFailedError    [CONTEXT]    double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;    [BUGGY]  double  sPar  =  Math.abs(tmp  *  Math.abs(lmPar));  [BUGGY]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  sPar  =  Math.abs(tmp  *  Math.abs(lmPar));	      double    sPar    =    Math.abs(dxNorm    *    Math.abs(lmPar));    	non-compiled	[CE]  cannot  find  symbol  tmp	19	None	replace
63	[BUG]  [BUGGY]  double  sPar  =  Math.abs(delta  -  fp);  [CE]  cannot  find  symbol  parl  [FE]        AssertionFailedError    [CONTEXT]    double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;    [BUGGY]  double  sPar  =  Math.abs(delta  -  fp);  [BUGGY]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  sPar  =  Math.abs(delta  -  fp);	      double    sPar    =    Math.abs(dxNorm    -    fp);    	non-compiled	[CE]  cannot  find  symbol  parl	18	None	replace
64	[BUG]  [BUGGY]  double  parl  =  0;  for(int  j  =  0;  j  <  solveCols;  ++j)  {  int  diag[j]  =  work1[j]  *  dxNorm  /  dxNorm;  }  [CE]  ']'  expected  [FE]                AssertionFailedError    [CONTEXT]    double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;    [BUGGY]  double  parl  =  0;  for(int  j  =  0;  j  <  solveCols;  ++j)  {  int  diag[j]  =  work1[j]  *  dxNorm  /  dxNorm;  }  [BUGGY]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  0;  for(int  j  =  0;  j  <  solveCols;  ++j)  {  int  diag[j]  =  work1[j]  *  dxNorm  /  dxNorm;  }	      double    parl    =    0;    for(int    j    =    0;    j    <    solvedCols;    ++j)    {    int    diag[j]    =    work1[j]    *    dxNorm    /    dxNorm;    }    	non-compiled	[CE]  ']'  expected	5	None	replace
65	[BUG]  [BUGGY]  double  parl  =  0;  for(int  j  =  0;  j  <  resolvedCols;  ++j)  {  int  diag[j]  =  work1[j]  /  dxNorm;  }  [CE]  ']'  expected  [FE]          AssertionFailedError    [CONTEXT]    double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;    [BUGGY]  double  parl  =  0;  for(int  j  =  0;  j  <  resolvedCols;  ++j)  {  int  diag[j]  =  work1[j]  /  dxNorm;  }  [BUGGY]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  0;  for(int  j  =  0;  j  <  resolvedCols;  ++j)  {  int  diag[j]  =  work1[j]  /  dxNorm;  }	      double    parl    =    0;    for(int    j    =    0;    j    <    solvedCols;    ++j)    {    int    diag[j]    =    work1[j]    /    dxNorm;    }    	non-compiled	[CE]  ']'  expected	2	None	replace
66	[BUG]  [BUGGY]  double  sPar  =  Math.abs(dxNorm  -  delta,  sum2);  [CE]  no  suitable  method  found  for  abs(double,double)  [FE]            AssertionFailedError    [CONTEXT]    double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;    [BUGGY]  double  sPar  =  Math.abs(dxNorm  -  delta,  sum2);  [BUGGY]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  sPar  =  Math.abs(dxNorm  -  delta,  sum2);	      double    sPar    =    Math.abs(dxNorm    -    delta);    	non-compiled	[CE]  no  suitable  method  found  for  abs(double,double)	15	None	replace
67	[BUG]  [BUGGY]  double  parl  =  0.0;  if(dxNorm  ==  0)  {  double  parl  =  0.0;  }  else  {  for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diag[j]  /  dxNorm;  }  [CE]  illegal  start  of  expression  [FE]    AssertionFailedError    [CONTEXT]    double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;    [BUGGY]  double  parl  =  0.0;  if(dxNorm  ==  0)  {  double  parl  =  0.0;  }  else  {  for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diag[j]  /  dxNorm;  }  [BUGGY]    if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double    parl    =    0.0;    if(dxNorm  ==  0)  {  double  parl  =  0.0;  }  else  {  for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diag[j]  /  dxNorm;  }	  	non-compiled	[CE]  illegal  start  of  expression	8	None	add
68	[BUG]  [BUGGY]  double  parl  =  0.0;  if(dxNorm  ==  0)  {  double  parl  =  0.0;  }  else  {  for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diag[pj]  /  dxNorm;  }  [CE]  illegal  start  of  expression  [FE]      AssertionFailedError    [CONTEXT]    double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;    [BUGGY]  double  parl  =  0.0;  if(dxNorm  ==  0)  {  double  parl  =  0.0;  }  else  {  for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diag[pj]  /  dxNorm;  }  [BUGGY]    if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double    parl    =    0.0;    if(dxNorm  ==  0)  {  double  parl  =  0.0;  }  else  {  for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diag[pj]  /  dxNorm;  }	  	non-compiled	[CE]  illegal  start  of  expression	8	None	add
69	[BUG]  [BUGGY]  double  parl  =  0.0;  if(dxNorm  ==  0)  {  double  parl  =  0.0;  }  else  {  for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diag[j]  /  delta;  }  [CE]  illegal  start  of  expression  [FE]        AssertionFailedError    [CONTEXT]    double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;    [BUGGY]  double  parl  =  0.0;  if(dxNorm  ==  0)  {  double  parl  =  0.0;  }  else  {  for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diag[j]  /  delta;  }  [BUGGY]    if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double    parl    =    0.0;    if(dxNorm  ==  0)  {  double  parl  =  0.0;  }  else  {  for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diag[j]  /  delta;  }	  	non-compiled	[CE]  illegal  start  of  expression	8	None	add
70	[BUG]  [BUGGY]  double  parl  =  0.0;  if(dxNorm  ==  0)  {  double  parl  =  0.0;  }  else  {  for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diag[j]  /  dxNorm;  return;  }  [CE]  illegal  start  of  expression  [FE]          AssertionFailedError    [CONTEXT]    double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;    [BUGGY]  double  parl  =  0.0;  if(dxNorm  ==  0)  {  double  parl  =  0.0;  }  else  {  for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diag[j]  /  dxNorm;  return;  }  [BUGGY]    if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double    parl    =    0.0;    if(dxNorm  ==  0)  {  double  parl  =  0.0;  }  else  {  for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diag[j]  /  dxNorm;  return;  }	  	non-compiled	[CE]  illegal  start  of  expression	8	None	add
71	[BUG]  [BUGGY]  double  parl  =  0;  for(int  j  =  0;  j  <  resolvedCols;  ++j)  {  int  diag[j]  =  work1[j]  *  Math.PI  /  dxNorm;  }  [CE]  ']'  expected  [FE]            AssertionFailedError    [CONTEXT]    double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;    [BUGGY]  double  parl  =  0;  for(int  j  =  0;  j  <  resolvedCols;  ++j)  {  int  diag[j]  =  work1[j]  *  Math.PI  /  dxNorm;  }  [BUGGY]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  0;  for(int  j  =  0;  j  <  resolvedCols;  ++j)  {  int  diag[j]  =  work1[j]  *  Math.PI  /  dxNorm;  }	      double    parl    =    0;    for(int    j    =    0;    j    <    solvedCols;    ++j)    {    int    diag[j]    =    work1[j]    *    Math.PI    /    dxNorm;    }    	non-compiled	[CE]  ']'  expected	3	None	replace
72	[BUG]  [BUGGY]  double  parl  =  0;  for(int  j  =  0;  j  <  solveCols;  ++j)  {  int  diag[j]  =  work1[j]  *  Math.PI  /  dxNorm;  }  [CE]  ']'  expected  [FE]              AssertionFailedError    [CONTEXT]    double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;    [BUGGY]  double  parl  =  0;  for(int  j  =  0;  j  <  solveCols;  ++j)  {  int  diag[j]  =  work1[j]  *  Math.PI  /  dxNorm;  }  [BUGGY]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  0;  for(int  j  =  0;  j  <  solveCols;  ++j)  {  int  diag[j]  =  work1[j]  *  Math.PI  /  dxNorm;  }	      double    parl    =    0;    for(int    j    =    0;    j    <    solvedCols;    ++j)    {    int    diag[j]    =    work1[j]    *    Math.PI    /    dxNorm;    }    	non-compiled	[CE]  ']'  expected	3	None	replace
73	[BUG]  [BUGGY]  double  sPar  =  Math.abs(lmpar  -  dxNorm);  [CE]  cannot  find  symbol  lmpar  [FE]          AssertionFailedError    [CONTEXT]    double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;    [BUGGY]  double  sPar  =  Math.abs(lmpar  -  dxNorm);  [BUGGY]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  sPar  =  Math.abs(lmpar  -  dxNorm);	      double    sPar    =    Math.abs(dxNorm    -    lmPar);    	non-compiled	[CE]  cannot  find  symbol  lmpar	14	None	replace
74	[BUG]  [BUGGY]  double  sPar  =  0.0;  [CE]  cannot  find  symbol  parl  [FE]                AssertionFailedError    [CONTEXT]    double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;    [BUGGY]  double  sPar  =  0.0;  [BUGGY]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  sPar  =  0.0;	      double    sPar    =    0;    	non-compiled	[CE]  cannot  find  symbol  parl	17	None	replace
75	[BUG]  [BUGGY]  double  sPar  =  0.5;  [CE]  cannot  find  symbol  parl  [FE]                  AssertionFailedError    [CONTEXT]    double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;    [BUGGY]  double  sPar  =  0.5;  [BUGGY]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  sPar  =  0.5;	      double    sPar    =    0;    	non-compiled	[CE]  cannot  find  symbol  parl	17	None	replace
76	[BUG]  [BUGGY]  double  sPar  =  Math.abs(dxNorm  *  Math.abs(fp  -  1));  [CE]  cannot  find  symbol  parl  [FE]            AssertionFailedError    [CONTEXT]    double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;    [BUGGY]  double  sPar  =  Math.abs(dxNorm  *  Math.abs(fp  -  1));  [BUGGY]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  sPar  =  Math.abs(dxNorm  *  Math.abs(fp  -  1));	      double    sPar    =    Math.abs(dxNorm    *    Math.abs(fp));    	non-compiled	[CE]  cannot  find  symbol  parl	20	None	replace
77	[BUG]  [BUGGY]  int  diag[j]  =  work1[j]  /  dxNorm;  [CE]  ']'  expected  [FE]          AssertionFailedError    [CONTEXT]    double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;    [BUGGY]  int  diag[j]  =  work1[j]  /  dxNorm;  [BUGGY]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	int  diag[j]  =  work1[j]  /  dxNorm;	      double    parl    =    0;    for(int    j    =    0;    j    <    solvedCols;    ++j)    {    int    diag[j]    =    work1[j]    /    dxNorm;    }    	non-compiled	[CE]  ']'  expected	2	None	replace
78	[BUG]  [BUGGY]  double  parl  =  0;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  diag[j]  =  work1[j]  *  dxNorm;  }  [CE]  ']'  expected  [FE]            AssertionFailedError    [CONTEXT]    double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;    [BUGGY]  double  parl  =  0;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  diag[j]  =  work1[j]  *  dxNorm;  }  [BUGGY]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  0;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  diag[j]  =  work1[j]  *  dxNorm;  }	      double    parl    =    0;    for(int    j    =    0;    j    <    solvedCols;    ++j)    {    int    diag[j]    =    work1[j]    /    dxNorm;    }    	non-compiled	[CE]  ']'  expected	2	None	replace
79	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;    [BUGGY]  double  parl  =  10.0;  [BUGGY]    if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	add	double  parl  =  10.0;	  double    parl    =    1.0;    	compilable	  [FE]  AssertionFailedError  	11	2	replace
80	[BUG]  [BUGGY]  double  parl  =  10.0;  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;    [BUGGY]  double  parl  =  10.0;  [BUGGY]    if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  10.0;	  double    parl    =    1.0;    	compilable	  [FE]  AssertionFailedError  	11	2	replace
81	[BUG]  [BUGGY]  double  parl  =  1;  double  parl  =  1;  if(rank  ==  0)  {  int  j  =  0;  for(int  j  =  0;  j  <  dxNorm;  ++j)  {  work1[j]  *=  diag[j]  /  dxNorm;  }  [CE]  illegal  start  of  expression  [FE]    AssertionFailedError    [CONTEXT]    double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;    [BUGGY]  double  parl  =  1;  double  parl  =  1;  if(rank  ==  0)  {  int  j  =  0;  for(int  j  =  0;  j  <  dxNorm;  ++j)  {  work1[j]  *=  diag[j]  /  dxNorm;  }  [BUGGY]    if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double    parl    =    1;    double  parl  =  1;  if(rank  ==  0)  {  int  j  =  0;  for(int  j  =  0;  j  <  dxNorm;  ++j)  {  work1[j]  *=  diag[j]  /  dxNorm;  }	  	non-compiled	[CE]  illegal  start  of  expression	6	None	add
82	[BUG]  [BUGGY]  double  parl  =  1;  double  parl  =  1;  if(rank  ==  0)  {  int  j  =  0;  for(int  j  =  0;  j  <  dxNorm;  ++j)  {  work1[j]  *=  work1[j]  /  dxNorm;  }  [CE]  illegal  start  of  expression  [FE]      AssertionFailedError    [CONTEXT]    double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;    [BUGGY]  double  parl  =  1;  double  parl  =  1;  if(rank  ==  0)  {  int  j  =  0;  for(int  j  =  0;  j  <  dxNorm;  ++j)  {  work1[j]  *=  work1[j]  /  dxNorm;  }  [BUGGY]    if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double    parl    =    1;    double  parl  =  1;  if(rank  ==  0)  {  int  j  =  0;  for(int  j  =  0;  j  <  dxNorm;  ++j)  {  work1[j]  *=  work1[j]  /  dxNorm;  }	  	non-compiled	[CE]  illegal  start  of  expression	6	None	add
83	[BUG]  [BUGGY]  double  parl  =  1;  double  parl  =  1;  if(rank  ==  0)  {  int  j  =  0;  for(int  j  =  0;  j  <  dxNorm;  ++j)  {  work1[pj]  *=  diag[j]  /  dxNorm;  }  [CE]  illegal  start  of  expression  [FE]        AssertionFailedError    [CONTEXT]    double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;    [BUGGY]  double  parl  =  1;  double  parl  =  1;  if(rank  ==  0)  {  int  j  =  0;  for(int  j  =  0;  j  <  dxNorm;  ++j)  {  work1[pj]  *=  diag[j]  /  dxNorm;  }  [BUGGY]    if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double    parl    =    1;    double  parl  =  1;  if(rank  ==  0)  {  int  j  =  0;  for(int  j  =  0;  j  <  dxNorm;  ++j)  {  work1[pj]  *=  diag[j]  /  dxNorm;  }	  	non-compiled	[CE]  illegal  start  of  expression	6	None	add
84	[BUG]  [BUGGY]  double  parl  =  1;  double  parl  =  1;  if(rank  ==  s)  {  for(int  j  =  0;  j  <  dxNorm;  ++j)  {  work1[j]  *=  diag[j]  /  dxNorm;  }  [CE]  illegal  start  of  expression  [FE]          AssertionFailedError    [CONTEXT]    double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;    [BUGGY]  double  parl  =  1;  double  parl  =  1;  if(rank  ==  s)  {  for(int  j  =  0;  j  <  dxNorm;  ++j)  {  work1[j]  *=  diag[j]  /  dxNorm;  }  [BUGGY]    if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double    parl    =    1;    double  parl  =  1;  if(rank  ==  s)  {  for(int  j  =  0;  j  <  dxNorm;  ++j)  {  work1[j]  *=  diag[j]  /  dxNorm;  }	  	non-compiled	[CE]  illegal  start  of  expression	6	None	add
85	[BUG]  [BUGGY]  double  sPar  =  Math.abs(dxNorm  /  delta);  [CE]  cannot  find  symbol  parl  [FE]            AssertionFailedError    [CONTEXT]    double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;    [BUGGY]  double  sPar  =  Math.abs(dxNorm  /  delta);  [BUGGY]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  sPar  =  Math.abs(dxNorm  /  delta);	      double    sPar    =    Math.abs(dxNorm    -    delta);    	non-compiled	[CE]  cannot  find  symbol  parl	15	None	replace
86	[BUG]  [BUGGY]  double  sPar  =  Math.abs(dmPar);  [CE]  cannot  find  symbol  dmPar  [FE]              AssertionFailedError    [CONTEXT]    double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;    [BUGGY]  double  sPar  =  Math.abs(dmPar);  [BUGGY]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  sPar  =  Math.abs(dmPar);	      double    sPar    =    Math.abs(lmPar);    	non-compiled	[CE]  cannot  find  symbol  dmPar	16	None	replace
87	[BUG]  [BUGGY]  double  parl  =  0;  for(int  j  =  0;  j  <  resolvedCols;  ++j)  {  int  diag[j]  =  work1[j]  *  dxNorm  /  dxNorm;  }  [CE]  ']'  expected  [FE]                AssertionFailedError    [CONTEXT]    double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;    [BUGGY]  double  parl  =  0;  for(int  j  =  0;  j  <  resolvedCols;  ++j)  {  int  diag[j]  =  work1[j]  *  dxNorm  /  dxNorm;  }  [BUGGY]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  0;  for(int  j  =  0;  j  <  resolvedCols;  ++j)  {  int  diag[j]  =  work1[j]  *  dxNorm  /  dxNorm;  }	      double    parl    =    0;    for(int    j    =    0;    j    <    solvedCols;    ++j)    {    int    diag[j]    =    work1[j]    *    dxNorm    /    dxNorm;    }    	non-compiled	[CE]  ']'  expected	5	None	replace
88	[BUG]  [BUGGY]  int  diag[j]  =  work1[j]  *  Math.PI  /  dxNorm;  [CE]  ']'  expected  [FE]            AssertionFailedError    [CONTEXT]    double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;    [BUGGY]  int  diag[j]  =  work1[j]  *  Math.PI  /  dxNorm;  [BUGGY]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	int  diag[j]  =  work1[j]  *  Math.PI  /  dxNorm;	      double    parl    =    0;    for(int    j    =    0;    j    <    solvedCols;    ++j)    {    int    diag[j]    =    work1[j]    *    Math.PI    /    dxNorm;    }    	non-compiled	[CE]  ']'  expected	3	None	replace
89	[BUG]  [BUGGY]  double  sPar  =  1.0;  [CE]  cannot  find  symbol  parl  [FE]                AssertionFailedError    [CONTEXT]    double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;    [BUGGY]  double  sPar  =  1.0;  [BUGGY]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  sPar  =  1.0;	      double    sPar    =    0;    	non-compiled	[CE]  cannot  find  symbol  parl	17	None	replace
90	[BUG]  [BUGGY]  double  parl  =  0.0;  if(dxNorm  ==  0.0)  {  double  parl  =  0.0;  }  [CE]  variable  parl  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]    AssertionFailedError    [CONTEXT]    double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;    [BUGGY]  double  parl  =  0.0;  if(dxNorm  ==  0.0)  {  double  parl  =  0.0;  }  [BUGGY]    if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double    parl    =    0.0;    if(dxNorm  ==  0.0)  {  double  parl  =  0.0;  }	  	non-compiled	[CE]  variable  parl  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	8	None	add
91	[BUG]  [BUGGY]  double  parl  =  0.0;  if(dxNorm  ==  lmPar)  {  double  parl  =  0.0;  }  [CE]  variable  parl  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]      AssertionFailedError    [CONTEXT]    double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;    [BUGGY]  double  parl  =  0.0;  if(dxNorm  ==  lmPar)  {  double  parl  =  0.0;  }  [BUGGY]    if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double    parl    =    0.0;    if(dxNorm  ==  lmPar)  {  double  parl  =  0.0;  }	  	non-compiled	[CE]  variable  parl  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	8	None	add
92	[BUG]  [BUGGY]  double  parl  =  0.0;  if(dxNorm  ==  0)  {  double  parl  =  0.0;  }  [CE]  variable  parl  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]        AssertionFailedError    [CONTEXT]    double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;    [BUGGY]  double  parl  =  0.0;  if(dxNorm  ==  0)  {  double  parl  =  0.0;  }  [BUGGY]    if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double    parl    =    0.0;    if(dxNorm  ==  0)  {  double  parl  =  0.0;  }	  	non-compiled	[CE]  variable  parl  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	8	None	add
