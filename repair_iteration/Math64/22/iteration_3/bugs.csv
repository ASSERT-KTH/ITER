bugid	buggy	buggy_class	suspiciousness	buggy_line	endbuggycode	original_failing_test_number	action	patch	original_buggy	execution_result	diagnosis	previous_bug_id	new_failing_test_number	this_action
1	[BUG]  [BUGGY]  double  parl  =  Math.abs(dxNorm  *  Math.abs(fp));  double  parl  =  Math.abs(dxNorm  *  Math.abs(fp));  [CE]  variable  parl  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]    AssertionFailedError    [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  Math.abs(dxNorm  *  Math.abs(fp));  double  parl  =  Math.abs(dxNorm  *  Math.abs(fp));  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double    parl    =    Math.abs(dxNorm    *    Math.abs(fp));    double  parl  =  Math.abs(dxNorm  *  Math.abs(fp));	  	non-compiled	[CE]  variable  parl  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	3	None	add
2	[BUG]  [BUGGY]  double  parl  =  Math.abs(dxNorm  *  Math.abs(fp));  Double  parl  =  Math.abs(dxNorm  *  Math.abs(fp));  [CE]  variable  parl  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]      AssertionFailedError    [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  Math.abs(dxNorm  *  Math.abs(fp));  Double  parl  =  Math.abs(dxNorm  *  Math.abs(fp));  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double    parl    =    Math.abs(dxNorm    *    Math.abs(fp));    Double  parl  =  Math.abs(dxNorm  *  Math.abs(fp));	  	non-compiled	[CE]  variable  parl  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	3	None	add
3	[BUG]  [BUGGY]  double  parl  =  Math.abs(dxNorm  *  Math.abs(fp));  double  dxNorm  =  Math.abs(dxNorm  *  Math.abs(fp));  [CE]  variable  dxNorm  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]        AssertionFailedError    [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  Math.abs(dxNorm  *  Math.abs(fp));  double  dxNorm  =  Math.abs(dxNorm  *  Math.abs(fp));  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double    parl    =    Math.abs(dxNorm    *    Math.abs(fp));    double  dxNorm  =  Math.abs(dxNorm  *  Math.abs(fp));	  	non-compiled	[CE]  variable  dxNorm  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	3	None	add
4	[BUG]  [BUGGY]  double  parl  =  Math.abs(dxNorm  *  Math.abs(fp));  double  fp  =  Math.abs(dxNorm  *  Math.abs(fp));  [CE]  variable  fp  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]          AssertionFailedError    [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  Math.abs(dxNorm  *  Math.abs(fp));  double  fp  =  Math.abs(dxNorm  *  Math.abs(fp));  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double    parl    =    Math.abs(dxNorm    *    Math.abs(fp));    double  fp  =  Math.abs(dxNorm  *  Math.abs(fp));	  	non-compiled	[CE]  variable  fp  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	3	None	add
5	[BUG]  [BUGGY]  double  parl  =  Math.abs(dxNorm  *  Math.abs(fp));  Math.abs(dxNorm  *  Math.abs(fp));  [CE]  variable  parl  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]            AssertionFailedError    [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  Math.abs(dxNorm  *  Math.abs(fp));  Math.abs(dxNorm  *  Math.abs(fp));  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double    parl    =    Math.abs(dxNorm    *    Math.abs(fp));    Math.abs(dxNorm  *  Math.abs(fp));	  	non-compiled	[CE]  variable  parl  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	3	None	add
6	[BUG]  [BUGGY]  if(lmPar  ==  0.0)  {  double  parl  =  0.0;  }  [CE]  cannot  find  symbol  parl  [FE]          AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  if(lmPar  ==  0.0)  {  double  parl  =  0.0;  }  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	if(lmPar  ==  0.0)  {  double  parl  =  0.0;  }	  double    parl    =    0.0;    if(dxNorm    ==    lmPar)    {    double    parl    =    0.0;    }    	non-compiled	[CE]  cannot  find  symbol  parl	91	None	replace
7	[BUG]  [BUGGY]  if(lmPar  ==  dxNorm)  {  double  parl  =  0.0;  }  [CE]  cannot  find  symbol  parl  [FE]            AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  if(lmPar  ==  dxNorm)  {  double  parl  =  0.0;  }  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	if(lmPar  ==  dxNorm)  {  double  parl  =  0.0;  }	  double    parl    =    0.0;    if(dxNorm    ==    lmPar)    {    double    parl    =    0.0;    }    	non-compiled	[CE]  cannot  find  symbol  parl	91	None	replace
8	[BUG]  [BUGGY]  if(lmPar!=  0.0)  {  double  parl  =  0.0;  }  [CE]  cannot  find  symbol  parl  [FE]              AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  if(lmPar!=  0.0)  {  double  parl  =  0.0;  }  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	if(lmPar!=  0.0)  {  double  parl  =  0.0;  }	  double    parl    =    0.0;    if(dxNorm    ==    lmPar)    {    double    parl    =    0.0;    }    	non-compiled	[CE]  cannot  find  symbol  parl	91	None	replace
9	[BUG]  [BUGGY]  double  sPar  =  Math.abs(lmPar  *  Math.abs(tmp));  [CE]  cannot  find  symbol  tmp  [FE]              AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  sPar  =  Math.abs(lmPar  *  Math.abs(tmp));  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  sPar  =  Math.abs(lmPar  *  Math.abs(tmp));	  double    sPar    =    Math.abs(tmp    *    Math.abs(lmPar));    	non-compiled	[CE]  cannot  find  symbol  tmp	62	None	replace
10	[BUG]  [BUGGY]  double  sPar  =  Math.abs(lmPar  *  Math.abs(lmPar));  [CE]  cannot  find  symbol  parl  [FE]                AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  sPar  =  Math.abs(lmPar  *  Math.abs(lmPar));  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  sPar  =  Math.abs(lmPar  *  Math.abs(lmPar));	  double    sPar    =    Math.abs(tmp    *    Math.abs(lmPar));    	non-compiled	[CE]  cannot  find  symbol  parl	62	None	replace
11	[BUG]  [BUGGY]  double  parl  =  0;  if(rank  ==  s)  {  for(int  j  =  0;  j  <  dxNorm;  ++j)  {  work1[j]  *=  diag[j]  /  dxNorm;  }  [CE]  illegal  start  of  expression  [FE]              AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  0;  if(rank  ==  s)  {  for(int  j  =  0;  j  <  dxNorm;  ++j)  {  work1[j]  *=  diag[j]  /  dxNorm;  }  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  0;  if(rank  ==  s)  {  for(int  j  =  0;  j  <  dxNorm;  ++j)  {  work1[j]  *=  diag[j]  /  dxNorm;  }	  double    parl    =    1;    double    parl    =    1;    if(rank    ==    s)    {    for(int    j    =    0;    j    <    dxNorm;    ++j)    {    work1[j]    *=    diag[j]    /    dxNorm;    }    	non-compiled	[CE]  illegal  start  of  expression	84	None	replace
12	[BUG]  [BUGGY]  double  parl  =  0.0;  if(rank  ==  s)  {  for(int  j  =  0;  j  <  dxNorm;  ++j)  {  work1[j]  *=  diag[j]  /  dxNorm;  }  [CE]  illegal  start  of  expression  [FE]                AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  0.0;  if(rank  ==  s)  {  for(int  j  =  0;  j  <  dxNorm;  ++j)  {  work1[j]  *=  diag[j]  /  dxNorm;  }  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  0.0;  if(rank  ==  s)  {  for(int  j  =  0;  j  <  dxNorm;  ++j)  {  work1[j]  *=  diag[j]  /  dxNorm;  }	  double    parl    =    1;    double    parl    =    1;    if(rank    ==    s)    {    for(int    j    =    0;    j    <    dxNorm;    ++j)    {    work1[j]    *=    diag[j]    /    dxNorm;    }    	non-compiled	[CE]  illegal  start  of  expression	84	None	replace
13	[BUG]  [BUGGY]  double  parl  =  0;  if(rank  ==  s)  {  for(int  j  =  0;  j  <  dxNorm;  ++j)  {  work2[j]  *=  diag[j]  /  dxNorm;  }  [CE]  illegal  start  of  expression  [FE]                  AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  0;  if(rank  ==  s)  {  for(int  j  =  0;  j  <  dxNorm;  ++j)  {  work2[j]  *=  diag[j]  /  dxNorm;  }  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  0;  if(rank  ==  s)  {  for(int  j  =  0;  j  <  dxNorm;  ++j)  {  work2[j]  *=  diag[j]  /  dxNorm;  }	  double    parl    =    1;    double    parl    =    1;    if(rank    ==    s)    {    for(int    j    =    0;    j    <    dxNorm;    ++j)    {    work1[j]    *=    diag[j]    /    dxNorm;    }    	non-compiled	[CE]  illegal  start  of  expression	84	None	replace
14	[BUG]  [BUGGY]  double  parl  =  0;  if(rank  ==  s)  {  for(int  j  =  0;  j  <  dxNorm;  ++j)  {  work1[j]  *=  diag[j]  /  delta;  }  [CE]  illegal  start  of  expression  [FE]                    AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  0;  if(rank  ==  s)  {  for(int  j  =  0;  j  <  dxNorm;  ++j)  {  work1[j]  *=  diag[j]  /  delta;  }  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  0;  if(rank  ==  s)  {  for(int  j  =  0;  j  <  dxNorm;  ++j)  {  work1[j]  *=  diag[j]  /  delta;  }	  double    parl    =    1;    double    parl    =    1;    if(rank    ==    s)    {    for(int    j    =    0;    j    <    dxNorm;    ++j)    {    work1[j]    *=    diag[j]    /    dxNorm;    }    	non-compiled	[CE]  illegal  start  of  expression	84	None	replace
15	[BUG]  [BUGGY]  double  parl  =  0.0;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  diag[j]  =  work1[j]  *  dxNorm;  }  [CE]  ']'  expected  [FE]                AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  0.0;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  diag[j]  =  work1[j]  *  dxNorm;  }  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  0.0;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  diag[j]  =  work1[j]  *  dxNorm;  }	  double    parl    =    0;    for(int    j    =    0;    j    <    solvedCols;    ++j)    {    int    diag[j]    =    work1[j]    *    dxNorm;    }    	non-compiled	[CE]  ']'  expected	78	None	replace
16	[BUG]  [BUGGY]  double  parl  =  0;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  diag[j]  =  work2[j]  *  dxNorm;  }  [CE]  ']'  expected  [FE]                  AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  0;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  diag[j]  =  work2[j]  *  dxNorm;  }  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  0;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  diag[j]  =  work2[j]  *  dxNorm;  }	  double    parl    =    0;    for(int    j    =    0;    j    <    solvedCols;    ++j)    {    int    diag[j]    =    work1[j]    *    dxNorm;    }    	non-compiled	[CE]  ']'  expected	78	None	replace
17	[BUG]  [BUGGY]  double  parl  =  0;  for(int  j  =  0;  j  <  resolvedCols;  ++j)  {  int  diag[j]  =  work1[j]  *  dxNorm;  }  [CE]  ']'  expected  [FE]                    AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  0;  for(int  j  =  0;  j  <  resolvedCols;  ++j)  {  int  diag[j]  =  work1[j]  *  dxNorm;  }  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  0;  for(int  j  =  0;  j  <  resolvedCols;  ++j)  {  int  diag[j]  =  work1[j]  *  dxNorm;  }	  double    parl    =    0;    for(int    j    =    0;    j    <    solvedCols;    ++j)    {    int    diag[j]    =    work1[j]    *    dxNorm;    }    	non-compiled	[CE]  ']'  expected	78	None	replace
18	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]                    AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  Math.abs(fp  *  Math.abs(delta));  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	add	double  parl  =  Math.abs(fp  *  Math.abs(delta));	  double    sPar    =    Math.abs(fp    *    Math.abs(dxNorm));    	compilable	  [FE]  AssertionFailedError  	42	4	replace
19	[BUG]  [BUGGY]  double  parl  =  Math.abs(fp  *  Math.abs(delta));  [FE]  AssertionFailedError  [FE]                    AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  Math.abs(fp  *  Math.abs(delta));  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  Math.abs(fp  *  Math.abs(delta));	  double    sPar    =    Math.abs(fp    *    Math.abs(dxNorm));    	compilable	  [FE]  AssertionFailedError  	42	4	replace
20	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]                      AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  Math.abs(fp  *  Math.abs(dxNorm));  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	add	double  parl  =  Math.abs(fp  *  Math.abs(dxNorm));	  double    sPar    =    Math.abs(fp    *    Math.abs(dxNorm));    	compilable	  [FE]  AssertionFailedError  	42	4	replace
21	[BUG]  [BUGGY]  double  parl  =  Math.abs(fp  *  Math.abs(dxNorm));  [FE]  AssertionFailedError  [FE]                      AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  Math.abs(fp  *  Math.abs(dxNorm));  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  Math.abs(fp  *  Math.abs(dxNorm));	  double    sPar    =    Math.abs(fp    *    Math.abs(dxNorm));    	compilable	  [FE]  AssertionFailedError  	42	4	replace
22	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]                AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  Math.abs(dxNorm  *  fp);  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	add	double  parl  =  Math.abs(dxNorm  *  fp);	  double    sPar    =    Math.abs(dxNorm    *    fp);    	compilable	  [FE]  AssertionFailedError  	35	4	replace
23	[BUG]  [BUGGY]  double  parl  =  Math.abs(dxNorm  *  fp);  [FE]  AssertionFailedError  [FE]                AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  Math.abs(dxNorm  *  fp);  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  Math.abs(dxNorm  *  fp);	  double    sPar    =    Math.abs(dxNorm    *    fp);    	compilable	  [FE]  AssertionFailedError  	35	4	replace
24	[BUG]  [BUGGY]  double  sPar  =  Math.abs(lmPar  *  fp);  [CE]  cannot  find  symbol  parl  [FE]                  AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  sPar  =  Math.abs(lmPar  *  fp);  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  sPar  =  Math.abs(lmPar  *  fp);	  double    sPar    =    Math.abs(dxNorm    *    fp);    	non-compiled	[CE]  cannot  find  symbol  parl	35	None	replace
25	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]                    AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  Math.abs(fp  *  dxNorm);  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	add	double  parl  =  Math.abs(fp  *  dxNorm);	  double    sPar    =    Math.abs(dxNorm    *    fp);    	compilable	  [FE]  AssertionFailedError  	35	4	replace
26	[BUG]  [BUGGY]  double  parl  =  Math.abs(fp  *  dxNorm);  [FE]  AssertionFailedError  [FE]                    AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  Math.abs(fp  *  dxNorm);  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  Math.abs(fp  *  dxNorm);	  double    sPar    =    Math.abs(dxNorm    *    fp);    	compilable	  [FE]  AssertionFailedError  	35	4	replace
27	[BUG]  [BUGGY]  double  sPar  =  Math.abs(lmPar  *  Math.abs(delta));  [CE]  cannot  find  symbol  parl  [FE]                  AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  sPar  =  Math.abs(lmPar  *  Math.abs(delta));  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  sPar  =  Math.abs(lmPar  *  Math.abs(delta));	  double    sPar    =    Math.abs(dxNorm    *    Math.abs(delta));    	non-compiled	[CE]  cannot  find  symbol  parl	41	None	replace
28	[BUG]  [BUGGY]  double  sPar  =  Math.abs(fp  *  Math.abs(delta));  [CE]  cannot  find  symbol  parl  [FE]                    AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  sPar  =  Math.abs(fp  *  Math.abs(delta));  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  sPar  =  Math.abs(fp  *  Math.abs(delta));	  double    sPar    =    Math.abs(dxNorm    *    Math.abs(delta));    	non-compiled	[CE]  cannot  find  symbol  parl	41	None	replace
29	[BUG]  [BUGGY]  for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diag[j]  /  dxNorm;  }  [CE]  cannot  find  symbol  parl  [FE]        AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diag[j]  /  dxNorm;  }  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diag[j]  /  dxNorm;  }	  double    parl    =    0.0;    if(dxNorm    ==    0)    {    double    parl    =    0.0;    }    else    {    for(int    j    =    0;    j    <    0;    ++j)    {    work1[j]    *=    diag[j]    /    dxNorm;    }    	non-compiled	[CE]  cannot  find  symbol  parl	67	None	replace
30	[BUG]  [BUGGY]  double  parl  =  1.0;  if(dxNorm  ==  0.0)  {  for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diag[j]  /  dxNorm;  }  [CE]  illegal  start  of  expression  [FE]          AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  1.0;  if(dxNorm  ==  0.0)  {  for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diag[j]  /  dxNorm;  }  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  1.0;  if(dxNorm  ==  0.0)  {  for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diag[j]  /  dxNorm;  }	  double    parl    =    0.0;    if(dxNorm    ==    0)    {    double    parl    =    0.0;    }    else    {    for(int    j    =    0;    j    <    0;    ++j)    {    work1[j]    *=    diag[j]    /    dxNorm;    }    	non-compiled	[CE]  illegal  start  of  expression	67	None	replace
31	[BUG]  [BUGGY]  double  parl  =  1.0;  if(dxNorm  ==  0)  {  for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diag[j]  /  dxNorm;  }  [CE]  illegal  start  of  expression  [FE]            AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  1.0;  if(dxNorm  ==  0)  {  for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diag[j]  /  dxNorm;  }  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  1.0;  if(dxNorm  ==  0)  {  for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diag[j]  /  dxNorm;  }	  double    parl    =    0.0;    if(dxNorm    ==    0)    {    double    parl    =    0.0;    }    else    {    for(int    j    =    0;    j    <    0;    ++j)    {    work1[j]    *=    diag[j]    /    dxNorm;    }    	non-compiled	[CE]  illegal  start  of  expression	67	None	replace
32	[BUG]  [BUGGY]  for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diag[j]  /  delta;  }  [CE]  cannot  find  symbol  parl  [FE]              AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diag[j]  /  delta;  }  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diag[j]  /  delta;  }	  double    parl    =    0.0;    if(dxNorm    ==    0)    {    double    parl    =    0.0;    }    else    {    for(int    j    =    0;    j    <    0;    ++j)    {    work1[j]    *=    diag[j]    /    dxNorm;    }    	non-compiled	[CE]  cannot  find  symbol  parl	67	None	replace
33	[BUG]  [BUGGY]  double  parl  =  2;  double  parl  =  2;  [CE]  variable  parl  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]    AssertionFailedError    [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  2;  double  parl  =  2;  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double    parl    =    2;    double  parl  =  2;	  	non-compiled	[CE]  variable  parl  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	36	None	add
34	[BUG]  [BUGGY]  double  parl  =  2;  Double  parl  =  2;  [CE]  variable  parl  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]      AssertionFailedError    [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  2;  Double  parl  =  2;  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double    parl    =    2;    Double  parl  =  2;	  	non-compiled	[CE]  variable  parl  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	36	None	add
35	[BUG]  [BUGGY]  double  parl  =  2;  int  parl  =  2;  [CE]  variable  parl  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]        AssertionFailedError    [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  2;  int  parl  =  2;  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double    parl    =    2;    int  parl  =  2;	  	non-compiled	[CE]  variable  parl  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	36	None	add
36	[BUG]  [BUGGY]  double  parl  =  2;  double  pl  =  2;  [CE]  variable  parl  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]          AssertionFailedError    [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  2;  double  pl  =  2;  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double    parl    =    2;    double  pl  =  2;	  	non-compiled	[CE]  variable  parl  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	36	None	add
37	[BUG]  [BUGGY]  double  parl  =  0.0;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  diag[j]  =  work2[j]  *  Math.PI  /  dxNorm;  }  [CE]  ']'  expected  [FE]                    AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  0.0;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  diag[j]  =  work2[j]  *  Math.PI  /  dxNorm;  }  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  0.0;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  diag[j]  =  work2[j]  *  Math.PI  /  dxNorm;  }	  double    parl    =    0;    for(int    j    =    0;    j    <    solvedCols;    ++j)    {    int    diag[j]    =    work2[j]    *    Math.PI    /    dxNorm;    }    	non-compiled	[CE]  ']'  expected	59	None	replace
38	[BUG]  [BUGGY]  double  parl  =  0;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  diag[j]  =  work2[j]  *  Math.PI  /  delta;  }  [CE]  ']'  expected  [FE]                      AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  0;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  diag[j]  =  work2[j]  *  Math.PI  /  delta;  }  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  0;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  diag[j]  =  work2[j]  *  Math.PI  /  delta;  }	  double    parl    =    0;    for(int    j    =    0;    j    <    solvedCols;    ++j)    {    int    diag[j]    =    work2[j]    *    Math.PI    /    dxNorm;    }    	non-compiled	[CE]  ']'  expected	59	None	replace
39	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]                AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  Math.abs(dxNorm  /  fp);  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	add	double  parl  =  Math.abs(dxNorm  /  fp);	  double    sPar    =    Math.abs(dxNorm    /    delta);    	compilable	  [FE]  AssertionFailedError  	85	2	replace
40	[BUG]  [BUGGY]  double  parl  =  Math.abs(dxNorm  /  fp);  [FE]  AssertionFailedError  [FE]                AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  Math.abs(dxNorm  /  fp);  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  Math.abs(dxNorm  /  fp);	  double    sPar    =    Math.abs(dxNorm    /    delta);    	compilable	  [FE]  AssertionFailedError  	85	2	replace
41	[BUG]  [BUGGY]  double  sPar  =  Math.abs(dxNorm  *  delta);  [CE]  cannot  find  symbol  parl  [FE]                  AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  sPar  =  Math.abs(dxNorm  *  delta);  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  sPar  =  Math.abs(dxNorm  *  delta);	  double    sPar    =    Math.abs(dxNorm    /    delta);    	non-compiled	[CE]  cannot  find  symbol  parl	85	None	replace
42	[BUG]  [BUGGY]  double  sPar  =  Math.abs(dxNorm  /  fp);  [CE]  cannot  find  symbol  parl  [FE]                    AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  sPar  =  Math.abs(dxNorm  /  fp);  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  sPar  =  Math.abs(dxNorm  /  fp);	  double    sPar    =    Math.abs(dxNorm    /    delta);    	non-compiled	[CE]  cannot  find  symbol  parl	85	None	replace
43	[BUG]  [BUGGY]  double  sPar  =  Math.abs(dxNorm  /  lmPar);  [CE]  cannot  find  symbol  parl  [FE]                      AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  sPar  =  Math.abs(dxNorm  /  lmPar);  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  sPar  =  Math.abs(dxNorm  /  lmPar);	  double    sPar    =    Math.abs(dxNorm    /    delta);    	non-compiled	[CE]  cannot  find  symbol  parl	85	None	replace
44	[BUG]  [BUGGY]  double  parl  =  0.0;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  diag[j]  =  work1[j]  *  dxNorm  /  delta;  }  [CE]  ']'  expected  [FE]                    AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  0.0;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  diag[j]  =  work1[j]  *  dxNorm  /  delta;  }  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  0.0;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  diag[j]  =  work1[j]  *  dxNorm  /  delta;  }	  double    parl    =    0;    for(int    j    =    0;    j    <    solvedCols;    ++j)    {    int    diag[j]    =    work1[j]    *    dxNorm    /    delta;    }    	non-compiled	[CE]  ']'  expected	13	None	replace
45	[BUG]  [BUGGY]  double  parl  =  0;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  diag[j]  =  work2[j]  *  dxNorm  /  delta;  }  [CE]  ']'  expected  [FE]                      AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  0;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  diag[j]  =  work2[j]  *  dxNorm  /  delta;  }  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  0;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  diag[j]  =  work2[j]  *  dxNorm  /  delta;  }	  double    parl    =    0;    for(int    j    =    0;    j    <    solvedCols;    ++j)    {    int    diag[j]    =    work1[j]    *    dxNorm    /    delta;    }    	non-compiled	[CE]  ']'  expected	13	None	replace
46	[BUG]  [BUGGY]  double  parl  =  0;  for(int  j  =  0;  j  <  solveCols;  ++j)  {  int  diag[j]  =  work1[j]  *  dxNorm  /  delta;  }  [CE]  ']'  expected  [FE]                        AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  0;  for(int  j  =  0;  j  <  solveCols;  ++j)  {  int  diag[j]  =  work1[j]  *  dxNorm  /  delta;  }  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  0;  for(int  j  =  0;  j  <  solveCols;  ++j)  {  int  diag[j]  =  work1[j]  *  dxNorm  /  delta;  }	  double    parl    =    0;    for(int    j    =    0;    j    <    solvedCols;    ++j)    {    int    diag[j]    =    work1[j]    *    dxNorm    /    delta;    }    	non-compiled	[CE]  ']'  expected	13	None	replace
47	[BUG]  [BUGGY]  double  parl  =  0.0;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  diag[j]  =  work2[j]  *  dxNorm  /  dxNorm;  }  [CE]  ']'  expected  [FE]                      AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  0.0;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  diag[j]  =  work2[j]  *  dxNorm  /  dxNorm;  }  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  0.0;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  diag[j]  =  work2[j]  *  dxNorm  /  dxNorm;  }	  double    parl    =    0.0;    for(int    j    =    0;    j    <    solvedCols;    ++j)    {    int    diag[j]    =    work1[j]    *    dxNorm    /    dxNorm;    }    	non-compiled	[CE]  ']'  expected	14	None	replace
48	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]              AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  Math.abs(lmPar  *  fp);  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	add	double  parl  =  Math.abs(lmPar  *  fp);	  double    sPar    =    Math.abs(lmPar    *    dxNorm);    	compilable	  [FE]  AssertionFailedError  	1	2	replace
49	[BUG]  [BUGGY]  double  parl  =  Math.abs(lmPar  *  fp);  [FE]  AssertionFailedError  [FE]              AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  Math.abs(lmPar  *  fp);  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  Math.abs(lmPar  *  fp);	  double    sPar    =    Math.abs(lmPar    *    dxNorm);    	compilable	  [FE]  AssertionFailedError  	1	2	replace
50	[BUG]  [BUGGY]  double  sPar  =  Math.abs(lmPar  *  sum2);  [CE]  cannot  find  symbol  parl  [FE]                AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  sPar  =  Math.abs(lmPar  *  sum2);  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  sPar  =  Math.abs(lmPar  *  sum2);	  double    sPar    =    Math.abs(lmPar    *    dxNorm);    	non-compiled	[CE]  cannot  find  symbol  parl	1	None	replace
51	[BUG]  [BUGGY]  double  solvedCols  =  3;  [CE]  cannot  find  symbol  parl  [FE]        AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  solvedCols  =  3;  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  solvedCols  =  3;	  double    solvedCols    =    1;    	non-compiled	[CE]  cannot  find  symbol  parl	21	None	replace
52	[BUG]  [BUGGY]  double  sPar  =  Math.abs(delta  -  lmPar);  [CE]  cannot  find  symbol  parl  [FE]            AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  sPar  =  Math.abs(delta  -  lmPar);  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  sPar  =  Math.abs(delta  -  lmPar);	  double    sPar    =    Math.abs(delta    -    fp);    	non-compiled	[CE]  cannot  find  symbol  parl	63	None	replace
53	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]              AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  Math.abs(delta  -  fp);  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	add	double  parl  =  Math.abs(delta  -  fp);	  double    sPar    =    Math.abs(delta    -    fp);    	compilable	  [FE]  AssertionFailedError  	63	4	replace
54	[BUG]  [BUGGY]  double  parl  =  Math.abs(delta  -  fp);  [FE]  AssertionFailedError  [FE]              AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  Math.abs(delta  -  fp);  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  Math.abs(delta  -  fp);	  double    sPar    =    Math.abs(delta    -    fp);    	compilable	  [FE]  AssertionFailedError  	63	4	replace
55	[BUG]  [BUGGY]  double  sPar  =  Math.abs(fp  -  delta);  [CE]  cannot  find  symbol  parl  [FE]                AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  sPar  =  Math.abs(fp  -  delta);  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  sPar  =  Math.abs(fp  -  delta);	  double    sPar    =    Math.abs(delta    -    fp);    	non-compiled	[CE]  cannot  find  symbol  parl	63	None	replace
56	[BUG]  [BUGGY]  double  sPar  =  Math.abs(delta  /  fp);  [CE]  cannot  find  symbol  parl  [FE]                  AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  sPar  =  Math.abs(delta  /  fp);  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  sPar  =  Math.abs(delta  /  fp);	  double    sPar    =    Math.abs(delta    -    fp);    	non-compiled	[CE]  cannot  find  symbol  parl	63	None	replace
57	[BUG]  [BUGGY]  double  sPar  =  Math.abs(sum2,  lmPar);  [CE]  no  suitable  method  found  for  abs(double,double)  [FE]                    AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  sPar  =  Math.abs(sum2,  lmPar);  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  sPar  =  Math.abs(sum2,  lmPar);	  double    sPar    =    Math.abs(lmPar,    sum2);    	non-compiled	[CE]  no  suitable  method  found  for  abs(double,double)	45	None	replace
58	[BUG]  [BUGGY]  double  sPar  =  Math.abs(sum,  lmPar);  [CE]  cannot  find  symbol  sum  [FE]                      AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  sPar  =  Math.abs(sum,  lmPar);  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  sPar  =  Math.abs(sum,  lmPar);	  double    sPar    =    Math.abs(lmPar,    sum2);    	non-compiled	[CE]  cannot  find  symbol  sum	45	None	replace
59	[BUG]  [BUGGY]  double  sPar  =  Math.abs(lmPar,  sum1,  sum2);  [CE]  cannot  find  symbol  sum1  [FE]                        AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  sPar  =  Math.abs(lmPar,  sum1,  sum2);  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  sPar  =  Math.abs(lmPar,  sum1,  sum2);	  double    sPar    =    Math.abs(lmPar,    sum2);    	non-compiled	[CE]  cannot  find  symbol  sum1	45	None	replace
60	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]                  AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  Math.abs(fp  -  delta);  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	add	double  parl  =  Math.abs(fp  -  delta);	  double    sPar    =    Math.abs(fp    -    lmPar);    	compilable	  [FE]  AssertionFailedError  	12	4	replace
61	[BUG]  [BUGGY]  double  parl  =  Math.abs(fp  -  delta);  [FE]  AssertionFailedError  [FE]                  AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  Math.abs(fp  -  delta);  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  Math.abs(fp  -  delta);	  double    sPar    =    Math.abs(fp    -    lmPar);    	compilable	  [FE]  AssertionFailedError  	12	4	replace
62	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]                    AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  Math.abs(lmPar  -  fp);  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	add	double  parl  =  Math.abs(lmPar  -  fp);	  double    sPar    =    Math.abs(fp    -    lmPar);    	compilable	  [FE]  AssertionFailedError  	12	4	replace
63	[BUG]  [BUGGY]  double  parl  =  Math.abs(lmPar  -  fp);  [FE]  AssertionFailedError  [FE]                    AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  Math.abs(lmPar  -  fp);  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  Math.abs(lmPar  -  fp);	  double    sPar    =    Math.abs(fp    -    lmPar);    	compilable	  [FE]  AssertionFailedError  	12	4	replace
64	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]                      AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  Math.abs(fp  -  lmPar);  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	add	double  parl  =  Math.abs(fp  -  lmPar);	  double    sPar    =    Math.abs(fp    -    lmPar);    	compilable	  [FE]  AssertionFailedError  	12	4	replace
65	[BUG]  [BUGGY]  double  parl  =  Math.abs(fp  -  lmPar);  [FE]  AssertionFailedError  [FE]                      AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  Math.abs(fp  -  lmPar);  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  Math.abs(fp  -  lmPar);	  double    sPar    =    Math.abs(fp    -    lmPar);    	compilable	  [FE]  AssertionFailedError  	12	4	replace
66	[BUG]  [BUGGY]  Double  solvedCols  =  0;  [CE]  incompatible  types  [FE]          AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  Double  solvedCols  =  0;  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	Double  solvedCols  =  0;	          double    solvedCols    =    0;    Double    solvedCols    =    0;    	non-compiled	[CE]  incompatible  types	49	None	replace
67	[BUG]  [BUGGY]  solveCols  =  0;  [CE]  cannot  find  symbol  solveCols  [FE]            AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  solveCols  =  0;  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	solveCols  =  0;	          double    solvedCols    =    0;    Double    solvedCols    =    0;    	non-compiled	[CE]  cannot  find  symbol  solveCols	49	None	replace
68	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  Double  parl  =  1.0;  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	add	Double  parl  =  1.0;	  double    parl    =    1.0;    Double    parl    =    1.0;    	compilable	  [FE]  AssertionFailedError  	30	2	replace
69	[BUG]  [BUGGY]  Double  parl  =  1.0;  [FE]  AssertionFailedError  [FE]          AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  Double  parl  =  1.0;  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	Double  parl  =  1.0;	  double    parl    =    1.0;    Double    parl    =    1.0;    	compilable	  [FE]  AssertionFailedError  	30	2	replace
70	[BUG]  [BUGGY]  double  sPar  =  10.0;  [CE]  cannot  find  symbol  parl  [FE]                    AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  sPar  =  10.0;  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  sPar  =  10.0;	  double    sPar    =    0.0;    	non-compiled	[CE]  cannot  find  symbol  parl	74	None	replace
71	[BUG]  [BUGGY]  double  dk  =  1.0;  [CE]  cannot  find  symbol  parl  [FE]              AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  dk  =  1.0;  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  dk  =  1.0;	  double    parl    =    1.0;    dk    =    1.0;    	non-compiled	[CE]  cannot  find  symbol  parl	32	None	replace
72	[BUG]  [BUGGY]  dk  =  1.0;  [CE]  cannot  find  symbol  dk  [FE]                AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  dk  =  1.0;  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	dk  =  1.0;	  double    parl    =    1.0;    dk    =    1.0;    	non-compiled	[CE]  cannot  find  symbol  dk	32	None	replace
73	[BUG]  [BUGGY]  double  dl  =  1.0;  [CE]  cannot  find  symbol  parl  [FE]                  AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  dl  =  1.0;  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  dl  =  1.0;	  double    parl    =    1.0;    dk    =    1.0;    	non-compiled	[CE]  cannot  find  symbol  parl	32	None	replace
74	[BUG]  [BUGGY]  double  dx  =  1.0;  [CE]  cannot  find  symbol  parl  [FE]                    AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  dx  =  1.0;  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  dx  =  1.0;	  double    parl    =    1.0;    dk    =    1.0;    	non-compiled	[CE]  cannot  find  symbol  parl	32	None	replace
75	[BUG]  [BUGGY]  double  sPar  =  2;  [CE]  cannot  find  symbol  parl  [FE]                    AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  sPar  =  2;  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  sPar  =  2;	  double    sPar    =    1;    	non-compiled	[CE]  cannot  find  symbol  parl	38	None	replace
76	[BUG]  [BUGGY]  int  diag[j]  =  work1[j]  *  dxNorm;  [CE]  ']'  expected  [FE]              AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  int  diag[j]  =  work1[j]  *  dxNorm;  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	int  diag[j]  =  work1[j]  *  dxNorm;	  int    diag[j]    =    work1[j]    /    dxNorm;    	non-compiled	[CE]  ']'  expected	77	None	replace
77	[BUG]  [BUGGY]  int  diag[j]  =  work2[j]  /  dxNorm;  [CE]  ']'  expected  [FE]                AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  int  diag[j]  =  work2[j]  /  dxNorm;  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	int  diag[j]  =  work2[j]  /  dxNorm;	  int    diag[j]    =    work1[j]    /    dxNorm;    	non-compiled	[CE]  ']'  expected	77	None	replace
78	[BUG]  [BUGGY]  double  diag[j]  =  work1[j]  /  dxNorm;  [CE]  ']'  expected  [FE]                  AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  diag[j]  =  work1[j]  /  dxNorm;  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  diag[j]  =  work1[j]  /  dxNorm;	  int    diag[j]    =    work1[j]    /    dxNorm;    	non-compiled	[CE]  ']'  expected	77	None	replace
79	[BUG]  [BUGGY]  int  diag[j]  =  work3[j]  /  dxNorm;  [CE]  ']'  expected  [FE]                    AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  int  diag[j]  =  work3[j]  /  dxNorm;  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	int  diag[j]  =  work3[j]  /  dxNorm;	  int    diag[j]    =    work1[j]    /    dxNorm;    	non-compiled	[CE]  ']'  expected	77	None	replace
80	[BUG]  [BUGGY]  double  solvedCols  =  0.5;  [CE]  cannot  find  symbol  parl  [FE]            AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  solvedCols  =  0.5;  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  solvedCols  =  0.5;	  double    solvedCols    =    1.0;    	non-compiled	[CE]  cannot  find  symbol  parl	23	None	replace
81	[BUG]  [BUGGY]  double  lmPar  =  1;  [CE]  cannot  find  symbol  parl  [FE]                      AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  lmPar  =  1;  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  lmPar  =  1;	  double    lmPar    =    0;    	non-compiled	[CE]  cannot  find  symbol  parl	39	None	replace
82	[BUG]  [BUGGY]  double  par2  =  0;  [CE]  cannot  find  symbol  parl  [FE]                        AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  par2  =  0;  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  par2  =  0;	  double    lmPar    =    0;    	non-compiled	[CE]  cannot  find  symbol  parl	39	None	replace
83	[BUG]  [BUGGY]  double  parl  =  0;  if(rank  ==  0)  {  int  j  =  0;  for(int  j  =  0;  j  <  dxNorm;  ++j)  {  work1[j]  *=  diag[j]  /  dxNorm;  }  [CE]  illegal  start  of  expression  [FE]        AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  0;  if(rank  ==  0)  {  int  j  =  0;  for(int  j  =  0;  j  <  dxNorm;  ++j)  {  work1[j]  *=  diag[j]  /  dxNorm;  }  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  0;  if(rank  ==  0)  {  int  j  =  0;  for(int  j  =  0;  j  <  dxNorm;  ++j)  {  work1[j]  *=  diag[j]  /  dxNorm;  }	  double    parl    =    1;    double    parl    =    1;    if(rank    ==    0)    {    int    j    =    0;    for(int    j    =    0;    j    <    dxNorm;    ++j)    {    work1[j]    *=    diag[j]    /    dxNorm;    }    	non-compiled	[CE]  illegal  start  of  expression	81	None	replace
84	[BUG]  [BUGGY]  double  parl  =  1.0;  if(rank  ==  0)  {  int  j  =  0;  for(int  j  =  0;  j  <  dxNorm;  ++j)  {  work1[j]  *=  diag[j]  /  dxNorm;  }  [CE]  illegal  start  of  expression  [FE]          AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  1.0;  if(rank  ==  0)  {  int  j  =  0;  for(int  j  =  0;  j  <  dxNorm;  ++j)  {  work1[j]  *=  diag[j]  /  dxNorm;  }  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  1.0;  if(rank  ==  0)  {  int  j  =  0;  for(int  j  =  0;  j  <  dxNorm;  ++j)  {  work1[j]  *=  diag[j]  /  dxNorm;  }	  double    parl    =    1;    double    parl    =    1;    if(rank    ==    0)    {    int    j    =    0;    for(int    j    =    0;    j    <    dxNorm;    ++j)    {    work1[j]    *=    diag[j]    /    dxNorm;    }    	non-compiled	[CE]  illegal  start  of  expression	81	None	replace
85	[BUG]  [BUGGY]  double  parl  =  0;  if(rank  ==  0)  {  int  j  =  0;  for(int  j  =  0;  j  <  dxNorm;  ++j)  {  work2[j]  *=  diag[j]  /  dxNorm;  }  [CE]  illegal  start  of  expression  [FE]            AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  0;  if(rank  ==  0)  {  int  j  =  0;  for(int  j  =  0;  j  <  dxNorm;  ++j)  {  work2[j]  *=  diag[j]  /  dxNorm;  }  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  0;  if(rank  ==  0)  {  int  j  =  0;  for(int  j  =  0;  j  <  dxNorm;  ++j)  {  work2[j]  *=  diag[j]  /  dxNorm;  }	  double    parl    =    1;    double    parl    =    1;    if(rank    ==    0)    {    int    j    =    0;    for(int    j    =    0;    j    <    dxNorm;    ++j)    {    work1[j]    *=    diag[j]    /    dxNorm;    }    	non-compiled	[CE]  illegal  start  of  expression	81	None	replace
86	[BUG]  [BUGGY]  double  parl  =  0;  if(parl  ==  0)  {  int  j  =  0;  for(int  j  =  0;  j  <  dxNorm;  ++j)  {  work1[j]  *=  diag[j]  /  dxNorm;  }  [CE]  illegal  start  of  expression  [FE]              AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  0;  if(parl  ==  0)  {  int  j  =  0;  for(int  j  =  0;  j  <  dxNorm;  ++j)  {  work1[j]  *=  diag[j]  /  dxNorm;  }  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  0;  if(parl  ==  0)  {  int  j  =  0;  for(int  j  =  0;  j  <  dxNorm;  ++j)  {  work1[j]  *=  diag[j]  /  dxNorm;  }	  double    parl    =    1;    double    parl    =    1;    if(rank    ==    0)    {    int    j    =    0;    for(int    j    =    0;    j    <    dxNorm;    ++j)    {    work1[j]    *=    diag[j]    /    dxNorm;    }    	non-compiled	[CE]  illegal  start  of  expression	81	None	replace
87	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]                  AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  Math.abs(fp);  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	add	double  parl  =  Math.abs(fp);	  double    sPar    =    Math.abs(fp);    	compilable	  [FE]  AssertionFailedError  	44	4	replace
88	[BUG]  [BUGGY]  double  parl  =  Math.abs(fp);  [FE]  AssertionFailedError  [FE]                  AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  Math.abs(fp);  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  Math.abs(fp);	  double    sPar    =    Math.abs(fp);    	compilable	  [FE]  AssertionFailedError  	44	4	replace
89	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]                    AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  Math.abs(dxNorm);  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	add	double  parl  =  Math.abs(dxNorm);	  double    sPar    =    Math.abs(fp);    	compilable	  [FE]  AssertionFailedError  	44	4	replace
90	[BUG]  [BUGGY]  double  parl  =  Math.abs(dxNorm);  [FE]  AssertionFailedError  [FE]                    AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  Math.abs(dxNorm);  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  Math.abs(dxNorm);	  double    sPar    =    Math.abs(fp);    	compilable	  [FE]  AssertionFailedError  	44	4	replace
91	[BUG]  [BUGGY]  Double  parl  =  1;  [CE]  incompatible  types  [FE]          AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  Double  parl  =  1;  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	Double  parl  =  1;	  double    parl    =    1;    Double    parl    =    1;    	non-compiled	[CE]  incompatible  types	6	None	replace
92	[BUG]  [BUGGY]  double  parl  =  0.0;  for(int  j  =  0;  j  <  resolvedCols;  ++j)  {  int  diag[j]  =  work1[j]  /  dxNorm;  }  [CE]  ']'  expected  [FE]              AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  0.0;  for(int  j  =  0;  j  <  resolvedCols;  ++j)  {  int  diag[j]  =  work1[j]  /  dxNorm;  }  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  0.0;  for(int  j  =  0;  j  <  resolvedCols;  ++j)  {  int  diag[j]  =  work1[j]  /  dxNorm;  }	  double    parl    =    0;    for(int    j    =    0;    j    <    resolvedCols;    ++j)    {    int    diag[j]    =    work1[j]    /    dxNorm;    }    	non-compiled	[CE]  ']'  expected	65	None	replace
93	[BUG]  [BUGGY]  double  parl  =  0;  for(int  j  =  0;  j  <  resolvedCols;  ++j)  {  int  diag[j]  =  work1[j]  /  delta;  }  [CE]  ']'  expected  [FE]                AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  0;  for(int  j  =  0;  j  <  resolvedCols;  ++j)  {  int  diag[j]  =  work1[j]  /  delta;  }  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  0;  for(int  j  =  0;  j  <  resolvedCols;  ++j)  {  int  diag[j]  =  work1[j]  /  delta;  }	  double    parl    =    0;    for(int    j    =    0;    j    <    resolvedCols;    ++j)    {    int    diag[j]    =    work1[j]    /    dxNorm;    }    	non-compiled	[CE]  ']'  expected	65	None	replace
94	[BUG]  [BUGGY]  double  parl  =  Math.abs(fp  *  Math.abs(sum2));  [CE]  variable  sum2  might  not  have  been  initialized  [FE]                AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  Math.abs(fp  *  Math.abs(sum2));  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  Math.abs(fp  *  Math.abs(sum2));	  double    sPar    =    Math.abs(fp    *    Math.abs(lmPar));    	non-compiled	[CE]  variable  sum2  might  not  have  been  initialized	2	None	replace
95	[BUG]  [BUGGY]  double  sPar  =  Math.abs(fp  *  Math.abs(sum2));  [CE]  cannot  find  symbol  parl  [FE]                  AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  sPar  =  Math.abs(fp  *  Math.abs(sum2));  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  sPar  =  Math.abs(fp  *  Math.abs(sum2));	  double    sPar    =    Math.abs(fp    *    Math.abs(lmPar));    	non-compiled	[CE]  cannot  find  symbol  parl	2	None	replace
96	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]                      AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  Math.abs(fp  *  delta);  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	add	double  parl  =  Math.abs(fp  *  delta);	  double    sPar    =    Math.abs(fp    *    dxNorm);    	compilable	  [FE]  AssertionFailedError  	43	4	replace
97	[BUG]  [BUGGY]  double  parl  =  Math.abs(fp  *  delta);  [FE]  AssertionFailedError  [FE]                      AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  Math.abs(fp  *  delta);  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  Math.abs(fp  *  delta);	  double    sPar    =    Math.abs(fp    *    dxNorm);    	compilable	  [FE]  AssertionFailedError  	43	4	replace
98	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]                        AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  Math.abs(fp  *  lmPar);  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	add	double  parl  =  Math.abs(fp  *  lmPar);	  double    sPar    =    Math.abs(fp    *    dxNorm);    	compilable	  [FE]  AssertionFailedError  	43	2	replace
99	[BUG]  [BUGGY]  double  parl  =  Math.abs(fp  *  lmPar);  [FE]  AssertionFailedError  [FE]                        AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  Math.abs(fp  *  lmPar);  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  Math.abs(fp  *  lmPar);	  double    sPar    =    Math.abs(fp    *    dxNorm);    	compilable	  [FE]  AssertionFailedError  	43	2	replace
100	[BUG]  [BUGGY]  double  sPar  =  Math.abs(dp  -  dxNorm);  [CE]  cannot  find  symbol  dp  [FE]              AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  sPar  =  Math.abs(dp  -  dxNorm);  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  sPar  =  Math.abs(dp  -  dxNorm);	  double    sPar    =    Math.abs(lmpar    -    dxNorm);    	non-compiled	[CE]  cannot  find  symbol  dp	73	None	replace
101	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  Double  parl  =  0.0;  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	add	Double  parl  =  0.0;	  double    parl    =    0.0;    double    parl    =    0.0;    	compilable	  [FE]  AssertionFailedError  	24	2	replace
102	[BUG]  [BUGGY]  Double  parl  =  0.0;  [FE]  AssertionFailedError  [FE]        AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  Double  parl  =  0.0;  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	Double  parl  =  0.0;	  double    parl    =    0.0;    double    parl    =    0.0;    	compilable	  [FE]  AssertionFailedError  	24	2	replace
103	[BUG]  [BUGGY]  double  parl  =  0;  int  parl  =  0;  [CE]  variable  parl  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]            AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  0;  int  parl  =  0;  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  0;  int  parl  =  0;	  double    parl    =    1;    int    parl    =    1;    	non-compiled	[CE]  variable  parl  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	7	None	replace
104	[BUG]  [BUGGY]  int  parl  =  1;  [CE]  possible  loss  of  precision  [FE]              AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  int  parl  =  1;  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	int  parl  =  1;	  double    parl    =    1;    int    parl    =    1;    	non-compiled	[CE]  possible  loss  of  precision	7	None	replace
105	[BUG]  [BUGGY]  int  parl  =  0;  [CE]  possible  loss  of  precision  [FE]                AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  int  parl  =  0;  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	int  parl  =  0;	  double    parl    =    1;    int    parl    =    1;    	non-compiled	[CE]  possible  loss  of  precision	7	None	replace
106	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]                AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  Math.abs(fp  *  Math.abs(dxNorm  -  1));  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	add	double  parl  =  Math.abs(fp  *  Math.abs(dxNorm  -  1));	  double    sPar    =    Math.abs(dxNorm    *    Math.abs(fp    -    1));    	compilable	  [FE]  AssertionFailedError  	76	4	replace
107	[BUG]  [BUGGY]  double  parl  =  Math.abs(fp  *  Math.abs(dxNorm  -  1));  [FE]  AssertionFailedError  [FE]                AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  Math.abs(fp  *  Math.abs(dxNorm  -  1));  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  Math.abs(fp  *  Math.abs(dxNorm  -  1));	  double    sPar    =    Math.abs(dxNorm    *    Math.abs(fp    -    1));    	compilable	  [FE]  AssertionFailedError  	76	4	replace
108	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]                  AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  Math.abs(dxNorm  *  Math.abs(delta  -  1));  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	add	double  parl  =  Math.abs(dxNorm  *  Math.abs(delta  -  1));	  double    sPar    =    Math.abs(dxNorm    *    Math.abs(fp    -    1));    	compilable	  [FE]  AssertionFailedError  	76	4	replace
109	[BUG]  [BUGGY]  double  parl  =  Math.abs(dxNorm  *  Math.abs(delta  -  1));  [FE]  AssertionFailedError  [FE]                  AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  Math.abs(dxNorm  *  Math.abs(delta  -  1));  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  Math.abs(dxNorm  *  Math.abs(delta  -  1));	  double    sPar    =    Math.abs(dxNorm    *    Math.abs(fp    -    1));    	compilable	  [FE]  AssertionFailedError  	76	4	replace
110	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]                    AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  Math.abs(dxNorm  *  Math.abs(fp  -  1));  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	add	double  parl  =  Math.abs(dxNorm  *  Math.abs(fp  -  1));	  double    sPar    =    Math.abs(dxNorm    *    Math.abs(fp    -    1));    	compilable	  [FE]  AssertionFailedError  	76	4	replace
111	[BUG]  [BUGGY]  double  parl  =  Math.abs(dxNorm  *  Math.abs(fp  -  1));  [FE]  AssertionFailedError  [FE]                    AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  Math.abs(dxNorm  *  Math.abs(fp  -  1));  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  Math.abs(dxNorm  *  Math.abs(fp  -  1));	  double    sPar    =    Math.abs(dxNorm    *    Math.abs(fp    -    1));    	compilable	  [FE]  AssertionFailedError  	76	4	replace
112	[BUG]  [BUGGY]  double  sPar  =  Math.abs(fp  *  Math.abs(dxNorm  -  1));  [CE]  cannot  find  symbol  parl  [FE]                      AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  sPar  =  Math.abs(fp  *  Math.abs(dxNorm  -  1));  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  sPar  =  Math.abs(fp  *  Math.abs(dxNorm  -  1));	  double    sPar    =    Math.abs(dxNorm    *    Math.abs(fp    -    1));    	non-compiled	[CE]  cannot  find  symbol  parl	76	None	replace
113	[BUG]  [BUGGY]  double  parl  =  0.0;  for(int  j  =  0;  j  <  solveCols;  ++j)  {  int  diag[j]  =  work1[j]  *  dxNorm  /  dxNorm;  }  [CE]  ']'  expected  [FE]                    AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  0.0;  for(int  j  =  0;  j  <  solveCols;  ++j)  {  int  diag[j]  =  work1[j]  *  dxNorm  /  dxNorm;  }  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  0.0;  for(int  j  =  0;  j  <  solveCols;  ++j)  {  int  diag[j]  =  work1[j]  *  dxNorm  /  dxNorm;  }	  double    parl    =    0;    for(int    j    =    0;    j    <    solveCols;    ++j)    {    int    diag[j]    =    work1[j]    *    dxNorm    /    dxNorm;    }    	non-compiled	[CE]  ']'  expected	64	None	replace
114	[BUG]  [BUGGY]  double  parl  =  0;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  diag[j]  =  work2[j]  *  dxNorm;  [CE]  ']'  expected  [FE]                    AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  0;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  diag[j]  =  work2[j]  *  dxNorm;  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  0;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  diag[j]  =  work2[j]  *  dxNorm;	  double    parl    =    0;    for(int    j    =    0;    j    <    solvedCols;    ++j)    {    int    diag[j]    =    work1[j]    *    dxNorm;    	non-compiled	[CE]  ']'  expected	54	None	replace
115	[BUG]  [BUGGY]  if(dxNorm  ==  0.0)  {  double  parl  =  0.0;  }  [CE]  cannot  find  symbol  parl  [FE]        AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  if(dxNorm  ==  0.0)  {  double  parl  =  0.0;  }  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	if(dxNorm  ==  0.0)  {  double  parl  =  0.0;  }	  double    parl    =    0.0;    if(dxNorm    ==    0.0)    {    double    parl    =    0.0;    }    	non-compiled	[CE]  cannot  find  symbol  parl	90	None	replace
116	[BUG]  [BUGGY]  if(dxNorm  ==  0.0  ||  dxNorm  ==  0.0)  {  double  parl  =  0.0;  }  [CE]  cannot  find  symbol  parl  [FE]          AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  if(dxNorm  ==  0.0  ||  dxNorm  ==  0.0)  {  double  parl  =  0.0;  }  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	if(dxNorm  ==  0.0  ||  dxNorm  ==  0.0)  {  double  parl  =  0.0;  }	  double    parl    =    0.0;    if(dxNorm    ==    0.0)    {    double    parl    =    0.0;    }    	non-compiled	[CE]  cannot  find  symbol  parl	90	None	replace
117	[BUG]  [BUGGY]  double  parl  =  0;  for(int  j  =  0;  j  <  resolvedCols;  ++j)  {  int  diag[j]  =  work1[j]  *  dxNorm  /  delta;  }  [CE]  ']'  expected  [FE]                    AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  0;  for(int  j  =  0;  j  <  resolvedCols;  ++j)  {  int  diag[j]  =  work1[j]  *  dxNorm  /  delta;  }  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  0;  for(int  j  =  0;  j  <  resolvedCols;  ++j)  {  int  diag[j]  =  work1[j]  *  dxNorm  /  delta;  }	  double    parl    =    0;    for(int    j    =    0;    j    <    resolvedCols;    ++j)    {    int    diag[j]    =    work1[j]    *    dxNorm    /    dxNorm;    }    	non-compiled	[CE]  ']'  expected	87	None	replace
118	[BUG]  [BUGGY]  double  parl  =  0.0;  for(int  j  =  0;  j  <  resolvedCols;  ++j)  {  int  diag[j]  =  work1[j]  *  dxNorm  /  dxNorm;  }  [CE]  ']'  expected  [FE]                      AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  0.0;  for(int  j  =  0;  j  <  resolvedCols;  ++j)  {  int  diag[j]  =  work1[j]  *  dxNorm  /  dxNorm;  }  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  0.0;  for(int  j  =  0;  j  <  resolvedCols;  ++j)  {  int  diag[j]  =  work1[j]  *  dxNorm  /  dxNorm;  }	  double    parl    =    0;    for(int    j    =    0;    j    <    resolvedCols;    ++j)    {    int    diag[j]    =    work1[j]    *    dxNorm    /    dxNorm;    }    	non-compiled	[CE]  ']'  expected	87	None	replace
119	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]                  AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  Math.abs(dxNorm  -  delta);  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	add	double  parl  =  Math.abs(dxNorm  -  delta);	  double    sPar    =    Math.abs(delta    -    dxNorm);    	compilable	  [FE]  AssertionFailedError  	56	4	replace
120	[BUG]  [BUGGY]  double  parl  =  Math.abs(dxNorm  -  delta);  [FE]  AssertionFailedError  [FE]                  AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  Math.abs(dxNorm  -  delta);  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  Math.abs(dxNorm  -  delta);	  double    sPar    =    Math.abs(delta    -    dxNorm);    	compilable	  [FE]  AssertionFailedError  	56	4	replace
121	[BUG]  [BUGGY]  double  sPar  =  Math.abs(delta  /  dxNorm);  [CE]  cannot  find  symbol  parl  [FE]                    AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  sPar  =  Math.abs(delta  /  dxNorm);  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  sPar  =  Math.abs(delta  /  dxNorm);	  double    sPar    =    Math.abs(delta    -    dxNorm);    	non-compiled	[CE]  cannot  find  symbol  parl	56	None	replace
122	[BUG]  [BUGGY]  double  parl  =  0.0;  for(int  j  =  0;  j  <  solveCols;  ++j)  {  int  diag[j]  =  work1[j]  *  Math.PI  /  dxNorm;  }  [CE]  ']'  expected  [FE]                  AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  0.0;  for(int  j  =  0;  j  <  solveCols;  ++j)  {  int  diag[j]  =  work1[j]  *  Math.PI  /  dxNorm;  }  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  0.0;  for(int  j  =  0;  j  <  solveCols;  ++j)  {  int  diag[j]  =  work1[j]  *  Math.PI  /  dxNorm;  }	  double    parl    =    0;    for(int    j    =    0;    j    <    solveCols;    ++j)    {    int    diag[j]    =    work1[j]    *    Math.PI    /    dxNorm;    }    	non-compiled	[CE]  ']'  expected	72	None	replace
123	[BUG]  [BUGGY]  double  parl  =  0;  for(int  j  =  0;  j  <  solveCols;  ++j)  {  int  diag[j]  =  work1[j]  *  Math.PI  /  delta;  }  [CE]  ']'  expected  [FE]                    AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  0;  for(int  j  =  0;  j  <  solveCols;  ++j)  {  int  diag[j]  =  work1[j]  *  Math.PI  /  delta;  }  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  0;  for(int  j  =  0;  j  <  solveCols;  ++j)  {  int  diag[j]  =  work1[j]  *  Math.PI  /  delta;  }	  double    parl    =    0;    for(int    j    =    0;    j    <    solveCols;    ++j)    {    int    diag[j]    =    work1[j]    *    Math.PI    /    dxNorm;    }    	non-compiled	[CE]  ']'  expected	72	None	replace
124	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]                AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  Math.abs(fp  *  Math.abs(lmPar));  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	add	double  parl  =  Math.abs(fp  *  Math.abs(lmPar));	  double    sPar    =    Math.abs(lmPar    *    Math.abs(fp));    	compilable	  [FE]  AssertionFailedError  	40	2	replace
125	[BUG]  [BUGGY]  double  parl  =  Math.abs(fp  *  Math.abs(lmPar));  [FE]  AssertionFailedError  [FE]                AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  Math.abs(fp  *  Math.abs(lmPar));  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  Math.abs(fp  *  Math.abs(lmPar));	  double    sPar    =    Math.abs(lmPar    *    Math.abs(fp));    	compilable	  [FE]  AssertionFailedError  	40	2	replace
126	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]                  AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  Math.abs(lmPar  *  Math.abs(fp));  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	add	double  parl  =  Math.abs(lmPar  *  Math.abs(fp));	  double    sPar    =    Math.abs(lmPar    *    Math.abs(fp));    	compilable	  [FE]  AssertionFailedError  	40	2	replace
127	[BUG]  [BUGGY]  double  parl  =  Math.abs(lmPar  *  Math.abs(fp));  [FE]  AssertionFailedError  [FE]                  AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  Math.abs(lmPar  *  Math.abs(fp));  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  Math.abs(lmPar  *  Math.abs(fp));	  double    sPar    =    Math.abs(lmPar    *    Math.abs(fp));    	compilable	  [FE]  AssertionFailedError  	40	2	replace
128	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]                    AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  Math.abs(lmPar  *  Math.abs(delta));  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	add	double  parl  =  Math.abs(lmPar  *  Math.abs(delta));	  double    sPar    =    Math.abs(lmPar    *    Math.abs(fp));    	compilable	  [FE]  AssertionFailedError  	40	2	replace
129	[BUG]  [BUGGY]  double  parl  =  Math.abs(lmPar  *  Math.abs(delta));  [FE]  AssertionFailedError  [FE]                    AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  Math.abs(lmPar  *  Math.abs(delta));  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  Math.abs(lmPar  *  Math.abs(delta));	  double    sPar    =    Math.abs(lmPar    *    Math.abs(fp));    	compilable	  [FE]  AssertionFailedError  	40	2	replace
130	[BUG]  [BUGGY]  double  parl  =  0.0;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  diag[j]  =  work1[j]  *  Math.PI  /  delta;  }  [CE]  ']'  expected  [FE]                AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  0.0;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  diag[j]  =  work1[j]  *  Math.PI  /  delta;  }  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  0.0;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  diag[j]  =  work1[j]  *  Math.PI  /  delta;  }	  double    parl    =    0.0;    for(int    j    =    0;    j    <    solvedCols;    ++j)    {    int    diag[j]    =    work1[j]    *    Math.PI    /    dxNorm;    }    	non-compiled	[CE]  ']'  expected	57	None	replace
131	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]              AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  Math.abs(dxNorm  -  lmPar);  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	add	double  parl  =  Math.abs(dxNorm  -  lmPar);	  double    sPar    =    Math.abs(lmPar    -    dxNorm);    	compilable	  [FE]  AssertionFailedError  	10	4	replace
132	[BUG]  [BUGGY]  double  parl  =  Math.abs(dxNorm  -  lmPar);  [FE]  AssertionFailedError  [FE]              AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  Math.abs(dxNorm  -  lmPar);  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  Math.abs(dxNorm  -  lmPar);	  double    sPar    =    Math.abs(lmPar    -    dxNorm);    	compilable	  [FE]  AssertionFailedError  	10	4	replace
133	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]                AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  Math.abs(lmPar  -  delta);  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	add	double  parl  =  Math.abs(lmPar  -  delta);	  double    sPar    =    Math.abs(lmPar    -    dxNorm);    	compilable	  [FE]  AssertionFailedError  	10	2	replace
134	[BUG]  [BUGGY]  double  parl  =  Math.abs(lmPar  -  delta);  [FE]  AssertionFailedError  [FE]                AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  Math.abs(lmPar  -  delta);  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  Math.abs(lmPar  -  delta);	  double    sPar    =    Math.abs(lmPar    -    dxNorm);    	compilable	  [FE]  AssertionFailedError  	10	2	replace
135	[BUG]  [BUGGY]  double  parl  =  0.0;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  diag[j]  =  work2[j]  /  dxNorm;  }  [CE]  ']'  expected  [FE]                  AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  0.0;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  diag[j]  =  work2[j]  /  dxNorm;  }  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  0.0;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  diag[j]  =  work2[j]  /  dxNorm;  }	  double    parl    =    0;    for(int    j    =    0;    j    <    solvedCols;    ++j)    {    int    diag[j]    =    work2[j]    /    dxNorm;    }    	non-compiled	[CE]  ']'  expected	20	None	replace
136	[BUG]  [BUGGY]  double  parl  =  0;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  diag[j]  =  work2[j]  /  delta;  }  [CE]  ']'  expected  [FE]                    AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  0;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  diag[j]  =  work2[j]  /  delta;  }  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  0;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  diag[j]  =  work2[j]  /  delta;  }	  double    parl    =    0;    for(int    j    =    0;    j    <    solvedCols;    ++j)    {    int    diag[j]    =    work2[j]    /    dxNorm;    }    	non-compiled	[CE]  ']'  expected	20	None	replace
137	[BUG]  [BUGGY]  int  parl  =  1.0;  [CE]  possible  loss  of  precision  [FE]            AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  int  parl  =  1.0;  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	int  parl  =  1.0;	  double    parl    =    1.0;    int    parl    =    1.0;    	non-compiled	[CE]  possible  loss  of  precision	31	None	replace
138	[BUG]  [BUGGY]  Integer  parl  =  1.0;  [CE]  incompatible  types  [FE]              AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  Integer  parl  =  1.0;  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	Integer  parl  =  1.0;	  double    parl    =    1.0;    int    parl    =    1.0;    	non-compiled	[CE]  incompatible  types	31	None	replace
139	[BUG]  [BUGGY]  double  sPar  =  Math.abs(qy  /  delta);  [CE]  bad  operand  types  for  binary  operator  '/'  [FE]                  AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  sPar  =  Math.abs(qy  /  delta);  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  sPar  =  Math.abs(qy  /  delta);	  double    sPar    =    Math.abs(qy);    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '/'	61	None	replace
140	[BUG]  [BUGGY]  double  sPar  =  Math.abs(qy,  lmPar);  [CE]  no  suitable  method  found  for  abs(double[],double)  [FE]                    AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  sPar  =  Math.abs(qy,  lmPar);  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  sPar  =  Math.abs(qy,  lmPar);	  double    sPar    =    Math.abs(qy);    	non-compiled	[CE]  no  suitable  method  found  for  abs(double[],double)	61	None	replace
141	[BUG]  [BUGGY]  double  sPar  =  Math.abs(qy  -  delta);  [CE]  bad  operand  types  for  binary  operator  '-'  [FE]                      AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  sPar  =  Math.abs(qy  -  delta);  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  sPar  =  Math.abs(qy  -  delta);	  double    sPar    =    Math.abs(qy);    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '-'	61	None	replace
142	[BUG]  [BUGGY]  double  parl  =  0.5;  double  parl  =  0.5;  [CE]  variable  parl  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]    AssertionFailedError    [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  0.5;  double  parl  =  0.5;  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double    parl    =    0.5;    double  parl  =  0.5;	  	non-compiled	[CE]  variable  parl  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	16	None	add
143	[BUG]  [BUGGY]  double  parl  =  0.5;  Double  parl  =  0.5;  [CE]  variable  parl  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]      AssertionFailedError    [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  0.5;  Double  parl  =  0.5;  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double    parl    =    0.5;    Double  parl  =  0.5;	  	non-compiled	[CE]  variable  parl  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	16	None	add
144	[BUG]  [BUGGY]  double  parl  =  0.5;  int  parl  =  0.5;  [CE]  variable  parl  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]        AssertionFailedError    [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  0.5;  int  parl  =  0.5;  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double    parl    =    0.5;    int  parl  =  0.5;	  	non-compiled	[CE]  variable  parl  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	16	None	add
145	[BUG]  [BUGGY]  double  parl  =  0.5;  double  pl  =  0.5;  [CE]  variable  parl  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]          AssertionFailedError    [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  0.5;  double  pl  =  0.5;  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double    parl    =    0.5;    double  pl  =  0.5;	  	non-compiled	[CE]  variable  parl  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	16	None	add
146	[BUG]  [BUGGY]  double  parl  =  0;  for(int  j  =  0;  j  <  resolvedCols;  ++j)  {  int  diag[j]  =  work1[j]  *  Math.PI  /  delta;  }  [CE]  ']'  expected  [FE]                  AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  0;  for(int  j  =  0;  j  <  resolvedCols;  ++j)  {  int  diag[j]  =  work1[j]  *  Math.PI  /  delta;  }  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  0;  for(int  j  =  0;  j  <  resolvedCols;  ++j)  {  int  diag[j]  =  work1[j]  *  Math.PI  /  delta;  }	  double    parl    =    0;    for(int    j    =    0;    j    <    solvedCols;    ++j)    {    int    diag[j]    =    work1[j]    *    Math.PI    /    delta;    }    	non-compiled	[CE]  ']'  expected	58	None	replace
147	[BUG]  [BUGGY]  for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diag[pj]  /  dxNorm;  }  [CE]  cannot  find  symbol  pj  [FE]          AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diag[pj]  /  dxNorm;  }  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diag[pj]  /  dxNorm;  }	  double    parl    =    0.0;    if(dxNorm    ==    0)    {    double    parl    =    0.0;    }    else    {    for(int    j    =    0;    j    <    0;    ++j)    {    work1[j]    *=    diag[pj]    /    dxNorm;    }    	non-compiled	[CE]  cannot  find  symbol  pj	68	None	replace
148	[BUG]  [BUGGY]  double  parl  =  1.0;  if(dxNorm  ==  0.0)  {  for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diag[pj]  /  dxNorm;  }  [CE]  illegal  start  of  expression  [FE]            AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  1.0;  if(dxNorm  ==  0.0)  {  for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diag[pj]  /  dxNorm;  }  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  1.0;  if(dxNorm  ==  0.0)  {  for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diag[pj]  /  dxNorm;  }	  double    parl    =    0.0;    if(dxNorm    ==    0)    {    double    parl    =    0.0;    }    else    {    for(int    j    =    0;    j    <    0;    ++j)    {    work1[j]    *=    diag[pj]    /    dxNorm;    }    	non-compiled	[CE]  illegal  start  of  expression	68	None	replace
149	[BUG]  [BUGGY]  double  parl  =  0.0;  if(dxNorm  ==  0)  {  for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diag[pj]  /  dxNorm;  }  [CE]  illegal  start  of  expression  [FE]              AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  0.0;  if(dxNorm  ==  0)  {  for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diag[pj]  /  dxNorm;  }  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  0.0;  if(dxNorm  ==  0)  {  for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diag[pj]  /  dxNorm;  }	  double    parl    =    0.0;    if(dxNorm    ==    0)    {    double    parl    =    0.0;    }    else    {    for(int    j    =    0;    j    <    0;    ++j)    {    work1[j]    *=    diag[pj]    /    dxNorm;    }    	non-compiled	[CE]  illegal  start  of  expression	68	None	replace
150	[BUG]  [BUGGY]  double  parl  =  0.0;  if(dxNorm  ==  0)  {  for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diag[pj]  /  delta;  }  [CE]  illegal  start  of  expression  [FE]                AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  0.0;  if(dxNorm  ==  0)  {  for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diag[pj]  /  delta;  }  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  0.0;  if(dxNorm  ==  0)  {  for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diag[pj]  /  delta;  }	  double    parl    =    0.0;    if(dxNorm    ==    0)    {    double    parl    =    0.0;    }    else    {    for(int    j    =    0;    j    <    0;    ++j)    {    work1[j]    *=    diag[pj]    /    dxNorm;    }    	non-compiled	[CE]  illegal  start  of  expression	68	None	replace
151	[BUG]  [BUGGY]  Math  parl  =  1;  [CE]  incompatible  types  [FE]                AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  Math  parl  =  1;  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	Math  parl  =  1;	  double    parl    =    1;    Math    parl    =    1;    	non-compiled	[CE]  incompatible  types	9	None	replace
152	[BUG]  [BUGGY]  double  parl  =  0;  Math  parl  =  0;  [CE]  variable  parl  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]                  AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  0;  Math  parl  =  0;  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  0;  Math  parl  =  0;	  double    parl    =    1;    Math    parl    =    1;    	non-compiled	[CE]  variable  parl  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	9	None	replace
153	[BUG]  [BUGGY]  Math  parl  =  0;  [CE]  incompatible  types  [FE]                    AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  Math  parl  =  0;  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	Math  parl  =  0;	  double    parl    =    1;    Math    parl    =    1;    	non-compiled	[CE]  incompatible  types	9	None	replace
154	[BUG]  [BUGGY]  int  diag[j]  =  work1[j]  *  Math.PI  /  dxNorm  +  1;  [CE]  ']'  expected  [FE]                AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  int  diag[j]  =  work1[j]  *  Math.PI  /  dxNorm  +  1;  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	int  diag[j]  =  work1[j]  *  Math.PI  /  dxNorm  +  1;	  int    diag[j]    =    work1[j]    *    Math.PI    /    dxNorm;    	non-compiled	[CE]  ']'  expected	88	None	replace
155	[BUG]  [BUGGY]  int  diag[j]  =  work2[j]  *  Math.PI  /  dxNorm;  [CE]  ']'  expected  [FE]                  AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  int  diag[j]  =  work2[j]  *  Math.PI  /  dxNorm;  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	int  diag[j]  =  work2[j]  *  Math.PI  /  dxNorm;	  int    diag[j]    =    work1[j]    *    Math.PI    /    dxNorm;    	non-compiled	[CE]  ']'  expected	88	None	replace
156	[BUG]  [BUGGY]  int  diag[j]  =  work1[j]  *  Math.PI  /  fp;  [CE]  ']'  expected  [FE]                    AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  int  diag[j]  =  work1[j]  *  Math.PI  /  fp;  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	int  diag[j]  =  work1[j]  *  Math.PI  /  fp;	  int    diag[j]    =    work1[j]    *    Math.PI    /    dxNorm;    	non-compiled	[CE]  ']'  expected	88	None	replace
157	[BUG]  [BUGGY]  double  solvedCols  =  10.0;  [CE]  cannot  find  symbol  parl  [FE]          AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  solvedCols  =  10.0;  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  solvedCols  =  10.0;	  double    solvedCols    =    0.0;    	non-compiled	[CE]  cannot  find  symbol  parl	22	None	replace
158	[BUG]  [BUGGY]  double  lmPar  =  1.0;  [CE]  cannot  find  symbol  parl  [FE]        AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  lmPar  =  1.0;  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  lmPar  =  1.0;	  double    parl    =    1.0;    double    parl    =    1.0;    	non-compiled	[CE]  cannot  find  symbol  parl	29	None	replace
159	[BUG]  [BUGGY]          double    solvedCols    =    0;    double  solveCols  =  0;  double  solvedCols  =  0;  double  solveCols  =  0;  [CE]  variable  solvedCols  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]    AssertionFailedError    [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]          double    solvedCols    =    0;    double  solveCols  =  0;  double  solvedCols  =  0;  double  solveCols  =  0;  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	                double        solvedCols        =        0;        double    solveCols    =    0;    double  solvedCols  =  0;  double  solveCols  =  0;	  	non-compiled	[CE]  variable  solvedCols  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	51	None	add
160	[BUG]  [BUGGY]          double    solvedCols    =    0;    double  solveCols  =  0;  Double  solvedCols  =  0;  double  solveCols  =  0;  [CE]  variable  solvedCols  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]      AssertionFailedError    [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]          double    solvedCols    =    0;    double  solveCols  =  0;  Double  solvedCols  =  0;  double  solveCols  =  0;  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	                double        solvedCols        =        0;        double    solveCols    =    0;    Double  solvedCols  =  0;  double  solveCols  =  0;	  	non-compiled	[CE]  variable  solvedCols  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	51	None	add
161	[BUG]  [BUGGY]          double    solvedCols    =    0;    double  solveCols  =  0;  double  solveCols  =  0;  double  solveCols  =  0;  [CE]  variable  solveCols  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]        AssertionFailedError    [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]          double    solvedCols    =    0;    double  solveCols  =  0;  double  solveCols  =  0;  double  solveCols  =  0;  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	                double        solvedCols        =        0;        double    solveCols    =    0;    double  solveCols  =  0;  double  solveCols  =  0;	  	non-compiled	[CE]  variable  solveCols  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	51	None	add
162	[BUG]  [BUGGY]          double    solvedCols    =    0;    double  solveCols  =  0;  int  solvedCols  =  0;  double  solveCols  =  0;  [CE]  variable  solvedCols  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]          AssertionFailedError    [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]          double    solvedCols    =    0;    double  solveCols  =  0;  int  solvedCols  =  0;  double  solveCols  =  0;  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	                double        solvedCols        =        0;        double    solveCols    =    0;    int  solvedCols  =  0;  double  solveCols  =  0;	  	non-compiled	[CE]  variable  solvedCols  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	51	None	add
163	[BUG]  [BUGGY]  solvedCols  =  0;  [CE]  cannot  find  symbol  parl  [FE]    AssertionFailedError    [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  solvedCols  =  0;  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	solvedCols  =  0;	          double    solvedCols    =    0;    double    solveCols    =    0;    	non-compiled	[CE]  cannot  find  symbol  parl	52	None	replace
164	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  0.5  *  lmPar;  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	add	double  parl  =  0.5  *  lmPar;	  double    parl    =    0.5;    	compilable	  [FE]  AssertionFailedError  	17	2	replace
165	[BUG]  [BUGGY]  double  parl  =  0.5  *  lmPar;  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  0.5  *  lmPar;  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  0.5  *  lmPar;	  double    parl    =    0.5;    	compilable	  [FE]  AssertionFailedError  	17	2	replace
166	[BUG]  [BUGGY]  double  parl  =  0.0;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  diag[j]  =  work1[j]  /  delta;  }  [CE]  ']'  expected  [FE]                AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  0.0;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  diag[j]  =  work1[j]  /  delta;  }  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  0.0;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  diag[j]  =  work1[j]  /  delta;  }	  double    parl    =    0;    for(int    j    =    0;    j    <    solvedCols;    ++j)    {    int    diag[j]    =    work1[j]    /    delta;    }    	non-compiled	[CE]  ']'  expected	19	None	replace
167	[BUG]  [BUGGY]  for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diag[j]  /  dxNorm;  return;  }  [CE]  cannot  find  symbol  parl  [FE]              AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diag[j]  /  dxNorm;  return;  }  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diag[j]  /  dxNorm;  return;  }	  double    parl    =    0.0;    if(dxNorm    ==    0)    {    double    parl    =    0.0;    }    else    {    for(int    j    =    0;    j    <    0;    ++j)    {    work1[j]    *=    diag[j]    /    dxNorm;    return;    }    	non-compiled	[CE]  cannot  find  symbol  parl	70	None	replace
168	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]                AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  0.0;  for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diag[j]  /  dxNorm;  return;  }  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	add	double  parl  =  0.0;  for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diag[j]  /  dxNorm;  return;  }	  double    parl    =    0.0;    if(dxNorm    ==    0)    {    double    parl    =    0.0;    }    else    {    for(int    j    =    0;    j    <    0;    ++j)    {    work1[j]    *=    diag[j]    /    dxNorm;    return;    }    	compilable	  [FE]  AssertionFailedError  	70	2	replace
169	[BUG]  [BUGGY]  double  parl  =  0.0;  for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diag[j]  /  dxNorm;  return;  }  [FE]  AssertionFailedError  [FE]                AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  0.0;  for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diag[j]  /  dxNorm;  return;  }  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  0.0;  for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diag[j]  /  dxNorm;  return;  }	  double    parl    =    0.0;    if(dxNorm    ==    0)    {    double    parl    =    0.0;    }    else    {    for(int    j    =    0;    j    <    0;    ++j)    {    work1[j]    *=    diag[j]    /    dxNorm;    return;    }    	compilable	  [FE]  AssertionFailedError  	70	2	replace
170	[BUG]  [BUGGY]  double  parl  =  1.0;  if(dxNorm  ==  0.0)  {  for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diag[j]  /  dxNorm;  return;  }  [CE]  illegal  start  of  expression  [FE]                  AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  1.0;  if(dxNorm  ==  0.0)  {  for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diag[j]  /  dxNorm;  return;  }  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  1.0;  if(dxNorm  ==  0.0)  {  for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diag[j]  /  dxNorm;  return;  }	  double    parl    =    0.0;    if(dxNorm    ==    0)    {    double    parl    =    0.0;    }    else    {    for(int    j    =    0;    j    <    0;    ++j)    {    work1[j]    *=    diag[j]    /    dxNorm;    return;    }    	non-compiled	[CE]  illegal  start  of  expression	70	None	replace
171	[BUG]  [BUGGY]  double  parl  =  1.0;  if(dxNorm  ==  0)  {  for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diag[j]  /  dxNorm;  return;  }  [CE]  illegal  start  of  expression  [FE]                    AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  1.0;  if(dxNorm  ==  0)  {  for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diag[j]  /  dxNorm;  return;  }  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  1.0;  if(dxNorm  ==  0)  {  for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diag[j]  /  dxNorm;  return;  }	  double    parl    =    0.0;    if(dxNorm    ==    0)    {    double    parl    =    0.0;    }    else    {    for(int    j    =    0;    j    <    0;    ++j)    {    work1[j]    *=    diag[j]    /    dxNorm;    return;    }    	non-compiled	[CE]  illegal  start  of  expression	70	None	replace
172	[BUG]  [BUGGY]  double  parl  =  0.0;  if(fp  ==  0.0)  {  for(int  i  =  0;  i  <  dxNorm;  ++i)  {  sum2  +=  Math.pow(10.0,  dxNorm);  }  [CE]  illegal  start  of  expression  [FE]                AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  0.0;  if(fp  ==  0.0)  {  for(int  i  =  0;  i  <  dxNorm;  ++i)  {  sum2  +=  Math.pow(10.0,  dxNorm);  }  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  0.0;  if(fp  ==  0.0)  {  for(int  i  =  0;  i  <  dxNorm;  ++i)  {  sum2  +=  Math.pow(10.0,  dxNorm);  }	  double    parl    =    0.0;    if(rank    ==    0.0)    {    for(int    i    =    0;    i    <    dxNorm;    ++i)    {    sum2    +=    Math.pow(10.0,    dxNorm);    }    	non-compiled	[CE]  illegal  start  of  expression	28	None	replace
173	[BUG]  [BUGGY]  double  parl  =  0.0;  if(parl  ==  0.0)  {  for(int  i  =  0;  i  <  dxNorm;  ++i)  {  sum2  +=  Math.pow(10.0,  dxNorm);  }  [CE]  illegal  start  of  expression  [FE]                  AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  0.0;  if(parl  ==  0.0)  {  for(int  i  =  0;  i  <  dxNorm;  ++i)  {  sum2  +=  Math.pow(10.0,  dxNorm);  }  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  0.0;  if(parl  ==  0.0)  {  for(int  i  =  0;  i  <  dxNorm;  ++i)  {  sum2  +=  Math.pow(10.0,  dxNorm);  }	  double    parl    =    0.0;    if(rank    ==    0.0)    {    for(int    i    =    0;    i    <    dxNorm;    ++i)    {    sum2    +=    Math.pow(10.0,    dxNorm);    }    	non-compiled	[CE]  illegal  start  of  expression	28	None	replace
174	[BUG]  [BUGGY]  int  parl  =  0.0;  if(parl  ==  0.0)  {  for(int  i  =  0;  i  <  dxNorm;  ++i)  {  sum2  +=  Math.pow(10.0,  dxNorm);  }  [CE]  illegal  start  of  expression  [FE]                    AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  int  parl  =  0.0;  if(parl  ==  0.0)  {  for(int  i  =  0;  i  <  dxNorm;  ++i)  {  sum2  +=  Math.pow(10.0,  dxNorm);  }  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	int  parl  =  0.0;  if(parl  ==  0.0)  {  for(int  i  =  0;  i  <  dxNorm;  ++i)  {  sum2  +=  Math.pow(10.0,  dxNorm);  }	  double    parl    =    0.0;    if(rank    ==    0.0)    {    for(int    i    =    0;    i    <    dxNorm;    ++i)    {    sum2    +=    Math.pow(10.0,    dxNorm);    }    	non-compiled	[CE]  illegal  start  of  expression	28	None	replace
175	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  dxNorm;  ++i)  {  sum2  +=  Math.pow(10.0,  dxNorm);  }  [CE]  cannot  find  symbol  parl  [FE]                      AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  for(int  i  =  0;  i  <  dxNorm;  ++i)  {  sum2  +=  Math.pow(10.0,  dxNorm);  }  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	for(int  i  =  0;  i  <  dxNorm;  ++i)  {  sum2  +=  Math.pow(10.0,  dxNorm);  }	  double    parl    =    0.0;    if(rank    ==    0.0)    {    for(int    i    =    0;    i    <    dxNorm;    ++i)    {    sum2    +=    Math.pow(10.0,    dxNorm);    }    	non-compiled	[CE]  cannot  find  symbol  parl	28	None	replace
176	[BUG]  [BUGGY]  double  parl  =  10.0;  double  parl  =  10.0;  [CE]  variable  parl  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]    AssertionFailedError    [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  10.0;  double  parl  =  10.0;  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double    parl    =    10.0;    double  parl  =  10.0;	  	non-compiled	[CE]  variable  parl  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	79	None	add
177	[BUG]  [BUGGY]  double  parl  =  10.0;  Double  parl  =  10.0;  [CE]  variable  parl  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]      AssertionFailedError    [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  10.0;  Double  parl  =  10.0;  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double    parl    =    10.0;    Double  parl  =  10.0;	  	non-compiled	[CE]  variable  parl  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	79	None	add
178	[BUG]  [BUGGY]  double  parl  =  10.0;  int  parl  =  10.0;  [CE]  variable  parl  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]        AssertionFailedError    [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  10.0;  int  parl  =  10.0;  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double    parl    =    10.0;    int  parl  =  10.0;	  	non-compiled	[CE]  variable  parl  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	79	None	add
179	[BUG]  [BUGGY]  double  parl  =  10.0;  double  pl  =  10.0;  [CE]  variable  parl  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]          AssertionFailedError    [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  10.0;  double  pl  =  10.0;  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double    parl    =    10.0;    double  pl  =  10.0;	  	non-compiled	[CE]  variable  parl  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	79	None	add
180	[BUG]  [BUGGY]  int  solvedCols  =  0;  [CE]  cannot  find  symbol  parl  [FE]            AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  int  solvedCols  =  0;  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	int  solvedCols  =  0;	          double    solvedCols    =    0;    int    solvedCols    =    0;    	non-compiled	[CE]  cannot  find  symbol  parl	50	None	replace
181	[BUG]  [BUGGY]  Integer  solvedCols  =  0;  [CE]  cannot  find  symbol  parl  [FE]              AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  Integer  solvedCols  =  0;  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	Integer  solvedCols  =  0;	          double    solvedCols    =    0;    int    solvedCols    =    0;    	non-compiled	[CE]  cannot  find  symbol  parl	50	None	replace
182	[BUG]  [BUGGY]  double  parl  =  0;  if(rank  ==  0)  {  int  j  =  0;  for(int  j  =  0;  j  <  dxNorm;  ++j)  {  work1[pj]  *=  diag[j]  /  dxNorm;  }  [CE]  illegal  start  of  expression  [FE]            AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  0;  if(rank  ==  0)  {  int  j  =  0;  for(int  j  =  0;  j  <  dxNorm;  ++j)  {  work1[pj]  *=  diag[j]  /  dxNorm;  }  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  0;  if(rank  ==  0)  {  int  j  =  0;  for(int  j  =  0;  j  <  dxNorm;  ++j)  {  work1[pj]  *=  diag[j]  /  dxNorm;  }	  double    parl    =    1;    double    parl    =    1;    if(rank    ==    0)    {    int    j    =    0;    for(int    j    =    0;    j    <    dxNorm;    ++j)    {    work1[pj]    *=    diag[j]    /    dxNorm;    }    	non-compiled	[CE]  illegal  start  of  expression	83	None	replace
183	[BUG]  [BUGGY]  double  parl  =  1.0;  if(rank  ==  0)  {  int  j  =  0;  for(int  j  =  0;  j  <  dxNorm;  ++j)  {  work1[pj]  *=  diag[j]  /  dxNorm;  }  [CE]  illegal  start  of  expression  [FE]              AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  1.0;  if(rank  ==  0)  {  int  j  =  0;  for(int  j  =  0;  j  <  dxNorm;  ++j)  {  work1[pj]  *=  diag[j]  /  dxNorm;  }  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  1.0;  if(rank  ==  0)  {  int  j  =  0;  for(int  j  =  0;  j  <  dxNorm;  ++j)  {  work1[pj]  *=  diag[j]  /  dxNorm;  }	  double    parl    =    1;    double    parl    =    1;    if(rank    ==    0)    {    int    j    =    0;    for(int    j    =    0;    j    <    dxNorm;    ++j)    {    work1[pj]    *=    diag[j]    /    dxNorm;    }    	non-compiled	[CE]  illegal  start  of  expression	83	None	replace
184	[BUG]  [BUGGY]  double  parl  =  0;  if(parl  ==  0)  {  int  j  =  0;  for(int  j  =  0;  j  <  dxNorm;  ++j)  {  work1[pj]  *=  diag[j]  /  dxNorm;  }  [CE]  illegal  start  of  expression  [FE]                AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  0;  if(parl  ==  0)  {  int  j  =  0;  for(int  j  =  0;  j  <  dxNorm;  ++j)  {  work1[pj]  *=  diag[j]  /  dxNorm;  }  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  0;  if(parl  ==  0)  {  int  j  =  0;  for(int  j  =  0;  j  <  dxNorm;  ++j)  {  work1[pj]  *=  diag[j]  /  dxNorm;  }	  double    parl    =    1;    double    parl    =    1;    if(rank    ==    0)    {    int    j    =    0;    for(int    j    =    0;    j    <    dxNorm;    ++j)    {    work1[pj]    *=    diag[j]    /    dxNorm;    }    	non-compiled	[CE]  illegal  start  of  expression	83	None	replace
185	[BUG]  [BUGGY]  if(dxNorm  ==  0.0)  {  double  parl  =  0.0;  }  else  {  for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diag[j]  /  delta;  }  [CE]  illegal  start  of  expression  [FE]            AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  if(dxNorm  ==  0.0)  {  double  parl  =  0.0;  }  else  {  for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diag[j]  /  delta;  }  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	if(dxNorm  ==  0.0)  {  double  parl  =  0.0;  }  else  {  for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diag[j]  /  delta;  }	  double    parl    =    0.0;    if(dxNorm    ==    0)    {    double    parl    =    0.0;    }    else    {    for(int    j    =    0;    j    <    0;    ++j)    {    work1[j]    *=    diag[j]    /    delta;    }    	non-compiled	[CE]  illegal  start  of  expression	69	None	replace
186	[BUG]  [BUGGY]  double  parl  =  1.0;  if(dxNorm  ==  0)  {  for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diag[j]  /  delta;  }  [CE]  illegal  start  of  expression  [FE]              AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  1.0;  if(dxNorm  ==  0)  {  for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diag[j]  /  delta;  }  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  1.0;  if(dxNorm  ==  0)  {  for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diag[j]  /  delta;  }	  double    parl    =    0.0;    if(dxNorm    ==    0)    {    double    parl    =    0.0;    }    else    {    for(int    j    =    0;    j    <    0;    ++j)    {    work1[j]    *=    diag[j]    /    delta;    }    	non-compiled	[CE]  illegal  start  of  expression	69	None	replace
187	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]                AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  0.0;  for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diag[j]  /  delta;  }  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	add	double  parl  =  0.0;  for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diag[j]  /  delta;  }	  double    parl    =    0.0;    if(dxNorm    ==    0)    {    double    parl    =    0.0;    }    else    {    for(int    j    =    0;    j    <    0;    ++j)    {    work1[j]    *=    diag[j]    /    delta;    }    	compilable	  [FE]  AssertionFailedError  	69	2	replace
188	[BUG]  [BUGGY]  double  parl  =  0.0;  for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diag[j]  /  delta;  }  [FE]  AssertionFailedError  [FE]                AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  0.0;  for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diag[j]  /  delta;  }  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  0.0;  for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diag[j]  /  delta;  }	  double    parl    =    0.0;    if(dxNorm    ==    0)    {    double    parl    =    0.0;    }    else    {    for(int    j    =    0;    j    <    0;    ++j)    {    work1[j]    *=    diag[j]    /    delta;    }    	compilable	  [FE]  AssertionFailedError  	69	2	replace
189	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]              AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  0;  double  pl  =  0;  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	add	double  parl  =  0;  double  pl  =  0;	  double    parl    =    1;    double    pl    =    1;    	compilable	  [FE]  AssertionFailedError  	8	2	replace
190	[BUG]  [BUGGY]  double  parl  =  0;  double  pl  =  0;  [FE]  AssertionFailedError  [FE]              AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  0;  double  pl  =  0;  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  0;  double  pl  =  0;	  double    parl    =    1;    double    pl    =    1;    	compilable	  [FE]  AssertionFailedError  	8	2	replace
191	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  Math.abs(dxNorm  *  Math.abs(fp  -  delta));  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	add	double  parl  =  Math.abs(dxNorm  *  Math.abs(fp  -  delta));	  double    parl    =    Math.abs(dxNorm    *    Math.abs(fp));    	compilable	  [FE]  AssertionFailedError  	4	4	replace
192	[BUG]  [BUGGY]  double  parl  =  Math.abs(dxNorm  *  Math.abs(fp  -  delta));  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  Math.abs(dxNorm  *  Math.abs(fp  -  delta));  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  Math.abs(dxNorm  *  Math.abs(fp  -  delta));	  double    parl    =    Math.abs(dxNorm    *    Math.abs(fp));    	compilable	  [FE]  AssertionFailedError  	4	4	replace
193	[BUG]  [BUGGY]  double  parl  =  0;  if(rank  ==  0)  {  int  j  =  0;  for(int  j  =  0;  j  <  dxNorm;  ++j)  {  work1[j]  *=  work1[j]  /  dxNorm;  }  [CE]  illegal  start  of  expression  [FE]          AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  0;  if(rank  ==  0)  {  int  j  =  0;  for(int  j  =  0;  j  <  dxNorm;  ++j)  {  work1[j]  *=  work1[j]  /  dxNorm;  }  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  0;  if(rank  ==  0)  {  int  j  =  0;  for(int  j  =  0;  j  <  dxNorm;  ++j)  {  work1[j]  *=  work1[j]  /  dxNorm;  }	  double    parl    =    1;    double    parl    =    1;    if(rank    ==    0)    {    int    j    =    0;    for(int    j    =    0;    j    <    dxNorm;    ++j)    {    work1[j]    *=    work1[j]    /    dxNorm;    }    	non-compiled	[CE]  illegal  start  of  expression	82	None	replace
194	[BUG]  [BUGGY]  double  parl  =  1.0;  if(rank  ==  0)  {  int  j  =  0;  for(int  j  =  0;  j  <  dxNorm;  ++j)  {  work1[j]  *=  work1[j]  /  dxNorm;  }  [CE]  illegal  start  of  expression  [FE]            AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  1.0;  if(rank  ==  0)  {  int  j  =  0;  for(int  j  =  0;  j  <  dxNorm;  ++j)  {  work1[j]  *=  work1[j]  /  dxNorm;  }  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  1.0;  if(rank  ==  0)  {  int  j  =  0;  for(int  j  =  0;  j  <  dxNorm;  ++j)  {  work1[j]  *=  work1[j]  /  dxNorm;  }	  double    parl    =    1;    double    parl    =    1;    if(rank    ==    0)    {    int    j    =    0;    for(int    j    =    0;    j    <    dxNorm;    ++j)    {    work1[j]    *=    work1[j]    /    dxNorm;    }    	non-compiled	[CE]  illegal  start  of  expression	82	None	replace
195	[BUG]  [BUGGY]  for(int  j  =  0;  j  <  dxNorm;  ++j)  {  work1[j]  *=  work1[j]  /  dxNorm;  }  [CE]  cannot  find  symbol  parl  [FE]              AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  for(int  j  =  0;  j  <  dxNorm;  ++j)  {  work1[j]  *=  work1[j]  /  dxNorm;  }  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	for(int  j  =  0;  j  <  dxNorm;  ++j)  {  work1[j]  *=  work1[j]  /  dxNorm;  }	  double    parl    =    1;    double    parl    =    1;    if(rank    ==    0)    {    int    j    =    0;    for(int    j    =    0;    j    <    dxNorm;    ++j)    {    work1[j]    *=    work1[j]    /    dxNorm;    }    	non-compiled	[CE]  cannot  find  symbol  parl	82	None	replace
196	[BUG]  [BUGGY]  double  parl  =  0;  if(parl  ==  0)  {  int  j  =  0;  for(int  j  =  0;  j  <  dxNorm;  ++j)  {  work1[j]  *=  work1[j]  /  dxNorm;  }  [CE]  illegal  start  of  expression  [FE]                AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  0;  if(parl  ==  0)  {  int  j  =  0;  for(int  j  =  0;  j  <  dxNorm;  ++j)  {  work1[j]  *=  work1[j]  /  dxNorm;  }  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  0;  if(parl  ==  0)  {  int  j  =  0;  for(int  j  =  0;  j  <  dxNorm;  ++j)  {  work1[j]  *=  work1[j]  /  dxNorm;  }	  double    parl    =    1;    double    parl    =    1;    if(rank    ==    0)    {    int    j    =    0;    for(int    j    =    0;    j    <    dxNorm;    ++j)    {    work1[j]    *=    work1[j]    /    dxNorm;    }    	non-compiled	[CE]  illegal  start  of  expression	82	None	replace
197	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]            AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  Math.abs(dxNorm  -  fp);  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	add	double  parl  =  Math.abs(dxNorm  -  fp);	  double    sPar    =    Math.abs(fp    -    dxNorm);    	compilable	  [FE]  AssertionFailedError  	33	2	replace
198	[BUG]  [BUGGY]  double  parl  =  Math.abs(dxNorm  -  fp);  [FE]  AssertionFailedError  [FE]            AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  Math.abs(dxNorm  -  fp);  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  Math.abs(dxNorm  -  fp);	  double    sPar    =    Math.abs(fp    -    dxNorm);    	compilable	  [FE]  AssertionFailedError  	33	2	replace
199	[BUG]  [BUGGY]  double  sPar  =  Math.abs(sum2  -  dxNorm,  dxNorm);  [CE]  no  suitable  method  found  for  abs(double,double)  [FE]                AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  sPar  =  Math.abs(sum2  -  dxNorm,  dxNorm);  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  sPar  =  Math.abs(sum2  -  dxNorm,  dxNorm);	  double    sPar    =    Math.abs(dxNorm    -    delta,    sum2);    	non-compiled	[CE]  no  suitable  method  found  for  abs(double,double)	66	None	replace
200	[BUG]  [BUGGY]  double  sPar  =  Math.abs(sum2  -  dxNorm,  lmPar);  [CE]  no  suitable  method  found  for  abs(double,double)  [FE]                  AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  sPar  =  Math.abs(sum2  -  dxNorm,  lmPar);  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  sPar  =  Math.abs(sum2  -  dxNorm,  lmPar);	  double    sPar    =    Math.abs(dxNorm    -    delta,    sum2);    	non-compiled	[CE]  no  suitable  method  found  for  abs(double,double)	66	None	replace
201	[BUG]  [BUGGY]  double  sPar  =  Math.abs(lmPar  -  delta,  sum2);  [CE]  no  suitable  method  found  for  abs(double,double)  [FE]                    AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  sPar  =  Math.abs(lmPar  -  delta,  sum2);  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  sPar  =  Math.abs(lmPar  -  delta,  sum2);	  double    sPar    =    Math.abs(dxNorm    -    delta,    sum2);    	non-compiled	[CE]  no  suitable  method  found  for  abs(double,double)	66	None	replace
202	[BUG]  [BUGGY]  double  sPar  =  Math.abs(sum2  -  dxNorm,  fp);  [CE]  no  suitable  method  found  for  abs(double,double)  [FE]                      AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  sPar  =  Math.abs(sum2  -  dxNorm,  fp);  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  sPar  =  Math.abs(sum2  -  dxNorm,  fp);	  double    sPar    =    Math.abs(dxNorm    -    delta,    sum2);    	non-compiled	[CE]  no  suitable  method  found  for  abs(double,double)	66	None	replace
203	[BUG]  [BUGGY]  if(dxNorm  ==  0)  {  double  parl  =  0.0;  }  [CE]  cannot  find  symbol  parl  [FE]            AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  if(dxNorm  ==  0)  {  double  parl  =  0.0;  }  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	if(dxNorm  ==  0)  {  double  parl  =  0.0;  }	  double    parl    =    0.0;    if(dxNorm    ==    0)    {    double    parl    =    0.0;    }    	non-compiled	[CE]  cannot  find  symbol  parl	92	None	replace
204	[BUG]  [BUGGY]  int  parl  =  0.0;  if(rank  ==  0.0)  {  for(int  i  =  0;  i  <  dxNorm;  ++i)  {  parl  =  0.0;  }  [CE]  illegal  start  of  expression  [FE]          AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  int  parl  =  0.0;  if(rank  ==  0.0)  {  for(int  i  =  0;  i  <  dxNorm;  ++i)  {  parl  =  0.0;  }  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	int  parl  =  0.0;  if(rank  ==  0.0)  {  for(int  i  =  0;  i  <  dxNorm;  ++i)  {  parl  =  0.0;  }	  double    parl    =    0.0;    if(rank    ==    0.0)    {    for(int    i    =    0;    i    <    dxNorm;    ++i)    {    double    parl    =    0.0;    }    	non-compiled	[CE]  illegal  start  of  expression	25	None	replace
205	[BUG]  [BUGGY]  int  parl  =  0.0;  if(parl  ==  0.0)  {  for(int  i  =  0;  i  <  dxNorm;  ++i)  {  parl  =  0.0;  }  [CE]  illegal  start  of  expression  [FE]            AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  int  parl  =  0.0;  if(parl  ==  0.0)  {  for(int  i  =  0;  i  <  dxNorm;  ++i)  {  parl  =  0.0;  }  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	int  parl  =  0.0;  if(parl  ==  0.0)  {  for(int  i  =  0;  i  <  dxNorm;  ++i)  {  parl  =  0.0;  }	  double    parl    =    0.0;    if(rank    ==    0.0)    {    for(int    i    =    0;    i    <    dxNorm;    ++i)    {    double    parl    =    0.0;    }    	non-compiled	[CE]  illegal  start  of  expression	25	None	replace
206	[BUG]  [BUGGY]  int  parl  =  0.0;  if(rank  ==  0.0)  {  for(int  i  =  0;  i  <  dxNorm;  ++i)  {  double  parl  =  0.0;  }  [CE]  illegal  start  of  expression  [FE]              AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  int  parl  =  0.0;  if(rank  ==  0.0)  {  for(int  i  =  0;  i  <  dxNorm;  ++i)  {  double  parl  =  0.0;  }  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	int  parl  =  0.0;  if(rank  ==  0.0)  {  for(int  i  =  0;  i  <  dxNorm;  ++i)  {  double  parl  =  0.0;  }	  double    parl    =    0.0;    if(rank    ==    0.0)    {    for(int    i    =    0;    i    <    dxNorm;    ++i)    {    double    parl    =    0.0;    }    	non-compiled	[CE]  illegal  start  of  expression	25	None	replace
207	[BUG]  [BUGGY]  double  parl  =  0.0;  for(int  j  =  0;  j  <  resolvedCols;  ++j)  {  int  diag[j]  =  work1[j]  *  Math.PI  /  dxNorm;  }  [CE]  ']'  expected  [FE]                AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  0.0;  for(int  j  =  0;  j  <  resolvedCols;  ++j)  {  int  diag[j]  =  work1[j]  *  Math.PI  /  dxNorm;  }  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  0.0;  for(int  j  =  0;  j  <  resolvedCols;  ++j)  {  int  diag[j]  =  work1[j]  *  Math.PI  /  dxNorm;  }	  double    parl    =    0;    for(int    j    =    0;    j    <    resolvedCols;    ++j)    {    int    diag[j]    =    work1[j]    *    Math.PI    /    dxNorm;    }    	non-compiled	[CE]  ']'  expected	71	None	replace
208	[BUG]  [BUGGY]  double  parl  =  0.0;  if(fp  ==  0.0)  {  for(int  j  =  0;  j  <  dxNorm;  ++j)  {  sum2  =  0.0;  }  [CE]  illegal  start  of  expression  [FE]            AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  0.0;  if(fp  ==  0.0)  {  for(int  j  =  0;  j  <  dxNorm;  ++j)  {  sum2  =  0.0;  }  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  0.0;  if(fp  ==  0.0)  {  for(int  j  =  0;  j  <  dxNorm;  ++j)  {  sum2  =  0.0;  }	  double    parl    =    0.0;    if(rank    ==    0.0)    {    for(int    j    =    0;    j    <    dxNorm;    ++j)    {    sum2    =    0.0;    }    	non-compiled	[CE]  illegal  start  of  expression	26	None	replace
209	[BUG]  [BUGGY]  double  parl  =  1.0;  if(rank  ==  0.0)  {  for(int  j  =  0;  j  <  dxNorm;  ++j)  {  sum2  =  0.0;  }  [CE]  illegal  start  of  expression  [FE]              AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  1.0;  if(rank  ==  0.0)  {  for(int  j  =  0;  j  <  dxNorm;  ++j)  {  sum2  =  0.0;  }  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  1.0;  if(rank  ==  0.0)  {  for(int  j  =  0;  j  <  dxNorm;  ++j)  {  sum2  =  0.0;  }	  double    parl    =    0.0;    if(rank    ==    0.0)    {    for(int    j    =    0;    j    <    dxNorm;    ++j)    {    sum2    =    0.0;    }    	non-compiled	[CE]  illegal  start  of  expression	26	None	replace
210	[BUG]  [BUGGY]  double  parl  =  0.0;  if(parl  ==  0.0)  {  for(int  j  =  0;  j  <  dxNorm;  ++j)  {  sum2  =  0.0;  }  [CE]  illegal  start  of  expression  [FE]                AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  0.0;  if(parl  ==  0.0)  {  for(int  j  =  0;  j  <  dxNorm;  ++j)  {  sum2  =  0.0;  }  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  0.0;  if(parl  ==  0.0)  {  for(int  j  =  0;  j  <  dxNorm;  ++j)  {  sum2  =  0.0;  }	  double    parl    =    0.0;    if(rank    ==    0.0)    {    for(int    j    =    0;    j    <    dxNorm;    ++j)    {    sum2    =    0.0;    }    	non-compiled	[CE]  illegal  start  of  expression	26	None	replace
211	[BUG]  [BUGGY]  double  parl  =  0.0;  if(dxNorm  ==  0.0)  {  for(int  j  =  0;  j  <  dxNorm;  ++j)  {  sum2  =  0.0;  }  [CE]  illegal  start  of  expression  [FE]                  AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  0.0;  if(dxNorm  ==  0.0)  {  for(int  j  =  0;  j  <  dxNorm;  ++j)  {  sum2  =  0.0;  }  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  0.0;  if(dxNorm  ==  0.0)  {  for(int  j  =  0;  j  <  dxNorm;  ++j)  {  sum2  =  0.0;  }	  double    parl    =    0.0;    if(rank    ==    0.0)    {    for(int    j    =    0;    j    <    dxNorm;    ++j)    {    sum2    =    0.0;    }    	non-compiled	[CE]  illegal  start  of  expression	26	None	replace
212	[BUG]  [BUGGY]  double  sPar  =  Math.abs(lmPar  /  dxNorm);  [CE]  cannot  find  symbol  parl  [FE]              AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  sPar  =  Math.abs(lmPar  /  dxNorm);  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  sPar  =  Math.abs(lmPar  /  dxNorm);	  double    sPar    =    Math.abs(lmPar    -    dxNorm);    	non-compiled	[CE]  cannot  find  symbol  parl	10	None	replace
213	[BUG]  [BUGGY]  double  sPar  =  Math.abs(delta);  [CE]  cannot  find  symbol  parl  [FE]                      AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  sPar  =  Math.abs(delta);  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  sPar  =  Math.abs(delta);	  double    sPar    =    Math.abs(dxNorm);    	non-compiled	[CE]  cannot  find  symbol  parl	46	None	replace
214	[BUG]  [BUGGY]  double  sPar  =  Math.abs(lmPar  *  Math.abs(dxNorm));  [CE]  cannot  find  symbol  parl  [FE]                    AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  sPar  =  Math.abs(lmPar  *  Math.abs(dxNorm));  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  sPar  =  Math.abs(lmPar  *  Math.abs(dxNorm));	  double    sPar    =    Math.abs(fp    *    Math.abs(dxNorm));    	non-compiled	[CE]  cannot  find  symbol  parl	42	None	replace
215	[BUG]  [BUGGY]  double  parPar  =  Math.abs(lmPar  -  fp);  [CE]  cannot  find  symbol  parl  [FE]                  AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parPar  =  Math.abs(lmPar  -  fp);  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parPar  =  Math.abs(lmPar  -  fp);	  double    sPar    =    Math.abs(fp    -    lmPar);    	non-compiled	[CE]  cannot  find  symbol  parl	12	None	replace
216	[BUG]  [BUGGY]  double  par  =  Math.abs(lmPar  -  fp);  [CE]  cannot  find  symbol  parl  [FE]                    AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  par  =  Math.abs(lmPar  -  fp);  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  par  =  Math.abs(lmPar  -  fp);	  double    sPar    =    Math.abs(fp    -    lmPar);    	non-compiled	[CE]  cannot  find  symbol  parl	12	None	replace
217	[BUG]  [BUGGY]  double  parl  =  1.0;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  diag[j]  =  work1[j]  *  Math.PI  /  dxNorm;  }  [CE]  ']'  expected  [FE]                AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  1.0;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  diag[j]  =  work1[j]  *  Math.PI  /  dxNorm;  }  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  1.0;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  diag[j]  =  work1[j]  *  Math.PI  /  dxNorm;  }	  double    parl    =    0.0;    for(int    j    =    0;    j    <    solvedCols;    ++j)    {    int    diag[j]    =    work1[j]    *    Math.PI    /    dxNorm;    }    	non-compiled	[CE]  ']'  expected	57	None	replace
218	[BUG]  [BUGGY]  double  sPar  =  3;  [CE]  cannot  find  symbol  parl  [FE]                    AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  sPar  =  3;  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  sPar  =  3;	  double    sPar    =    1;    	non-compiled	[CE]  cannot  find  symbol  parl	38	None	replace
219	[BUG]  [BUGGY]  double  parl  =  0;  if(rank  ==  s)  {  for(int  j  =  0;  j  <  dxNorm;  ++j)  {  work1[j]  *=  permutation[j]  /  dxNorm;  }  [CE]  illegal  start  of  expression  [FE]              AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  0;  if(rank  ==  s)  {  for(int  j  =  0;  j  <  dxNorm;  ++j)  {  work1[j]  *=  permutation[j]  /  dxNorm;  }  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  0;  if(rank  ==  s)  {  for(int  j  =  0;  j  <  dxNorm;  ++j)  {  work1[j]  *=  permutation[j]  /  dxNorm;  }	  double    parl    =    1;    double    parl    =    1;    if(rank    ==    s)    {    for(int    j    =    0;    j    <    dxNorm;    ++j)    {    work1[j]    *=    diag[j]    /    dxNorm;    }    	non-compiled	[CE]  illegal  start  of  expression	84	None	replace
220	[BUG]  [BUGGY]  double  parl  =  0;  if(parl  ==  s)  {  for(int  j  =  0;  j  <  dxNorm;  ++j)  {  work1[j]  *=  diag[j]  /  dxNorm;  }  [CE]  illegal  start  of  expression  [FE]                AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  0;  if(parl  ==  s)  {  for(int  j  =  0;  j  <  dxNorm;  ++j)  {  work1[j]  *=  diag[j]  /  dxNorm;  }  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  0;  if(parl  ==  s)  {  for(int  j  =  0;  j  <  dxNorm;  ++j)  {  work1[j]  *=  diag[j]  /  dxNorm;  }	  double    parl    =    1;    double    parl    =    1;    if(rank    ==    s)    {    for(int    j    =    0;    j    <    dxNorm;    ++j)    {    work1[j]    *=    diag[j]    /    dxNorm;    }    	non-compiled	[CE]  illegal  start  of  expression	84	None	replace
221	[BUG]  [BUGGY]  int  diag[j]  =  work1[j]  *  Math.PI  /  lmPar;  [CE]  ']'  expected  [FE]                AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  int  diag[j]  =  work1[j]  *  Math.PI  /  lmPar;  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	int  diag[j]  =  work1[j]  *  Math.PI  /  lmPar;	  int    diag[j]    =    work1[j]    *    Math.PI    /    dxNorm;    	non-compiled	[CE]  ']'  expected	88	None	replace
222	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  Math.abs(dxNorm  *  Math.abs(delta));  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	add	double  parl  =  Math.abs(dxNorm  *  Math.abs(delta));	  double    parl    =    Math.abs(dxNorm    *    Math.abs(fp));    	compilable	  [FE]  AssertionFailedError  	4	4	replace
223	[BUG]  [BUGGY]  double  parl  =  Math.abs(dxNorm  *  Math.abs(delta));  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  Math.abs(dxNorm  *  Math.abs(delta));  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  Math.abs(dxNorm  *  Math.abs(delta));	  double    parl    =    Math.abs(dxNorm    *    Math.abs(fp));    	compilable	  [FE]  AssertionFailedError  	4	4	replace
224	[BUG]  [BUGGY]  double  parl  =  0;  for(int  j  =  0;  j  <  solveCols;  ++j)  {  int  diag[j]  =  work2[j]  *  Math.PI  /  dxNorm;  }  [CE]  ']'  expected  [FE]                  AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  0;  for(int  j  =  0;  j  <  solveCols;  ++j)  {  int  diag[j]  =  work2[j]  *  Math.PI  /  dxNorm;  }  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  0;  for(int  j  =  0;  j  <  solveCols;  ++j)  {  int  diag[j]  =  work2[j]  *  Math.PI  /  dxNorm;  }	  double    parl    =    0;    for(int    j    =    0;    j    <    solveCols;    ++j)    {    int    diag[j]    =    work1[j]    *    Math.PI    /    dxNorm;    }    	non-compiled	[CE]  ']'  expected	72	None	replace
225	[BUG]  [BUGGY]  double  parl  =  0;  for(int  j  =  0;  j  <  resolvedCols;  ++j)  {  int  diag[j]  =  work2[j]  *  Math.PI  /  dxNorm;  }  [CE]  ']'  expected  [FE]                    AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  0;  for(int  j  =  0;  j  <  resolvedCols;  ++j)  {  int  diag[j]  =  work2[j]  *  Math.PI  /  dxNorm;  }  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  0;  for(int  j  =  0;  j  <  resolvedCols;  ++j)  {  int  diag[j]  =  work2[j]  *  Math.PI  /  dxNorm;  }	  double    parl    =    0;    for(int    j    =    0;    j    <    solvedCols;    ++j)    {    int    diag[j]    =    work2[j]    *    Math.PI    /    dxNorm;    }    	non-compiled	[CE]  ']'  expected	59	None	replace
226	[BUG]  [BUGGY]  double  parl  =  0;  if(function  ==  0)  {  int  j  =  0;  for(int  j  =  0;  j  <  dxNorm;  ++j)  {  work1[j]  *=  diag[j]  /  dxNorm;  }  [CE]  illegal  start  of  expression  [FE]        AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  0;  if(function  ==  0)  {  int  j  =  0;  for(int  j  =  0;  j  <  dxNorm;  ++j)  {  work1[j]  *=  diag[j]  /  dxNorm;  }  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  0;  if(function  ==  0)  {  int  j  =  0;  for(int  j  =  0;  j  <  dxNorm;  ++j)  {  work1[j]  *=  diag[j]  /  dxNorm;  }	  double    parl    =    1;    double    parl    =    1;    if(rank    ==    0)    {    int    j    =    0;    for(int    j    =    0;    j    <    dxNorm;    ++j)    {    work1[j]    *=    diag[j]    /    dxNorm;    }    	non-compiled	[CE]  illegal  start  of  expression	81	None	replace
227	[BUG]  [BUGGY]  double  sPar  =  Math.abs(dxNorm  *  lmPar);  [CE]  cannot  find  symbol  parl  [FE]                AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  sPar  =  Math.abs(dxNorm  *  lmPar);  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  sPar  =  Math.abs(dxNorm  *  lmPar);	  double    sPar    =    Math.abs(dxNorm    *    fp);    	non-compiled	[CE]  cannot  find  symbol  parl	35	None	replace
228	[BUG]  [BUGGY]  double  parl  =  0;  if(function  ==  0)  {  int  j  =  0;  for(int  j  =  0;  j  <  dxNorm;  ++j)  {  work1[j]  *=  work1[j]  /  dxNorm;  }  [CE]  illegal  start  of  expression  [FE]          AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  0;  if(function  ==  0)  {  int  j  =  0;  for(int  j  =  0;  j  <  dxNorm;  ++j)  {  work1[j]  *=  work1[j]  /  dxNorm;  }  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  0;  if(function  ==  0)  {  int  j  =  0;  for(int  j  =  0;  j  <  dxNorm;  ++j)  {  work1[j]  *=  work1[j]  /  dxNorm;  }	  double    parl    =    1;    double    parl    =    1;    if(rank    ==    0)    {    int    j    =    0;    for(int    j    =    0;    j    <    dxNorm;    ++j)    {    work1[j]    *=    work1[j]    /    dxNorm;    }    	non-compiled	[CE]  illegal  start  of  expression	82	None	replace
229	[BUG]  [BUGGY]  double  parl  =  0;  if(rank  ==  0)  {  int  j  =  0;  for(int  j  =  0;  j  <  dxNorm;  ++j)  {  work1[j]  *=  work2[j]  /  dxNorm;  }  [CE]  illegal  start  of  expression  [FE]            AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  0;  if(rank  ==  0)  {  int  j  =  0;  for(int  j  =  0;  j  <  dxNorm;  ++j)  {  work1[j]  *=  work2[j]  /  dxNorm;  }  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  0;  if(rank  ==  0)  {  int  j  =  0;  for(int  j  =  0;  j  <  dxNorm;  ++j)  {  work1[j]  *=  work2[j]  /  dxNorm;  }	  double    parl    =    1;    double    parl    =    1;    if(rank    ==    0)    {    int    j    =    0;    for(int    j    =    0;    j    <    dxNorm;    ++j)    {    work1[j]    *=    work1[j]    /    dxNorm;    }    	non-compiled	[CE]  illegal  start  of  expression	82	None	replace
230	[BUG]  [BUGGY]  double  parl  =  0;  if(dxNorm  ==  0)  {  work1[j]  *=  diag[j]  /  dxNorm;  }  [CE]  cannot  find  symbol  j  [FE]        AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  0;  if(dxNorm  ==  0)  {  work1[j]  *=  diag[j]  /  dxNorm;  }  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  0;  if(dxNorm  ==  0)  {  work1[j]  *=  diag[j]  /  dxNorm;  }	  double    parl    =    0.0;    if(dxNorm    ==    0)    {    double    parl    =    0.0;    }    else    {    for(int    j    =    0;    j    <    0;    ++j)    {    work1[j]    *=    diag[j]    /    dxNorm;    }    	non-compiled	[CE]  cannot  find  symbol  j	67	None	replace
231	[BUG]  [BUGGY]  double  parl  =  1.0;  if(dxNorm  ==  0.0)  {  work1[j]  *=  diag[j]  /  dxNorm;  }  [CE]  cannot  find  symbol  j  [FE]          AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  1.0;  if(dxNorm  ==  0.0)  {  work1[j]  *=  diag[j]  /  dxNorm;  }  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  1.0;  if(dxNorm  ==  0.0)  {  work1[j]  *=  diag[j]  /  dxNorm;  }	  double    parl    =    0.0;    if(dxNorm    ==    0)    {    double    parl    =    0.0;    }    else    {    for(int    j    =    0;    j    <    0;    ++j)    {    work1[j]    *=    diag[j]    /    dxNorm;    }    	non-compiled	[CE]  cannot  find  symbol  j	67	None	replace
232	[BUG]  [BUGGY]  double  parl  =  1.0;  if(dxNorm  ==  0)  {  work1[j]  *=  diag[j]  /  dxNorm;  }  [CE]  cannot  find  symbol  j  [FE]            AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  1.0;  if(dxNorm  ==  0)  {  work1[j]  *=  diag[j]  /  dxNorm;  }  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  1.0;  if(dxNorm  ==  0)  {  work1[j]  *=  diag[j]  /  dxNorm;  }	  double    parl    =    0.0;    if(dxNorm    ==    0)    {    double    parl    =    0.0;    }    else    {    for(int    j    =    0;    j    <    0;    ++j)    {    work1[j]    *=    diag[j]    /    dxNorm;    }    	non-compiled	[CE]  cannot  find  symbol  j	67	None	replace
233	[BUG]  [BUGGY]  double  sPar  =  Math.abs(dmPar  -  delta);  [CE]  cannot  find  symbol  dmPar  [FE]                AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  sPar  =  Math.abs(dmPar  -  delta);  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  sPar  =  Math.abs(dmPar  -  delta);	  double    sPar    =    Math.abs(lmPar    -    delta);    	non-compiled	[CE]  cannot  find  symbol  dmPar	55	None	replace
234	[BUG]  [BUGGY]  double  solveCols  =  0;  [CE]  cannot  find  symbol  parl  [FE]    AssertionFailedError    [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  solveCols  =  0;  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  solveCols  =  0;	          double    solvedCols    =    0;    double    solveCols    =    0;    	non-compiled	[CE]  cannot  find  symbol  parl	52	None	replace
235	[BUG]  [BUGGY]  if(lmPar  ==  0)  {  double  parl  =  0.0;  }  [CE]  cannot  find  symbol  parl  [FE]          AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  if(lmPar  ==  0)  {  double  parl  =  0.0;  }  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	if(lmPar  ==  0)  {  double  parl  =  0.0;  }	  double    parl    =    0.0;    if(dxNorm    ==    lmPar)    {    double    parl    =    0.0;    }    	non-compiled	[CE]  cannot  find  symbol  parl	91	None	replace
236	[BUG]  [BUGGY]  double  tmp  =  0;  double  pl  =  0;  [CE]  cannot  find  symbol  parl  [FE]              AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  tmp  =  0;  double  pl  =  0;  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  tmp  =  0;  double  pl  =  0;	  double    parl    =    1;    double    pl    =    1;    	non-compiled	[CE]  cannot  find  symbol  parl	8	None	replace
237	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]                AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  0;  double  pl  =  1;  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	add	double  parl  =  0;  double  pl  =  1;	  double    parl    =    1;    double    pl    =    1;    	compilable	  [FE]  AssertionFailedError  	8	2	replace
238	[BUG]  [BUGGY]  double  parl  =  0;  double  pl  =  1;  [FE]  AssertionFailedError  [FE]                AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  0;  double  pl  =  1;  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  0;  double  pl  =  1;	  double    parl    =    1;    double    pl    =    1;    	compilable	  [FE]  AssertionFailedError  	8	2	replace
239	[BUG]  [BUGGY]  Double  dk  =  1.0;  [CE]  cannot  find  symbol  parl  [FE]              AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  Double  dk  =  1.0;  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	Double  dk  =  1.0;	  double    parl    =    1.0;    dk    =    1.0;    	non-compiled	[CE]  cannot  find  symbol  parl	32	None	replace
240	[BUG]  [BUGGY]  double  parl  =  0;  if(rank  ==  0.0)  {  for(int  i  =  0;  i  <  dxNorm;  ++i)  {  double  parl  =  0.0;  }  [CE]  illegal  start  of  expression  [FE]          AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  0;  if(rank  ==  0.0)  {  for(int  i  =  0;  i  <  dxNorm;  ++i)  {  double  parl  =  0.0;  }  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  0;  if(rank  ==  0.0)  {  for(int  i  =  0;  i  <  dxNorm;  ++i)  {  double  parl  =  0.0;  }	  double    parl    =    0.0;    if(rank    ==    0.0)    {    for(int    i    =    0;    i    <    dxNorm;    ++i)    {    double    parl    =    0.0;    }    	non-compiled	[CE]  illegal  start  of  expression	25	None	replace
241	[BUG]  [BUGGY]  if(dxNorm  ==  0.0)  {  for(int  i  =  0;  i  <  dxNorm;  ++i)  {  double  parl  =  0.0;  }  [CE]  illegal  start  of  expression  [FE]            AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  if(dxNorm  ==  0.0)  {  for(int  i  =  0;  i  <  dxNorm;  ++i)  {  double  parl  =  0.0;  }  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	if(dxNorm  ==  0.0)  {  for(int  i  =  0;  i  <  dxNorm;  ++i)  {  double  parl  =  0.0;  }	  double    parl    =    0.0;    if(rank    ==    0.0)    {    for(int    i    =    0;    i    <    dxNorm;    ++i)    {    double    parl    =    0.0;    }    	non-compiled	[CE]  illegal  start  of  expression	25	None	replace
242	[BUG]  [BUGGY]  double  parl  =  0;  for(int  j  =  0;  j  <  resolvedCols;  ++j)  {  int  diag[j]  =  work2[j]  *  dxNorm  /  dxNorm;  }  [CE]  ']'  expected  [FE]                    AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  0;  for(int  j  =  0;  j  <  resolvedCols;  ++j)  {  int  diag[j]  =  work2[j]  *  dxNorm  /  dxNorm;  }  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  0;  for(int  j  =  0;  j  <  resolvedCols;  ++j)  {  int  diag[j]  =  work2[j]  *  dxNorm  /  dxNorm;  }	  double    parl    =    0;    for(int    j    =    0;    j    <    resolvedCols;    ++j)    {    int    diag[j]    =    work1[j]    *    dxNorm    /    dxNorm;    }    	non-compiled	[CE]  ']'  expected	87	None	replace
243	[BUG]  [BUGGY]  double  sPar  =  Math.abs(qy  +  delta);  [CE]  bad  operand  types  for  binary  operator  '+'  [FE]                  AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  sPar  =  Math.abs(qy  +  delta);  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  sPar  =  Math.abs(qy  +  delta);	  double    sPar    =    Math.abs(qy);    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '+'	61	None	replace
244	[BUG]  [BUGGY]  double  parl  =  0;  for(int  j  =  0;  j  <  solveCols;  ++j)  {  int  diag[j]  =  work1[j]  *  dxNorm;  [CE]  ']'  expected  [FE]                    AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  0;  for(int  j  =  0;  j  <  solveCols;  ++j)  {  int  diag[j]  =  work1[j]  *  dxNorm;  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  0;  for(int  j  =  0;  j  <  solveCols;  ++j)  {  int  diag[j]  =  work1[j]  *  dxNorm;	  double    parl    =    0;    for(int    j    =    0;    j    <    solvedCols;    ++j)    {    int    diag[j]    =    work1[j]    *    dxNorm;    	non-compiled	[CE]  ']'  expected	54	None	replace
245	[BUG]  [BUGGY]  double  parl  =  0;  for(int  j  =  0;  j  <  solveCols;  ++j)  {  int  diag[j]  =  work1[j]  *  dxNorm;  }  [CE]  ']'  expected  [FE]                      AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  0;  for(int  j  =  0;  j  <  solveCols;  ++j)  {  int  diag[j]  =  work1[j]  *  dxNorm;  }  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  0;  for(int  j  =  0;  j  <  solveCols;  ++j)  {  int  diag[j]  =  work1[j]  *  dxNorm;  }	  double    parl    =    0;    for(int    j    =    0;    j    <    solvedCols;    ++j)    {    int    diag[j]    =    work1[j]    *    dxNorm;    	non-compiled	[CE]  ']'  expected	54	None	replace
246	[BUG]  [BUGGY]  double  parl  =  0;  for(int  j  =  0;  j  <  resolvedCols;  ++j)  {  int  work1[j]  =  work2[j]  /  dxNorm;  }  [CE]  ']'  expected  [FE]              AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  0;  for(int  j  =  0;  j  <  resolvedCols;  ++j)  {  int  work1[j]  =  work2[j]  /  dxNorm;  }  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  0;  for(int  j  =  0;  j  <  resolvedCols;  ++j)  {  int  work1[j]  =  work2[j]  /  dxNorm;  }	  double    parl    =    0;    for(int    j    =    0;    j    <    resolvedCols;    ++j)    {    int    diag[j]    =    work1[j]    /    dxNorm;    }    	non-compiled	[CE]  ']'  expected	65	None	replace
247	[BUG]  [BUGGY]  double  parl  =  0;  for(int  j  =  0;  j  <  resolvedCols;  ++j)  {  int  diag[j]  =  work2[j]  /  dxNorm;  }  [CE]  ']'  expected  [FE]                AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  0;  for(int  j  =  0;  j  <  resolvedCols;  ++j)  {  int  diag[j]  =  work2[j]  /  dxNorm;  }  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  0;  for(int  j  =  0;  j  <  resolvedCols;  ++j)  {  int  diag[j]  =  work2[j]  /  dxNorm;  }	  double    parl    =    0;    for(int    j    =    0;    j    <    resolvedCols;    ++j)    {    int    diag[j]    =    work1[j]    /    dxNorm;    }    	non-compiled	[CE]  ']'  expected	65	None	replace
248	[BUG]  [BUGGY]  double  parPar  =  Math.abs(lmPar  *  Math.abs(fp));  [CE]  cannot  find  symbol  parl  [FE]                AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parPar  =  Math.abs(lmPar  *  Math.abs(fp));  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parPar  =  Math.abs(lmPar  *  Math.abs(fp));	  double    sPar    =    Math.abs(fp    *    Math.abs(lmPar));    	non-compiled	[CE]  cannot  find  symbol  parl	2	None	replace
249	[BUG]  [BUGGY]  double  parPar  =  Math.abs(fp  *  Math.abs(delta));  [CE]  cannot  find  symbol  parl  [FE]                  AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parPar  =  Math.abs(fp  *  Math.abs(delta));  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parPar  =  Math.abs(fp  *  Math.abs(delta));	  double    sPar    =    Math.abs(fp    *    Math.abs(lmPar));    	non-compiled	[CE]  cannot  find  symbol  parl	2	None	replace
250	[BUG]  [BUGGY]  double  parl  =  0;  if(function  ==  0)  {  int  j  =  0;  for(int  j  =  0;  j  <  dxNorm;  ++j)  {  work1[pj]  *=  diag[j]  /  dxNorm;  }  [CE]  illegal  start  of  expression  [FE]            AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  0;  if(function  ==  0)  {  int  j  =  0;  for(int  j  =  0;  j  <  dxNorm;  ++j)  {  work1[pj]  *=  diag[j]  /  dxNorm;  }  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  0;  if(function  ==  0)  {  int  j  =  0;  for(int  j  =  0;  j  <  dxNorm;  ++j)  {  work1[pj]  *=  diag[j]  /  dxNorm;  }	  double    parl    =    1;    double    parl    =    1;    if(rank    ==    0)    {    int    j    =    0;    for(int    j    =    0;    j    <    dxNorm;    ++j)    {    work1[pj]    *=    diag[j]    /    dxNorm;    }    	non-compiled	[CE]  illegal  start  of  expression	83	None	replace
251	[BUG]  [BUGGY]  double  parl  =  0;  if(rank  ==  0.0)  {  for(int  i  =  0;  i  <  dxNorm;  ++i)  {  sum2  +=  Math.pow(10.0,  dxNorm);  }  [CE]  illegal  start  of  expression  [FE]                AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  0;  if(rank  ==  0.0)  {  for(int  i  =  0;  i  <  dxNorm;  ++i)  {  sum2  +=  Math.pow(10.0,  dxNorm);  }  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  0;  if(rank  ==  0.0)  {  for(int  i  =  0;  i  <  dxNorm;  ++i)  {  sum2  +=  Math.pow(10.0,  dxNorm);  }	  double    parl    =    0.0;    if(rank    ==    0.0)    {    for(int    i    =    0;    i    <    dxNorm;    ++i)    {    sum2    +=    Math.pow(10.0,    dxNorm);    }    	non-compiled	[CE]  illegal  start  of  expression	28	None	replace
252	[BUG]  [BUGGY]  double  parl  =  1.0;  if(rank  ==  0.0)  {  for(int  i  =  0;  i  <  dxNorm;  ++i)  {  sum2  +=  Math.pow(10.0,  dxNorm);  }  [CE]  illegal  start  of  expression  [FE]                  AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  1.0;  if(rank  ==  0.0)  {  for(int  i  =  0;  i  <  dxNorm;  ++i)  {  sum2  +=  Math.pow(10.0,  dxNorm);  }  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  1.0;  if(rank  ==  0.0)  {  for(int  i  =  0;  i  <  dxNorm;  ++i)  {  sum2  +=  Math.pow(10.0,  dxNorm);  }	  double    parl    =    0.0;    if(rank    ==    0.0)    {    for(int    i    =    0;    i    <    dxNorm;    ++i)    {    sum2    +=    Math.pow(10.0,    dxNorm);    }    	non-compiled	[CE]  illegal  start  of  expression	28	None	replace
253	[BUG]  [BUGGY]  double  parl  =  0;  if(dxNorm  ==  0)  {  0  =  0;  }  else  {  for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diag[j]  /  dxNorm;  return;  }  [CE]  illegal  start  of  expression  [FE]              AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  0;  if(dxNorm  ==  0)  {  0  =  0;  }  else  {  for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diag[j]  /  dxNorm;  return;  }  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  0;  if(dxNorm  ==  0)  {  0  =  0;  }  else  {  for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diag[j]  /  dxNorm;  return;  }	  double    parl    =    0.0;    if(dxNorm    ==    0)    {    double    parl    =    0.0;    }    else    {    for(int    j    =    0;    j    <    0;    ++j)    {    work1[j]    *=    diag[j]    /    dxNorm;    return;    }    	non-compiled	[CE]  illegal  start  of  expression	70	None	replace
254	[BUG]  [BUGGY]  double  parl  =  1.0;  if(dxNorm  ==  0.0)  {  ++j;  }  else  {  for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diag[j]  /  dxNorm;  return;  }  [CE]  illegal  start  of  expression  [FE]                AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  1.0;  if(dxNorm  ==  0.0)  {  ++j;  }  else  {  for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diag[j]  /  dxNorm;  return;  }  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  1.0;  if(dxNorm  ==  0.0)  {  ++j;  }  else  {  for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diag[j]  /  dxNorm;  return;  }	  double    parl    =    0.0;    if(dxNorm    ==    0)    {    double    parl    =    0.0;    }    else    {    for(int    j    =    0;    j    <    0;    ++j)    {    work1[j]    *=    diag[j]    /    dxNorm;    return;    }    	non-compiled	[CE]  illegal  start  of  expression	70	None	replace
255	[BUG]  [BUGGY]  double  parl  =  0;  if(dxNorm  ==  0)  {  0  =  0;  }  else  {  for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diag[j]  /  dxNorm;  return  [CE]  illegal  start  of  expression  [FE]                  AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  0;  if(dxNorm  ==  0)  {  0  =  0;  }  else  {  for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diag[j]  /  dxNorm;  return  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  0;  if(dxNorm  ==  0)  {  0  =  0;  }  else  {  for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diag[j]  /  dxNorm;  return	  double    parl    =    0.0;    if(dxNorm    ==    0)    {    double    parl    =    0.0;    }    else    {    for(int    j    =    0;    j    <    0;    ++j)    {    work1[j]    *=    diag[j]    /    dxNorm;    return;    }    	non-compiled	[CE]  illegal  start  of  expression	70	None	replace
256	[BUG]  [BUGGY]          double    solvedCols    =    0;    double  solveCols  =  0;  double  solvedCols  =  0;  Double  solveCols  =  0;  [CE]  variable  solvedCols  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]    AssertionFailedError    [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]          double    solvedCols    =    0;    double  solveCols  =  0;  double  solvedCols  =  0;  Double  solveCols  =  0;  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	                double        solvedCols        =        0;        double    solveCols    =    0;    double  solvedCols  =  0;  Double  solveCols  =  0;	  	non-compiled	[CE]  variable  solvedCols  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	51	None	add
257	[BUG]  [BUGGY]  double  parl  =  0;  if(dxNorm  ==  0)  {  0  =  0;  }  else  {  for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diag[pj]  /  dxNorm;  }  [CE]  illegal  start  of  expression  [FE]          AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  0;  if(dxNorm  ==  0)  {  0  =  0;  }  else  {  for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diag[pj]  /  dxNorm;  }  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  0;  if(dxNorm  ==  0)  {  0  =  0;  }  else  {  for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diag[pj]  /  dxNorm;  }	  double    parl    =    0.0;    if(dxNorm    ==    0)    {    double    parl    =    0.0;    }    else    {    for(int    j    =    0;    j    <    0;    ++j)    {    work1[j]    *=    diag[pj]    /    dxNorm;    }    	non-compiled	[CE]  illegal  start  of  expression	68	None	replace
258	[BUG]  [BUGGY]  double  parl  =  0;  if(dxNorm  ==  0)  {  0  =  0;  }  else  {  for(int  j  =  0;  j  <  0;  ++j)  {  work2[j]  *=  diag[pj]  /  dxNorm;  }  [CE]  illegal  start  of  expression  [FE]            AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  0;  if(dxNorm  ==  0)  {  0  =  0;  }  else  {  for(int  j  =  0;  j  <  0;  ++j)  {  work2[j]  *=  diag[pj]  /  dxNorm;  }  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  0;  if(dxNorm  ==  0)  {  0  =  0;  }  else  {  for(int  j  =  0;  j  <  0;  ++j)  {  work2[j]  *=  diag[pj]  /  dxNorm;  }	  double    parl    =    0.0;    if(dxNorm    ==    0)    {    double    parl    =    0.0;    }    else    {    for(int    j    =    0;    j    <    0;    ++j)    {    work1[j]    *=    diag[pj]    /    dxNorm;    }    	non-compiled	[CE]  illegal  start  of  expression	68	None	replace
259	[BUG]  [BUGGY]  double  parl  =  0;  if(dxNorm  ==  0)  {  0  =  0;  }  else  {  for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diag[  [CE]  illegal  start  of  expression  [FE]              AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  0;  if(dxNorm  ==  0)  {  0  =  0;  }  else  {  for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diag[  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  0;  if(dxNorm  ==  0)  {  0  =  0;  }  else  {  for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diag[	  double    parl    =    0.0;    if(dxNorm    ==    0)    {    double    parl    =    0.0;    }    else    {    for(int    j    =    0;    j    <    0;    ++j)    {    work1[j]    *=    diag[pj]    /    dxNorm;    }    	non-compiled	[CE]  illegal  start  of  expression	68	None	replace
260	[BUG]  [BUGGY]  double  parl  =  0;  if(dxNorm  ==  0)  {  0  =  0;  }  else  {  for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diagnostic[pj]  /  dxNorm;  }  [CE]  illegal  start  of  expression  [FE]                AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  0;  if(dxNorm  ==  0)  {  0  =  0;  }  else  {  for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diagnostic[pj]  /  dxNorm;  }  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  0;  if(dxNorm  ==  0)  {  0  =  0;  }  else  {  for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diagnostic[pj]  /  dxNorm;  }	  double    parl    =    0.0;    if(dxNorm    ==    0)    {    double    parl    =    0.0;    }    else    {    for(int    j    =    0;    j    <    0;    ++j)    {    work1[j]    *=    diag[pj]    /    dxNorm;    }    	non-compiled	[CE]  illegal  start  of  expression	68	None	replace
261	[BUG]  [BUGGY]  double  sPar  =  Math.abs(lmPar  *  Math.abs(fp  -  1));  [CE]  cannot  find  symbol  parl  [FE]                AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  sPar  =  Math.abs(lmPar  *  Math.abs(fp  -  1));  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  sPar  =  Math.abs(lmPar  *  Math.abs(fp  -  1));	  double    sPar    =    Math.abs(dxNorm    *    Math.abs(fp    -    1));    	non-compiled	[CE]  cannot  find  symbol  parl	76	None	replace
262	[BUG]  [BUGGY]  double  sPar  =  Math.abs(dxNorm  *  Math.abs(delta  -  1));  [CE]  cannot  find  symbol  parl  [FE]                  AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  sPar  =  Math.abs(dxNorm  *  Math.abs(delta  -  1));  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  sPar  =  Math.abs(dxNorm  *  Math.abs(delta  -  1));	  double    sPar    =    Math.abs(dxNorm    *    Math.abs(fp    -    1));    	non-compiled	[CE]  cannot  find  symbol  parl	76	None	replace
263	[BUG]  [BUGGY]  double  parPar  =  0;  [CE]  cannot  find  symbol  parl  [FE]                      AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parPar  =  0;  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parPar  =  0;	  double    lmPar    =    0;    	non-compiled	[CE]  cannot  find  symbol  parl	39	None	replace
264	[BUG]  [BUGGY]  double  lmPar  =  2;  [CE]  cannot  find  symbol  parl  [FE]                        AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  lmPar  =  2;  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  lmPar  =  2;	  double    lmPar    =    0;    	non-compiled	[CE]  cannot  find  symbol  parl	39	None	replace
265	[BUG]  [BUGGY]  double  parl  =  0;  if(dxNorm  ==  0)  {  0  =  0.0;  }  else  {  for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diag[j]  /  delta;  }  [CE]  illegal  start  of  expression  [FE]            AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  0;  if(dxNorm  ==  0)  {  0  =  0.0;  }  else  {  for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diag[j]  /  delta;  }  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  0;  if(dxNorm  ==  0)  {  0  =  0.0;  }  else  {  for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diag[j]  /  delta;  }	  double    parl    =    0.0;    if(dxNorm    ==    0)    {    double    parl    =    0.0;    }    else    {    for(int    j    =    0;    j    <    0;    ++j)    {    work1[j]    *=    diag[j]    /    delta;    }    	non-compiled	[CE]  illegal  start  of  expression	69	None	replace
266	[BUG]  [BUGGY]  double  parl  =  0;  if(dxNorm  ==  0)  {  0  =  0.0;  }  else  {  for(int  j  =  0;  j  <  0;  ++j)  {  work2[j]  *=  diag[j]  /  delta;  }  [CE]  illegal  start  of  expression  [FE]              AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  0;  if(dxNorm  ==  0)  {  0  =  0.0;  }  else  {  for(int  j  =  0;  j  <  0;  ++j)  {  work2[j]  *=  diag[j]  /  delta;  }  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  0;  if(dxNorm  ==  0)  {  0  =  0.0;  }  else  {  for(int  j  =  0;  j  <  0;  ++j)  {  work2[j]  *=  diag[j]  /  delta;  }	  double    parl    =    0.0;    if(dxNorm    ==    0)    {    double    parl    =    0.0;    }    else    {    for(int    j    =    0;    j    <    0;    ++j)    {    work1[j]    *=    diag[j]    /    delta;    }    	non-compiled	[CE]  illegal  start  of  expression	69	None	replace
267	[BUG]  [BUGGY]  double  parl  =  0;  if(dxNorm  ==  0)  {  0  =  0.0;  }  else  {  for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diag[j]  /  delta  [CE]  ';'  expected  [FE]                AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  0;  if(dxNorm  ==  0)  {  0  =  0.0;  }  else  {  for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diag[j]  /  delta  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  0;  if(dxNorm  ==  0)  {  0  =  0.0;  }  else  {  for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diag[j]  /  delta	  double    parl    =    0.0;    if(dxNorm    ==    0)    {    double    parl    =    0.0;    }    else    {    for(int    j    =    0;    j    <    0;    ++j)    {    work1[j]    *=    diag[j]    /    delta;    }    	non-compiled	[CE]  ';'  expected	69	None	replace
268	[BUG]  [BUGGY]  double  parl  =  Math.abs(dxNorm  *  Math.abs(fp));  double  dl  =  Math.abs(dxNorm  *  Math.abs(fp));  [CE]  variable  parl  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]    AssertionFailedError    [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  Math.abs(dxNorm  *  Math.abs(fp));  double  dl  =  Math.abs(dxNorm  *  Math.abs(fp));  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double    parl    =    Math.abs(dxNorm    *    Math.abs(fp));    double  dl  =  Math.abs(dxNorm  *  Math.abs(fp));	  	non-compiled	[CE]  variable  parl  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	3	None	add
269	[BUG]  [BUGGY]  double  sPar  =  Math.abs(sum1,  lmPar);  [CE]  cannot  find  symbol  sum1  [FE]                    AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  sPar  =  Math.abs(sum1,  lmPar);  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  sPar  =  Math.abs(sum1,  lmPar);	  double    sPar    =    Math.abs(lmPar,    sum2);    	non-compiled	[CE]  cannot  find  symbol  sum1	45	None	replace
270	[BUG]  [BUGGY]  double  sPar  =  Math.abs(lmPar  /  fp);  [CE]  cannot  find  symbol  parl  [FE]              AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  sPar  =  Math.abs(lmPar  /  fp);  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  sPar  =  Math.abs(lmPar  /  fp);	  double    sPar    =    Math.abs(lmPar    -    fp);    	non-compiled	[CE]  cannot  find  symbol  parl	34	None	replace
271	[BUG]  [BUGGY]  Double  parl  =  0;  [CE]  incompatible  types  [FE]          AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  Double  parl  =  0;  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	Double  parl  =  0;	  double    parl    =    1;    Double    parl    =    1;    	non-compiled	[CE]  incompatible  types	6	None	replace
272	[BUG]  [BUGGY]  double  parl  =  10.0;  if(rank  ==  0)  {  for(int  j  =  0;  j  <  0;  ++j)  {  double  parl  =  10.0;  }  [CE]  illegal  start  of  expression  [FE]    AssertionFailedError    [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  10.0;  if(rank  ==  0)  {  for(int  j  =  0;  j  <  0;  ++j)  {  double  parl  =  10.0;  }  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double    parl    =    10.0;    if(rank  ==  0)  {  for(int  j  =  0;  j  <  0;  ++j)  {  double  parl  =  10.0;  }	  	non-compiled	[CE]  illegal  start  of  expression	79	None	add
273	[BUG]  [BUGGY]  double  parl  =  10.0;  if(rank  ==  0)  {  for(int  j  =  0;  j  <  0;  ++j)  {  sum2  =  0;  }  [CE]  illegal  start  of  expression  [FE]      AssertionFailedError    [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  10.0;  if(rank  ==  0)  {  for(int  j  =  0;  j  <  0;  ++j)  {  sum2  =  0;  }  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double    parl    =    10.0;    if(rank  ==  0)  {  for(int  j  =  0;  j  <  0;  ++j)  {  sum2  =  0;  }	  	non-compiled	[CE]  illegal  start  of  expression	79	None	add
274	[BUG]  [BUGGY]  double  parl  =  10.0;  if(rank  ==  0)  {  for(int  j  =  0;  j  <  0;  ++j)  {  int  diag[j]  =  work1[j]  /  dxNorm;  }  [CE]  ']'  expected  [FE]        AssertionFailedError    [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  10.0;  if(rank  ==  0)  {  for(int  j  =  0;  j  <  0;  ++j)  {  int  diag[j]  =  work1[j]  /  dxNorm;  }  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double    parl    =    10.0;    if(rank  ==  0)  {  for(int  j  =  0;  j  <  0;  ++j)  {  int  diag[j]  =  work1[j]  /  dxNorm;  }	  	non-compiled	[CE]  ']'  expected	79	None	add
275	[BUG]  [BUGGY]  double  sPar  =  Math.abs(value  *  Math.abs(lmPar));  [CE]  cannot  find  symbol  value  [FE]              AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  sPar  =  Math.abs(value  *  Math.abs(lmPar));  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  sPar  =  Math.abs(value  *  Math.abs(lmPar));	  double    sPar    =    Math.abs(tmp    *    Math.abs(lmPar));    	non-compiled	[CE]  cannot  find  symbol  value	62	None	replace
276	[BUG]  [BUGGY]  double  parl  =  0;  if(rank  ==  0.0)  {  for(int  j  =  0;  j  <  dxNorm;  ++j)  {  sum2  =  0.0;  }  [CE]  illegal  start  of  expression  [FE]            AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  0;  if(rank  ==  0.0)  {  for(int  j  =  0;  j  <  dxNorm;  ++j)  {  sum2  =  0.0;  }  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  0;  if(rank  ==  0.0)  {  for(int  j  =  0;  j  <  dxNorm;  ++j)  {  sum2  =  0.0;  }	  double    parl    =    0.0;    if(rank    ==    0.0)    {    for(int    j    =    0;    j    <    dxNorm;    ++j)    {    sum2    =    0.0;    }    	non-compiled	[CE]  illegal  start  of  expression	26	None	replace
277	[BUG]  [BUGGY]  double  sPar  =  Math.abs(lmPar  /  delta);  [CE]  cannot  find  symbol  parl  [FE]                AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  sPar  =  Math.abs(lmPar  /  delta);  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  sPar  =  Math.abs(lmPar  /  delta);	  double    sPar    =    Math.abs(dxNorm    /    delta);    	non-compiled	[CE]  cannot  find  symbol  parl	85	None	replace
278	[BUG]  [BUGGY]  double  parl  =  1.0;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  diag[j]  =  work1[j]  /  dxNorm;  }  [CE]  ']'  expected  [FE]              AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  1.0;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  diag[j]  =  work1[j]  /  dxNorm;  }  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  1.0;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  diag[j]  =  work1[j]  /  dxNorm;  }	  double    parl    =    0.0;    for(int    j    =    0;    j    <    solvedCols;    ++j)    {    int    diag[j]    =    work1[j]    /    dxNorm;    }    	non-compiled	[CE]  ']'  expected	18	None	replace
279	[BUG]  [BUGGY]  double  parl  =  0.0;  for(int  j  =  0;  j  <  solveCols;  ++j)  {  int  diag[j]  =  work1[j]  /  dxNorm;  }  [CE]  ']'  expected  [FE]                AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  0.0;  for(int  j  =  0;  j  <  solveCols;  ++j)  {  int  diag[j]  =  work1[j]  /  dxNorm;  }  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  0.0;  for(int  j  =  0;  j  <  solveCols;  ++j)  {  int  diag[j]  =  work1[j]  /  dxNorm;  }	  double    parl    =    0.0;    for(int    j    =    0;    j    <    solvedCols;    ++j)    {    int    diag[j]    =    work1[j]    /    dxNorm;    }    	non-compiled	[CE]  ']'  expected	18	None	replace
280	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  0.5  *  dxNorm;  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	add	double  parl  =  0.5  *  dxNorm;	  double    parl    =    0.5;    	compilable	  [FE]  AssertionFailedError  	17	4	replace
281	[BUG]  [BUGGY]  double  parl  =  0.5  *  dxNorm;  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  0.5  *  dxNorm;  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  0.5  *  dxNorm;	  double    parl    =    0.5;    	compilable	  [FE]  AssertionFailedError  	17	4	replace
282	[BUG]  [BUGGY]  double  parPar  =  Math.abs(lmPar  *  Math.abs(delta));  [CE]  cannot  find  symbol  parl  [FE]                AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parPar  =  Math.abs(lmPar  *  Math.abs(delta));  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parPar  =  Math.abs(lmPar  *  Math.abs(delta));	  double    sPar    =    Math.abs(lmPar    *    Math.abs(fp));    	non-compiled	[CE]  cannot  find  symbol  parl	40	None	replace
283	[BUG]  [BUGGY]  double  sPar  =  Math.abs(fp  *  lmPar);  [CE]  cannot  find  symbol  parl  [FE]                      AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  sPar  =  Math.abs(fp  *  lmPar);  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  sPar  =  Math.abs(fp  *  lmPar);	  double    sPar    =    Math.abs(fp    *    dxNorm);    	non-compiled	[CE]  cannot  find  symbol  parl	43	None	replace
284	[BUG]  [BUGGY]  double  sPar  =  Math.abs(dk  *  fp);  [CE]  cannot  find  symbol  dk  [FE]                        AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  sPar  =  Math.abs(dk  *  fp);  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  sPar  =  Math.abs(dk  *  fp);	  double    sPar    =    Math.abs(fp    *    dxNorm);    	non-compiled	[CE]  cannot  find  symbol  dk	43	None	replace
285	[BUG]  [BUGGY]  double  sPar  =  Math.abs(fp  /  dxNorm);  [CE]  cannot  find  symbol  parl  [FE]            AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  sPar  =  Math.abs(fp  /  dxNorm);  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  sPar  =  Math.abs(fp  /  dxNorm);	  double    sPar    =    Math.abs(fp    -    dxNorm);    	non-compiled	[CE]  cannot  find  symbol  parl	33	None	replace
286	[BUG]  [BUGGY]  double  sPar  =  Math.abs(dxNorm  -  dxNorm);  [CE]  cannot  find  symbol  parl  [FE]              AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  sPar  =  Math.abs(dxNorm  -  dxNorm);  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  sPar  =  Math.abs(dxNorm  -  dxNorm);	  double    sPar    =    Math.abs(lmpar    -    dxNorm);    	non-compiled	[CE]  cannot  find  symbol  parl	73	None	replace
287	[BUG]  [BUGGY]  double  parl  =  1.0;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  diag[j]  =  work1[j]  *  dxNorm  /  dxNorm;  }  [CE]  ']'  expected  [FE]                      AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  1.0;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  diag[j]  =  work1[j]  *  dxNorm  /  dxNorm;  }  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  1.0;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  diag[j]  =  work1[j]  *  dxNorm  /  dxNorm;  }	  double    parl    =    0.0;    for(int    j    =    0;    j    <    solvedCols;    ++j)    {    int    diag[j]    =    work1[j]    *    dxNorm    /    dxNorm;    }    	non-compiled	[CE]  ']'  expected	14	None	replace
288	[BUG]  [BUGGY]  double  sPar  =  0.5  +  delta;  [CE]  cannot  find  symbol  parl  [FE]                      AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  sPar  =  0.5  +  delta;  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  sPar  =  0.5  +  delta;	  double    sPar    =    0.5;    	non-compiled	[CE]  cannot  find  symbol  parl	75	None	replace
289	[BUG]  [BUGGY]  double  parl  =  0;  for(int  j  =  0;  j  <  solveCols;  ++j)  {  int  diag[j]  =  work2[j]  *  dxNorm  /  dxNorm;  }  [CE]  ']'  expected  [FE]                    AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  0;  for(int  j  =  0;  j  <  solveCols;  ++j)  {  int  diag[j]  =  work2[j]  *  dxNorm  /  dxNorm;  }  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  0;  for(int  j  =  0;  j  <  solveCols;  ++j)  {  int  diag[j]  =  work2[j]  *  dxNorm  /  dxNorm;  }	  double    parl    =    0;    for(int    j    =    0;    j    <    solveCols;    ++j)    {    int    diag[j]    =    work1[j]    *    dxNorm    /    dxNorm;    }    	non-compiled	[CE]  ']'  expected	64	None	replace
290	[BUG]  [BUGGY]  int  work1[j]  =  work2[j]  /  dxNorm;  [CE]  ']'  expected  [FE]              AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  int  work1[j]  =  work2[j]  /  dxNorm;  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	int  work1[j]  =  work2[j]  /  dxNorm;	  int    diag[j]    =    work1[j]    /    dxNorm;    	non-compiled	[CE]  ']'  expected	77	None	replace
291	[BUG]  [BUGGY]  double  paramPar  =  0;  [CE]  cannot  find  symbol  parl  [FE]                      AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  paramPar  =  0;  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  paramPar  =  0;	  double    lmPar    =    0;    	non-compiled	[CE]  cannot  find  symbol  parl	39	None	replace
292	[BUG]  [BUGGY]  double  par  =  Math.abs(dxNorm  -  fp);  [CE]  cannot  find  symbol  parl  [FE]            AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  par  =  Math.abs(dxNorm  -  fp);  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  par  =  Math.abs(dxNorm  -  fp);	  double    sPar    =    Math.abs(fp    -    dxNorm);    	non-compiled	[CE]  cannot  find  symbol  parl	33	None	replace
293	[BUG]  [BUGGY]  if(dxNorm  ==  0)  {  double  parl  =  0.0;  }  else  {  for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diag[j]  /  dxNorm;  }  [CE]  illegal  start  of  expression  [FE]        AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  if(dxNorm  ==  0)  {  double  parl  =  0.0;  }  else  {  for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diag[j]  /  dxNorm;  }  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	if(dxNorm  ==  0)  {  double  parl  =  0.0;  }  else  {  for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diag[j]  /  dxNorm;  }	  double    parl    =    0.0;    if(dxNorm    ==    0)    {    double    parl    =    0.0;    }    else    {    for(int    j    =    0;    j    <    0;    ++j)    {    work1[j]    *=    diag[j]    /    dxNorm;    }    	non-compiled	[CE]  illegal  start  of  expression	67	None	replace
294	[BUG]  [BUGGY]  if(dxNorm  ==  0.0)  {  double  parl  =  0.0;  }  else  {  for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diag[j]  /  dxNorm;  }  [CE]  illegal  start  of  expression  [FE]          AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  if(dxNorm  ==  0.0)  {  double  parl  =  0.0;  }  else  {  for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diag[j]  /  dxNorm;  }  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	if(dxNorm  ==  0.0)  {  double  parl  =  0.0;  }  else  {  for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diag[j]  /  dxNorm;  }	  double    parl    =    0.0;    if(dxNorm    ==    0)    {    double    parl    =    0.0;    }    else    {    for(int    j    =    0;    j    <    0;    ++j)    {    work1[j]    *=    diag[j]    /    dxNorm;    }    	non-compiled	[CE]  illegal  start  of  expression	67	None	replace
295	[BUG]  [BUGGY]  if(dxNorm!=  0.0)  {  double  parl  =  0.0;  }  else  {  for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diag[j]  /  dxNorm;  }  [CE]  illegal  start  of  expression  [FE]            AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  if(dxNorm!=  0.0)  {  double  parl  =  0.0;  }  else  {  for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diag[j]  /  dxNorm;  }  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	if(dxNorm!=  0.0)  {  double  parl  =  0.0;  }  else  {  for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diag[j]  /  dxNorm;  }	  double    parl    =    0.0;    if(dxNorm    ==    0)    {    double    parl    =    0.0;    }    else    {    for(int    j    =    0;    j    <    0;    ++j)    {    work1[j]    *=    diag[j]    /    dxNorm;    }    	non-compiled	[CE]  illegal  start  of  expression	67	None	replace
296	[BUG]  [BUGGY]  if(dxNorm  ==  0.0)  {  double  parl  =  1.0;  }  else  {  for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diag[j]  /  dxNorm;  }  [CE]  illegal  start  of  expression  [FE]              AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  if(dxNorm  ==  0.0)  {  double  parl  =  1.0;  }  else  {  for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diag[j]  /  dxNorm;  }  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	if(dxNorm  ==  0.0)  {  double  parl  =  1.0;  }  else  {  for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diag[j]  /  dxNorm;  }	  double    parl    =    0.0;    if(dxNorm    ==    0)    {    double    parl    =    0.0;    }    else    {    for(int    j    =    0;    j    <    0;    ++j)    {    work1[j]    *=    diag[j]    /    dxNorm;    }    	non-compiled	[CE]  illegal  start  of  expression	67	None	replace
297	[BUG]  [BUGGY]  double  parl  =  0;  for(int  j  =  0;  j  <  resolvedCols;  ++j)  {  int  diag[j]  =  work3[j]  *  dxNorm  /  dxNorm;  }  [CE]  ']'  expected  [FE]                    AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  0;  for(int  j  =  0;  j  <  resolvedCols;  ++j)  {  int  diag[j]  =  work3[j]  *  dxNorm  /  dxNorm;  }  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  0;  for(int  j  =  0;  j  <  resolvedCols;  ++j)  {  int  diag[j]  =  work3[j]  *  dxNorm  /  dxNorm;  }	  double    parl    =    0;    for(int    j    =    0;    j    <    resolvedCols;    ++j)    {    int    diag[j]    =    work1[j]    *    dxNorm    /    dxNorm;    }    	non-compiled	[CE]  ']'  expected	87	None	replace
298	[BUG]  [BUGGY]  double  sPar  =  Math.abs(dxNorm  -  1);  [CE]  cannot  find  symbol  parl  [FE]                      AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  sPar  =  Math.abs(dxNorm  -  1);  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  sPar  =  Math.abs(dxNorm  -  1);	  double    sPar    =    Math.abs(dxNorm);    	non-compiled	[CE]  cannot  find  symbol  parl	46	None	replace
299	[BUG]  [BUGGY]  if(dxNorm  <  0)  {  double  parl  =  0.0;  }  [CE]  cannot  find  symbol  parl  [FE]            AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  if(dxNorm  <  0)  {  double  parl  =  0.0;  }  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	if(dxNorm  <  0)  {  double  parl  =  0.0;  }	  double    parl    =    0.0;    if(dxNorm    ==    0)    {    double    parl    =    0.0;    }    	non-compiled	[CE]  cannot  find  symbol  parl	92	None	replace
300	[BUG]  [BUGGY]  if(dxNorm  ==  0)  {  double  parl  =  0.0;  }  else  {  for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diag[j]  /  delta;  }  [CE]  illegal  start  of  expression  [FE]            AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  if(dxNorm  ==  0)  {  double  parl  =  0.0;  }  else  {  for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diag[j]  /  delta;  }  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	if(dxNorm  ==  0)  {  double  parl  =  0.0;  }  else  {  for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diag[j]  /  delta;  }	  double    parl    =    0.0;    if(dxNorm    ==    0)    {    double    parl    =    0.0;    }    else    {    for(int    j    =    0;    j    <    0;    ++j)    {    work1[j]    *=    diag[j]    /    delta;    }    	non-compiled	[CE]  illegal  start  of  expression	69	None	replace
301	[BUG]  [BUGGY]  if(dxNorm!=  0.0)  {  double  parl  =  0.0;  }  else  {  for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diag[j]  /  delta;  }  [CE]  illegal  start  of  expression  [FE]              AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  if(dxNorm!=  0.0)  {  double  parl  =  0.0;  }  else  {  for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diag[j]  /  delta;  }  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	if(dxNorm!=  0.0)  {  double  parl  =  0.0;  }  else  {  for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diag[j]  /  delta;  }	  double    parl    =    0.0;    if(dxNorm    ==    0)    {    double    parl    =    0.0;    }    else    {    for(int    j    =    0;    j    <    0;    ++j)    {    work1[j]    *=    diag[j]    /    delta;    }    	non-compiled	[CE]  illegal  start  of  expression	69	None	replace
302	[BUG]  [BUGGY]  if(dxNorm!=  0)  {  double  parl  =  0.0;  }  else  {  for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diag[j]  /  delta;  }  [CE]  illegal  start  of  expression  [FE]                AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  if(dxNorm!=  0)  {  double  parl  =  0.0;  }  else  {  for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diag[j]  /  delta;  }  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	if(dxNorm!=  0)  {  double  parl  =  0.0;  }  else  {  for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diag[j]  /  delta;  }	  double    parl    =    0.0;    if(dxNorm    ==    0)    {    double    parl    =    0.0;    }    else    {    for(int    j    =    0;    j    <    0;    ++j)    {    work1[j]    *=    diag[j]    /    delta;    }    	non-compiled	[CE]  illegal  start  of  expression	69	None	replace
303	[BUG]  [BUGGY]  double  dr  =  1.0;  [CE]  cannot  find  symbol  parl  [FE]              AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  dr  =  1.0;  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  dr  =  1.0;	  double    parl    =    1.0;    dk    =    1.0;    	non-compiled	[CE]  cannot  find  symbol  parl	32	None	replace
304	[BUG]  [BUGGY]  double  dt  =  1.0;  [CE]  cannot  find  symbol  parl  [FE]                AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  dt  =  1.0;  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  dt  =  1.0;	  double    parl    =    1.0;    dk    =    1.0;    	non-compiled	[CE]  cannot  find  symbol  parl	32	None	replace
305	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]                AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  Math.abs(lmPar  *  Math.abs(dxNorm));  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	add	double  parl  =  Math.abs(lmPar  *  Math.abs(dxNorm));	  double    sPar    =    Math.abs(lmPar    *    Math.abs(fp));    	compilable	  [FE]  AssertionFailedError  	40	2	replace
306	[BUG]  [BUGGY]  double  parl  =  Math.abs(lmPar  *  Math.abs(dxNorm));  [FE]  AssertionFailedError  [FE]                AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  Math.abs(lmPar  *  Math.abs(dxNorm));  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  Math.abs(lmPar  *  Math.abs(dxNorm));	  double    sPar    =    Math.abs(lmPar    *    Math.abs(fp));    	compilable	  [FE]  AssertionFailedError  	40	2	replace
307	[BUG]  [BUGGY]  int  diag[j]  =  work2[j]  *  dxNorm  /  dxNorm;  [CE]  ']'  expected  [FE]                        AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  int  diag[j]  =  work2[j]  *  dxNorm  /  dxNorm;  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	int  diag[j]  =  work2[j]  *  dxNorm  /  dxNorm;	  double    parl    =    0;    for(int    j    =    0;    j    <    solvedCols;    ++j)    {    int    diag[j]    =    work2[j]    *    dxNorm    /    dxNorm;    }    	non-compiled	[CE]  ']'  expected	15	None	replace
308	[BUG]  [BUGGY]  float  solvedCols  =  0;  [CE]  cannot  find  symbol  parl  [FE]            AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  float  solvedCols  =  0;  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	float  solvedCols  =  0;	          double    solvedCols    =    0;    int    solvedCols    =    0;    	non-compiled	[CE]  cannot  find  symbol  parl	50	None	replace
309	[BUG]  [BUGGY]  if(dxNorm  ==  0)  {  double  parl  =  0.0;  }  else  {  for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diag[j]  /  dxNorm;  return;  }  [CE]  illegal  start  of  expression  [FE]              AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  if(dxNorm  ==  0)  {  double  parl  =  0.0;  }  else  {  for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diag[j]  /  dxNorm;  return;  }  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	if(dxNorm  ==  0)  {  double  parl  =  0.0;  }  else  {  for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diag[j]  /  dxNorm;  return;  }	  double    parl    =    0.0;    if(dxNorm    ==    0)    {    double    parl    =    0.0;    }    else    {    for(int    j    =    0;    j    <    0;    ++j)    {    work1[j]    *=    diag[j]    /    dxNorm;    return;    }    	non-compiled	[CE]  illegal  start  of  expression	70	None	replace
310	[BUG]  [BUGGY]  if(dxNorm  ==  0.0)  {  double  parl  =  0.0;  }  else  {  for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diag[j]  /  dxNorm;  return;  }  [CE]  illegal  start  of  expression  [FE]                AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  if(dxNorm  ==  0.0)  {  double  parl  =  0.0;  }  else  {  for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diag[j]  /  dxNorm;  return;  }  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	if(dxNorm  ==  0.0)  {  double  parl  =  0.0;  }  else  {  for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diag[j]  /  dxNorm;  return;  }	  double    parl    =    0.0;    if(dxNorm    ==    0)    {    double    parl    =    0.0;    }    else    {    for(int    j    =    0;    j    <    0;    ++j)    {    work1[j]    *=    diag[j]    /    dxNorm;    return;    }    	non-compiled	[CE]  illegal  start  of  expression	70	None	replace
311	[BUG]  [BUGGY]  if(dxNorm!=  0.0)  {  double  parl  =  0.0;  }  else  {  for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diag[j]  /  dxNorm;  return;  }  [CE]  illegal  start  of  expression  [FE]                  AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  if(dxNorm!=  0.0)  {  double  parl  =  0.0;  }  else  {  for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diag[j]  /  dxNorm;  return;  }  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	if(dxNorm!=  0.0)  {  double  parl  =  0.0;  }  else  {  for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diag[j]  /  dxNorm;  return;  }	  double    parl    =    0.0;    if(dxNorm    ==    0)    {    double    parl    =    0.0;    }    else    {    for(int    j    =    0;    j    <    0;    ++j)    {    work1[j]    *=    diag[j]    /    dxNorm;    return;    }    	non-compiled	[CE]  illegal  start  of  expression	70	None	replace
312	[BUG]  [BUGGY]  if(dxNorm!=  0)  {  double  parl  =  0.0;  }  else  {  for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diag[j]  /  dxNorm;  return;  }  [CE]  illegal  start  of  expression  [FE]                    AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  if(dxNorm!=  0)  {  double  parl  =  0.0;  }  else  {  for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diag[j]  /  dxNorm;  return;  }  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	if(dxNorm!=  0)  {  double  parl  =  0.0;  }  else  {  for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diag[j]  /  dxNorm;  return;  }	  double    parl    =    0.0;    if(dxNorm    ==    0)    {    double    parl    =    0.0;    }    else    {    for(int    j    =    0;    j    <    0;    ++j)    {    work1[j]    *=    diag[j]    /    dxNorm;    return;    }    	non-compiled	[CE]  illegal  start  of  expression	70	None	replace
313	[BUG]  [BUGGY]  double  solveCols  =  0.0;  [CE]  cannot  find  symbol  parl  [FE]          AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  solveCols  =  0.0;  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  solveCols  =  0.0;	  double    solvedCols    =    0.0;    	non-compiled	[CE]  cannot  find  symbol  parl	22	None	replace
314	[BUG]  [BUGGY]  double  solvedCols  =  1.0  *  lmPar.length;  [CE]  double  cannot  be  dereferenced  [FE]            AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  solvedCols  =  1.0  *  lmPar.length;  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  solvedCols  =  1.0  *  lmPar.length;	  double    solvedCols    =    1.0;    	non-compiled	[CE]  double  cannot  be  dereferenced	23	None	replace
315	[BUG]  [BUGGY]  double  solveCols  =  1.0;  [CE]  cannot  find  symbol  parl  [FE]              AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  solveCols  =  1.0;  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  solveCols  =  1.0;	  double    solvedCols    =    1.0;    	non-compiled	[CE]  cannot  find  symbol  parl	23	None	replace
316	[BUG]  [BUGGY]  int  j  =  0;  for(int  j  =  0;  j  <  dxNorm;  ++j)  {  work1[j]  *=  work1[j]  /  dxNorm;  }  [CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]          AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  int  j  =  0;  for(int  j  =  0;  j  <  dxNorm;  ++j)  {  work1[j]  *=  work1[j]  /  dxNorm;  }  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	int  j  =  0;  for(int  j  =  0;  j  <  dxNorm;  ++j)  {  work1[j]  *=  work1[j]  /  dxNorm;  }	  double    parl    =    1;    double    parl    =    1;    if(rank    ==    0)    {    int    j    =    0;    for(int    j    =    0;    j    <    dxNorm;    ++j)    {    work1[j]    *=    work1[j]    /    dxNorm;    }    	non-compiled	[CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	82	None	replace
317	[BUG]  [BUGGY]  if(s)  {  double  parl  =  1;  if(rank  ==  s)  {  for(int  j  =  0;  j  <  dxNorm;  ++j)  {  work1[j]  *=  diag[j]  /  dxNorm;  }  [CE]  illegal  start  of  expression  [FE]              AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  if(s)  {  double  parl  =  1;  if(rank  ==  s)  {  for(int  j  =  0;  j  <  dxNorm;  ++j)  {  work1[j]  *=  diag[j]  /  dxNorm;  }  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	if(s)  {  double  parl  =  1;  if(rank  ==  s)  {  for(int  j  =  0;  j  <  dxNorm;  ++j)  {  work1[j]  *=  diag[j]  /  dxNorm;  }	  double    parl    =    1;    double    parl    =    1;    if(rank    ==    s)    {    for(int    j    =    0;    j    <    dxNorm;    ++j)    {    work1[j]    *=    diag[j]    /    dxNorm;    }    	non-compiled	[CE]  illegal  start  of  expression	84	None	replace
318	[BUG]  [BUGGY]  if(fp  >  0.0)  {  double  parl  =  1;  if(rank  ==  s)  {  for(int  j  =  0;  j  <  dxNorm;  ++j)  {  work1[j]  *=  diag[j]  /  dxNorm;  }  [CE]  illegal  start  of  expression  [FE]                AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  if(fp  >  0.0)  {  double  parl  =  1;  if(rank  ==  s)  {  for(int  j  =  0;  j  <  dxNorm;  ++j)  {  work1[j]  *=  diag[j]  /  dxNorm;  }  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	if(fp  >  0.0)  {  double  parl  =  1;  if(rank  ==  s)  {  for(int  j  =  0;  j  <  dxNorm;  ++j)  {  work1[j]  *=  diag[j]  /  dxNorm;  }	  double    parl    =    1;    double    parl    =    1;    if(rank    ==    s)    {    for(int    j    =    0;    j    <    dxNorm;    ++j)    {    work1[j]    *=    diag[j]    /    dxNorm;    }    	non-compiled	[CE]  illegal  start  of  expression	84	None	replace
319	[BUG]  [BUGGY]  double  parl  =  0.5;  if(dxNorm  ==  lmPar)  {  double  parl  =  0.5;  }  [CE]  variable  parl  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]    AssertionFailedError    [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  0.5;  if(dxNorm  ==  lmPar)  {  double  parl  =  0.5;  }  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double    parl    =    0.5;    if(dxNorm  ==  lmPar)  {  double  parl  =  0.5;  }	  	non-compiled	[CE]  variable  parl  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	16	None	add
320	[BUG]  [BUGGY]  double  parl  =  0.5;  if(dxNorm  ==  0)  {  double  parl  =  0.5;  }  [CE]  variable  parl  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]      AssertionFailedError    [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  0.5;  if(dxNorm  ==  0)  {  double  parl  =  0.5;  }  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double    parl    =    0.5;    if(dxNorm  ==  0)  {  double  parl  =  0.5;  }	  	non-compiled	[CE]  variable  parl  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	16	None	add
321	[BUG]  [BUGGY]  double  parl  =  0.5;  if(dxNorm  ==  0.0)  {  double  parl  =  0.5;  }  [CE]  variable  parl  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]        AssertionFailedError    [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  0.5;  if(dxNorm  ==  0.0)  {  double  parl  =  0.5;  }  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double    parl    =    0.5;    if(dxNorm  ==  0.0)  {  double  parl  =  0.5;  }	  	non-compiled	[CE]  variable  parl  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	16	None	add
322	[BUG]  [BUGGY]  double  parl  =  0;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  diag[j]  =  work3[j]  /  delta;  }  [CE]  ']'  expected  [FE]                AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  0;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  diag[j]  =  work3[j]  /  delta;  }  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  0;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  diag[j]  =  work3[j]  /  delta;  }	  double    parl    =    0;    for(int    j    =    0;    j    <    solvedCols;    ++j)    {    int    diag[j]    =    work1[j]    /    delta;    }    	non-compiled	[CE]  ']'  expected	19	None	replace
323	[BUG]  [BUGGY]  int  diag[j]  =  work1[j]  /  delta;  [CE]  ']'  expected  [FE]                  AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  int  diag[j]  =  work1[j]  /  delta;  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	int  diag[j]  =  work1[j]  /  delta;	  double    parl    =    0;    for(int    j    =    0;    j    <    solvedCols;    ++j)    {    int    diag[j]    =    work1[j]    /    delta;    }    	non-compiled	[CE]  ']'  expected	19	None	replace
324	[BUG]  [BUGGY]  double  parl  =  10.0;  if(dxNorm  ==  lmPar)  {  double  parl  =  10.0;  }  [CE]  variable  parl  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]    AssertionFailedError    [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  10.0;  if(dxNorm  ==  lmPar)  {  double  parl  =  10.0;  }  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double    parl    =    10.0;    if(dxNorm  ==  lmPar)  {  double  parl  =  10.0;  }	  	non-compiled	[CE]  variable  parl  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	79	None	add
325	[BUG]  [BUGGY]  double  parl  =  10.0;  if(dxNorm  ==  0)  {  double  parl  =  10.0;  }  [CE]  variable  parl  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]      AssertionFailedError    [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  10.0;  if(dxNorm  ==  0)  {  double  parl  =  10.0;  }  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double    parl    =    10.0;    if(dxNorm  ==  0)  {  double  parl  =  10.0;  }	  	non-compiled	[CE]  variable  parl  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	79	None	add
326	[BUG]  [BUGGY]  double  parl  =  10.0;  if(dxNorm  ==  0.0)  {  double  parl  =  10.0;  }  [CE]  variable  parl  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]        AssertionFailedError    [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  10.0;  if(dxNorm  ==  0.0)  {  double  parl  =  10.0;  }  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double    parl    =    10.0;    if(dxNorm  ==  0.0)  {  double  parl  =  10.0;  }	  	non-compiled	[CE]  variable  parl  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	79	None	add
327	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]                AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  Math.abs(dxNorm  *  Math.abs(lmPar));  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	add	double  parl  =  Math.abs(dxNorm  *  Math.abs(lmPar));	  double    sPar    =    Math.abs(fp    *    Math.abs(lmPar));    	compilable	  [FE]  AssertionFailedError  	2	2	replace
328	[BUG]  [BUGGY]  double  parl  =  Math.abs(dxNorm  *  Math.abs(lmPar));  [FE]  AssertionFailedError  [FE]                AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  Math.abs(dxNorm  *  Math.abs(lmPar));  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  Math.abs(dxNorm  *  Math.abs(lmPar));	  double    sPar    =    Math.abs(fp    *    Math.abs(lmPar));    	compilable	  [FE]  AssertionFailedError  	2	2	replace
329	[BUG]  [BUGGY]  if(dxNorm  ==  0)  {  double  parl  =  0.0;  }  else  {  for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diag[pj]  /  dxNorm;  }  [CE]  illegal  start  of  expression  [FE]          AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  if(dxNorm  ==  0)  {  double  parl  =  0.0;  }  else  {  for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diag[pj]  /  dxNorm;  }  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	if(dxNorm  ==  0)  {  double  parl  =  0.0;  }  else  {  for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diag[pj]  /  dxNorm;  }	  double    parl    =    0.0;    if(dxNorm    ==    0)    {    double    parl    =    0.0;    }    else    {    for(int    j    =    0;    j    <    0;    ++j)    {    work1[j]    *=    diag[pj]    /    dxNorm;    }    	non-compiled	[CE]  illegal  start  of  expression	68	None	replace
330	[BUG]  [BUGGY]  if(dxNorm  ==  0.0)  {  double  parl  =  0.0;  }  else  {  for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diag[pj]  /  dxNorm;  }  [CE]  illegal  start  of  expression  [FE]            AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  if(dxNorm  ==  0.0)  {  double  parl  =  0.0;  }  else  {  for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diag[pj]  /  dxNorm;  }  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	if(dxNorm  ==  0.0)  {  double  parl  =  0.0;  }  else  {  for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diag[pj]  /  dxNorm;  }	  double    parl    =    0.0;    if(dxNorm    ==    0)    {    double    parl    =    0.0;    }    else    {    for(int    j    =    0;    j    <    0;    ++j)    {    work1[j]    *=    diag[pj]    /    dxNorm;    }    	non-compiled	[CE]  illegal  start  of  expression	68	None	replace
331	[BUG]  [BUGGY]  if(dxNorm!=  0.0)  {  double  parl  =  0.0;  }  else  {  for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diag[pj]  /  dxNorm;  }  [CE]  illegal  start  of  expression  [FE]              AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  if(dxNorm!=  0.0)  {  double  parl  =  0.0;  }  else  {  for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diag[pj]  /  dxNorm;  }  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	if(dxNorm!=  0.0)  {  double  parl  =  0.0;  }  else  {  for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diag[pj]  /  dxNorm;  }	  double    parl    =    0.0;    if(dxNorm    ==    0)    {    double    parl    =    0.0;    }    else    {    for(int    j    =    0;    j    <    0;    ++j)    {    work1[j]    *=    diag[pj]    /    dxNorm;    }    	non-compiled	[CE]  illegal  start  of  expression	68	None	replace
332	[BUG]  [BUGGY]  if(dxNorm!=  0)  {  double  parl  =  0.0;  }  else  {  for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diag[pj]  /  dxNorm;  }  [CE]  illegal  start  of  expression  [FE]                AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  if(dxNorm!=  0)  {  double  parl  =  0.0;  }  else  {  for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diag[pj]  /  dxNorm;  }  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	if(dxNorm!=  0)  {  double  parl  =  0.0;  }  else  {  for(int  j  =  0;  j  <  0;  ++j)  {  work1[j]  *=  diag[pj]  /  dxNorm;  }	  double    parl    =    0.0;    if(dxNorm    ==    0)    {    double    parl    =    0.0;    }    else    {    for(int    j    =    0;    j    <    0;    ++j)    {    work1[j]    *=    diag[pj]    /    dxNorm;    }    	non-compiled	[CE]  illegal  start  of  expression	68	None	replace
333	[BUG]  [BUGGY]  if(dxNorm  ==  0)  {  double  parl  =  0.0;  if(rank  ==  0.0)  {  for(int  i  =  0;  i  <  dxNorm;  ++i)  {  parl  =  0.0;  }  [CE]  illegal  start  of  expression  [FE]          AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  if(dxNorm  ==  0)  {  double  parl  =  0.0;  if(rank  ==  0.0)  {  for(int  i  =  0;  i  <  dxNorm;  ++i)  {  parl  =  0.0;  }  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	if(dxNorm  ==  0)  {  double  parl  =  0.0;  if(rank  ==  0.0)  {  for(int  i  =  0;  i  <  dxNorm;  ++i)  {  parl  =  0.0;  }	  double    parl    =    0.0;    if(rank    ==    0.0)    {    for(int    i    =    0;    i    <    dxNorm;    ++i)    {    double    parl    =    0.0;    }    	non-compiled	[CE]  illegal  start  of  expression	25	None	replace
334	[BUG]  [BUGGY]  if(dxNorm  ==  lmPar)  {  double  parl  =  0.0;  }  [CE]  cannot  find  symbol  parl  [FE]          AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  if(dxNorm  ==  lmPar)  {  double  parl  =  0.0;  }  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	if(dxNorm  ==  lmPar)  {  double  parl  =  0.0;  }	  double    parl    =    0.0;    if(dxNorm    ==    lmPar)    {    double    parl    =    0.0;    }    	non-compiled	[CE]  cannot  find  symbol  parl	91	None	replace
335	[BUG]  [BUGGY]  int  parl  =  0.0;  if(dxNorm  ==  lmPar)  {  double  parl  =  0.0;  }  [CE]  possible  loss  of  precision  [FE]            AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  int  parl  =  0.0;  if(dxNorm  ==  lmPar)  {  double  parl  =  0.0;  }  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	int  parl  =  0.0;  if(dxNorm  ==  lmPar)  {  double  parl  =  0.0;  }	  double    parl    =    0.0;    if(dxNorm    ==    lmPar)    {    double    parl    =    0.0;    }    	non-compiled	[CE]  possible  loss  of  precision	91	None	replace
336	[BUG]  [BUGGY]  double  sPar  =  Math.abs(qy,  fp);  [CE]  no  suitable  method  found  for  abs(double[],double)  [FE]                  AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  sPar  =  Math.abs(qy,  fp);  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  sPar  =  Math.abs(qy,  fp);	  double    sPar    =    Math.abs(qy);    	non-compiled	[CE]  no  suitable  method  found  for  abs(double[],double)	61	None	replace
337	[BUG]  [BUGGY]  int  parl  =  0.0;  if(rank  ==  0.0)  {  for(int  j  =  0;  j  <  dxNorm;  ++j)  {  sum2  =  0.0;  }  [CE]  illegal  start  of  expression  [FE]            AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  int  parl  =  0.0;  if(rank  ==  0.0)  {  for(int  j  =  0;  j  <  dxNorm;  ++j)  {  sum2  =  0.0;  }  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	int  parl  =  0.0;  if(rank  ==  0.0)  {  for(int  j  =  0;  j  <  dxNorm;  ++j)  {  sum2  =  0.0;  }	  double    parl    =    0.0;    if(rank    ==    0.0)    {    for(int    j    =    0;    j    <    dxNorm;    ++j)    {    sum2    =    0.0;    }    	non-compiled	[CE]  illegal  start  of  expression	26	None	replace
338	[BUG]  [BUGGY]  double  parl  =  2;  double  parl  =  3;  [CE]  variable  parl  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]    AssertionFailedError    [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  2;  double  parl  =  3;  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double    parl    =    2;    double  parl  =  3;	  	non-compiled	[CE]  variable  parl  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	36	None	add
339	[BUG]  [BUGGY]  double  sPar  =  Math.abs(dyNorm  -  delta);  [CE]  cannot  find  symbol  dyNorm  [FE]                  AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  sPar  =  Math.abs(dyNorm  -  delta);  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  sPar  =  Math.abs(dyNorm  -  delta);	  double    sPar    =    Math.abs(delta    -    dxNorm);    	non-compiled	[CE]  cannot  find  symbol  dyNorm	56	None	replace
340	[BUG]  [BUGGY]  double  parl  =  0;  for(int  j  =  0;  j  <  solveCols;  ++j)  {  int  diag[j]  =  work3[j]  *  dxNorm  /  dxNorm;  }  [CE]  ']'  expected  [FE]                    AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  0;  for(int  j  =  0;  j  <  solveCols;  ++j)  {  int  diag[j]  =  work3[j]  *  dxNorm  /  dxNorm;  }  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  0;  for(int  j  =  0;  j  <  solveCols;  ++j)  {  int  diag[j]  =  work3[j]  *  dxNorm  /  dxNorm;  }	  double    parl    =    0;    for(int    j    =    0;    j    <    solveCols;    ++j)    {    int    diag[j]    =    work1[j]    *    dxNorm    /    dxNorm;    }    	non-compiled	[CE]  ']'  expected	64	None	replace
341	[BUG]  [BUGGY]  double  sPar  =  Math.abs(dxNorm  -  fp,  sum2);  [CE]  no  suitable  method  found  for  abs(double,double)  [FE]                AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  sPar  =  Math.abs(dxNorm  -  fp,  sum2);  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  sPar  =  Math.abs(dxNorm  -  fp,  sum2);	  double    sPar    =    Math.abs(dxNorm    -    delta,    sum2);    	non-compiled	[CE]  no  suitable  method  found  for  abs(double,double)	66	None	replace
342	[BUG]  [BUGGY]  double  sPar  =  Math.abs(dxNorm  -  lmPar,  sum2);  [CE]  no  suitable  method  found  for  abs(double,double)  [FE]                  AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  sPar  =  Math.abs(dxNorm  -  lmPar,  sum2);  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  sPar  =  Math.abs(dxNorm  -  lmPar,  sum2);	  double    sPar    =    Math.abs(dxNorm    -    delta,    sum2);    	non-compiled	[CE]  no  suitable  method  found  for  abs(double,double)	66	None	replace
343	[BUG]  [BUGGY]  double  paramsPar  =  0.0;  [CE]  cannot  find  symbol  parl  [FE]                    AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  paramsPar  =  0.0;  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  paramsPar  =  0.0;	  double    sPar    =    0.0;    	non-compiled	[CE]  cannot  find  symbol  parl	74	None	replace
344	[BUG]  [BUGGY]          double    solvedCols    =    0;    double  solveCols  =  0;  double  solvedcols  =  0;  double  solveCols  =  0;  [CE]  variable  solveCols  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]    AssertionFailedError    [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]          double    solvedCols    =    0;    double  solveCols  =  0;  double  solvedcols  =  0;  double  solveCols  =  0;  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	                double        solvedCols        =        0;        double    solveCols    =    0;    double  solvedcols  =  0;  double  solveCols  =  0;	  	non-compiled	[CE]  variable  solveCols  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	51	None	add
345	[BUG]  [BUGGY]          double    solvedCols    =    0;    double  solveCols  =  0;  double  solvedCOLs  =  0;  double  solveCols  =  0;  [CE]  variable  solveCols  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]      AssertionFailedError    [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]          double    solvedCols    =    0;    double  solveCols  =  0;  double  solvedCOLs  =  0;  double  solveCols  =  0;  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	                double        solvedCols        =        0;        double    solveCols    =    0;    double  solvedCOLs  =  0;  double  solveCols  =  0;	  	non-compiled	[CE]  variable  solveCols  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	51	None	add
346	[BUG]  [BUGGY]  int  j  =  0;  for(int  j  =  0;  j  <  dxNorm;  ++j)  {  work1[pj]  *=  diag[j]  /  dxNorm;  }  [CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]            AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  int  j  =  0;  for(int  j  =  0;  j  <  dxNorm;  ++j)  {  work1[pj]  *=  diag[j]  /  dxNorm;  }  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	int  j  =  0;  for(int  j  =  0;  j  <  dxNorm;  ++j)  {  work1[pj]  *=  diag[j]  /  dxNorm;  }	  double    parl    =    1;    double    parl    =    1;    if(rank    ==    0)    {    int    j    =    0;    for(int    j    =    0;    j    <    dxNorm;    ++j)    {    work1[pj]    *=    diag[j]    /    dxNorm;    }    	non-compiled	[CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	83	None	replace
347	[BUG]  [BUGGY]  int  diag[j]  =  work1[j]  *  Math.PI  /  delta;  [CE]  ']'  expected  [FE]                  AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  int  diag[j]  =  work1[j]  *  Math.PI  /  delta;  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	int  diag[j]  =  work1[j]  *  Math.PI  /  delta;	  double    parl    =    0;    for(int    j    =    0;    j    <    solvedCols;    ++j)    {    int    diag[j]    =    work1[j]    *    Math.PI    /    delta;    }    	non-compiled	[CE]  ']'  expected	58	None	replace
348	[BUG]  [BUGGY]  double  pl  =  0;  [CE]  cannot  find  symbol  parl  [FE]              AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  pl  =  0;  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  pl  =  0;	  double    parl    =    1;    double    pl    =    1;    	non-compiled	[CE]  cannot  find  symbol  parl	8	None	replace
349	[BUG]  [BUGGY]  double  sPar  =  0.5  *  dxNorm;  [CE]  cannot  find  symbol  parl  [FE]                      AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  sPar  =  0.5  *  dxNorm;  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  sPar  =  0.5  *  dxNorm;	  double    sPar    =    0.5;    	non-compiled	[CE]  cannot  find  symbol  parl	75	None	replace
350	[BUG]  [BUGGY]  int  diag[j]  =  work1[j]  *  dxNorm  /  delta;  [CE]  ']'  expected  [FE]                    AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  int  diag[j]  =  work1[j]  *  dxNorm  /  delta;  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	int  diag[j]  =  work1[j]  *  dxNorm  /  delta;	  double    parl    =    0;    for(int    j    =    0;    j    <    solvedCols;    ++j)    {    int    diag[j]    =    work1[j]    *    dxNorm    /    delta;    }    	non-compiled	[CE]  ']'  expected	13	None	replace
351	[BUG]  [BUGGY]  int  parl  =  0.0;  if(rank  ==  0.0)  {  for(int  i  =  0;  i  <  dxNorm;  ++i)  {  sum2  +=  Math.pow(10.0,  dxNorm);  }  [CE]  illegal  start  of  expression  [FE]                AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  int  parl  =  0.0;  if(rank  ==  0.0)  {  for(int  i  =  0;  i  <  dxNorm;  ++i)  {  sum2  +=  Math.pow(10.0,  dxNorm);  }  [BUGGY]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	int  parl  =  0.0;  if(rank  ==  0.0)  {  for(int  i  =  0;  i  <  dxNorm;  ++i)  {  sum2  +=  Math.pow(10.0,  dxNorm);  }	  double    parl    =    0.0;    if(rank    ==    0.0)    {    for(int    i    =    0;    i    <    dxNorm;    ++i)    {    sum2    +=    Math.pow(10.0,    dxNorm);    }    	non-compiled	[CE]  illegal  start  of  expression	28	None	replace
352	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  Math.abs(dxNorm  /  Math.abs(fp));  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	add	double  parl  =  Math.abs(dxNorm  /  Math.abs(fp));	  double    parl    =    Math.abs(dxNorm    *    Math.abs(fp));    	compilable	  [FE]  AssertionFailedError  	4	2	replace
353	[BUG]  [BUGGY]  double  parl  =  Math.abs(dxNorm  /  Math.abs(fp));  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  Math.abs(dxNorm  /  Math.abs(fp));  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double  parl  =  Math.abs(dxNorm  /  Math.abs(fp));	  double    parl    =    Math.abs(dxNorm    *    Math.abs(fp));    	compilable	  [FE]  AssertionFailedError  	4	2	replace
354	[BUG]  [BUGGY]  double  parl  =  Math.abs(dxNorm  *  Math.abs(fp));  double  pl  =  Math.abs(dxNorm  *  Math.abs(fp));  [CE]  variable  parl  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]    AssertionFailedError    [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  double  parl  =  Math.abs(dxNorm  *  Math.abs(fp));  double  pl  =  Math.abs(dxNorm  *  Math.abs(fp));  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	double    parl    =    Math.abs(dxNorm    *    Math.abs(fp));    double  pl  =  Math.abs(dxNorm  *  Math.abs(fp));	  	non-compiled	[CE]  variable  parl  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	3	None	add
355	[BUG]  [BUGGY]  int  diag[j]  =  work1[j]  *  Math.PI  /  dkNorm;  [CE]  ']'  expected  [FE]                AssertionFailedError      [CONTEXT]      double  fp  =  dxNorm  -  delta;  if  (fp  <=  0.1  *  delta)  {  lmPar  =  0;  return;  }    double  sum2;      [BUGGY]  int  diag[j]  =  work1[j]  *  Math.PI  /  dkNorm;  [BUGGY]      double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	528	528	2	replace	int  diag[j]  =  work1[j]  *  Math.PI  /  dkNorm;	  int    diag[j]    =    work1[j]    *    Math.PI    /    dxNorm;    	non-compiled	[CE]  ']'  expected	88	None	replace
