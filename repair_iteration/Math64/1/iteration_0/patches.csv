bugid	buggy	buggy_class	suspiciousness	buggy_line	endbuggycode	original_failing_test_number	action	patch	original_buggy	execution_result	diagnosis	previous_bug_id	new_failing_test_number	this_action
1	[BUG]  [BUGGY]  for(int  j  =  0;  j  <  solvedCols.length;  ++j)  {  [CE]  int  cannot  be  dereferenced  [FE]    AssertionFailedError  [CONTEXT]  lmPar  =  0;  return;  }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  [BUGGY]  for(int  j  =  0;  j  <  solvedCols.length;  ++j)  {  [BUGGY]  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	530	530	2	replace	for(int  j  =  0;  j  <  solvedCols.length;  ++j)  {	for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  	non-compiled	[CE]  int  cannot  be  dereferenced	1	None	replace
2	[BUG]  [BUGGY]    [CE]  <identifier>  expected  [FE]      AssertionFailedError  [CONTEXT]  lmPar  =  0;  return;  }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  [BUGGY]    [BUGGY]  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	530	530	2	replace	  	for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  	non-compiled	[CE]  <identifier>  expected	1	None	replace
3	[BUG]  [BUGGY]    int  solvedCols  =  Math.min(solvedCols,  0);  [CE]  variable  solvedCols  might  not  have  been  initialized  [FE]    AssertionFailedError  [CONTEXT]  lmPar  =  0;  return;  }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  [BUGGY]    int  solvedCols  =  Math.min(solvedCols,  0);  [BUGGY]  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	530	530	2	replace	    int  solvedCols  =  Math.min(solvedCols,  0);		non-compiled	[CE]  variable  solvedCols  might  not  have  been  initialized	2	None	add
4	[BUG]  [BUGGY]    int  solvedCols  =  Math.min(solvedCols,  parl);  [CE]  possible  loss  of  precision  [FE]      AssertionFailedError  [CONTEXT]  lmPar  =  0;  return;  }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  [BUGGY]    int  solvedCols  =  Math.min(solvedCols,  parl);  [BUGGY]  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	530	530	2	replace	    int  solvedCols  =  Math.min(solvedCols,  parl);		non-compiled	[CE]  possible  loss  of  precision	2	None	add
5	[BUG]  [BUGGY]    int  solvedCols  =  Math.min(resolvedCols,  parl);  [CE]  cannot  find  symbol  resolvedCols  [FE]        AssertionFailedError  [CONTEXT]  lmPar  =  0;  return;  }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  [BUGGY]    int  solvedCols  =  Math.min(resolvedCols,  parl);  [BUGGY]  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	530	530	2	replace	    int  solvedCols  =  Math.min(resolvedCols,  parl);		non-compiled	[CE]  cannot  find  symbol  resolvedCols	2	None	add
6	[BUG]  [BUGGY]    int  solvedCols  =  Math.min(resolvedCols,  0);  [CE]  cannot  find  symbol  resolvedCols  [FE]          AssertionFailedError  [CONTEXT]  lmPar  =  0;  return;  }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  [BUGGY]    int  solvedCols  =  Math.min(resolvedCols,  0);  [BUGGY]  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	530	530	2	replace	    int  solvedCols  =  Math.min(resolvedCols,  0);		non-compiled	[CE]  cannot  find  symbol  resolvedCols	2	None	add
7	[BUG]  [BUGGY]  for(int  j  =  0;  j  <  foundCols;  ++j)  {  [CE]  cannot  find  symbol  foundCols  [FE]    AssertionFailedError  [CONTEXT]  lmPar  =  0;  return;  }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  [BUGGY]  for(int  j  =  0;  j  <  foundCols;  ++j)  {  [BUGGY]  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	530	530	2	replace	for(int  j  =  0;  j  <  foundCols;  ++j)  {	for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  	non-compiled	[CE]  cannot  find  symbol  foundCols	1	None	replace
8	[BUG]  [BUGGY]    int  solvedCols  =  Math.min(solvedCols,  sum2);  [CE]  possible  loss  of  precision  [FE]    AssertionFailedError  [CONTEXT]  lmPar  =  0;  return;  }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  [BUGGY]    int  solvedCols  =  Math.min(solvedCols,  sum2);  [BUGGY]  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	530	530	2	replace	    int  solvedCols  =  Math.min(solvedCols,  sum2);		non-compiled	[CE]  possible  loss  of  precision	2	None	add
9	[BUG]  [BUGGY]    int  solvedCols  =  Math.min(solvedCols,  sum2  -  1);  [CE]  possible  loss  of  precision  [FE]      AssertionFailedError  [CONTEXT]  lmPar  =  0;  return;  }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  [BUGGY]    int  solvedCols  =  Math.min(solvedCols,  sum2  -  1);  [BUGGY]  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	530	530	2	replace	    int  solvedCols  =  Math.min(solvedCols,  sum2  -  1);		non-compiled	[CE]  possible  loss  of  precision	2	None	add
10	[BUG]  [BUGGY]    double  dxNorm  =  Math.sqrt(rank);  [CE]  variable  dxNorm  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]    AssertionFailedError  [CONTEXT]  lmPar  =  0;  return;  }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  [BUGGY]    double  dxNorm  =  Math.sqrt(rank);  [BUGGY]  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	530	530	2	replace	    double  dxNorm  =  Math.sqrt(rank);		non-compiled	[CE]  variable  dxNorm  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	2	None	add
11	[BUG]  [BUGGY]    double  dxNorm  =  Math.abs(rank  -  solvedCols);  [CE]  variable  dxNorm  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]      AssertionFailedError  [CONTEXT]  lmPar  =  0;  return;  }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  [BUGGY]    double  dxNorm  =  Math.abs(rank  -  solvedCols);  [BUGGY]  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	530	530	2	replace	    double  dxNorm  =  Math.abs(rank  -  solvedCols);		non-compiled	[CE]  variable  dxNorm  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	2	None	add
12	[BUG]  [BUGGY]    double  dxNorm  =  Math.random();  [CE]  variable  dxNorm  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]        AssertionFailedError  [CONTEXT]  lmPar  =  0;  return;  }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  [BUGGY]    double  dxNorm  =  Math.random();  [BUGGY]  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	530	530	2	replace	    double  dxNorm  =  Math.random();		non-compiled	[CE]  variable  dxNorm  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	2	None	add
13	[BUG]  [BUGGY]    int  i  =  0;  [CE]  variable  i  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]          AssertionFailedError  [CONTEXT]  lmPar  =  0;  return;  }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  [BUGGY]    int  i  =  0;  [BUGGY]  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	530	530	2	replace	    int  i  =  0;		non-compiled	[CE]  variable  i  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	2	None	add
14	[BUG]  [BUGGY]    double  dxNorm  =  Math.sqrt(rank,  solveCols);  [CE]  variable  dxNorm  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]            AssertionFailedError  [CONTEXT]  lmPar  =  0;  return;  }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  [BUGGY]    double  dxNorm  =  Math.sqrt(rank,  solveCols);  [BUGGY]  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	530	530	2	replace	    double  dxNorm  =  Math.sqrt(rank,  solveCols);		non-compiled	[CE]  variable  dxNorm  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	2	None	add
15	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError  [CONTEXT]  lmPar  =  0;  return;  }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  [BUGGY]  for(int  j  =  0;  j  <  parl;  ++j)  {  [BUGGY]  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	530	530	2	add	for(int  j  =  0;  j  <  parl;  ++j)  {	for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  	compilable	  [FE]  AssertionFailedError  	1	7	replace
16	[BUG]  [BUGGY]  for(int  j  =  0;  j  <  parl;  ++j)  {  [FE]  AssertionFailedError  [FE]    AssertionFailedError  [CONTEXT]  lmPar  =  0;  return;  }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  [BUGGY]  for(int  j  =  0;  j  <  parl;  ++j)  {  [BUGGY]  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	530	530	2	replace	for(int  j  =  0;  j  <  parl;  ++j)  {	for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  	compilable	  [FE]  AssertionFailedError  	1	7	replace
17	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError  [CONTEXT]  lmPar  =  0;  return;  }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  [BUGGY]  for(int  j  =  0;  j  <  diag.length;  ++j)  {  [BUGGY]  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	530	530	2	add	for(int  j  =  0;  j  <  diag.length;  ++j)  {	for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  	compilable	  [FE]  AssertionFailedError  	1	2	replace
18	[BUG]  [BUGGY]  for(int  j  =  0;  j  <  diag.length;  ++j)  {  [FE]  AssertionFailedError  [FE]      AssertionFailedError  [CONTEXT]  lmPar  =  0;  return;  }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  [BUGGY]  for(int  j  =  0;  j  <  diag.length;  ++j)  {  [BUGGY]  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	530	530	2	replace	for(int  j  =  0;  j  <  diag.length;  ++j)  {	for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  	compilable	  [FE]  AssertionFailedError  	1	2	replace
