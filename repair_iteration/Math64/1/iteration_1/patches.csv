bugid	buggy	buggy_class	suspiciousness	buggy_line	endbuggycode	original_failing_test_number	action	patch	original_buggy	execution_result	diagnosis	previous_bug_id	new_failing_test_number	this_action
1	[BUG]  [BUGGY]  for(int  j  =  0;  j  <  diag.length;  ++j)  {  for(int  j  =  0;  j  <  diag.length;  ++j)  {  [CE]  illegal  start  of  expression  [FE]    AssertionFailedError    [CONTEXT]    lmPar  =  0;  return;  }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {    [BUGGY]  for(int  j  =  0;  j  <  diag.length;  ++j)  {  for(int  j  =  0;  j  <  diag.length;  ++j)  {  [BUGGY]    int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	530	530	2	replace	for(int    j    =    0;    j    <    diag.length;    ++j)    {    for(int  j  =  0;  j  <  diag.length;  ++j)  {	  	non-compiled	[CE]  illegal  start  of  expression	17	None	add
2	[BUG]  [BUGGY]  for(int  j  =  0;  j  <  diag.length;  ++j)  {  int  j  =  0;  j  <  diag.length;  ++j)  {  [CE]  >  expected  [FE]      AssertionFailedError    [CONTEXT]    lmPar  =  0;  return;  }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {    [BUGGY]  for(int  j  =  0;  j  <  diag.length;  ++j)  {  int  j  =  0;  j  <  diag.length;  ++j)  {  [BUGGY]    int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	530	530	2	replace	for(int    j    =    0;    j    <    diag.length;    ++j)    {    int  j  =  0;  j  <  diag.length;  ++j)  {	  	non-compiled	[CE]  >  expected	17	None	add
3	[BUG]  [BUGGY]  for(int  j  =  0;  j  <  diag.length;  ++j)  {  For(int  j  =  0;  j  <  diag.length;  ++j)  {  [CE]  '.class'  expected  [FE]        AssertionFailedError    [CONTEXT]    lmPar  =  0;  return;  }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {    [BUGGY]  for(int  j  =  0;  j  <  diag.length;  ++j)  {  For(int  j  =  0;  j  <  diag.length;  ++j)  {  [BUGGY]    int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	530	530	2	replace	for(int    j    =    0;    j    <    diag.length;    ++j)    {    For(int  j  =  0;  j  <  diag.length;  ++j)  {	  	non-compiled	[CE]  '.class'  expected	17	None	add
4	[BUG]  [BUGGY]  for(int  j  =  0;  j  <  diag.length;  ++j)  {  Integer  j  =  0;  j  <  diag.length;  ++j)  {  [CE]  >  expected  [FE]          AssertionFailedError    [CONTEXT]    lmPar  =  0;  return;  }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {    [BUGGY]  for(int  j  =  0;  j  <  diag.length;  ++j)  {  Integer  j  =  0;  j  <  diag.length;  ++j)  {  [BUGGY]    int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	530	530	2	replace	for(int    j    =    0;    j    <    diag.length;    ++j)    {    Integer  j  =  0;  j  <  diag.length;  ++j)  {	  	non-compiled	[CE]  >  expected	17	None	add
5	[BUG]  [BUGGY]  for(int  j  =  0;  j  <  diag.length;  ++j)  {  with  diag.length  =  0;  j  <  diag.length;  ++j)  {  [CE]  ';'  expected  [FE]            AssertionFailedError    [CONTEXT]    lmPar  =  0;  return;  }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {    [BUGGY]  for(int  j  =  0;  j  <  diag.length;  ++j)  {  with  diag.length  =  0;  j  <  diag.length;  ++j)  {  [BUGGY]    int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	530	530	2	replace	for(int    j    =    0;    j    <    diag.length;    ++j)    {    with  diag.length  =  0;  j  <  diag.length;  ++j)  {	  	non-compiled	[CE]  ';'  expected	17	None	add
6	[BUG]  [BUGGY]  double  dxNorm  =  Math.sqrt(rank,  sum2);  [CE]  <identifier>  expected  [FE]        AssertionFailedError    [CONTEXT]    lmPar  =  0;  return;  }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {    [BUGGY]  double  dxNorm  =  Math.sqrt(rank,  sum2);  [BUGGY]    for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	530	530	2	replace	double  dxNorm  =  Math.sqrt(rank,  sum2);	      double    dxNorm    =    Math.sqrt(rank);    	non-compiled	[CE]  <identifier>  expected	10	None	replace
7	[BUG]  [BUGGY]  double  dxNorm  =  Math.sqrt(solvedCols);  [CE]  <identifier>  expected  [FE]          AssertionFailedError    [CONTEXT]    lmPar  =  0;  return;  }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {    [BUGGY]  double  dxNorm  =  Math.sqrt(solvedCols);  [BUGGY]    for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	530	530	2	replace	double  dxNorm  =  Math.sqrt(solvedCols);	      double    dxNorm    =    Math.sqrt(rank);    	non-compiled	[CE]  <identifier>  expected	10	None	replace
8	[BUG]  [BUGGY]  double  dxNorm  =  Math.sqrt(diag);  [CE]  <identifier>  expected  [FE]            AssertionFailedError    [CONTEXT]    lmPar  =  0;  return;  }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {    [BUGGY]  double  dxNorm  =  Math.sqrt(diag);  [BUGGY]    for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	530	530	2	replace	double  dxNorm  =  Math.sqrt(diag);	      double    dxNorm    =    Math.sqrt(rank);    	non-compiled	[CE]  <identifier>  expected	10	None	replace
9	[BUG]  [BUGGY]  double  dxNorm  =  Math.sqrt(parl);  [CE]  <identifier>  expected  [FE]              AssertionFailedError    [CONTEXT]    lmPar  =  0;  return;  }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {    [BUGGY]  double  dxNorm  =  Math.sqrt(parl);  [BUGGY]    for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	530	530	2	replace	double  dxNorm  =  Math.sqrt(parl);	      double    dxNorm    =    Math.sqrt(rank);    	non-compiled	[CE]  <identifier>  expected	10	None	replace
10	[BUG]  [BUGGY]  int  solvedCols  =  Math.min(rank,  0);  [CE]  <identifier>  expected  [FE]              AssertionFailedError    [CONTEXT]    lmPar  =  0;  return;  }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {    [BUGGY]  int  solvedCols  =  Math.min(rank,  0);  [BUGGY]    for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	530	530	2	replace	int  solvedCols  =  Math.min(rank,  0);	      int    solvedCols    =    Math.min(resolvedCols,    0);    	non-compiled	[CE]  <identifier>  expected	6	None	replace
11	[BUG]  [BUGGY]  int  solvedCols  =  Math.min(parl,  0);  [CE]  <identifier>  expected  [FE]                AssertionFailedError    [CONTEXT]    lmPar  =  0;  return;  }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {    [BUGGY]  int  solvedCols  =  Math.min(parl,  0);  [BUGGY]    for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	530	530	2	replace	int  solvedCols  =  Math.min(parl,  0);	      int    solvedCols    =    Math.min(resolvedCols,    0);    	non-compiled	[CE]  <identifier>  expected	6	None	replace
12	[BUG]  [BUGGY]  double  i  =  0;  [CE]  <identifier>  expected  [FE]              AssertionFailedError    [CONTEXT]    lmPar  =  0;  return;  }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {    [BUGGY]  double  i  =  0;  [BUGGY]    for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	530	530	2	replace	double  i  =  0;	      int    i    =    0;    	non-compiled	[CE]  <identifier>  expected	13	None	replace
13	[BUG]  [BUGGY]  int  i  =  1;  [CE]  <identifier>  expected  [FE]                AssertionFailedError    [CONTEXT]    lmPar  =  0;  return;  }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {    [BUGGY]  int  i  =  1;  [BUGGY]    for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	530	530	2	replace	int  i  =  1;	      int    i    =    0;    	non-compiled	[CE]  <identifier>  expected	13	None	replace
14	[BUG]  [BUGGY]  int  i  =  2;  [CE]  <identifier>  expected  [FE]                  AssertionFailedError    [CONTEXT]    lmPar  =  0;  return;  }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {    [BUGGY]  int  i  =  2;  [BUGGY]    for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	530	530	2	replace	int  i  =  2;	      int    i    =    0;    	non-compiled	[CE]  <identifier>  expected	13	None	replace
15	[BUG]  [BUGGY]  for(int  j  =  0;  j  <  parl;  ++j)  {  for(int  j  =  0;  j  <  parl;  ++j)  {  [CE]  illegal  start  of  expression  [FE]    AssertionFailedError    [CONTEXT]    lmPar  =  0;  return;  }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {    [BUGGY]  for(int  j  =  0;  j  <  parl;  ++j)  {  for(int  j  =  0;  j  <  parl;  ++j)  {  [BUGGY]    int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	530	530	2	replace	for(int    j    =    0;    j    <    parl;    ++j)    {    for(int  j  =  0;  j  <  parl;  ++j)  {	  	non-compiled	[CE]  illegal  start  of  expression	15	None	add
16	[BUG]  [BUGGY]  for(int  j  =  0;  j  <  parl;  ++j)  {  int  j  =  0;  j  <  parl;  ++j)  {  [CE]  >  expected  [FE]      AssertionFailedError    [CONTEXT]    lmPar  =  0;  return;  }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {    [BUGGY]  for(int  j  =  0;  j  <  parl;  ++j)  {  int  j  =  0;  j  <  parl;  ++j)  {  [BUGGY]    int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	530	530	2	replace	for(int    j    =    0;    j    <    parl;    ++j)    {    int  j  =  0;  j  <  parl;  ++j)  {	  	non-compiled	[CE]  >  expected	15	None	add
17	[BUG]  [BUGGY]  for(int  j  =  0;  j  <  parl;  ++j)  {  For(int  j  =  0;  j  <  parl;  ++j)  {  [CE]  '.class'  expected  [FE]        AssertionFailedError    [CONTEXT]    lmPar  =  0;  return;  }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {    [BUGGY]  for(int  j  =  0;  j  <  parl;  ++j)  {  For(int  j  =  0;  j  <  parl;  ++j)  {  [BUGGY]    int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	530	530	2	replace	for(int    j    =    0;    j    <    parl;    ++j)    {    For(int  j  =  0;  j  <  parl;  ++j)  {	  	non-compiled	[CE]  '.class'  expected	15	None	add
18	[BUG]  [BUGGY]  for(int  j  =  0;  j  <  parl;  ++j)  {  Integer  j  =  0;  j  <  parl;  ++j)  {  [CE]  >  expected  [FE]          AssertionFailedError    [CONTEXT]    lmPar  =  0;  return;  }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {    [BUGGY]  for(int  j  =  0;  j  <  parl;  ++j)  {  Integer  j  =  0;  j  <  parl;  ++j)  {  [BUGGY]    int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	530	530	2	replace	for(int    j    =    0;    j    <    parl;    ++j)    {    Integer  j  =  0;  j  <  parl;  ++j)  {	  	non-compiled	[CE]  >  expected	15	None	add
19	[BUG]  [BUGGY]  double  dxNorm  =  Math.abs(solvedCols  -rank);  [CE]  <identifier>  expected  [FE]          AssertionFailedError    [CONTEXT]    lmPar  =  0;  return;  }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {    [BUGGY]  double  dxNorm  =  Math.abs(solvedCols  -rank);  [BUGGY]    for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	530	530	2	replace	double  dxNorm  =  Math.abs(solvedCols  -rank);	      double    dxNorm    =    Math.abs(rank    -    solvedCols);    	non-compiled	[CE]  <identifier>  expected	11	None	replace
20	[BUG]  [BUGGY]  double  dxNorm  =  Math.abs(sum2  -  solvedCols);  [CE]  <identifier>  expected  [FE]            AssertionFailedError    [CONTEXT]    lmPar  =  0;  return;  }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {    [BUGGY]  double  dxNorm  =  Math.abs(sum2  -  solvedCols);  [BUGGY]    for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	530	530	2	replace	double  dxNorm  =  Math.abs(sum2  -  solvedCols);	      double    dxNorm    =    Math.abs(rank    -    solvedCols);    	non-compiled	[CE]  <identifier>  expected	11	None	replace
21	[BUG]  [BUGGY]  double  dxNorm  =  Math.abs(diagR  -  solvedCols);  [CE]  <identifier>  expected  [FE]              AssertionFailedError    [CONTEXT]    lmPar  =  0;  return;  }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {    [BUGGY]  double  dxNorm  =  Math.abs(diagR  -  solvedCols);  [BUGGY]    for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	530	530	2	replace	double  dxNorm  =  Math.abs(diagR  -  solvedCols);	      double    dxNorm    =    Math.abs(rank    -    solvedCols);    	non-compiled	[CE]  <identifier>  expected	11	None	replace
22	[BUG]  [BUGGY]  for(int  j  =  0;  j  <  solveCols.length;  ++j)  {  [CE]  cannot  find  symbol  solveCols  [FE]    AssertionFailedError    [CONTEXT]    lmPar  =  0;  return;  }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {    [BUGGY]  for(int  j  =  0;  j  <  solveCols.length;  ++j)  {  [BUGGY]    int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	530	530	2	replace	for(int  j  =  0;  j  <  solveCols.length;  ++j)  {	  for(int    j    =    0;    j    <    diag.length;    ++j)    {    	non-compiled	[CE]  cannot  find  symbol  solveCols	18	None	replace
23	[BUG]  [BUGGY]  double  dxNorm  =  Math.log(rank);  [CE]  <identifier>  expected  [FE]            AssertionFailedError    [CONTEXT]    lmPar  =  0;  return;  }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {    [BUGGY]  double  dxNorm  =  Math.log(rank);  [BUGGY]    for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	530	530	2	replace	double  dxNorm  =  Math.log(rank);	      double    dxNorm    =    Math.random();    	non-compiled	[CE]  <identifier>  expected	12	None	replace
24	[BUG]  [BUGGY]  double  dxNorm  =  Math.rint(rank);  [CE]  <identifier>  expected  [FE]              AssertionFailedError    [CONTEXT]    lmPar  =  0;  return;  }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {    [BUGGY]  double  dxNorm  =  Math.rint(rank);  [BUGGY]    for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	530	530	2	replace	double  dxNorm  =  Math.rint(rank);	      double    dxNorm    =    Math.random();    	non-compiled	[CE]  <identifier>  expected	12	None	replace
25	[BUG]  [BUGGY]  double  dxNorm  =  Math.sqrt(solveCols,rank);  [CE]  <identifier>  expected  [FE]                AssertionFailedError    [CONTEXT]    lmPar  =  0;  return;  }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {    [BUGGY]  double  dxNorm  =  Math.sqrt(solveCols,rank);  [BUGGY]    for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	530	530	2	replace	double  dxNorm  =  Math.sqrt(solveCols,rank);	      double    dxNorm    =    Math.sqrt(rank,    solveCols);    	non-compiled	[CE]  <identifier>  expected	14	None	replace
26	[BUG]  [BUGGY]  double  dxNorm  =  Math.sqrt(diag,  solveCols);  [CE]  <identifier>  expected  [FE]                  AssertionFailedError    [CONTEXT]    lmPar  =  0;  return;  }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {    [BUGGY]  double  dxNorm  =  Math.sqrt(diag,  solveCols);  [BUGGY]    for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	530	530	2	replace	double  dxNorm  =  Math.sqrt(diag,  solveCols);	      double    dxNorm    =    Math.sqrt(rank,    solveCols);    	non-compiled	[CE]  <identifier>  expected	14	None	replace
27	[BUG]  [BUGGY]  double  dxNorm  =  Math.sqrt(random,  solveCols);  [CE]  <identifier>  expected  [FE]                    AssertionFailedError    [CONTEXT]    lmPar  =  0;  return;  }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {    [BUGGY]  double  dxNorm  =  Math.sqrt(random,  solveCols);  [BUGGY]    for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	530	530	2	replace	double  dxNorm  =  Math.sqrt(random,  solveCols);	      double    dxNorm    =    Math.sqrt(rank,    solveCols);    	non-compiled	[CE]  <identifier>  expected	14	None	replace
28	[BUG]  [BUGGY]  for(int  j  =  0;  j  <  resolvedCols.length;  ++j)  {  [CE]  cannot  find  symbol  resolvedCols  [FE]        AssertionFailedError    [CONTEXT]    lmPar  =  0;  return;  }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {    [BUGGY]  for(int  j  =  0;  j  <  resolvedCols.length;  ++j)  {  [BUGGY]    int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	530	530	2	replace	for(int  j  =  0;  j  <  resolvedCols.length;  ++j)  {	  for(int    j    =    0;    j    <    solvedCols.length;    ++j)    {    	non-compiled	[CE]  cannot  find  symbol  resolvedCols	1	None	replace
29	[BUG]  [BUGGY]  int  solvedCols  =  Math.min(rank,  parl);  [CE]  <identifier>  expected  [FE]            AssertionFailedError    [CONTEXT]    lmPar  =  0;  return;  }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {    [BUGGY]  int  solvedCols  =  Math.min(rank,  parl);  [BUGGY]    for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	530	530	2	replace	int  solvedCols  =  Math.min(rank,  parl);	      int    solvedCols    =    Math.min(resolvedCols,    parl);    	non-compiled	[CE]  <identifier>  expected	5	None	replace
30	[BUG]  [BUGGY]  int  solvedCols  =  Math.min(resolvedCols,  sum2);  [CE]  <identifier>  expected  [FE]              AssertionFailedError    [CONTEXT]    lmPar  =  0;  return;  }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {    [BUGGY]  int  solvedCols  =  Math.min(resolvedCols,  sum2);  [BUGGY]    for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	530	530	2	replace	int  solvedCols  =  Math.min(resolvedCols,  sum2);	      int    solvedCols    =    Math.min(resolvedCols,    parl);    	non-compiled	[CE]  <identifier>  expected	5	None	replace
31	[BUG]  [BUGGY]  int  solvedCols  =  Math.min(resolvedCols,  lmPar);  [CE]  <identifier>  expected  [FE]                AssertionFailedError    [CONTEXT]    lmPar  =  0;  return;  }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {    [BUGGY]  int  solvedCols  =  Math.min(resolvedCols,  lmPar);  [BUGGY]    for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	530	530	2	replace	int  solvedCols  =  Math.min(resolvedCols,  lmPar);	      int    solvedCols    =    Math.min(resolvedCols,    parl);    	non-compiled	[CE]  <identifier>  expected	5	None	replace
32	[BUG]  [BUGGY]  double  solvedCols  =  Math.min(solvedCols,  sum2  -  1);  [CE]  <identifier>  expected  [FE]          AssertionFailedError    [CONTEXT]    lmPar  =  0;  return;  }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {    [BUGGY]  double  solvedCols  =  Math.min(solvedCols,  sum2  -  1);  [BUGGY]    for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	530	530	2	replace	double  solvedCols  =  Math.min(solvedCols,  sum2  -  1);	      int    solvedCols    =    Math.min(solvedCols,    sum2    -    1);    	non-compiled	[CE]  <identifier>  expected	9	None	replace
33	[BUG]  [BUGGY]  double  solvedCols  =  Math.min(sum2,  sum2  -  1);  [CE]  <identifier>  expected  [FE]            AssertionFailedError    [CONTEXT]    lmPar  =  0;  return;  }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {    [BUGGY]  double  solvedCols  =  Math.min(sum2,  sum2  -  1);  [BUGGY]    for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	530	530	2	replace	double  solvedCols  =  Math.min(sum2,  sum2  -  1);	      int    solvedCols    =    Math.min(solvedCols,    sum2    -    1);    	non-compiled	[CE]  <identifier>  expected	9	None	replace
34	[BUG]  [BUGGY]  Double  solvedCols  =  Math.min(solvedCols,  sum2  -  1);  [CE]  <identifier>  expected  [FE]              AssertionFailedError    [CONTEXT]    lmPar  =  0;  return;  }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {    [BUGGY]  Double  solvedCols  =  Math.min(solvedCols,  sum2  -  1);  [BUGGY]    for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	530	530	2	replace	Double  solvedCols  =  Math.min(solvedCols,  sum2  -  1);	      int    solvedCols    =    Math.min(solvedCols,    sum2    -    1);    	non-compiled	[CE]  <identifier>  expected	9	None	replace
35	[BUG]  [BUGGY]  double  solvedCols  =  Math.min(sum2,  solvedCols  -  1);  [CE]  <identifier>  expected  [FE]                AssertionFailedError    [CONTEXT]    lmPar  =  0;  return;  }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {    [BUGGY]  double  solvedCols  =  Math.min(sum2,  solvedCols  -  1);  [BUGGY]    for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	530	530	2	replace	double  solvedCols  =  Math.min(sum2,  solvedCols  -  1);	      int    solvedCols    =    Math.min(solvedCols,    sum2    -    1);    	non-compiled	[CE]  <identifier>  expected	9	None	replace
36	[BUG]  [BUGGY]  double  solvedCols  =  Math.min(solvedCols,  sum2);  [CE]  <identifier>  expected  [FE]        AssertionFailedError    [CONTEXT]    lmPar  =  0;  return;  }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {    [BUGGY]  double  solvedCols  =  Math.min(solvedCols,  sum2);  [BUGGY]    for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	530	530	2	replace	double  solvedCols  =  Math.min(solvedCols,  sum2);	      int    solvedCols    =    Math.min(solvedCols,    sum2);    	non-compiled	[CE]  <identifier>  expected	8	None	replace
37	[BUG]  [BUGGY]  Double  solvedCols  =  Math.min(solvedCols,  sum2);  [CE]  <identifier>  expected  [FE]          AssertionFailedError    [CONTEXT]    lmPar  =  0;  return;  }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {    [BUGGY]  Double  solvedCols  =  Math.min(solvedCols,  sum2);  [BUGGY]    for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	530	530	2	replace	Double  solvedCols  =  Math.min(solvedCols,  sum2);	      int    solvedCols    =    Math.min(solvedCols,    sum2);    	non-compiled	[CE]  <identifier>  expected	8	None	replace
38	[BUG]  [BUGGY]  long  solvedCols  =  Math.min(solvedCols,  sum2);  [CE]  <identifier>  expected  [FE]            AssertionFailedError    [CONTEXT]    lmPar  =  0;  return;  }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {    [BUGGY]  long  solvedCols  =  Math.min(solvedCols,  sum2);  [BUGGY]    for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	530	530	2	replace	long  solvedCols  =  Math.min(solvedCols,  sum2);	      int    solvedCols    =    Math.min(solvedCols,    sum2);    	non-compiled	[CE]  <identifier>  expected	8	None	replace
39	[BUG]  [BUGGY]  double  solvedCols  =  Math.min(solvedCols,  parl);  [CE]  <identifier>  expected  [FE]          AssertionFailedError    [CONTEXT]    lmPar  =  0;  return;  }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {    [BUGGY]  double  solvedCols  =  Math.min(solvedCols,  parl);  [BUGGY]    for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	530	530	2	replace	double  solvedCols  =  Math.min(solvedCols,  parl);	      int    solvedCols    =    Math.min(solvedCols,    parl);    	non-compiled	[CE]  <identifier>  expected	4	None	replace
40	[BUG]  [BUGGY]  Double  solvedCols  =  Math.min(solvedCols,  parl);  [CE]  <identifier>  expected  [FE]            AssertionFailedError    [CONTEXT]    lmPar  =  0;  return;  }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {    [BUGGY]  Double  solvedCols  =  Math.min(solvedCols,  parl);  [BUGGY]    for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	530	530	2	replace	Double  solvedCols  =  Math.min(solvedCols,  parl);	      int    solvedCols    =    Math.min(solvedCols,    parl);    	non-compiled	[CE]  <identifier>  expected	4	None	replace
41	[BUG]  [BUGGY]  float  solvedCols  =  Math.min(solvedCols,  parl);  [CE]  <identifier>  expected  [FE]              AssertionFailedError    [CONTEXT]    lmPar  =  0;  return;  }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {    [BUGGY]  float  solvedCols  =  Math.min(solvedCols,  parl);  [BUGGY]    for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	530	530	2	replace	float  solvedCols  =  Math.min(solvedCols,  parl);	      int    solvedCols    =    Math.min(solvedCols,    parl);    	non-compiled	[CE]  <identifier>  expected	4	None	replace
42	[BUG]  [BUGGY]  double  permutation[]  =  dxNorm.doubleValue();  [CE]  <identifier>  expected  [FE]          AssertionFailedError    [CONTEXT]    lmPar  =  0;  return;  }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {    [BUGGY]  double  permutation[]  =  dxNorm.doubleValue();  [BUGGY]    int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	530	530	2	replace	double  permutation[]  =  dxNorm.doubleValue();	      	non-compiled	[CE]  <identifier>  expected	2	None	replace
43	[BUG]  [BUGGY]  int  permutation[j]  =  work1[j]  /  dxNorm;  [CE]  ']'  expected  [FE]            AssertionFailedError    [CONTEXT]    lmPar  =  0;  return;  }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {    [BUGGY]  int  permutation[j]  =  work1[j]  /  dxNorm;  [BUGGY]    int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	530	530	2	replace	int  permutation[j]  =  work1[j]  /  dxNorm;	      	non-compiled	[CE]  ']'  expected	2	None	replace
44	[BUG]  [BUGGY]  int  permutation[j]  =  work1[j];  [CE]  ']'  expected  [FE]              AssertionFailedError    [CONTEXT]    lmPar  =  0;  return;  }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {    [BUGGY]  int  permutation[j]  =  work1[j];  [BUGGY]    int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	530	530	2	replace	int  permutation[j]  =  work1[j];	      	non-compiled	[CE]  ']'  expected	2	None	replace
45	[BUG]  [BUGGY]  int  permutation[j]  =  Math.abs(work1[j]  /  dxNorm);  [CE]  ']'  expected  [FE]                AssertionFailedError    [CONTEXT]    lmPar  =  0;  return;  }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {    [BUGGY]  int  permutation[j]  =  Math.abs(work1[j]  /  dxNorm);  [BUGGY]    int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	530	530	2	replace	int  permutation[j]  =  Math.abs(work1[j]  /  dxNorm);	      	non-compiled	[CE]  ']'  expected	2	None	replace
46	[BUG]  [BUGGY]  for(int  j  =  0;  j  <  solveCols;  ++j)  {  [CE]  cannot  find  symbol  solveCols  [FE]    AssertionFailedError    [CONTEXT]    lmPar  =  0;  return;  }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {    [BUGGY]  for(int  j  =  0;  j  <  solveCols;  ++j)  {  [BUGGY]    int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	530	530	2	replace	for(int  j  =  0;  j  <  solveCols;  ++j)  {	  for(int    j    =    0;    j    <    parl;    ++j)    {    	non-compiled	[CE]  cannot  find  symbol  solveCols	16	None	replace
47	[BUG]  [BUGGY]  for(int  j  =  0;  j  <  resolvedCols;  ++j)  {  [CE]  cannot  find  symbol  resolvedCols  [FE]      AssertionFailedError    [CONTEXT]    lmPar  =  0;  return;  }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {    [BUGGY]  for(int  j  =  0;  j  <  resolvedCols;  ++j)  {  [BUGGY]    int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	530	530	2	replace	for(int  j  =  0;  j  <  resolvedCols;  ++j)  {	  for(int    j    =    0;    j    <    parl;    ++j)    {    	non-compiled	[CE]  cannot  find  symbol  resolvedCols	16	None	replace
48	[BUG]  [BUGGY]  for(int  j  =  0;  j  <  parl;  ++j)  {  if(j  =  0;  j  <  parl;  ++j)  {  [CE]  ')'  expected  [FE]    AssertionFailedError    [CONTEXT]    lmPar  =  0;  return;  }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {    [BUGGY]  for(int  j  =  0;  j  <  parl;  ++j)  {  if(j  =  0;  j  <  parl;  ++j)  {  [BUGGY]    int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	530	530	2	replace	for(int    j    =    0;    j    <    parl;    ++j)    {    if(j  =  0;  j  <  parl;  ++j)  {	  	non-compiled	[CE]  ')'  expected	15	None	add
49	[BUG]  [BUGGY]  double  dxNorm  =  Math.sqrt(parl,  solveCols);  [CE]  <identifier>  expected  [FE]                AssertionFailedError    [CONTEXT]    lmPar  =  0;  return;  }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {    [BUGGY]  double  dxNorm  =  Math.sqrt(parl,  solveCols);  [BUGGY]    for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	530	530	2	replace	double  dxNorm  =  Math.sqrt(parl,  solveCols);	      double    dxNorm    =    Math.sqrt(rank,    solveCols);    	non-compiled	[CE]  <identifier>  expected	14	None	replace
50	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    lmPar  =  0;  return;  }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {    [BUGGY]  for(int  j  =  0;  j  <  work2.length;  ++j)  {  [BUGGY]    int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	530	530	2	add	for(int  j  =  0;  j  <  work2.length;  ++j)  {	  for(int    j    =    0;    j    <    diag.length;    ++j)    {    	compilable	  [FE]  AssertionFailedError  	18	2	replace
51	[BUG]  [BUGGY]  for(int  j  =  0;  j  <  work2.length;  ++j)  {  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    lmPar  =  0;  return;  }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {    [BUGGY]  for(int  j  =  0;  j  <  work2.length;  ++j)  {  [BUGGY]    int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	530	530	2	replace	for(int  j  =  0;  j  <  work2.length;  ++j)  {	  for(int    j    =    0;    j    <    diag.length;    ++j)    {    	compilable	  [FE]  AssertionFailedError  	18	2	replace
52	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]    lmPar  =  0;  return;  }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {    [BUGGY]  for(int  j  =  0;  j  <  permutation.length;  ++j)  {  [BUGGY]    int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	530	530	2	add	for(int  j  =  0;  j  <  permutation.length;  ++j)  {	  for(int    j    =    0;    j    <    diag.length;    ++j)    {    	compilable	  [FE]  AssertionFailedError  	18	2	replace
53	[BUG]  [BUGGY]  for(int  j  =  0;  j  <  permutation.length;  ++j)  {  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]    lmPar  =  0;  return;  }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {    [BUGGY]  for(int  j  =  0;  j  <  permutation.length;  ++j)  {  [BUGGY]    int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	530	530	2	replace	for(int  j  =  0;  j  <  permutation.length;  ++j)  {	  for(int    j    =    0;    j    <    diag.length;    ++j)    {    	compilable	  [FE]  AssertionFailedError  	18	2	replace
54	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]    lmPar  =  0;  return;  }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {    [BUGGY]  for(int  j  =  0;  j  <  work1.length;  ++j)  {  [BUGGY]    int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	530	530	2	add	for(int  j  =  0;  j  <  work1.length;  ++j)  {	  for(int    j    =    0;    j    <    diag.length;    ++j)    {    	compilable	  [FE]  AssertionFailedError  	18	2	replace
55	[BUG]  [BUGGY]  for(int  j  =  0;  j  <  work1.length;  ++j)  {  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]    lmPar  =  0;  return;  }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {    [BUGGY]  for(int  j  =  0;  j  <  work1.length;  ++j)  {  [BUGGY]    int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	530	530	2	replace	for(int  j  =  0;  j  <  work1.length;  ++j)  {	  for(int    j    =    0;    j    <    diag.length;    ++j)    {    	compilable	  [FE]  AssertionFailedError  	18	2	replace
56	[BUG]  [BUGGY]  double  dxNorm  =  Math.abs(solvedCols  -  ratio);  [CE]  <identifier>  expected  [FE]          AssertionFailedError    [CONTEXT]    lmPar  =  0;  return;  }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {    [BUGGY]  double  dxNorm  =  Math.abs(solvedCols  -  ratio);  [BUGGY]    for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	530	530	2	replace	double  dxNorm  =  Math.abs(solvedCols  -  ratio);	      double    dxNorm    =    Math.abs(rank    -    solvedCols);    	non-compiled	[CE]  <identifier>  expected	11	None	replace
57	[BUG]  [BUGGY]  for(int  j  =  0;  j  <  diag.length;  ++j)  {  if(j  =  0;  j  <  diag.length;  ++j)  {  [CE]  ')'  expected  [FE]    AssertionFailedError    [CONTEXT]    lmPar  =  0;  return;  }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {    [BUGGY]  for(int  j  =  0;  j  <  diag.length;  ++j)  {  if(j  =  0;  j  <  diag.length;  ++j)  {  [BUGGY]    int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	530	530	2	replace	for(int    j    =    0;    j    <    diag.length;    ++j)    {    if(j  =  0;  j  <  diag.length;  ++j)  {	  	non-compiled	[CE]  ')'  expected	17	None	add
58	[BUG]  [BUGGY]  int  solvedCols  =  Math.min(sum2,  0);  [CE]  <identifier>  expected  [FE]        AssertionFailedError    [CONTEXT]    lmPar  =  0;  return;  }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {    [BUGGY]  int  solvedCols  =  Math.min(sum2,  0);  [BUGGY]    for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	530	530	2	replace	int  solvedCols  =  Math.min(sum2,  0);	      int    solvedCols    =    Math.min(solvedCols,    0);    	non-compiled	[CE]  <identifier>  expected	3	None	replace
59	[BUG]  [BUGGY]  float  solvedCols  =  Math.min(solvedCols,  sum2  -  1);  [CE]  <identifier>  expected  [FE]          AssertionFailedError    [CONTEXT]    lmPar  =  0;  return;  }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {    [BUGGY]  float  solvedCols  =  Math.min(solvedCols,  sum2  -  1);  [BUGGY]    for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	530	530	2	replace	float  solvedCols  =  Math.min(solvedCols,  sum2  -  1);	      int    solvedCols    =    Math.min(solvedCols,    sum2    -    1);    	non-compiled	[CE]  <identifier>  expected	9	None	replace
60	[BUG]  [BUGGY]  for(int  j  =  0;  j  <  sum2;  ++j)  {  [CE]  variable  sum2  might  not  have  been  initialized  [FE]    AssertionFailedError    [CONTEXT]    lmPar  =  0;  return;  }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {    [BUGGY]  for(int  j  =  0;  j  <  sum2;  ++j)  {  [BUGGY]    int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	530	530	2	replace	for(int  j  =  0;  j  <  sum2;  ++j)  {	  for(int    j    =    0;    j    <    parl;    ++j)    {    	non-compiled	[CE]  variable  sum2  might  not  have  been  initialized	16	None	replace
61	[BUG]  [BUGGY]  int  j  =  solvedCols[0];  [CE]  <identifier>  expected  [FE]          AssertionFailedError    [CONTEXT]    lmPar  =  0;  return;  }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {    [BUGGY]  int  j  =  solvedCols[0];  [BUGGY]    int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	530	530	2	replace	int  j  =  solvedCols[0];	      	non-compiled	[CE]  <identifier>  expected	2	None	replace
62	[BUG]  [BUGGY]  int  permutation[j]  =  qy[0];  [CE]  ']'  expected  [FE]            AssertionFailedError    [CONTEXT]    lmPar  =  0;  return;  }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {    [BUGGY]  int  permutation[j]  =  qy[0];  [BUGGY]    int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	530	530	2	replace	int  permutation[j]  =  qy[0];	      	non-compiled	[CE]  ']'  expected	2	None	replace
63	[BUG]  [BUGGY]  For(int  j  =  0;  j  <  solvedCols.length;  ++j)  {  [CE]  '.class'  expected  [FE]        AssertionFailedError    [CONTEXT]    lmPar  =  0;  return;  }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {    [BUGGY]  For(int  j  =  0;  j  <  solvedCols.length;  ++j)  {  [BUGGY]    int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	530	530	2	replace	For(int  j  =  0;  j  <  solvedCols.length;  ++j)  {	  for(int    j    =    0;    j    <    solvedCols.length;    ++j)    {    	non-compiled	[CE]  '.class'  expected	1	None	replace
64	[BUG]  [BUGGY]  float  solvedCols  =  Math.min(solvedCols,  sum2);  [CE]  <identifier>  expected  [FE]        AssertionFailedError    [CONTEXT]    lmPar  =  0;  return;  }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {    [BUGGY]  float  solvedCols  =  Math.min(solvedCols,  sum2);  [BUGGY]    for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	530	530	2	replace	float  solvedCols  =  Math.min(solvedCols,  sum2);	      int    solvedCols    =    Math.min(solvedCols,    sum2);    	non-compiled	[CE]  <identifier>  expected	8	None	replace
65	[BUG]  [BUGGY]  double  dxNorm  =  Math.abs(rank);  [CE]  <identifier>  expected  [FE]            AssertionFailedError    [CONTEXT]    lmPar  =  0;  return;  }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {    [BUGGY]  double  dxNorm  =  Math.abs(rank);  [BUGGY]    for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	530	530	2	replace	double  dxNorm  =  Math.abs(rank);	      double    dxNorm    =    Math.random();    	non-compiled	[CE]  <identifier>  expected	12	None	replace
66	[BUG]  [BUGGY]  for(int  j  =  0;  j  <  diag.length;  ++j)  {  for(int  j  =  0;  j  <  diag.length);  ++j)  {  [CE]  ';'  expected  [FE]    AssertionFailedError    [CONTEXT]    lmPar  =  0;  return;  }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {    [BUGGY]  for(int  j  =  0;  j  <  diag.length;  ++j)  {  for(int  j  =  0;  j  <  diag.length);  ++j)  {  [BUGGY]    int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	530	530	2	replace	for(int    j    =    0;    j    <    diag.length;    ++j)    {    for(int  j  =  0;  j  <  diag.length);  ++j)  {	  	non-compiled	[CE]  ';'  expected	17	None	add
67	[BUG]  [BUGGY]  double  dxNorm  =  Math.abs(diag.length  -  solvedCols);  [CE]  <identifier>  expected  [FE]          AssertionFailedError    [CONTEXT]    lmPar  =  0;  return;  }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {    [BUGGY]  double  dxNorm  =  Math.abs(diag.length  -  solvedCols);  [BUGGY]    for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	530	530	2	replace	double  dxNorm  =  Math.abs(diag.length  -  solvedCols);	      double    dxNorm    =    Math.abs(rank    -    solvedCols);    	non-compiled	[CE]  <identifier>  expected	11	None	replace
68	[BUG]  [BUGGY]  int  solvedCols  =  Math.min(diag,  0);  [CE]  <identifier>  expected  [FE]        AssertionFailedError    [CONTEXT]    lmPar  =  0;  return;  }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {    [BUGGY]  int  solvedCols  =  Math.min(diag,  0);  [BUGGY]    for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	530	530	2	replace	int  solvedCols  =  Math.min(diag,  0);	      int    solvedCols    =    Math.min(solvedCols,    0);    	non-compiled	[CE]  <identifier>  expected	3	None	replace
69	[BUG]  [BUGGY]  int  j  =  0;  [CE]  <identifier>  expected  [FE]              AssertionFailedError    [CONTEXT]    lmPar  =  0;  return;  }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {    [BUGGY]  int  j  =  0;  [BUGGY]    for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	530	530	2	replace	int  j  =  0;	      int    i    =    0;    	non-compiled	[CE]  <identifier>  expected	13	None	replace
70	[BUG]  [BUGGY]  int  solvedCols  =  Math.min(solvedCols,  parl  -  1);  [CE]  <identifier>  expected  [FE]          AssertionFailedError    [CONTEXT]    lmPar  =  0;  return;  }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {    [BUGGY]  int  solvedCols  =  Math.min(solvedCols,  parl  -  1);  [BUGGY]    for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	530	530	2	replace	int  solvedCols  =  Math.min(solvedCols,  parl  -  1);	      int    solvedCols    =    Math.min(solvedCols,    parl);    	non-compiled	[CE]  <identifier>  expected	4	None	replace
71	[BUG]  [BUGGY]  int  solvedCols  =  Math.min(solvedCols,  parl  +  1);  [CE]  <identifier>  expected  [FE]            AssertionFailedError    [CONTEXT]    lmPar  =  0;  return;  }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {    [BUGGY]  int  solvedCols  =  Math.min(solvedCols,  parl  +  1);  [BUGGY]    for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	530	530	2	replace	int  solvedCols  =  Math.min(solvedCols,  parl  +  1);	      int    solvedCols    =    Math.min(solvedCols,    parl);    	non-compiled	[CE]  <identifier>  expected	4	None	replace
72	[BUG]  [BUGGY]  for(int  j  =  0;  j  <  parl;  ++j)  {  for(int  j  =  0;  j  <  parl);  ++j)  {  [CE]  ';'  expected  [FE]    AssertionFailedError    [CONTEXT]    lmPar  =  0;  return;  }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {    [BUGGY]  for(int  j  =  0;  j  <  parl;  ++j)  {  for(int  j  =  0;  j  <  parl);  ++j)  {  [BUGGY]    int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	530	530	2	replace	for(int    j    =    0;    j    <    parl;    ++j)    {    for(int  j  =  0;  j  <  parl);  ++j)  {	  	non-compiled	[CE]  ';'  expected	15	None	add
73	[BUG]  [BUGGY]  double  dxNorm  =  Math.sqrt(diag,  parl);  [CE]  <identifier>  expected  [FE]        AssertionFailedError    [CONTEXT]    lmPar  =  0;  return;  }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {    [BUGGY]  double  dxNorm  =  Math.sqrt(diag,  parl);  [BUGGY]    for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	530	530	2	replace	double  dxNorm  =  Math.sqrt(diag,  parl);	      double    dxNorm    =    Math.sqrt(rank);    	non-compiled	[CE]  <identifier>  expected	10	None	replace
74	[BUG]  [BUGGY]  double  dxNorm  =  Math.sqrt(diag[0]);  [CE]  <identifier>  expected  [FE]          AssertionFailedError    [CONTEXT]    lmPar  =  0;  return;  }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {    [BUGGY]  double  dxNorm  =  Math.sqrt(diag[0]);  [BUGGY]    for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	530	530	2	replace	double  dxNorm  =  Math.sqrt(diag[0]);	      double    dxNorm    =    Math.sqrt(rank);    	non-compiled	[CE]  <identifier>  expected	10	None	replace
75	[BUG]  [BUGGY]  double  dxNorm  =  Math.abs(diag[0]);  [CE]  <identifier>  expected  [FE]          AssertionFailedError    [CONTEXT]    lmPar  =  0;  return;  }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {    [BUGGY]  double  dxNorm  =  Math.abs(diag[0]);  [BUGGY]    int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	530	530	2	replace	double  dxNorm  =  Math.abs(diag[0]);	      	non-compiled	[CE]  <identifier>  expected	2	None	replace
76	[BUG]  [BUGGY]  double  dxNorm  =  Math.abs(diag[0]  *  Math.abs(parl));  [CE]  <identifier>  expected  [FE]            AssertionFailedError    [CONTEXT]    lmPar  =  0;  return;  }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {    [BUGGY]  double  dxNorm  =  Math.abs(diag[0]  *  Math.abs(parl));  [BUGGY]    int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	530	530	2	replace	double  dxNorm  =  Math.abs(diag[0]  *  Math.abs(parl));	      	non-compiled	[CE]  <identifier>  expected	2	None	replace
77	[BUG]  [BUGGY]  double  dxNorm  =  Math.abs(diag[0]  *  Math.abs(rank));  [CE]  <identifier>  expected  [FE]              AssertionFailedError    [CONTEXT]    lmPar  =  0;  return;  }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {    [BUGGY]  double  dxNorm  =  Math.abs(diag[0]  *  Math.abs(rank));  [BUGGY]    int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	530	530	2	replace	double  dxNorm  =  Math.abs(diag[0]  *  Math.abs(rank));	      	non-compiled	[CE]  <identifier>  expected	2	None	replace
78	[BUG]  [BUGGY]  int  solvedCols  =  Math.min(resolvedCols,  parl  -  1);  [CE]  <identifier>  expected  [FE]            AssertionFailedError    [CONTEXT]    lmPar  =  0;  return;  }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {    [BUGGY]  int  solvedCols  =  Math.min(resolvedCols,  parl  -  1);  [BUGGY]    for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	530	530	2	replace	int  solvedCols  =  Math.min(resolvedCols,  parl  -  1);	      int    solvedCols    =    Math.min(resolvedCols,    parl);    	non-compiled	[CE]  <identifier>  expected	5	None	replace
79	[BUG]  [BUGGY]  int  solvedCols  =  Math.min(resolvedCols,  parl  +  1);  [CE]  <identifier>  expected  [FE]              AssertionFailedError    [CONTEXT]    lmPar  =  0;  return;  }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {    [BUGGY]  int  solvedCols  =  Math.min(resolvedCols,  parl  +  1);  [BUGGY]    for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	530	530	2	replace	int  solvedCols  =  Math.min(resolvedCols,  parl  +  1);	      int    solvedCols    =    Math.min(resolvedCols,    parl);    	non-compiled	[CE]  <identifier>  expected	5	None	replace
