bugid	buggy	buggy_class	suspiciousness	buggy_line	endbuggycode	original_failing_test_number	action	patch	original_buggy	execution_result	diagnosis	previous_bug_id	new_failing_test_number	this_action
1	[BUG]  [BUGGY]    tmpVec  =  permutation[j];  [CE]  cannot  find  symbol  j  [FE]    AssertionFailedError  [CONTEXT]    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  [BUGGY]    tmpVec  =  permutation[j];  [BUGGY]  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	    tmpVec  =  permutation[j];		non-compiled	[CE]  cannot  find  symbol  j	40	None	add
2	[BUG]  [BUGGY]    tmpVec  =  permutation[j].doubleValue();  [CE]  cannot  find  symbol  j  [FE]      AssertionFailedError  [CONTEXT]    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  [BUGGY]    tmpVec  =  permutation[j].doubleValue();  [BUGGY]  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	    tmpVec  =  permutation[j].doubleValue();		non-compiled	[CE]  cannot  find  symbol  j	40	None	add
3	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError  [CONTEXT]    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  [BUGGY]    oldRes  =  tmpVec;  [BUGGY]  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	add	    oldRes  =  tmpVec;		compilable	  [FE]  AssertionFailedError  	40	10	add
4	[BUG]  [BUGGY]    oldRes  =  tmpVec;  [FE]  AssertionFailedError  [FE]        AssertionFailedError  [CONTEXT]    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  [BUGGY]    oldRes  =  tmpVec;  [BUGGY]  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	    oldRes  =  tmpVec;		compilable	  [FE]  AssertionFailedError  	40	10	add
5	[BUG]  [BUGGY]    tmpVec  =  permutation[pj];  [CE]  cannot  find  symbol  pj  [FE]          AssertionFailedError  [CONTEXT]    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  [BUGGY]    tmpVec  =  permutation[pj];  [BUGGY]  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	    tmpVec  =  permutation[pj];		non-compiled	[CE]  cannot  find  symbol  pj	40	None	add
6	[BUG]  [BUGGY]    tmpVec  =  Math.max(remainings,  previousCost);  [CE]  cannot  find  symbol  remainings  [FE]            AssertionFailedError  [CONTEXT]    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  [BUGGY]    tmpVec  =  Math.max(remainings,  previousCost);  [BUGGY]  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	    tmpVec  =  Math.max(remainings,  previousCost);		non-compiled	[CE]  cannot  find  symbol  remainings	40	None	add
7	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError  [CONTEXT]    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  [BUGGY]  residuals  =  tmpVec;  [BUGGY]  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	add	residuals  =  tmpVec;	residuals  =  oldRes;  	compilable	  [FE]  AssertionFailedError  	39	10	replace
8	[BUG]  [BUGGY]  residuals  =  tmpVec;  [FE]  AssertionFailedError  [FE]    AssertionFailedError  [CONTEXT]    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  [BUGGY]  residuals  =  tmpVec;  [BUGGY]  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	residuals  =  tmpVec;	residuals  =  oldRes;  	compilable	  [FE]  AssertionFailedError  	39	10	replace
9	[BUG]  [BUGGY]  remainders  =  tmpVec;  [CE]  cannot  find  symbol  remainders  [FE]      AssertionFailedError  [CONTEXT]    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  [BUGGY]  remainders  =  tmpVec;  [BUGGY]  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	remainders  =  tmpVec;	residuals  =  oldRes;  	non-compiled	[CE]  cannot  find  symbol  remainders	39	None	replace
10	[BUG]  [BUGGY]  res  =  tmpVec;  [CE]  cannot  find  symbol  res  [FE]        AssertionFailedError  [CONTEXT]    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  [BUGGY]  res  =  tmpVec;  [BUGGY]  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	res  =  tmpVec;	residuals  =  oldRes;  	non-compiled	[CE]  cannot  find  symbol  res	39	None	replace
11	[BUG]  [BUGGY]  remainings  =  tmpVec;  [CE]  cannot  find  symbol  remainings  [FE]          AssertionFailedError  [CONTEXT]    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  [BUGGY]  remainings  =  tmpVec;  [BUGGY]  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	remainings  =  tmpVec;	residuals  =  oldRes;  	non-compiled	[CE]  cannot  find  symbol  remainings	39	None	replace
12	[BUG]  [BUGGY]    tmpVec  =  new  VectorialPointValuePair(previousCost);  [CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double)  [FE]    AssertionFailedError  [CONTEXT]    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  [BUGGY]    tmpVec  =  new  VectorialPointValuePair(previousCost);  [BUGGY]  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	    tmpVec  =  new  VectorialPointValuePair(previousCost);		non-compiled	[CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double)	40	None	add
13	[BUG]  [BUGGY]    tmpVec  =  new  VectorialPointValuePair();  [CE]  no  suitable  constructor  found  for  VectorialPointValuePair()  [FE]      AssertionFailedError  [CONTEXT]    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  [BUGGY]    tmpVec  =  new  VectorialPointValuePair();  [BUGGY]  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	    tmpVec  =  new  VectorialPointValuePair();		non-compiled	[CE]  no  suitable  constructor  found  for  VectorialPointValuePair()	40	None	add
14	[BUG]  [BUGGY]    tmpVec  =  new  VectorialPointValuePair(previousCost,  cost);  [CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double,double)  [FE]        AssertionFailedError  [CONTEXT]    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  [BUGGY]    tmpVec  =  new  VectorialPointValuePair(previousCost,  cost);  [BUGGY]  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	    tmpVec  =  new  VectorialPointValuePair(previousCost,  cost);		non-compiled	[CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double,double)	40	None	add
15	[BUG]  [BUGGY]    tmpVec  =  new  VectorialPointValuePair(previousCost,  preRed);  [CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double,double)  [FE]          AssertionFailedError  [CONTEXT]    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  [BUGGY]    tmpVec  =  new  VectorialPointValuePair(previousCost,  preRed);  [BUGGY]  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	    tmpVec  =  new  VectorialPointValuePair(previousCost,  preRed);		non-compiled	[CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double,double)	40	None	add
16	[BUG]  [BUGGY]  résults  =  tmpVec;  [CE]  cannot  find  symbol  r  [FE]    AssertionFailedError  [CONTEXT]    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  [BUGGY]  résults  =  tmpVec;  [BUGGY]  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	résults  =  tmpVec;	residuals  =  oldRes;  	non-compiled	[CE]  cannot  find  symbol  r	39	None	replace
17	[BUG]  [BUGGY]  results  =  tmpVec;  [CE]  cannot  find  symbol  results  [FE]    AssertionFailedError  [CONTEXT]    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  [BUGGY]  results  =  tmpVec;  [BUGGY]  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	results  =  tmpVec;	residuals  =  oldRes;  	non-compiled	[CE]  cannot  find  symbol  results	39	None	replace
18	[BUG]  [BUGGY]  residuals  -=  oldRes;  [CE]  bad  operand  types  for  binary  operator  '-'  [FE]      AssertionFailedError  [CONTEXT]    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  [BUGGY]  residuals  -=  oldRes;  [BUGGY]  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	residuals  -=  oldRes;	residuals  =  oldRes;  	non-compiled	[CE]  bad  operand  types  for  binary  operator  '-'	39	None	replace
19	[BUG]  [BUGGY]    if(tmpVec!=  previousCost)  {  cost  =  previousCost;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  point[pj]  =  oldX[pj];  }  [CE]  illegal  start  of  expression  [FE]    AssertionFailedError  [CONTEXT]    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  [BUGGY]    if(tmpVec!=  previousCost)  {  cost  =  previousCost;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  point[pj]  =  oldX[pj];  }  [BUGGY]  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	    if(tmpVec!=  previousCost)  {  cost  =  previousCost;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  point[pj]  =  oldX[pj];  }		non-compiled	[CE]  illegal  start  of  expression	40	None	add
20	[BUG]  [BUGGY]    if(tmpVec!=  previousCost)  {  cost  =  previousCost;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  permutation[j]  =  oldX[pj];  }  [CE]  illegal  start  of  expression  [FE]      AssertionFailedError  [CONTEXT]    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  [BUGGY]    if(tmpVec!=  previousCost)  {  cost  =  previousCost;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  permutation[j]  =  oldX[pj];  }  [BUGGY]  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	    if(tmpVec!=  previousCost)  {  cost  =  previousCost;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  permutation[j]  =  oldX[pj];  }		non-compiled	[CE]  illegal  start  of  expression	40	None	add
21	[BUG]  [BUGGY]    if(tmpVec!=  previousCost)  {  cost  =  previousCost;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  point[pj]  =  oldX[pj].doubleValue();  }  [CE]  illegal  start  of  expression  [FE]        AssertionFailedError  [CONTEXT]    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  [BUGGY]    if(tmpVec!=  previousCost)  {  cost  =  previousCost;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  point[pj]  =  oldX[pj].doubleValue();  }  [BUGGY]  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	    if(tmpVec!=  previousCost)  {  cost  =  previousCost;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  point[pj]  =  oldX[pj].doubleValue();  }		non-compiled	[CE]  illegal  start  of  expression	40	None	add
22	[BUG]  [BUGGY]    if(tmpVec!=  previousCost)  {  cost  =  previousCost;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  point[j]  =  oldX[pj];  }  [CE]  illegal  start  of  expression  [FE]          AssertionFailedError  [CONTEXT]    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  [BUGGY]    if(tmpVec!=  previousCost)  {  cost  =  previousCost;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  point[j]  =  oldX[pj];  }  [BUGGY]  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	    if(tmpVec!=  previousCost)  {  cost  =  previousCost;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  point[j]  =  oldX[pj];  }		non-compiled	[CE]  illegal  start  of  expression	40	None	add
23	[BUG]  [BUGGY]    if(tmpVec!=  previousCost)  {  cost  =  previousCost;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  oldRes  =  oldX[pj];  }  [CE]  illegal  start  of  expression  [FE]            AssertionFailedError  [CONTEXT]    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  [BUGGY]    if(tmpVec!=  previousCost)  {  cost  =  previousCost;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  oldRes  =  oldX[pj];  }  [BUGGY]  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	    if(tmpVec!=  previousCost)  {  cost  =  previousCost;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  oldRes  =  oldX[pj];  }		non-compiled	[CE]  illegal  start  of  expression	40	None	add
