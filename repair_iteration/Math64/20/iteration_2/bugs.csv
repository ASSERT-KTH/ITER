bugid	buggy	buggy_class	suspiciousness	buggy_line	endbuggycode	original_failing_test_number	action	patch	original_buggy	execution_result	diagnosis	previous_bug_id	new_failing_test_number	this_action
1	[BUG]  [BUGGY]  residuals  =  tmpVec  +  1;  [CE]  bad  operand  types  for  binary  operator  '+'  [FE]    AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;    [BUGGY]  residuals  =  tmpVec  +  1;  [BUGGY]    oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	residuals  =  tmpVec  +  1;	  residuals    =    tmpVec;    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '+'	8	None	replace
2	[BUG]  [BUGGY]  tmpVec  =  previousCost;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  point[pj]  =  oldX[pj].doubleValue();  }  [CE]  incompatible  types  [FE]            AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;    [BUGGY]  tmpVec  =  previousCost;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  point[pj]  =  oldX[pj].doubleValue();  }  [BUGGY]    residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	tmpVec  =  previousCost;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  point[pj]  =  oldX[pj].doubleValue();  }	      if(tmpVec!=    previousCost)    {    cost    =    previousCost;    for(int    j    =    0;    j    <    solvedCols;    ++j)    {    point[pj]    =    oldX[pj].doubleValue();    }    	non-compiled	[CE]  incompatible  types	21	None	replace
3	[BUG]  [BUGGY]  tmpVec  =  previousCost;  for(int  j  =  0;  j  <  resolvedCols;  ++j)  {  point[pj]  =  oldX[pj].doubleValue();  }  [CE]  incompatible  types  [FE]              AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;    [BUGGY]  tmpVec  =  previousCost;  for(int  j  =  0;  j  <  resolvedCols;  ++j)  {  point[pj]  =  oldX[pj].doubleValue();  }  [BUGGY]    residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	tmpVec  =  previousCost;  for(int  j  =  0;  j  <  resolvedCols;  ++j)  {  point[pj]  =  oldX[pj].doubleValue();  }	      if(tmpVec!=    previousCost)    {    cost    =    previousCost;    for(int    j    =    0;    j    <    solvedCols;    ++j)    {    point[pj]    =    oldX[pj].doubleValue();    }    	non-compiled	[CE]  incompatible  types	21	None	replace
4	[BUG]  [BUGGY]  tmpVec  =  previousCost;  for(int  j  =  0;  j  <  solveCols;  ++j)  {  point[pj]  =  oldX[pj].doubleValue();  }  [CE]  incompatible  types  [FE]                AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;    [BUGGY]  tmpVec  =  previousCost;  for(int  j  =  0;  j  <  solveCols;  ++j)  {  point[pj]  =  oldX[pj].doubleValue();  }  [BUGGY]    residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	tmpVec  =  previousCost;  for(int  j  =  0;  j  <  solveCols;  ++j)  {  point[pj]  =  oldX[pj].doubleValue();  }	      if(tmpVec!=    previousCost)    {    cost    =    previousCost;    for(int    j    =    0;    j    <    solvedCols;    ++j)    {    point[pj]    =    oldX[pj].doubleValue();    }    	non-compiled	[CE]  incompatible  types	21	None	replace
5	[BUG]  [BUGGY]  tmpVec  =  previousCost;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  points[pj]  =  oldX[pj].doubleValue();  }  [CE]  incompatible  types  [FE]                  AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;    [BUGGY]  tmpVec  =  previousCost;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  points[pj]  =  oldX[pj].doubleValue();  }  [BUGGY]    residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	tmpVec  =  previousCost;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  points[pj]  =  oldX[pj].doubleValue();  }	      if(tmpVec!=    previousCost)    {    cost    =    previousCost;    for(int    j    =    0;    j    <    solvedCols;    ++j)    {    point[pj]    =    oldX[pj].doubleValue();    }    	non-compiled	[CE]  incompatible  types	21	None	replace
6	[BUG]  [BUGGY]  tmpVec  =  previousCost;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  permutation[j]  =  oldX[pj];  }  [CE]  incompatible  types  [FE]          AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;    [BUGGY]  tmpVec  =  previousCost;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  permutation[j]  =  oldX[pj];  }  [BUGGY]    residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	tmpVec  =  previousCost;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  permutation[j]  =  oldX[pj];  }	      if(tmpVec!=    previousCost)    {    cost    =    previousCost;    for(int    j    =    0;    j    <    solvedCols;    ++j)    {    permutation[j]    =    oldX[pj];    }    	non-compiled	[CE]  incompatible  types	20	None	replace
7	[BUG]  [BUGGY]  tmpVec  =  previousCost;  for(int  j  =  0;  j  <  resolvedCols;  ++j)  {  permutation[j]  =  oldX[pj];  }  [CE]  incompatible  types  [FE]            AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;    [BUGGY]  tmpVec  =  previousCost;  for(int  j  =  0;  j  <  resolvedCols;  ++j)  {  permutation[j]  =  oldX[pj];  }  [BUGGY]    residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	tmpVec  =  previousCost;  for(int  j  =  0;  j  <  resolvedCols;  ++j)  {  permutation[j]  =  oldX[pj];  }	      if(tmpVec!=    previousCost)    {    cost    =    previousCost;    for(int    j    =    0;    j    <    solvedCols;    ++j)    {    permutation[j]    =    oldX[pj];    }    	non-compiled	[CE]  incompatible  types	20	None	replace
8	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(previousCost,  preRed,  cost);  [CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double,double,double)  [FE]              AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;    [BUGGY]  tmpVec  =  new  VectorialPointValuePair(previousCost,  preRed,  cost);  [BUGGY]    residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	tmpVec  =  new  VectorialPointValuePair(previousCost,  preRed,  cost);	      tmpVec    =    new    VectorialPointValuePair(previousCost,    preRed);    	non-compiled	[CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double,double,double)	15	None	replace
9	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(previousCost,  preRed,  point);  [CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double,double,double[])  [FE]                AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;    [BUGGY]  tmpVec  =  new  VectorialPointValuePair(previousCost,  preRed,  point);  [BUGGY]    residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	tmpVec  =  new  VectorialPointValuePair(previousCost,  preRed,  point);	      tmpVec    =    new    VectorialPointValuePair(previousCost,    preRed);    	non-compiled	[CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double,double,double[])	15	None	replace
10	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(previousCost,  preRed,  lastIteration);  [CE]  cannot  find  symbol  lastIteration  [FE]                  AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;    [BUGGY]  tmpVec  =  new  VectorialPointValuePair(previousCost,  preRed,  lastIteration);  [BUGGY]    residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	tmpVec  =  new  VectorialPointValuePair(previousCost,  preRed,  lastIteration);	      tmpVec    =    new    VectorialPointValuePair(previousCost,    preRed);    	non-compiled	[CE]  cannot  find  symbol  lastIteration	15	None	replace
11	[BUG]  [BUGGY]  tmpVec  =  permutation[0];  [CE]  incompatible  types  [FE]        AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;    [BUGGY]  tmpVec  =  permutation[0];  [BUGGY]    residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	tmpVec  =  permutation[0];	      tmpVec    =    permutation[j];    	non-compiled	[CE]  incompatible  types	1	None	replace
12	[BUG]  [BUGGY]  tmpVec  =  permutation[j]  +  1;  [CE]  cannot  find  symbol  j  [FE]          AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;    [BUGGY]  tmpVec  =  permutation[j]  +  1;  [BUGGY]    residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	tmpVec  =  permutation[j]  +  1;	      tmpVec    =    permutation[j];    	non-compiled	[CE]  cannot  find  symbol  j	1	None	replace
13	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(previousCost,  oldX,  cost);  [CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double,double[],double)  [FE]            AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;    [BUGGY]  tmpVec  =  new  VectorialPointValuePair(previousCost,  oldX,  cost);  [BUGGY]    residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	tmpVec  =  new  VectorialPointValuePair(previousCost,  oldX,  cost);	      tmpVec    =    new    VectorialPointValuePair(previousCost,    cost);    	non-compiled	[CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double,double[],double)	14	None	replace
14	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(previousCost,  point,  cost);  [CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double,double[],double)  [FE]              AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;    [BUGGY]  tmpVec  =  new  VectorialPointValuePair(previousCost,  point,  cost);  [BUGGY]    residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	tmpVec  =  new  VectorialPointValuePair(previousCost,  point,  cost);	      tmpVec    =    new    VectorialPointValuePair(previousCost,    cost);    	non-compiled	[CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double,double[],double)	14	None	replace
15	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(currentCost,  cost);  [CE]  cannot  find  symbol  currentCost  [FE]                AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;    [BUGGY]  tmpVec  =  new  VectorialPointValuePair(currentCost,  cost);  [BUGGY]    residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	tmpVec  =  new  VectorialPointValuePair(currentCost,  cost);	      tmpVec    =    new    VectorialPointValuePair(previousCost,    cost);    	non-compiled	[CE]  cannot  find  symbol  currentCost	14	None	replace
16	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;    [BUGGY]  residuals  =  tmpVec;  oldRes  =  tmpVec;  [BUGGY]    oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	add	residuals    =    tmpVec;    oldRes  =  tmpVec;	  	compilable	  [FE]  AssertionFailedError  	7	10	add
17	[BUG]  [BUGGY]  residuals  =  tmpVec;  oldRes  =  tmpVec;  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;    [BUGGY]  residuals  =  tmpVec;  oldRes  =  tmpVec;  [BUGGY]    oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	residuals    =    tmpVec;    oldRes  =  tmpVec;	  	compilable	  [FE]  AssertionFailedError  	7	10	add
18	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;    [BUGGY]  residuals  =  tmpVec;  tmpVec  =  tmpVec;  [BUGGY]    oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	add	residuals    =    tmpVec;    tmpVec  =  tmpVec;	  	compilable	  [FE]  AssertionFailedError  	7	2	add
19	[BUG]  [BUGGY]  residuals  =  tmpVec;  tmpVec  =  tmpVec;  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;    [BUGGY]  residuals  =  tmpVec;  tmpVec  =  tmpVec;  [BUGGY]    oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	residuals    =    tmpVec;    tmpVec  =  tmpVec;	  	compilable	  [FE]  AssertionFailedError  	7	2	add
20	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;    [BUGGY]  residuals  =  tmpVec;  residuals  =  tmpVec;  [BUGGY]    oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	add	residuals    =    tmpVec;    residuals  =  tmpVec;	  	compilable	  [FE]  AssertionFailedError  	7	2	add
21	[BUG]  [BUGGY]  residuals  =  tmpVec;  residuals  =  tmpVec;  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;    [BUGGY]  residuals  =  tmpVec;  residuals  =  tmpVec;  [BUGGY]    oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	residuals    =    tmpVec;    residuals  =  tmpVec;	  	compilable	  [FE]  AssertionFailedError  	7	2	add
22	[BUG]  [BUGGY]  residuals  =  tmpVec;  remainings  =  tmpVec;  [CE]  cannot  find  symbol  remainings  [FE]          AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;    [BUGGY]  residuals  =  tmpVec;  remainings  =  tmpVec;  [BUGGY]    oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	residuals    =    tmpVec;    remainings  =  tmpVec;	  	non-compiled	[CE]  cannot  find  symbol  remainings	7	None	add
23	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;    [BUGGY]  residuals  =  tmpVec;  tmpVec  =  residuals;  [BUGGY]    oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	add	residuals    =    tmpVec;    tmpVec  =  residuals;	  	compilable	  [FE]  AssertionFailedError  	7	2	add
24	[BUG]  [BUGGY]  residuals  =  tmpVec;  tmpVec  =  residuals;  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;    [BUGGY]  residuals  =  tmpVec;  tmpVec  =  residuals;  [BUGGY]    oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	residuals    =    tmpVec;    tmpVec  =  residuals;	  	compilable	  [FE]  AssertionFailedError  	7	2	add
25	[BUG]  [BUGGY]  tmpVec  =  previousCost;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  oldRes  =  oldX[pj];  }  [CE]  incompatible  types  [FE]                AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;    [BUGGY]  tmpVec  =  previousCost;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  oldRes  =  oldX[pj];  }  [BUGGY]    residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	tmpVec  =  previousCost;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  oldRes  =  oldX[pj];  }	      if(tmpVec!=    previousCost)    {    cost    =    previousCost;    for(int    j    =    0;    j    <    solvedCols;    ++j)    {    int    oldRes    =    oldX[pj];    }    	non-compiled	[CE]  incompatible  types	23	None	replace
26	[BUG]  [BUGGY]  tmpVec  =  previousCost;  for(int  j  =  0;  j  <  resolvedCols;  ++j)  {  int  oldRes  =  oldX[pj];  }  [CE]  incompatible  types  [FE]                  AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;    [BUGGY]  tmpVec  =  previousCost;  for(int  j  =  0;  j  <  resolvedCols;  ++j)  {  int  oldRes  =  oldX[pj];  }  [BUGGY]    residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	tmpVec  =  previousCost;  for(int  j  =  0;  j  <  resolvedCols;  ++j)  {  int  oldRes  =  oldX[pj];  }	      if(tmpVec!=    previousCost)    {    cost    =    previousCost;    for(int    j    =    0;    j    <    solvedCols;    ++j)    {    int    oldRes    =    oldX[pj];    }    	non-compiled	[CE]  incompatible  types	23	None	replace
27	[BUG]  [BUGGY]  tmpVec  =  previousCost;  for(int  j  =  0;  j  <  solveCols;  ++j)  {  int  oldRes  =  oldX[pj];  }  [CE]  incompatible  types  [FE]                    AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;    [BUGGY]  tmpVec  =  previousCost;  for(int  j  =  0;  j  <  solveCols;  ++j)  {  int  oldRes  =  oldX[pj];  }  [BUGGY]    residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	tmpVec  =  previousCost;  for(int  j  =  0;  j  <  solveCols;  ++j)  {  int  oldRes  =  oldX[pj];  }	      if(tmpVec!=    previousCost)    {    cost    =    previousCost;    for(int    j    =    0;    j    <    solvedCols;    ++j)    {    int    oldRes    =    oldX[pj];    }    	non-compiled	[CE]  incompatible  types	23	None	replace
28	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(pj);  [CE]  cannot  find  symbol  pj  [FE]          AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;    [BUGGY]  tmpVec  =  new  VectorialPointValuePair(pj);  [BUGGY]    residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	tmpVec  =  new  VectorialPointValuePair(pj);	      tmpVec    =    new    VectorialPointValuePair();    	non-compiled	[CE]  cannot  find  symbol  pj	13	None	replace
29	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(remainings);  [CE]  cannot  find  symbol  remainings  [FE]            AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;    [BUGGY]  tmpVec  =  new  VectorialPointValuePair(remainings);  [BUGGY]    residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	tmpVec  =  new  VectorialPointValuePair(remainings);	      tmpVec    =    new    VectorialPointValuePair();    	non-compiled	[CE]  cannot  find  symbol  remainings	13	None	replace
30	[BUG]  [BUGGY]  tmpVec  =  previousCost;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  point[pj]  =  oldX[pj];  }  [CE]  incompatible  types  [FE]        AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;    [BUGGY]  tmpVec  =  previousCost;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  point[pj]  =  oldX[pj];  }  [BUGGY]    residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	tmpVec  =  previousCost;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  point[pj]  =  oldX[pj];  }	      if(tmpVec!=    previousCost)    {    cost    =    previousCost;    for(int    j    =    0;    j    <    solvedCols;    ++j)    {    point[pj]    =    oldX[pj];    }    	non-compiled	[CE]  incompatible  types	19	None	replace
31	[BUG]  [BUGGY]  tmpVec  =  previousCost;  for(int  j  =  0;  j  <  resolvedCols;  ++j)  {  point[pj]  =  oldX[pj];  }  [CE]  incompatible  types  [FE]          AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;    [BUGGY]  tmpVec  =  previousCost;  for(int  j  =  0;  j  <  resolvedCols;  ++j)  {  point[pj]  =  oldX[pj];  }  [BUGGY]    residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	tmpVec  =  previousCost;  for(int  j  =  0;  j  <  resolvedCols;  ++j)  {  point[pj]  =  oldX[pj];  }	      if(tmpVec!=    previousCost)    {    cost    =    previousCost;    for(int    j    =    0;    j    <    solvedCols;    ++j)    {    point[pj]    =    oldX[pj];    }    	non-compiled	[CE]  incompatible  types	19	None	replace
32	[BUG]  [BUGGY]  tmpVec  =  previousCost;  for(int  j  =  0;  j  <  solveCols;  ++j)  {  point[pj]  =  oldX[pj];  }  [CE]  incompatible  types  [FE]            AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;    [BUGGY]  tmpVec  =  previousCost;  for(int  j  =  0;  j  <  solveCols;  ++j)  {  point[pj]  =  oldX[pj];  }  [BUGGY]    residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	tmpVec  =  previousCost;  for(int  j  =  0;  j  <  solveCols;  ++j)  {  point[pj]  =  oldX[pj];  }	      if(tmpVec!=    previousCost)    {    cost    =    previousCost;    for(int    j    =    0;    j    <    solvedCols;    ++j)    {    point[pj]    =    oldX[pj];    }    	non-compiled	[CE]  incompatible  types	19	None	replace
33	[BUG]  [BUGGY]  tmpVec  =  previousCost;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  points[pj]  =  oldX[pj];  }  [CE]  incompatible  types  [FE]              AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;    [BUGGY]  tmpVec  =  previousCost;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  points[pj]  =  oldX[pj];  }  [BUGGY]    residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	tmpVec  =  previousCost;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  points[pj]  =  oldX[pj];  }	      if(tmpVec!=    previousCost)    {    cost    =    previousCost;    for(int    j    =    0;    j    <    solvedCols;    ++j)    {    point[pj]    =    oldX[pj];    }    	non-compiled	[CE]  incompatible  types	19	None	replace
34	[BUG]  [BUGGY]  [FE]  ArrayIndexOutOfBoundsException  [FE]            AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;    [BUGGY]  tmpVec  =  oldX;  [BUGGY]    oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	add	tmpVec  =  oldX;	  res    =    tmpVec;    	compilable	  [FE]  ArrayIndexOutOfBoundsException  	10	12	replace
35	[BUG]  [BUGGY]  tmpVec  =  oldX;  [FE]  ArrayIndexOutOfBoundsException  [FE]            AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;    [BUGGY]  tmpVec  =  oldX;  [BUGGY]    oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	tmpVec  =  oldX;	  res    =    tmpVec;    	compilable	  [FE]  ArrayIndexOutOfBoundsException  	10	12	replace
36	[BUG]  [BUGGY]  res  =  oldRes;  [CE]  cannot  find  symbol  res  [FE]              AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;    [BUGGY]  res  =  oldRes;  [BUGGY]    oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	res  =  oldRes;	  res    =    tmpVec;    	non-compiled	[CE]  cannot  find  symbol  res	10	None	replace
37	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;    [BUGGY]      oldRes  =  tmpVec;  oldRes  =  tmpVec;  [BUGGY]    residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	add	        oldRes    =    tmpVec;    oldRes  =  tmpVec;	  	compilable	  [FE]  AssertionFailedError  	3	10	add
38	[BUG]  [BUGGY]      oldRes  =  tmpVec;  oldRes  =  tmpVec;  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;    [BUGGY]      oldRes  =  tmpVec;  oldRes  =  tmpVec;  [BUGGY]    residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	        oldRes    =    tmpVec;    oldRes  =  tmpVec;	  	compilable	  [FE]  AssertionFailedError  	3	10	add
39	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;    [BUGGY]      oldRes  =  tmpVec;  tmpVec  =  tmpVec;  [BUGGY]    residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	add	        oldRes    =    tmpVec;    tmpVec  =  tmpVec;	  	compilable	  [FE]  AssertionFailedError  	3	10	add
40	[BUG]  [BUGGY]      oldRes  =  tmpVec;  tmpVec  =  tmpVec;  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;    [BUGGY]      oldRes  =  tmpVec;  tmpVec  =  tmpVec;  [BUGGY]    residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	        oldRes    =    tmpVec;    tmpVec  =  tmpVec;	  	compilable	  [FE]  AssertionFailedError  	3	10	add
41	[BUG]  [BUGGY]      oldRes  =  tmpVec;  new  VectorialPointValuePair(previousCost,  oldX,  oldRes,  tmpVec);  [CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double,double[],double[],double[])  [FE]        AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;    [BUGGY]      oldRes  =  tmpVec;  new  VectorialPointValuePair(previousCost,  oldX,  oldRes,  tmpVec);  [BUGGY]    residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	        oldRes    =    tmpVec;    new  VectorialPointValuePair(previousCost,  oldX,  oldRes,  tmpVec);	  	non-compiled	[CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double,double[],double[],double[])	3	None	add
42	[BUG]  [BUGGY]      oldRes  =  tmpVec;  new  VectorialPointValuePair(oldX,  oldRes,  tmpVec);  [CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double[],double[],double[])  [FE]          AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;    [BUGGY]      oldRes  =  tmpVec;  new  VectorialPointValuePair(oldX,  oldRes,  tmpVec);  [BUGGY]    residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	        oldRes    =    tmpVec;    new  VectorialPointValuePair(oldX,  oldRes,  tmpVec);	  	non-compiled	[CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double[],double[],double[])	3	None	add
43	[BUG]  [BUGGY]  residuals  -=  oldX;  [CE]  bad  operand  types  for  binary  operator  '-'  [FE]          AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;    [BUGGY]  residuals  -=  oldX;  [BUGGY]    oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	residuals  -=  oldX;	  residuals    -=    oldRes;    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '-'	18	None	replace
44	[BUG]  [BUGGY]  tmpVec  -=  oldRes;  [CE]  bad  operand  types  for  binary  operator  '-'  [FE]            AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;    [BUGGY]  tmpVec  -=  oldRes;  [BUGGY]    oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	tmpVec  -=  oldRes;	  residuals    -=    oldRes;    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '-'	18	None	replace
45	[BUG]  [BUGGY]  residuals  -=  oldRes.length;  [CE]  bad  operand  types  for  binary  operator  '-'  [FE]              AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;    [BUGGY]  residuals  -=  oldRes.length;  [BUGGY]    oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	residuals  -=  oldRes.length;	  residuals    -=    oldRes;    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '-'	18	None	replace
46	[BUG]  [BUGGY]  remainings  -=  oldRes.length;  [CE]  cannot  find  symbol  remainings  [FE]                AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;    [BUGGY]  remainings  -=  oldRes.length;  [BUGGY]    oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	remainings  -=  oldRes.length;	  residuals    -=    oldRes;    	non-compiled	[CE]  cannot  find  symbol  remainings	18	None	replace
47	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;    [BUGGY]  tmpVec  =  oldRes;  [BUGGY]    oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	add	tmpVec  =  oldRes;	  results    =    tmpVec;    	compilable	  [FE]  AssertionFailedError  	17	10	replace
48	[BUG]  [BUGGY]  tmpVec  =  oldRes;  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;    [BUGGY]  tmpVec  =  oldRes;  [BUGGY]    oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	tmpVec  =  oldRes;	  results    =    tmpVec;    	compilable	  [FE]  AssertionFailedError  	17	10	replace
49	[BUG]  [BUGGY]  results  =  oldRes;  [CE]  cannot  find  symbol  results  [FE]          AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;    [BUGGY]  results  =  oldRes;  [BUGGY]    oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	results  =  oldRes;	  results    =    tmpVec;    	non-compiled	[CE]  cannot  find  symbol  results	17	None	replace
50	[BUG]  [BUGGY]  result  =  tmpVec;  [CE]  cannot  find  symbol  result  [FE]            AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;    [BUGGY]  result  =  tmpVec;  [BUGGY]    oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	result  =  tmpVec;	  results    =    tmpVec;    	non-compiled	[CE]  cannot  find  symbol  result	17	None	replace
51	[BUG]  [BUGGY]  remainders  =  oldRes;  [CE]  cannot  find  symbol  remainders  [FE]          AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;    [BUGGY]  remainders  =  oldRes;  [BUGGY]    oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	remainders  =  oldRes;	  remainders    =    tmpVec;    	non-compiled	[CE]  cannot  find  symbol  remainders	9	None	replace
52	[BUG]  [BUGGY]  tmpVec  =  permutation[pj].doubleValue();  [CE]  cannot  find  symbol  pj  [FE]          AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;    [BUGGY]  tmpVec  =  permutation[pj].doubleValue();  [BUGGY]    residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	tmpVec  =  permutation[pj].doubleValue();	      tmpVec    =    permutation[j].doubleValue();    	non-compiled	[CE]  cannot  find  symbol  pj	2	None	replace
53	[BUG]  [BUGGY]  tmpVec  =  permutation[j].doubleValue()  +  1;  [CE]  cannot  find  symbol  j  [FE]            AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;    [BUGGY]  tmpVec  =  permutation[j].doubleValue()  +  1;  [BUGGY]    residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	tmpVec  =  permutation[j].doubleValue()  +  1;	      tmpVec    =    permutation[j].doubleValue();    	non-compiled	[CE]  cannot  find  symbol  j	2	None	replace
54	[BUG]  [BUGGY]  tmpVec  =  Math.max(result,  previousCost);  [CE]  cannot  find  symbol  result  [FE]                AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;    [BUGGY]  tmpVec  =  Math.max(result,  previousCost);  [BUGGY]    residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	tmpVec  =  Math.max(result,  previousCost);	      tmpVec    =    Math.max(remainings,    previousCost);    	non-compiled	[CE]  cannot  find  symbol  result	6	None	replace
55	[BUG]  [BUGGY]  tmpVec  =  Math.max(results,  previousCost);  [CE]  cannot  find  symbol  results  [FE]                  AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;    [BUGGY]  tmpVec  =  Math.max(results,  previousCost);  [BUGGY]    residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	tmpVec  =  Math.max(results,  previousCost);	      tmpVec    =    Math.max(remainings,    previousCost);    	non-compiled	[CE]  cannot  find  symbol  results	6	None	replace
56	[BUG]  [BUGGY]  tmpVec  =  Math.max(remainings,  oldX);  [CE]  cannot  find  symbol  remainings  [FE]                    AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;    [BUGGY]  tmpVec  =  Math.max(remainings,  oldX);  [BUGGY]    residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	tmpVec  =  Math.max(remainings,  oldX);	      tmpVec    =    Math.max(remainings,    previousCost);    	non-compiled	[CE]  cannot  find  symbol  remainings	6	None	replace
57	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(previousCost,  point);  [CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double,double[])  [FE]        AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;    [BUGGY]  tmpVec  =  new  VectorialPointValuePair(previousCost,  point);  [BUGGY]    residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	tmpVec  =  new  VectorialPointValuePair(previousCost,  point);	      tmpVec    =    new    VectorialPointValuePair(previousCost);    	non-compiled	[CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double,double[])	12	None	replace
58	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(pj,  previousCost);  [CE]  cannot  find  symbol  pj  [FE]          AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;    [BUGGY]  tmpVec  =  new  VectorialPointValuePair(pj,  previousCost);  [BUGGY]    residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	tmpVec  =  new  VectorialPointValuePair(pj,  previousCost);	      tmpVec    =    new    VectorialPointValuePair(previousCost);    	non-compiled	[CE]  cannot  find  symbol  pj	12	None	replace
59	[BUG]  [BUGGY]  oldRes  =  tmpVec  +  1;  [CE]  bad  operand  types  for  binary  operator  '+'  [FE]    AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;    [BUGGY]  oldRes  =  tmpVec  +  1;  [BUGGY]    residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	oldRes  =  tmpVec  +  1;	      oldRes    =    tmpVec;    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '+'	4	None	replace
60	[BUG]  [BUGGY]  tmpVec  =  oldX[pj];  [CE]  cannot  find  symbol  pj  [FE]              AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;    [BUGGY]  tmpVec  =  oldX[pj];  [BUGGY]    residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	tmpVec  =  oldX[pj];	      tmpVec    =    permutation[pj];    	non-compiled	[CE]  cannot  find  symbol  pj	5	None	replace
61	[BUG]  [BUGGY]  tmpVec  =  point[pj];  [CE]  cannot  find  symbol  pj  [FE]                AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;    [BUGGY]  tmpVec  =  point[pj];  [BUGGY]    residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	tmpVec  =  point[pj];	      tmpVec    =    permutation[pj];    	non-compiled	[CE]  cannot  find  symbol  pj	5	None	replace
62	[BUG]  [BUGGY]  remainings  =  oldRes;  [CE]  cannot  find  symbol  remainings  [FE]              AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;    [BUGGY]  remainings  =  oldRes;  [BUGGY]    oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	remainings  =  oldRes;	  remainings    =    tmpVec;    	non-compiled	[CE]  cannot  find  symbol  remainings	11	None	replace
63	[BUG]  [BUGGY]  tmpVec  =  previousCost;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  point[j]  =  oldX[pj];  }  [CE]  incompatible  types  [FE]              AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;    [BUGGY]  tmpVec  =  previousCost;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  point[j]  =  oldX[pj];  }  [BUGGY]    residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	tmpVec  =  previousCost;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  point[j]  =  oldX[pj];  }	      if(tmpVec!=    previousCost)    {    cost    =    previousCost;    for(int    j    =    0;    j    <    solvedCols;    ++j)    {    point[j]    =    oldX[pj];    }    	non-compiled	[CE]  incompatible  types	22	None	replace
64	[BUG]  [BUGGY]  tmpVec  =  previousCost;  for(int  j  =  0;  j  <  resolvedCols;  ++j)  {  point[j]  =  oldX[pj];  }  [CE]  incompatible  types  [FE]                AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;    [BUGGY]  tmpVec  =  previousCost;  for(int  j  =  0;  j  <  resolvedCols;  ++j)  {  point[j]  =  oldX[pj];  }  [BUGGY]    residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	tmpVec  =  previousCost;  for(int  j  =  0;  j  <  resolvedCols;  ++j)  {  point[j]  =  oldX[pj];  }	      if(tmpVec!=    previousCost)    {    cost    =    previousCost;    for(int    j    =    0;    j    <    solvedCols;    ++j)    {    point[j]    =    oldX[pj];    }    	non-compiled	[CE]  incompatible  types	22	None	replace
65	[BUG]  [BUGGY]  tmpVec  =  previousCost;  for(int  j  =  0;  j  <  solveCols;  ++j)  {  point[j]  =  oldX[pj];  }  [CE]  incompatible  types  [FE]                  AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;    [BUGGY]  tmpVec  =  previousCost;  for(int  j  =  0;  j  <  solveCols;  ++j)  {  point[j]  =  oldX[pj];  }  [BUGGY]    residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	tmpVec  =  previousCost;  for(int  j  =  0;  j  <  solveCols;  ++j)  {  point[j]  =  oldX[pj];  }	      if(tmpVec!=    previousCost)    {    cost    =    previousCost;    for(int    j    =    0;    j    <    solvedCols;    ++j)    {    point[j]    =    oldX[pj];    }    	non-compiled	[CE]  incompatible  types	22	None	replace
66	[BUG]  [BUGGY]  tmpVec  =  previousCost;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  points[j]  =  oldX[pj];  }  [CE]  incompatible  types  [FE]                    AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;    [BUGGY]  tmpVec  =  previousCost;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  points[j]  =  oldX[pj];  }  [BUGGY]    residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	tmpVec  =  previousCost;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  points[j]  =  oldX[pj];  }	      if(tmpVec!=    previousCost)    {    cost    =    previousCost;    for(int    j    =    0;    j    <    solvedCols;    ++j)    {    point[j]    =    oldX[pj];    }    	non-compiled	[CE]  incompatible  types	22	None	replace
67	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;    [BUGGY]  tmpVec  =  tmpVec;  [BUGGY]    oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	add	tmpVec  =  tmpVec;	  rsults    =    tmpVec;    	compilable	  [FE]  AssertionFailedError  	16	10	replace
68	[BUG]  [BUGGY]  tmpVec  =  tmpVec;  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;    [BUGGY]  tmpVec  =  tmpVec;  [BUGGY]    oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	tmpVec  =  tmpVec;	  rsults    =    tmpVec;    	compilable	  [FE]  AssertionFailedError  	16	10	replace
69	[BUG]  [BUGGY]  tmpVec  =  result;  [CE]  cannot  find  symbol  result  [FE]          AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;    [BUGGY]  tmpVec  =  result;  [BUGGY]    oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	tmpVec  =  result;	  rsults    =    tmpVec;    	non-compiled	[CE]  cannot  find  symbol  result	16	None	replace
70	[BUG]  [BUGGY]  value  =  tmpVec;  [CE]  cannot  find  symbol  value  [FE]            AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;    [BUGGY]  value  =  tmpVec;  [BUGGY]    oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	value  =  tmpVec;	  rsults    =    tmpVec;    	non-compiled	[CE]  cannot  find  symbol  value	16	None	replace
71	[BUG]  [BUGGY]  tmpVec  =  permutation[point];  [CE]  incompatible  types  [FE]              AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;    [BUGGY]  tmpVec  =  permutation[point];  [BUGGY]    residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	tmpVec  =  permutation[point];	      tmpVec    =    permutation[pj];    	non-compiled	[CE]  incompatible  types	5	None	replace
72	[BUG]  [BUGGY]  if(tmpVec!=  previousCost)  {  cost  =  prevCost;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  permutation[j]  =  oldX[pj];  }  [CE]  illegal  start  of  expression  [FE]          AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;    [BUGGY]  if(tmpVec!=  previousCost)  {  cost  =  prevCost;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  permutation[j]  =  oldX[pj];  }  [BUGGY]    residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	if(tmpVec!=  previousCost)  {  cost  =  prevCost;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  permutation[j]  =  oldX[pj];  }	      if(tmpVec!=    previousCost)    {    cost    =    previousCost;    for(int    j    =    0;    j    <    solvedCols;    ++j)    {    permutation[j]    =    oldX[pj];    }    	non-compiled	[CE]  illegal  start  of  expression	20	None	replace
73	[BUG]  [BUGGY]  if(tmpVec!=  previousCost)  {  cost  =  oldRes;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  permutation[j]  =  oldX[pj];  }  [CE]  illegal  start  of  expression  [FE]            AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;    [BUGGY]  if(tmpVec!=  previousCost)  {  cost  =  oldRes;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  permutation[j]  =  oldX[pj];  }  [BUGGY]    residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	if(tmpVec!=  previousCost)  {  cost  =  oldRes;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  permutation[j]  =  oldX[pj];  }	      if(tmpVec!=    previousCost)    {    cost    =    previousCost;    for(int    j    =    0;    j    <    solvedCols;    ++j)    {    permutation[j]    =    oldX[pj];    }    	non-compiled	[CE]  illegal  start  of  expression	20	None	replace
74	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(oldX);  [CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double[])  [FE]          AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;    [BUGGY]  tmpVec  =  new  VectorialPointValuePair(oldX);  [BUGGY]    residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	tmpVec  =  new  VectorialPointValuePair(oldX);	      tmpVec    =    new    VectorialPointValuePair();    	non-compiled	[CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double[])	13	None	replace
75	[BUG]  [BUGGY]  residuals  =  tmpVec;  if(remainings  ==  tmpVec)  {  cost  =  previousCost;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  oldRes  =  tmpVec;  }  [CE]  illegal  start  of  expression  [FE]    AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;    [BUGGY]  residuals  =  tmpVec;  if(remainings  ==  tmpVec)  {  cost  =  previousCost;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  oldRes  =  tmpVec;  }  [BUGGY]    oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	residuals    =    tmpVec;    if(remainings  ==  tmpVec)  {  cost  =  previousCost;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  oldRes  =  tmpVec;  }	  	non-compiled	[CE]  illegal  start  of  expression	7	None	add
76	[BUG]  [BUGGY]  residuals  =  tmpVec;  if(remainings  ==  tmpVec)  {  cost  =  previousCost;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  oldX[j]  =  oldX[j];  }  [CE]  illegal  start  of  expression  [FE]      AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;    [BUGGY]  residuals  =  tmpVec;  if(remainings  ==  tmpVec)  {  cost  =  previousCost;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  oldX[j]  =  oldX[j];  }  [BUGGY]    oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	residuals    =    tmpVec;    if(remainings  ==  tmpVec)  {  cost  =  previousCost;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  oldX[j]  =  oldX[j];  }	  	non-compiled	[CE]  illegal  start  of  expression	7	None	add
77	[BUG]  [BUGGY]  results  =  tmpVec  +  1;  [CE]  cannot  find  symbol  results  [FE]        AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;    [BUGGY]  results  =  tmpVec  +  1;  [BUGGY]    oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	results  =  tmpVec  +  1;	  results    =    tmpVec;    	non-compiled	[CE]  cannot  find  symbol  results	17	None	replace
78	[BUG]  [BUGGY]  results  =  tmpVec.results;  [CE]  cannot  find  symbol  results  [FE]          AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;    [BUGGY]  results  =  tmpVec.results;  [BUGGY]    oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	results  =  tmpVec.results;	  results    =    tmpVec;    	non-compiled	[CE]  cannot  find  symbol  results	17	None	replace
79	[BUG]  [BUGGY]  results  =  new  VectorialPointValuePair(oldX,  oldRes);  [CE]  cannot  find  symbol  results  [FE]            AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;    [BUGGY]  results  =  new  VectorialPointValuePair(oldX,  oldRes);  [BUGGY]    oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	results  =  new  VectorialPointValuePair(oldX,  oldRes);	  results    =    tmpVec;    	non-compiled	[CE]  cannot  find  symbol  results	17	None	replace
80	[BUG]  [BUGGY]  tmpVec  =  Math.max(relativeTolerance,  previousCost);  [CE]  cannot  find  symbol  relativeTolerance  [FE]                AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;    [BUGGY]  tmpVec  =  Math.max(relativeTolerance,  previousCost);  [BUGGY]    residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	tmpVec  =  Math.max(relativeTolerance,  previousCost);	      tmpVec    =    Math.max(remainings,    previousCost);    	non-compiled	[CE]  cannot  find  symbol  relativeTolerance	6	None	replace
81	[BUG]  [BUGGY]  remainders  =  tmpVec  +  1;  [CE]  cannot  find  symbol  remainders  [FE]          AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;    [BUGGY]  remainders  =  tmpVec  +  1;  [BUGGY]    oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	remainders  =  tmpVec  +  1;	  remainders    =    tmpVec;    	non-compiled	[CE]  cannot  find  symbol  remainders	9	None	replace
82	[BUG]  [BUGGY]  remainders  =  new  VectorialPointValuePair(oldX,  oldRes);  [CE]  cannot  find  symbol  remainders  [FE]            AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;    [BUGGY]  remainders  =  new  VectorialPointValuePair(oldX,  oldRes);  [BUGGY]    oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	remainders  =  new  VectorialPointValuePair(oldX,  oldRes);	  remainders    =    tmpVec;    	non-compiled	[CE]  cannot  find  symbol  remainders	9	None	replace
83	[BUG]  [BUGGY]  tmpVec  =  permutation[oldRes];  [CE]  incompatible  types  [FE]        AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;    [BUGGY]  tmpVec  =  permutation[oldRes];  [BUGGY]    residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	tmpVec  =  permutation[oldRes];	      tmpVec    =    permutation[j];    	non-compiled	[CE]  incompatible  types	1	None	replace
84	[BUG]  [BUGGY]  rsults  =  result;  [CE]  cannot  find  symbol  rsults  [FE]        AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;    [BUGGY]  rsults  =  result;  [BUGGY]    oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	rsults  =  result;	  rsults    =    tmpVec;    	non-compiled	[CE]  cannot  find  symbol  rsults	16	None	replace
85	[BUG]  [BUGGY]  rsults  =  cost;  [CE]  cannot  find  symbol  rsults  [FE]          AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;    [BUGGY]  rsults  =  cost;  [BUGGY]    oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	rsults  =  cost;	  rsults    =    tmpVec;    	non-compiled	[CE]  cannot  find  symbol  rsults	16	None	replace
86	[BUG]  [BUGGY]  tmpVec  =  permutation[0].doubleValue();  [CE]  int  cannot  be  dereferenced  [FE]          AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;    [BUGGY]  tmpVec  =  permutation[0].doubleValue();  [BUGGY]    residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	tmpVec  =  permutation[0].doubleValue();	      tmpVec    =    permutation[j].doubleValue();    	non-compiled	[CE]  int  cannot  be  dereferenced	2	None	replace
87	[BUG]  [BUGGY]  tmpVec  =  permutation[point].doubleValue();  [CE]  incompatible  types  [FE]            AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;    [BUGGY]  tmpVec  =  permutation[point].doubleValue();  [BUGGY]    residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	tmpVec  =  permutation[point].doubleValue();	      tmpVec    =    permutation[j].doubleValue();    	non-compiled	[CE]  incompatible  types	2	None	replace
88	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(lastX,  previousCost,  cost);  [CE]  cannot  find  symbol  lastX  [FE]            AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;    [BUGGY]  tmpVec  =  new  VectorialPointValuePair(lastX,  previousCost,  cost);  [BUGGY]    residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	tmpVec  =  new  VectorialPointValuePair(lastX,  previousCost,  cost);	      tmpVec    =    new    VectorialPointValuePair(previousCost,    cost);    	non-compiled	[CE]  cannot  find  symbol  lastX	14	None	replace
89	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(point,  previousCost,  cost);  [CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double[],double,double)  [FE]              AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;    [BUGGY]  tmpVec  =  new  VectorialPointValuePair(point,  previousCost,  cost);  [BUGGY]    residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	tmpVec  =  new  VectorialPointValuePair(point,  previousCost,  cost);	      tmpVec    =    new    VectorialPointValuePair(previousCost,    cost);    	non-compiled	[CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double[],double,double)	14	None	replace
90	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(pj,  previousCost,  cost);  [CE]  cannot  find  symbol  pj  [FE]                AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;    [BUGGY]  tmpVec  =  new  VectorialPointValuePair(pj,  previousCost,  cost);  [BUGGY]    residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	tmpVec  =  new  VectorialPointValuePair(pj,  previousCost,  cost);	      tmpVec    =    new    VectorialPointValuePair(previousCost,    cost);    	non-compiled	[CE]  cannot  find  symbol  pj	14	None	replace
91	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(last,  previousCost,  cost);  [CE]  cannot  find  symbol  last  [FE]                  AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;    [BUGGY]  tmpVec  =  new  VectorialPointValuePair(last,  previousCost,  cost);  [BUGGY]    residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	tmpVec  =  new  VectorialPointValuePair(last,  previousCost,  cost);	      tmpVec    =    new    VectorialPointValuePair(previousCost,    cost);    	non-compiled	[CE]  cannot  find  symbol  last	14	None	replace
92	[BUG]  [BUGGY]  if(tmpVec!=  null)  {  cost  =  previousCost;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  point[j]  =  oldX[pj];  }  [CE]  illegal  start  of  expression  [FE]              AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;    [BUGGY]  if(tmpVec!=  null)  {  cost  =  previousCost;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  point[j]  =  oldX[pj];  }  [BUGGY]    residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	if(tmpVec!=  null)  {  cost  =  previousCost;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  point[j]  =  oldX[pj];  }	      if(tmpVec!=    previousCost)    {    cost    =    previousCost;    for(int    j    =    0;    j    <    solvedCols;    ++j)    {    point[j]    =    oldX[pj];    }    	non-compiled	[CE]  illegal  start  of  expression	22	None	replace
93	[BUG]  [BUGGY]  if(tmpVec!=  previousCost)  {  cost  =  permutation[j];  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  point[j]  =  oldX[pj];  }  [CE]  illegal  start  of  expression  [FE]                AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;    [BUGGY]  if(tmpVec!=  previousCost)  {  cost  =  permutation[j];  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  point[j]  =  oldX[pj];  }  [BUGGY]    residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	if(tmpVec!=  previousCost)  {  cost  =  permutation[j];  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  point[j]  =  oldX[pj];  }	      if(tmpVec!=    previousCost)    {    cost    =    previousCost;    for(int    j    =    0;    j    <    solvedCols;    ++j)    {    point[j]    =    oldX[pj];    }    	non-compiled	[CE]  illegal  start  of  expression	22	None	replace
94	[BUG]  [BUGGY]  if(tmpVec!=  previousCost)  {  cost  =  permutation[j];  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  oldRes  =  oldX[pj];  }  [CE]  illegal  start  of  expression  [FE]                AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;    [BUGGY]  if(tmpVec!=  previousCost)  {  cost  =  permutation[j];  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  oldRes  =  oldX[pj];  }  [BUGGY]    residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	if(tmpVec!=  previousCost)  {  cost  =  permutation[j];  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  oldRes  =  oldX[pj];  }	      if(tmpVec!=    previousCost)    {    cost    =    previousCost;    for(int    j    =    0;    j    <    solvedCols;    ++j)    {    int    oldRes    =    oldX[pj];    }    	non-compiled	[CE]  illegal  start  of  expression	23	None	replace
95	[BUG]  [BUGGY]  if(tmpVec!=  previousCost)  {  cost  =  prevCost;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  oldRes  =  oldX[pj];  }  [CE]  illegal  start  of  expression  [FE]                  AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;    [BUGGY]  if(tmpVec!=  previousCost)  {  cost  =  prevCost;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  oldRes  =  oldX[pj];  }  [BUGGY]    residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	if(tmpVec!=  previousCost)  {  cost  =  prevCost;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  oldRes  =  oldX[pj];  }	      if(tmpVec!=    previousCost)    {    cost    =    previousCost;    for(int    j    =    0;    j    <    solvedCols;    ++j)    {    int    oldRes    =    oldX[pj];    }    	non-compiled	[CE]  illegal  start  of  expression	23	None	replace
96	[BUG]  [BUGGY]  residuals  -=  oldRes  +  1;  [CE]  bad  operand  types  for  binary  operator  '+'  [FE]          AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;    [BUGGY]  residuals  -=  oldRes  +  1;  [BUGGY]    oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	residuals  -=  oldRes  +  1;	  residuals    -=    oldRes;    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '+'	18	None	replace
97	[BUG]  [BUGGY]      oldRes  =  tmpVec;  if(remainings  >  0)  {  oldRes  =  tmpVec;  }  else  {  cost  =  previousCost;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  point[j]  =  point[j];  }  [CE]  illegal  start  of  expression  [FE]    AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;    [BUGGY]      oldRes  =  tmpVec;  if(remainings  >  0)  {  oldRes  =  tmpVec;  }  else  {  cost  =  previousCost;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  point[j]  =  point[j];  }  [BUGGY]    residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	        oldRes    =    tmpVec;    if(remainings  >  0)  {  oldRes  =  tmpVec;  }  else  {  cost  =  previousCost;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  point[j]  =  point[j];  }	  	non-compiled	[CE]  illegal  start  of  expression	3	None	add
98	[BUG]  [BUGGY]      oldRes  =  tmpVec;  if(remainings  >  0)  {  oldRes  =  tmpVec;  }  else  {  cost  =  previousCost;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  point[pj]  =  point[pj];  }  [CE]  illegal  start  of  expression  [FE]      AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;    [BUGGY]      oldRes  =  tmpVec;  if(remainings  >  0)  {  oldRes  =  tmpVec;  }  else  {  cost  =  previousCost;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  point[pj]  =  point[pj];  }  [BUGGY]    residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	        oldRes    =    tmpVec;    if(remainings  >  0)  {  oldRes  =  tmpVec;  }  else  {  cost  =  previousCost;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  point[pj]  =  point[pj];  }	  	non-compiled	[CE]  illegal  start  of  expression	3	None	add
99	[BUG]  [BUGGY]      oldRes  =  tmpVec;  if(remainings  >  0)  {  oldRes  =  tmpVec;  }  else  {  cost  =  previousCost;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  point[pj]  =  point[j];  }  [CE]  illegal  start  of  expression  [FE]        AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;    [BUGGY]      oldRes  =  tmpVec;  if(remainings  >  0)  {  oldRes  =  tmpVec;  }  else  {  cost  =  previousCost;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  point[pj]  =  point[j];  }  [BUGGY]    residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	        oldRes    =    tmpVec;    if(remainings  >  0)  {  oldRes  =  tmpVec;  }  else  {  cost  =  previousCost;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  point[pj]  =  point[j];  }	  	non-compiled	[CE]  illegal  start  of  expression	3	None	add
100	[BUG]  [BUGGY]  if(tmpVec!=  previousCost)  {  cost  =  permutation[j];  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  point[pj]  =  oldX[pj];  }  [CE]  illegal  start  of  expression  [FE]        AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;    [BUGGY]  if(tmpVec!=  previousCost)  {  cost  =  permutation[j];  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  point[pj]  =  oldX[pj];  }  [BUGGY]    residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	if(tmpVec!=  previousCost)  {  cost  =  permutation[j];  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  point[pj]  =  oldX[pj];  }	      if(tmpVec!=    previousCost)    {    cost    =    previousCost;    for(int    j    =    0;    j    <    solvedCols;    ++j)    {    point[pj]    =    oldX[pj];    }    	non-compiled	[CE]  illegal  start  of  expression	19	None	replace
101	[BUG]  [BUGGY]  if(tmpVec!=  previousCost)  {  cost  =  prevCost;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  point[pj]  =  oldX[pj];  }  [CE]  illegal  start  of  expression  [FE]          AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;    [BUGGY]  if(tmpVec!=  previousCost)  {  cost  =  prevCost;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  point[pj]  =  oldX[pj];  }  [BUGGY]    residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	if(tmpVec!=  previousCost)  {  cost  =  prevCost;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  point[pj]  =  oldX[pj];  }	      if(tmpVec!=    previousCost)    {    cost    =    previousCost;    for(int    j    =    0;    j    <    solvedCols;    ++j)    {    point[pj]    =    oldX[pj];    }    	non-compiled	[CE]  illegal  start  of  expression	19	None	replace
102	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(lastX,  previousCost);  [CE]  cannot  find  symbol  lastX  [FE]        AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;    [BUGGY]  tmpVec  =  new  VectorialPointValuePair(lastX,  previousCost);  [BUGGY]    residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	tmpVec  =  new  VectorialPointValuePair(lastX,  previousCost);	      tmpVec    =    new    VectorialPointValuePair(previousCost);    	non-compiled	[CE]  cannot  find  symbol  lastX	12	None	replace
103	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(point,  previousCost);  [CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double[],double)  [FE]          AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;    [BUGGY]  tmpVec  =  new  VectorialPointValuePair(point,  previousCost);  [BUGGY]    residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	tmpVec  =  new  VectorialPointValuePair(point,  previousCost);	      tmpVec    =    new    VectorialPointValuePair(previousCost);    	non-compiled	[CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double[],double)	12	None	replace
104	[BUG]  [BUGGY]  if(tmpVec!=  previousCost)  {  cost  =  permutation[j];  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  point[pj]  =  oldX[pj].doubleValue();  }  [CE]  illegal  start  of  expression  [FE]            AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;    [BUGGY]  if(tmpVec!=  previousCost)  {  cost  =  permutation[j];  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  point[pj]  =  oldX[pj].doubleValue();  }  [BUGGY]    residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	if(tmpVec!=  previousCost)  {  cost  =  permutation[j];  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  point[pj]  =  oldX[pj].doubleValue();  }	      if(tmpVec!=    previousCost)    {    cost    =    previousCost;    for(int    j    =    0;    j    <    solvedCols;    ++j)    {    point[pj]    =    oldX[pj].doubleValue();    }    	non-compiled	[CE]  illegal  start  of  expression	21	None	replace
105	[BUG]  [BUGGY]  if(tmpVec!=  previousCost)  {  cost  =  permutation[j].doubleValue();  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  point[pj]  =  oldX[pj].doubleValue();  }  [CE]  illegal  start  of  expression  [FE]              AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;    [BUGGY]  if(tmpVec!=  previousCost)  {  cost  =  permutation[j].doubleValue();  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  point[pj]  =  oldX[pj].doubleValue();  }  [BUGGY]    residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	if(tmpVec!=  previousCost)  {  cost  =  permutation[j].doubleValue();  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  point[pj]  =  oldX[pj].doubleValue();  }	      if(tmpVec!=    previousCost)    {    cost    =    previousCost;    for(int    j    =    0;    j    <    solvedCols;    ++j)    {    point[pj]    =    oldX[pj].doubleValue();    }    	non-compiled	[CE]  illegal  start  of  expression	21	None	replace
106	[BUG]  [BUGGY]  if(tmpVec!=  previousCost)  {  cost  =  permutation.length;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  point[pj]  =  oldX[pj].doubleValue();  }  [CE]  illegal  start  of  expression  [FE]                AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;    [BUGGY]  if(tmpVec!=  previousCost)  {  cost  =  permutation.length;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  point[pj]  =  oldX[pj].doubleValue();  }  [BUGGY]    residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	if(tmpVec!=  previousCost)  {  cost  =  permutation.length;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  point[pj]  =  oldX[pj].doubleValue();  }	      if(tmpVec!=    previousCost)    {    cost    =    previousCost;    for(int    j    =    0;    j    <    solvedCols;    ++j)    {    point[pj]    =    oldX[pj].doubleValue();    }    	non-compiled	[CE]  illegal  start  of  expression	21	None	replace
107	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(previousCost,  value);  [CE]  cannot  find  symbol  value  [FE]              AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;    [BUGGY]  tmpVec  =  new  VectorialPointValuePair(previousCost,  value);  [BUGGY]    residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	tmpVec  =  new  VectorialPointValuePair(previousCost,  value);	      tmpVec    =    new    VectorialPointValuePair(previousCost,    preRed);    	non-compiled	[CE]  cannot  find  symbol  value	15	None	replace
108	[BUG]  [BUGGY]  residuals  =  tmpVec;  tmpVec  =  tmpVec.doubleValue();  [CE]  cannot  find  symbol  [FE]    AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;    [BUGGY]  residuals  =  tmpVec;  tmpVec  =  tmpVec.doubleValue();  [BUGGY]    oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	residuals    =    tmpVec;    tmpVec  =  tmpVec.doubleValue();	  	non-compiled	[CE]  cannot  find  symbol	7	None	add
109	[BUG]  [BUGGY]  if(tmpVec!=  previousCost)  {  cost  =  permutation[j].remainder;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  point[pj]  =  oldX[pj];  }  [CE]  illegal  start  of  expression  [FE]        AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;    [BUGGY]  if(tmpVec!=  previousCost)  {  cost  =  permutation[j].remainder;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  point[pj]  =  oldX[pj];  }  [BUGGY]    residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	if(tmpVec!=  previousCost)  {  cost  =  permutation[j].remainder;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  point[pj]  =  oldX[pj];  }	      if(tmpVec!=    previousCost)    {    cost    =    previousCost;    for(int    j    =    0;    j    <    solvedCols;    ++j)    {    point[pj]    =    oldX[pj];    }    	non-compiled	[CE]  illegal  start  of  expression	19	None	replace
110	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(previousCost,  prered,  cost);  [CE]  cannot  find  symbol  prered  [FE]              AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;    [BUGGY]  tmpVec  =  new  VectorialPointValuePair(previousCost,  prered,  cost);  [BUGGY]    residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	tmpVec  =  new  VectorialPointValuePair(previousCost,  prered,  cost);	      tmpVec    =    new    VectorialPointValuePair(previousCost,    preRed);    	non-compiled	[CE]  cannot  find  symbol  prered	15	None	replace
111	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(lastX,  previousCost,  preRed);  [CE]  cannot  find  symbol  lastX  [FE]                AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;    [BUGGY]  tmpVec  =  new  VectorialPointValuePair(lastX,  previousCost,  preRed);  [BUGGY]    residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	tmpVec  =  new  VectorialPointValuePair(lastX,  previousCost,  preRed);	      tmpVec    =    new    VectorialPointValuePair(previousCost,    preRed);    	non-compiled	[CE]  cannot  find  symbol  lastX	15	None	replace
112	[BUG]  [BUGGY]  tmpVec  =  oldX[j];  [CE]  cannot  find  symbol  j  [FE]        AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;    [BUGGY]  tmpVec  =  oldX[j];  [BUGGY]    residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	tmpVec  =  oldX[j];	      tmpVec    =    permutation[j];    	non-compiled	[CE]  cannot  find  symbol  j	1	None	replace
113	[BUG]  [BUGGY]  tmpVec  =  cost[j];  [CE]  cannot  find  symbol  j  [FE]          AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;    [BUGGY]  tmpVec  =  cost[j];  [BUGGY]    residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	tmpVec  =  cost[j];	      tmpVec    =    permutation[j];    	non-compiled	[CE]  cannot  find  symbol  j	1	None	replace
114	[BUG]  [BUGGY]  tmpVec  =  Math.max(remainings,  cost);  [CE]  cannot  find  symbol  remainings  [FE]                AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;    [BUGGY]  tmpVec  =  Math.max(remainings,  cost);  [BUGGY]    residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	tmpVec  =  Math.max(remainings,  cost);	      tmpVec    =    Math.max(remainings,    previousCost);    	non-compiled	[CE]  cannot  find  symbol  remainings	6	None	replace
115	[BUG]  [BUGGY]  if(tmpVec!=  previousCost)  {  cost  =  permutation[j].remainder;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  point[j]  =  oldX[pj];  }  [CE]  illegal  start  of  expression  [FE]              AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;    [BUGGY]  if(tmpVec!=  previousCost)  {  cost  =  permutation[j].remainder;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  point[j]  =  oldX[pj];  }  [BUGGY]    residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	if(tmpVec!=  previousCost)  {  cost  =  permutation[j].remainder;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  point[j]  =  oldX[pj];  }	      if(tmpVec!=    previousCost)    {    cost    =    previousCost;    for(int    j    =    0;    j    <    solvedCols;    ++j)    {    point[j]    =    oldX[pj];    }    	non-compiled	[CE]  illegal  start  of  expression	22	None	replace
116	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(previousCost,  cost,  oldX);  [CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double,double,double[])  [FE]            AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;    [BUGGY]  tmpVec  =  new  VectorialPointValuePair(previousCost,  cost,  oldX);  [BUGGY]    residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	tmpVec  =  new  VectorialPointValuePair(previousCost,  cost,  oldX);	      tmpVec    =    new    VectorialPointValuePair(previousCost,    cost);    	non-compiled	[CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double,double,double[])	14	None	replace
117	[BUG]  [BUGGY]  residuals  -=  tmpVec;  [CE]  bad  operand  types  for  binary  operator  '-'  [FE]          AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;    [BUGGY]  residuals  -=  tmpVec;  [BUGGY]    oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	residuals  -=  tmpVec;	  residuals    -=    oldRes;    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '-'	18	None	replace
118	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(oldX,  oldRes);  [CE]  incompatible  types  [FE]          AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;    [BUGGY]  tmpVec  =  new  VectorialPointValuePair(oldX,  oldRes);  [BUGGY]    residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	tmpVec  =  new  VectorialPointValuePair(oldX,  oldRes);	      tmpVec    =    new    VectorialPointValuePair();    	non-compiled	[CE]  incompatible  types	13	None	replace
119	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(currentCost);  [CE]  cannot  find  symbol  currentCost  [FE]        AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;    [BUGGY]  tmpVec  =  new  VectorialPointValuePair(currentCost);  [BUGGY]    residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	tmpVec  =  new  VectorialPointValuePair(currentCost);	      tmpVec    =    new    VectorialPointValuePair(previousCost);    	non-compiled	[CE]  cannot  find  symbol  currentCost	12	None	replace
120	[BUG]  [BUGGY]      oldRes  =  tmpVec;  if(remainings  >  oldRes)  {  oldRes  =  tmpVec;  }  else  {  cost  =  previousCost;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  point[pj]  =  point[pj];  }  [CE]  illegal  start  of  expression  [FE]    AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;    [BUGGY]      oldRes  =  tmpVec;  if(remainings  >  oldRes)  {  oldRes  =  tmpVec;  }  else  {  cost  =  previousCost;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  point[pj]  =  point[pj];  }  [BUGGY]    residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	        oldRes    =    tmpVec;    if(remainings  >  oldRes)  {  oldRes  =  tmpVec;  }  else  {  cost  =  previousCost;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  point[pj]  =  point[pj];  }	  	non-compiled	[CE]  illegal  start  of  expression	3	None	add
121	[BUG]  [BUGGY]      oldRes  =  tmpVec;  if(remainings  >  oldRes)  {  oldRes  =  tmpVec;  }  else  {  cost  =  previousCost;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  point[pj]  =  point[pj].doubleValue();  }  [CE]  illegal  start  of  expression  [FE]      AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;    [BUGGY]      oldRes  =  tmpVec;  if(remainings  >  oldRes)  {  oldRes  =  tmpVec;  }  else  {  cost  =  previousCost;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  point[pj]  =  point[pj].doubleValue();  }  [BUGGY]    residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	        oldRes    =    tmpVec;    if(remainings  >  oldRes)  {  oldRes  =  tmpVec;  }  else  {  cost  =  previousCost;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  point[pj]  =  point[pj].doubleValue();  }	  	non-compiled	[CE]  illegal  start  of  expression	3	None	add
122	[BUG]  [BUGGY]      oldRes  =  tmpVec;  if(remainings  >  oldRes)  {  oldRes  =  tmpVec;  }  else  {  cost  =  previousCost;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  point[pj]  =  point[pj].getX();  }  [CE]  illegal  start  of  expression  [FE]        AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;    [BUGGY]      oldRes  =  tmpVec;  if(remainings  >  oldRes)  {  oldRes  =  tmpVec;  }  else  {  cost  =  previousCost;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  point[pj]  =  point[pj].getX();  }  [BUGGY]    residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	        oldRes    =    tmpVec;    if(remainings  >  oldRes)  {  oldRes  =  tmpVec;  }  else  {  cost  =  previousCost;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  point[pj]  =  point[pj].getX();  }	  	non-compiled	[CE]  illegal  start  of  expression	3	None	add
123	[BUG]  [BUGGY]  if(tmpVec!=  preRed)  {  cost  =  previousCost;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  permutation[j]  =  oldX[pj];  }  [CE]  illegal  start  of  expression  [FE]          AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;    [BUGGY]  if(tmpVec!=  preRed)  {  cost  =  previousCost;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  permutation[j]  =  oldX[pj];  }  [BUGGY]    residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	if(tmpVec!=  preRed)  {  cost  =  previousCost;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  permutation[j]  =  oldX[pj];  }	      if(tmpVec!=    previousCost)    {    cost    =    previousCost;    for(int    j    =    0;    j    <    solvedCols;    ++j)    {    permutation[j]    =    oldX[pj];    }    	non-compiled	[CE]  illegal  start  of  expression	20	None	replace
124	[BUG]  [BUGGY]  if(tmpVec!=  previousCost)  {  cost  =  permutation[j];  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  permutation[j]  =  oldX[pj];  }  [CE]  illegal  start  of  expression  [FE]            AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;    [BUGGY]  if(tmpVec!=  previousCost)  {  cost  =  permutation[j];  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  permutation[j]  =  oldX[pj];  }  [BUGGY]    residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	if(tmpVec!=  previousCost)  {  cost  =  permutation[j];  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  permutation[j]  =  oldX[pj];  }	      if(tmpVec!=    previousCost)    {    cost    =    previousCost;    for(int    j    =    0;    j    <    solvedCols;    ++j)    {    permutation[j]    =    oldX[pj];    }    	non-compiled	[CE]  illegal  start  of  expression	20	None	replace
125	[BUG]  [BUGGY]  if(tmpVec!=  previousCost)  {  cost  =  preRed;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  permutation[j]  =  oldX[pj];  }  [CE]  illegal  start  of  expression  [FE]              AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;    [BUGGY]  if(tmpVec!=  previousCost)  {  cost  =  preRed;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  permutation[j]  =  oldX[pj];  }  [BUGGY]    residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	if(tmpVec!=  previousCost)  {  cost  =  preRed;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  permutation[j]  =  oldX[pj];  }	      if(tmpVec!=    previousCost)    {    cost    =    previousCost;    for(int    j    =    0;    j    <    solvedCols;    ++j)    {    permutation[j]    =    oldX[pj];    }    	non-compiled	[CE]  illegal  start  of  expression	20	None	replace
126	[BUG]  [BUGGY]  if(tmpVec!=  preRed)  {  cost  =  previousCost;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  oldRes  =  oldX[pj];  }  [CE]  illegal  start  of  expression  [FE]                AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;    [BUGGY]  if(tmpVec!=  preRed)  {  cost  =  previousCost;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  oldRes  =  oldX[pj];  }  [BUGGY]    residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	if(tmpVec!=  preRed)  {  cost  =  previousCost;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  oldRes  =  oldX[pj];  }	      if(tmpVec!=    previousCost)    {    cost    =    previousCost;    for(int    j    =    0;    j    <    solvedCols;    ++j)    {    int    oldRes    =    oldX[pj];    }    	non-compiled	[CE]  illegal  start  of  expression	23	None	replace
127	[BUG]  [BUGGY]  if(tmpVec!=  previousCost)  {  cost  =  preRed;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  oldRes  =  oldX[pj];  }  [CE]  illegal  start  of  expression  [FE]                  AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;    [BUGGY]  if(tmpVec!=  previousCost)  {  cost  =  preRed;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  oldRes  =  oldX[pj];  }  [BUGGY]    residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	432	432	2	replace	if(tmpVec!=  previousCost)  {  cost  =  preRed;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  oldRes  =  oldX[pj];  }	      if(tmpVec!=    previousCost)    {    cost    =    previousCost;    for(int    j    =    0;    j    <    solvedCols;    ++j)    {    int    oldRes    =    oldX[pj];    }    	non-compiled	[CE]  illegal  start  of  expression	23	None	replace
