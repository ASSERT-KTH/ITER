bugid	buggy	buggy_class	suspiciousness	buggy_line	endbuggycode	original_failing_test_number	action	patch	original_buggy	execution_result	diagnosis	previous_bug_id	new_failing_test_number	this_action
1	[BUG]  [BUGGY]  sum  +=  work2[i][pj]  *  diagR[i]];  [CE]  ';'  expected  [FE]                AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum  +=  work2[i][pj]  *  diagR[i]];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	sum  +=  work2[i][pj]  *  diagR[i]];	  sum    +=    work2[i][pj]    *    diag[i]];    	non-compiled	[CE]  ';'  expected	89	None	replace
2	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum  +=  work1[i]  *  work3[i];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	add	sum  +=  work1[i]  *  work3[i];	  sum    +=    work2[i]    *    work3[i];    	compilable	  [FE]  AssertionFailedError  	102	10	replace
3	[BUG]  [BUGGY]  sum  +=  work1[i]  *  work3[i];  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum  +=  work1[i]  *  work3[i];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	sum  +=  work1[i]  *  work3[i];	  sum    +=    work2[i]    *    work3[i];    	compilable	  [FE]  AssertionFailedError  	102	10	replace
4	[BUG]  [BUGGY]  sum  +=  work1[i]  *  work3;  [CE]  bad  operand  types  for  binary  operator  '*'  [FE]            AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum  +=  work1[i]  *  work3;  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	sum  +=  work1[i]  *  work3;	  sum    +=    work2[i]    *    work3;    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '*'	46	None	replace
5	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]              AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum  +=  work1[i]  *  diagR[i];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	add	sum  +=  work1[i]  *  diagR[i];	  sum    +=    work2[i]    *    work3;    	compilable	  [FE]  AssertionFailedError  	46	8	replace
6	[BUG]  [BUGGY]  sum  +=  work1[i]  *  diagR[i];  [FE]  AssertionFailedError  [FE]              AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum  +=  work1[i]  *  diagR[i];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	sum  +=  work1[i]  *  diagR[i];	  sum    +=    work2[i]    *    work3;    	compilable	  [FE]  AssertionFailedError  	46	8	replace
7	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]                AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum  +=  work2[i]  *  diagR[i];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	add	sum  +=  work2[i]  *  diagR[i];	  sum    +=    work2[i]    *    work3;    	compilable	  [FE]  AssertionFailedError  	46	8	replace
8	[BUG]  [BUGGY]  sum  +=  work2[i]  *  diagR[i];  [FE]  AssertionFailedError  [FE]                AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum  +=  work2[i]  *  diagR[i];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	sum  +=  work2[i]  *  diagR[i];	  sum    +=    work2[i]    *    work3;    	compilable	  [FE]  AssertionFailedError  	46	8	replace
9	[BUG]  [BUGGY]  sum  +=  work1,  work2[i]  *  work3;  [CE]  ';'  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum  +=  work1,  work2[i]  *  work3;  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	sum  +=  work1,  work2[i]  *  work3;	  sum    +=    work2[i]    *    work3;    	non-compiled	[CE]  ';'  expected	46	None	replace
10	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]                AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum  +=  work2[i]  *  diag[i]  /  dxNorm;  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	add	sum  +=  work2[i]  *  diag[i]  /  dxNorm;	  sum    +=    work1[i][pj]    *    diag[i]    /    dxNorm;    	compilable	  [FE]  AssertionFailedError  	105	9	replace
11	[BUG]  [BUGGY]  sum  +=  work2[i]  *  diag[i]  /  dxNorm;  [FE]  AssertionFailedError  [FE]                AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum  +=  work2[i]  *  diag[i]  /  dxNorm;  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	sum  +=  work2[i]  *  diag[i]  /  dxNorm;	  sum    +=    work1[i][pj]    *    diag[i]    /    dxNorm;    	compilable	  [FE]  AssertionFailedError  	105	9	replace
12	[BUG]  [BUGGY]  sum  +=  work1[i][pj]  *  diagR[pj]  /  dxNorm;  [CE]  array  required,  but  double  found  [FE]                  AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum  +=  work1[i][pj]  *  diagR[pj]  /  dxNorm;  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	sum  +=  work1[i][pj]  *  diagR[pj]  /  dxNorm;	  sum    +=    work1[i][pj]    *    diag[i]    /    dxNorm;    	non-compiled	[CE]  array  required,  but  double  found	105	None	replace
13	[BUG]  [BUGGY]  sum  +=  work1[i][pj]  *  diag[pj]  /  dxNorm;  [CE]  array  required,  but  double  found  [FE]                    AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum  +=  work1[i][pj]  *  diag[pj]  /  dxNorm;  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	sum  +=  work1[i][pj]  *  diag[pj]  /  dxNorm;	  sum    +=    work1[i][pj]    *    diag[i]    /    dxNorm;    	non-compiled	[CE]  array  required,  but  double  found	105	None	replace
14	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]                      AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum  +=  work1.length  *  diag[i]  /  dxNorm;  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	add	sum  +=  work1.length  *  diag[i]  /  dxNorm;	  sum    +=    work1[i][pj]    *    diag[i]    /    dxNorm;    	compilable	  [FE]  AssertionFailedError  	105	9	replace
15	[BUG]  [BUGGY]  sum  +=  work1.length  *  diag[i]  /  dxNorm;  [FE]  AssertionFailedError  [FE]                      AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum  +=  work1.length  *  diag[i]  /  dxNorm;  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	sum  +=  work1.length  *  diag[i]  /  dxNorm;	  sum    +=    work1[i][pj]    *    diag[i]    /    dxNorm;    	compilable	  [FE]  AssertionFailedError  	105	9	replace
16	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.sqrt(solvedCols[i]  /  1,  sum);  [CE]  ']'  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  diagR[pj]  =  Math.sqrt(solvedCols[i]  /  1,  sum);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  diagR[pj]  =  Math.sqrt(solvedCols[i]  /  1,  sum);	  double    diagR[pj]    =    Math.sqrt(solvedCols[i]    -    1,    sum);    	non-compiled	[CE]  ']'  expected	28	None	replace
17	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.sqrt(diag[i]  -  1,  sum);  [CE]  ']'  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  diagR[pj]  =  Math.sqrt(diag[i]  -  1,  sum);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  diagR[pj]  =  Math.sqrt(diag[i]  -  1,  sum);	  double    diagR[pj]    =    Math.sqrt(solvedCols[i]    -    1,    sum);    	non-compiled	[CE]  ']'  expected	28	None	replace
18	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.sqrt(solvedCols[i]  *  1,  sum);  [CE]  ']'  expected  [FE]                          AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  diagR[pj]  =  Math.sqrt(solvedCols[i]  *  1,  sum);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  diagR[pj]  =  Math.sqrt(solvedCols[i]  *  1,  sum);	  double    diagR[pj]    =    Math.sqrt(solvedCols[i]    -    1,    sum);    	non-compiled	[CE]  ']'  expected	28	None	replace
19	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.sqrt(work1[i]  -  1,  sum);  [CE]  ']'  expected  [FE]                            AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  diagR[pj]  =  Math.sqrt(work1[i]  -  1,  sum);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  diagR[pj]  =  Math.sqrt(work1[i]  -  1,  sum);	  double    diagR[pj]    =    Math.sqrt(solvedCols[i]    -    1,    sum);    	non-compiled	[CE]  ']'  expected	28	None	replace
20	[BUG]  [BUGGY]  double[]  work2[pj]  =  1;  [CE]  ']'  expected  [FE]              AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double[]  work2[pj]  =  1;  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double[]  work2[pj]  =  1;	  double[]    work1[pj]    =    1;    	non-compiled	[CE]  ']'  expected	23	None	replace
21	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.sqrt(work1[i]  *  work2[i]);  [CE]  ']'  expected  [FE]              AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  diagR[pj]  =  Math.sqrt(work1[i]  *  work2[i]);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  diagR[pj]  =  Math.sqrt(work1[i]  *  work2[i]);	  double    diagR[pj]    =    Math.sqrt(work1[i]]);    	non-compiled	[CE]  ']'  expected	32	None	replace
22	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.sqrt(work1[i]  *  work3);  [CE]  ']'  expected  [FE]                AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  diagR[pj]  =  Math.sqrt(work1[i]  *  work3);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  diagR[pj]  =  Math.sqrt(work1[i]  *  work3);	  double    diagR[pj]    =    Math.sqrt(work1[i]]);    	non-compiled	[CE]  ']'  expected	32	None	replace
23	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.sqrt(work2[i]]);  [CE]  ']'  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  diagR[pj]  =  Math.sqrt(work2[i]]);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  diagR[pj]  =  Math.sqrt(work2[i]]);	  double    diagR[pj]    =    Math.sqrt(work1[i]]);    	non-compiled	[CE]  ']'  expected	32	None	replace
24	[BUG]  [BUGGY]  double  s  =  Math.min(work3,  work2),  sum;  [CE]  no  suitable  method  found  for  min(double[],double[])  [FE]                AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  s  =  Math.min(work3,  work2),  sum;  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  s  =  Math.min(work3,  work2),  sum;	  double    s    =    Math.min(work3,    work2);    	non-compiled	[CE]  no  suitable  method  found  for  min(double[],double[])	96	None	replace
25	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.sqrt(diag[i]  *  sum);  [CE]  ']'  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  diagR[pj]  =  Math.sqrt(diag[i]  *  sum);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  diagR[pj]  =  Math.sqrt(diag[i]  *  sum);	  double    diagR[pj]    =    Math.sqrt(diag[i]],    sum);    	non-compiled	[CE]  ']'  expected	26	None	replace
26	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.sqrt(diag[i]  /  sum);  [CE]  ']'  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  diagR[pj]  =  Math.sqrt(diag[i]  /  sum);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  diagR[pj]  =  Math.sqrt(diag[i]  /  sum);	  double    diagR[pj]    =    Math.sqrt(diag[i]],    sum);    	non-compiled	[CE]  ']'  expected	26	None	replace
27	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.sqrt(work1.length[i]  +  1);  [CE]  ']'  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  diagR[pj]  =  Math.sqrt(work1.length[i]  +  1);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  diagR[pj]  =  Math.sqrt(work1.length[i]  +  1);	  double    diagR[pj]    =    Math.sqrt(work1.length[i]]);    	non-compiled	[CE]  ']'  expected	35	None	replace
28	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.sqrt(work1.length[i]  *  work2.length);  [CE]  ']'  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  diagR[pj]  =  Math.sqrt(work1.length[i]  *  work2.length);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  diagR[pj]  =  Math.sqrt(work1.length[i]  *  work2.length);	  double    diagR[pj]    =    Math.sqrt(work1.length[i]]);    	non-compiled	[CE]  ']'  expected	35	None	replace
29	[BUG]  [BUGGY]  double[]  work1[pj]  =  Math.abs(work1[i]  *  work3);  [CE]  ']'  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double[]  work1[pj]  =  Math.abs(work1[i]  *  work3);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double[]  work1[pj]  =  Math.abs(work1[i]  *  work3);	  double[]    work1[pj]    =    Math.abs(work2[i]    *    work3);    	non-compiled	[CE]  ']'  expected	110	None	replace
30	[BUG]  [BUGGY]  double[]  work1[pj]  =  Math.abs(work1[i]  *  diagR[i]);  [CE]  ']'  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double[]  work1[pj]  =  Math.abs(work1[i]  *  diagR[i]);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double[]  work1[pj]  =  Math.abs(work1[i]  *  diagR[i]);	  double[]    work1[pj]    =    Math.abs(work2[i]    *    work3);    	non-compiled	[CE]  ']'  expected	110	None	replace
31	[BUG]  [BUGGY]  double[]  work1[pj]  =  Math.abs(work1[i]  *  work2);  [CE]  ']'  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double[]  work1[pj]  =  Math.abs(work1[i]  *  work2);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double[]  work1[pj]  =  Math.abs(work1[i]  *  work2);	  double[]    work1[pj]    =    Math.abs(work2[i]    *    work3);    	non-compiled	[CE]  ']'  expected	110	None	replace
32	[BUG]  [BUGGY]  double  s  =  Math.min(work1,  work1);  [CE]  no  suitable  method  found  for  min(double[],double[])  [FE]                  AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  s  =  Math.min(work1,  work1);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  s  =  Math.min(work1,  work1);	  double    s    =    Math.min(work2,    work1);    	non-compiled	[CE]  no  suitable  method  found  for  min(double[],double[])	77	None	replace
33	[BUG]  [BUGGY]  double  s  =  Math.min(work2,  work3);  [CE]  no  suitable  method  found  for  min(double[],double[])  [FE]                    AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  s  =  Math.min(work2,  work3);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  s  =  Math.min(work2,  work3);	  double    s    =    Math.min(work2,    work1);    	non-compiled	[CE]  no  suitable  method  found  for  min(double[],double[])	77	None	replace
34	[BUG]  [BUGGY]  double  s  =  Math.min(work2,  work3,  work1);  [CE]  no  suitable  method  found  for  min(double[],double[],double[])  [FE]                      AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  s  =  Math.min(work2,  work3,  work1);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  s  =  Math.min(work2,  work3,  work1);	  double    s    =    Math.min(work2,    work1);    	non-compiled	[CE]  no  suitable  method  found  for  min(double[],double[],double[])	77	None	replace
35	[BUG]  [BUGGY]  sum  +=  work3[i][pj]  *  diagR[i]];  [CE]  ';'  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum  +=  work3[i][pj]  *  diagR[i]];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	sum  +=  work3[i][pj]  *  diagR[i]];	  sum    +=    work3[i][pj]    *    diag[i]];    	non-compiled	[CE]  ';'  expected	58	None	replace
36	[BUG]  [BUGGY]  double[]  work1[pj]  =  Math.abs(diag[i].doubleValue());  [CE]  ']'  expected  [FE]            AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double[]  work1[pj]  =  Math.abs(diag[i].doubleValue());  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double[]  work1[pj]  =  Math.abs(diag[i].doubleValue());	  double[]    work1[pj]    =    Math.abs(diagR[pj].doubleValue());    	non-compiled	[CE]  ']'  expected	18	None	replace
37	[BUG]  [BUGGY]  double[]  work1[pj]  =  Math.abs(diag[pj].doubleValue()  +  1);  [CE]  ']'  expected  [FE]              AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double[]  work1[pj]  =  Math.abs(diag[pj].doubleValue()  +  1);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double[]  work1[pj]  =  Math.abs(diag[pj].doubleValue()  +  1);	  double[]    work1[pj]    =    Math.abs(diagR[pj].doubleValue());    	non-compiled	[CE]  ']'  expected	18	None	replace
38	[BUG]  [BUGGY]  double[]  work1[pj]  =  Math.abs(diagR[i].doubleValue());  [CE]  ']'  expected  [FE]                AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double[]  work1[pj]  =  Math.abs(diagR[i].doubleValue());  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double[]  work1[pj]  =  Math.abs(diagR[i].doubleValue());	  double[]    work1[pj]    =    Math.abs(diagR[pj].doubleValue());    	non-compiled	[CE]  ']'  expected	18	None	replace
39	[BUG]  [BUGGY]  s  =  Math.abs(work1[i]  *  work2[i]);  [CE]  cannot  find  symbol  s  [FE]        AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  s  =  Math.abs(work1[i]  *  work2[i]);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	s  =  Math.abs(work1[i]  *  work2[i]);	          double    s    =    Math.abs(work1[i]    *    work2[i]);    double    s    =    Math.abs(work1[i]    *    work2[i]);    	non-compiled	[CE]  cannot  find  symbol  s	68	None	replace
40	[BUG]  [BUGGY]  double[]  work1[pj]  =  Math.abs(work2[i]  /  1);  [CE]  ']'  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double[]  work1[pj]  =  Math.abs(work2[i]  /  1);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double[]  work1[pj]  =  Math.abs(work2[i]  /  1);	  double[]    work1[pj]    =    Math.abs(work2[i]    -    1);    	non-compiled	[CE]  ']'  expected	7	None	replace
41	[BUG]  [BUGGY]  double[]  work1[pj]  =  Math.abs(work2[i]  *  1);  [CE]  ']'  expected  [FE]                          AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double[]  work1[pj]  =  Math.abs(work2[i]  *  1);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double[]  work1[pj]  =  Math.abs(work2[i]  *  1);	  double[]    work1[pj]    =    Math.abs(work2[i]    -    1);    	non-compiled	[CE]  ']'  expected	7	None	replace
42	[BUG]  [BUGGY]  double[]  work1[pj]  =  Math.abs(work1[i]  /  1);  [CE]  ']'  expected  [FE]                            AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double[]  work1[pj]  =  Math.abs(work1[i]  /  1);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double[]  work1[pj]  =  Math.abs(work1[i]  /  1);	  double[]    work1[pj]    =    Math.abs(work2[i]    -    1);    	non-compiled	[CE]  ']'  expected	7	None	replace
43	[BUG]  [BUGGY]  double  s  =  Math.abs(sum[i]  *  work2[i],  work1);  [CE]  array  required,  but  double  found  [FE]            AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  s  =  Math.abs(sum[i]  *  work2[i],  work1);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  s  =  Math.abs(sum[i]  *  work2[i],  work1);	  double    s    =    Math.abs(work1[i]    *    work2[i],    sum);    	non-compiled	[CE]  array  required,  but  double  found	67	None	replace
44	[BUG]  [BUGGY]  double  s  =  Math.abs(work1[i]  *  work2[i],  sum,  sum);  [CE]  no  suitable  method  found  for  abs(double,double,double)  [FE]              AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  s  =  Math.abs(work1[i]  *  work2[i],  sum,  sum);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  s  =  Math.abs(work1[i]  *  work2[i],  sum,  sum);	  double    s    =    Math.abs(work1[i]    *    work2[i],    sum);    	non-compiled	[CE]  no  suitable  method  found  for  abs(double,double,double)	67	None	replace
45	[BUG]  [BUGGY]  double  s  =  Math.abs(sum,  work1[i]  *  work2[i],  work3);  [CE]  no  suitable  method  found  for  abs(double,double,double[])  [FE]                AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  s  =  Math.abs(sum,  work1[i]  *  work2[i],  work3);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  s  =  Math.abs(sum,  work1[i]  *  work2[i],  work3);	  double    s    =    Math.abs(work1[i]    *    work2[i],    sum);    	non-compiled	[CE]  no  suitable  method  found  for  abs(double,double,double[])	67	None	replace
46	[BUG]  [BUGGY]  double  s  =  Math.abs(work1[i]  *  work2[i],  sum,  parl);  [CE]  no  suitable  method  found  for  abs(double,double,double)  [FE]                  AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  s  =  Math.abs(work1[i]  *  work2[i],  sum,  parl);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  s  =  Math.abs(work1[i]  *  work2[i],  sum,  parl);	  double    s    =    Math.abs(work1[i]    *    work2[i],    sum);    	non-compiled	[CE]  no  suitable  method  found  for  abs(double,double,double)	67	None	replace
47	[BUG]  [BUGGY]  sum  +=  work3[i]  *  work1[i];  double  work2[i]  *  work1[i];  [CE]  ']'  expected  [FE]        AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum  +=  work3[i]  *  work1[i];  double  work2[i]  *  work1[i];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	sum  +=  work3[i]  *  work1[i];  double  work2[i]  *  work1[i];	  sum    +=    work2[i]    *    work1[i];    double    work2[i]    *    work1[i];    	non-compiled	[CE]  ']'  expected	84	None	replace
48	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.abs(work1[i]  *  work2[i]  +  1);  [CE]  ']'  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  diagR[pj]  =  Math.abs(work1[i]  *  work2[i]  +  1);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  diagR[pj]  =  Math.abs(work1[i]  *  work2[i]  +  1);	  double    diagR[pj]    =    Math.abs(work1[i]    *    work2[i]);    	non-compiled	[CE]  ']'  expected	73	None	replace
49	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.abs(work1[i]  *  work3[i]);  [CE]  ']'  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  diagR[pj]  =  Math.abs(work1[i]  *  work3[i]);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  diagR[pj]  =  Math.abs(work1[i]  *  work3[i]);	  double    diagR[pj]    =    Math.abs(work1[i]    *    work2[i]);    	non-compiled	[CE]  ']'  expected	73	None	replace
50	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.abs(work1[i]  *  work2[i]  +  sum);  [CE]  ']'  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  diagR[pj]  =  Math.abs(work1[i]  *  work2[i]  +  sum);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  diagR[pj]  =  Math.abs(work1[i]  *  work2[i]  +  sum);	  double    diagR[pj]    =    Math.abs(work1[i]    *    work2[i]);    	non-compiled	[CE]  ']'  expected	73	None	replace
51	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.sqrt(diag[i],  sum  +  1);  [CE]  ']'  expected  [FE]            AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  diagR[pj]  =  Math.sqrt(diag[i],  sum  +  1);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  diagR[pj]  =  Math.sqrt(diag[i],  sum  +  1);	  double    diagR[pj]    =    Math.sqrt(diag[i],    sum);    	non-compiled	[CE]  ']'  expected	51	None	replace
52	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.sqrt(diag[i],  sum  +  2);  [CE]  ']'  expected  [FE]              AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  diagR[pj]  =  Math.sqrt(diag[i],  sum  +  2);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  diagR[pj]  =  Math.sqrt(diag[i],  sum  +  2);	  double    diagR[pj]    =    Math.sqrt(diag[i],    sum);    	non-compiled	[CE]  ']'  expected	51	None	replace
53	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.sqrt(diag[i],  sum,  work3);  [CE]  ']'  expected  [FE]                AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  diagR[pj]  =  Math.sqrt(diag[i],  sum,  work3);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  diagR[pj]  =  Math.sqrt(diag[i],  sum,  work3);	  double    diagR[pj]    =    Math.sqrt(diag[i],    sum);    	non-compiled	[CE]  ']'  expected	51	None	replace
54	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.sqrt(work1[i],  sum  +  1);  [CE]  ']'  expected  [FE]              AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  diagR[pj]  =  Math.sqrt(work1[i],  sum  +  1);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  diagR[pj]  =  Math.sqrt(work1[i],  sum  +  1);	  double    diagR[pj]    =    Math.sqrt(work1[i],    sum);    	non-compiled	[CE]  ']'  expected	52	None	replace
55	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.sqrt(work1[i],  sum,  sum);  [CE]  ']'  expected  [FE]                AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  diagR[pj]  =  Math.sqrt(work1[i],  sum,  sum);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  diagR[pj]  =  Math.sqrt(work1[i],  sum,  sum);	  double    diagR[pj]    =    Math.sqrt(work1[i],    sum);    	non-compiled	[CE]  ']'  expected	52	None	replace
56	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.sqrt(work1[i],  work2[i]);  [CE]  ']'  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  diagR[pj]  =  Math.sqrt(work1[i],  work2[i]);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  diagR[pj]  =  Math.sqrt(work1[i],  work2[i]);	  double    diagR[pj]    =    Math.sqrt(work1[i],    sum);    	non-compiled	[CE]  ']'  expected	52	None	replace
57	[BUG]  [BUGGY]  double[]  workR[pj]  =  Math.abs(workR[pj].computeMask()  +  1);  [CE]  ']'  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double[]  workR[pj]  =  Math.abs(workR[pj].computeMask()  +  1);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double[]  workR[pj]  =  Math.abs(workR[pj].computeMask()  +  1);	  double[]    workR[pj]    =    Math.abs(workR[pj].computeMask());    	non-compiled	[CE]  ']'  expected	113	None	replace
58	[BUG]  [BUGGY]  double[]  workR[pj]  =  Math.abs(work1[pj].computeMask());  [CE]  ']'  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double[]  workR[pj]  =  Math.abs(work1[pj].computeMask());  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double[]  workR[pj]  =  Math.abs(work1[pj].computeMask());	  double[]    workR[pj]    =    Math.abs(workR[pj].computeMask());    	non-compiled	[CE]  ']'  expected	113	None	replace
59	[BUG]  [BUGGY]  double[]  workR[pj]  =  Math.abs(workR[pj].computeMask()  -  1);  [CE]  ']'  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double[]  workR[pj]  =  Math.abs(workR[pj].computeMask()  -  1);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double[]  workR[pj]  =  Math.abs(workR[pj].computeMask()  -  1);	  double[]    workR[pj]    =    Math.abs(workR[pj].computeMask());    	non-compiled	[CE]  ']'  expected	113	None	replace
60	[BUG]  [BUGGY]  sum  +=  work1[i][j]  *  diagR[i];  [CE]  array  required,  but  double  found  [FE]              AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum  +=  work1[i][j]  *  diagR[i];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	sum  +=  work1[i][j]  *  diagR[i];	  sum    +=    work1[i][j]    *    diag[i];    	non-compiled	[CE]  array  required,  but  double  found	109	None	replace
61	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]                AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum  +=  work2[i]  *  diag[i];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	add	sum  +=  work2[i]  *  diag[i];	  sum    +=    work1[i][j]    *    diag[i];    	compilable	  [FE]  AssertionFailedError  	109	7	replace
62	[BUG]  [BUGGY]  sum  +=  work2[i]  *  diag[i];  [FE]  AssertionFailedError  [FE]                AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum  +=  work2[i]  *  diag[i];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	sum  +=  work2[i]  *  diag[i];	  sum    +=    work1[i][j]    *    diag[i];    	compilable	  [FE]  AssertionFailedError  	109	7	replace
63	[BUG]  [BUGGY]  sum  +=  work3[i][j]  *  diag[i];  [CE]  array  required,  but  double  found  [FE]                  AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum  +=  work3[i][j]  *  diag[i];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	sum  +=  work3[i][j]  *  diag[i];	  sum    +=    work1[i][j]    *    diag[i];    	non-compiled	[CE]  array  required,  but  double  found	109	None	replace
64	[BUG]  [BUGGY]  sum  +=  work1[i][j]  /  diag[i];  [CE]  array  required,  but  double  found  [FE]                    AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum  +=  work1[i][j]  /  diag[i];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	sum  +=  work1[i][j]  /  diag[i];	  sum    +=    work1[i][j]    *    diag[i];    	non-compiled	[CE]  array  required,  but  double  found	109	None	replace
65	[BUG]  [BUGGY]  double[]  work1[pj]  =  Math.abs(work1[pj].computeMask());  [CE]  ']'  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double[]  work1[pj]  =  Math.abs(work1[pj].computeMask());  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double[]  work1[pj]  =  Math.abs(work1[pj].computeMask());	  double[]    work1[pj]    =    Math.abs(diagR[pj].computeMask());    	non-compiled	[CE]  ']'  expected	1	None	replace
66	[BUG]  [BUGGY]  double[]  work1[pj]  =  Math.abs(diagR[pj].computeMask()  +  1);  [CE]  ']'  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double[]  work1[pj]  =  Math.abs(diagR[pj].computeMask()  +  1);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double[]  work1[pj]  =  Math.abs(diagR[pj].computeMask()  +  1);	  double[]    work1[pj]    =    Math.abs(diagR[pj].computeMask());    	non-compiled	[CE]  ']'  expected	1	None	replace
67	[BUG]  [BUGGY]  double[]  work2[pj]  =  Math.abs(diagR[pj].computeMask());  [CE]  ']'  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double[]  work2[pj]  =  Math.abs(diagR[pj].computeMask());  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double[]  work2[pj]  =  Math.abs(diagR[pj].computeMask());	  double[]    work1[pj]    =    Math.abs(diagR[pj].computeMask());    	non-compiled	[CE]  ']'  expected	1	None	replace
68	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.sqrt(work3[i]);  [CE]  ']'  expected  [FE]                AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  diagR[pj]  =  Math.sqrt(work3[i]);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  diagR[pj]  =  Math.sqrt(work3[i]);	  double    diagR[pj]    =    Math.sqrt(work2[i]);    	non-compiled	[CE]  ']'  expected	99	None	replace
69	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.log(work2[i]);  [CE]  ']'  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  diagR[pj]  =  Math.log(work2[i]);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  diagR[pj]  =  Math.log(work2[i]);	  double    diagR[pj]    =    Math.sqrt(work2[i]);    	non-compiled	[CE]  ']'  expected	99	None	replace
70	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.sqrt(work1.length[i]);  [CE]  ']'  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  diagR[pj]  =  Math.sqrt(work1.length[i]);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  diagR[pj]  =  Math.sqrt(work1.length[i]);	  double    diagR[pj]    =    Math.sqrt(work2[i]);    	non-compiled	[CE]  ']'  expected	99	None	replace
71	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.sqrt(diagR[i]  /  sum);  [CE]  ']'  expected  [FE]                AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  diagR[pj]  =  Math.sqrt(diagR[i]  /  sum);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  diagR[pj]  =  Math.sqrt(diagR[i]  /  sum);	  double    diagR[pj]    =    Math.sqrt(diagR[i]],    sum);    	non-compiled	[CE]  ']'  expected	82	None	replace
72	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.sqrt(diagR[i]  *  sum);  [CE]  ']'  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  diagR[pj]  =  Math.sqrt(diagR[i]  *  sum);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  diagR[pj]  =  Math.sqrt(diagR[i]  *  sum);	  double    diagR[pj]    =    Math.sqrt(diagR[i]],    sum);    	non-compiled	[CE]  ']'  expected	82	None	replace
73	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.sqrt(diagR[i]  -  1,  sum);  [CE]  ']'  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  diagR[pj]  =  Math.sqrt(diagR[i]  -  1,  sum);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  diagR[pj]  =  Math.sqrt(diagR[i]  -  1,  sum);	  double    diagR[pj]    =    Math.sqrt(diagR[i]],    sum);    	non-compiled	[CE]  ']'  expected	82	None	replace
74	[BUG]  [BUGGY]  sum  +=  work1[i]  *  work3[i]];  [CE]  ';'  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum  +=  work1[i]  *  work3[i]];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	sum  +=  work1[i]  *  work3[i]];	  sum    +=    work2[i]    *    work3[i]];    	non-compiled	[CE]  ';'  expected	103	None	replace
75	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum2  +=  work3[i]  *  work1[i];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	add	sum2  +=  work3[i]  *  work1[i];	  sum2    +=    work1[i]    *    work2[i];    	compilable	  [FE]  AssertionFailedError  	95	12	replace
76	[BUG]  [BUGGY]  sum2  +=  work3[i]  *  work1[i];  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum2  +=  work3[i]  *  work1[i];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	sum2  +=  work3[i]  *  work1[i];	  sum2    +=    work1[i]    *    work2[i];    	compilable	  [FE]  AssertionFailedError  	95	12	replace
77	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum2  +=  work1[i]  *  work3[i];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	add	sum2  +=  work1[i]  *  work3[i];	  sum2    +=    work1[i]    *    work2[i];    	compilable	  [FE]  AssertionFailedError  	95	12	replace
78	[BUG]  [BUGGY]  sum2  +=  work1[i]  *  work3[i];  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum2  +=  work1[i]  *  work3[i];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	sum2  +=  work1[i]  *  work3[i];	  sum2    +=    work1[i]    *    work2[i];    	compilable	  [FE]  AssertionFailedError  	95	12	replace
79	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum2  +=  work3[i]  *  work2[i];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	add	sum2  +=  work3[i]  *  work2[i];	  sum2    +=    work1[i]    *    work2[i];    	compilable	  [FE]  AssertionFailedError  	95	13	replace
80	[BUG]  [BUGGY]  sum2  +=  work3[i]  *  work2[i];  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum2  +=  work3[i]  *  work2[i];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	sum2  +=  work3[i]  *  work2[i];	  sum2    +=    work1[i]    *    work2[i];    	compilable	  [FE]  AssertionFailedError  	95	13	replace
81	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.sqrt(solvedCols[i],  sum  +  2);  [CE]  ']'  expected  [FE]                AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  diagR[pj]  =  Math.sqrt(solvedCols[i],  sum  +  2);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  diagR[pj]  =  Math.sqrt(solvedCols[i],  sum  +  2);	  double    diagR[pj]    =    Math.sqrt(solvedCols[i],    sum    +    1);    	non-compiled	[CE]  ']'  expected	53	None	replace
82	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.sqrt(solvedCols[i],  sum  *  1);  [CE]  ']'  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  diagR[pj]  =  Math.sqrt(solvedCols[i],  sum  *  1);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  diagR[pj]  =  Math.sqrt(solvedCols[i],  sum  *  1);	  double    diagR[pj]    =    Math.sqrt(solvedCols[i],    sum    +    1);    	non-compiled	[CE]  ']'  expected	53	None	replace
83	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.sqrt(solvedCols[i],  sum  +  3);  [CE]  ']'  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  diagR[pj]  =  Math.sqrt(solvedCols[i],  sum  +  3);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  diagR[pj]  =  Math.sqrt(solvedCols[i],  sum  +  3);	  double    diagR[pj]    =    Math.sqrt(solvedCols[i],    sum    +    1);    	non-compiled	[CE]  ']'  expected	53	None	replace
84	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.sqrt(work1,  work2[i]]);  [CE]  ']'  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  diagR[pj]  =  Math.sqrt(work1,  work2[i]]);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  diagR[pj]  =  Math.sqrt(work1,  work2[i]]);	  double    diagR[pj]    =    Math.sqrt(work1,    solvedCols[i]]);    	non-compiled	[CE]  ']'  expected	34	None	replace
85	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.sqrt(work1,  work2);  [CE]  ']'  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  diagR[pj]  =  Math.sqrt(work1,  work2);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  diagR[pj]  =  Math.sqrt(work1,  work2);	  double    diagR[pj]    =    Math.sqrt(work1,    solvedCols[i]]);    	non-compiled	[CE]  ']'  expected	34	None	replace
86	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.sqrt(work1,  work2,  solvedCols[i]]);  [CE]  ']'  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  diagR[pj]  =  Math.sqrt(work1,  work2,  solvedCols[i]]);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  diagR[pj]  =  Math.sqrt(work1,  work2,  solvedCols[i]]);	  double    diagR[pj]    =    Math.sqrt(work1,    solvedCols[i]]);    	non-compiled	[CE]  ']'  expected	34	None	replace
87	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]              AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum  +=  work1.length  *  diag[i];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	add	sum  +=  work1.length  *  diag[i];	  sum    +=    diag[i][pj]    *    work1[i];    	compilable	  [FE]  AssertionFailedError  	87	5	replace
88	[BUG]  [BUGGY]  sum  +=  work1.length  *  diag[i];  [FE]  AssertionFailedError  [FE]              AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum  +=  work1.length  *  diag[i];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	sum  +=  work1.length  *  diag[i];	  sum    +=    diag[i][pj]    *    work1[i];    	compilable	  [FE]  AssertionFailedError  	87	5	replace
89	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum  +=  work2[i]  *  work3[i];  sum  +=  work2[i]  *  work3[i];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	add	sum    +=    work2[i]    *    work3[i];    sum  +=  work2[i]  *  work3[i];	  	compilable	  [FE]  AssertionFailedError  	101	6	add
90	[BUG]  [BUGGY]  sum  +=  work2[i]  *  work3[i];  sum  +=  work2[i]  *  work3[i];  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum  +=  work2[i]  *  work3[i];  sum  +=  work2[i]  *  work3[i];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	sum    +=    work2[i]    *    work3[i];    sum  +=  work2[i]  *  work3[i];	  	compilable	  [FE]  AssertionFailedError  	101	6	add
91	[BUG]  [BUGGY]  sum  +=  work2[i]  *  work3[i];  Sum  +=  work2[i]  *  work3[i];  [CE]  cannot  find  symbol  Sum  [FE]      AssertionFailedError    [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum  +=  work2[i]  *  work3[i];  Sum  +=  work2[i]  *  work3[i];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	sum    +=    work2[i]    *    work3[i];    Sum  +=  work2[i]  *  work3[i];	  	non-compiled	[CE]  cannot  find  symbol  Sum	101	None	add
92	[BUG]  [BUGGY]  sum  +=  work2[i]  *  work3[i];  double  sum  +=  work2[i]  *  work3[i];  [CE]  ';'  expected  [FE]        AssertionFailedError    [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum  +=  work2[i]  *  work3[i];  double  sum  +=  work2[i]  *  work3[i];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	sum    +=    work2[i]    *    work3[i];    double  sum  +=  work2[i]  *  work3[i];	  	non-compiled	[CE]  ';'  expected	101	None	add
93	[BUG]  [BUGGY]  sum  +=  work2[i]  *  work3[i];  total  +=  work2[i]  *  work3[i];  [CE]  cannot  find  symbol  total  [FE]          AssertionFailedError    [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum  +=  work2[i]  *  work3[i];  total  +=  work2[i]  *  work3[i];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	sum    +=    work2[i]    *    work3[i];    total  +=  work2[i]  *  work3[i];	  	non-compiled	[CE]  cannot  find  symbol  total	101	None	add
94	[BUG]  [BUGGY]  sum  +=  work2[i]  *  work3[i];  int  work2[i]  *  work3[i];  [CE]  ']'  expected  [FE]            AssertionFailedError    [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum  +=  work2[i]  *  work3[i];  int  work2[i]  *  work3[i];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	sum    +=    work2[i]    *    work3[i];    int  work2[i]  *  work3[i];	  	non-compiled	[CE]  ']'  expected	101	None	add
95	[BUG]  [BUGGY]  sum  +=  work3[i][pj]  *  diagR[i];  [CE]  array  required,  but  double  found  [FE]                  AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum  +=  work3[i][pj]  *  diagR[i];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	sum  +=  work3[i][pj]  *  diagR[i];	  sum    +=    work3[i][pj]    *    diag[i];    	non-compiled	[CE]  array  required,  but  double  found	38	None	replace
96	[BUG]  [BUGGY]  double[]  work3[pj]  =  1;  [CE]  ']'  expected  [FE]            AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double[]  work3[pj]  =  1;  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double[]  work3[pj]  =  1;	  double[]    work3[pj]    =    0;    	non-compiled	[CE]  ']'  expected	86	None	replace
97	[BUG]  [BUGGY]  double[]  work1[pj]  =  Math.abs(work1[i]  *  sum);  [CE]  ']'  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double[]  work1[pj]  =  Math.abs(work1[i]  *  sum);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double[]  work1[pj]  =  Math.abs(work1[i]  *  sum);	  double[]    work1[pj]    =    Math.abs(work2[i]    *    sum);    	non-compiled	[CE]  ']'  expected	6	None	replace
98	[BUG]  [BUGGY]  double[]  work1[pj]  =  Math.abs(work2[i]  /  sum);  [CE]  ']'  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double[]  work1[pj]  =  Math.abs(work2[i]  /  sum);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double[]  work1[pj]  =  Math.abs(work2[i]  /  sum);	  double[]    work1[pj]    =    Math.abs(work2[i]    *    sum);    	non-compiled	[CE]  ']'  expected	6	None	replace
99	[BUG]  [BUGGY]  double[]  work1[pj]  =  Math.abs(work2[i]  *  sum,  sum);  [CE]  ']'  expected  [FE]                          AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double[]  work1[pj]  =  Math.abs(work2[i]  *  sum,  sum);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double[]  work1[pj]  =  Math.abs(work2[i]  *  sum,  sum);	  double[]    work1[pj]    =    Math.abs(work2[i]    *    sum);    	non-compiled	[CE]  ']'  expected	6	None	replace
100	[BUG]  [BUGGY]  double  s  =  Math.abs(work1[i]  *  work2[i]  +  1);  double  s  =  Math.abs(work1[i]  *  work2[i]  +  1);  [CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]    AssertionFailedError    [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  s  =  Math.abs(work1[i]  *  work2[i]  +  1);  double  s  =  Math.abs(work1[i]  *  work2[i]  +  1);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double    s    =    Math.abs(work1[i]    *    work2[i]    +    1);    double  s  =  Math.abs(work1[i]  *  work2[i]  +  1);	  	non-compiled	[CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	65	None	add
101	[BUG]  [BUGGY]  double  s  =  Math.abs(work1[i]  *  work2[i]  +  1);  Double  s  =  Math.abs(work1[i]  *  work2[i]  +  1);  [CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]      AssertionFailedError    [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  s  =  Math.abs(work1[i]  *  work2[i]  +  1);  Double  s  =  Math.abs(work1[i]  *  work2[i]  +  1);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double    s    =    Math.abs(work1[i]    *    work2[i]    +    1);    Double  s  =  Math.abs(work1[i]  *  work2[i]  +  1);	  	non-compiled	[CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	65	None	add
102	[BUG]  [BUGGY]  double  s  =  Math.abs(work1[i]  *  work2[i]  +  1);  int  s  =  Math.abs(work1[i]  *  work2[i]  +  1);  [CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]        AssertionFailedError    [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  s  =  Math.abs(work1[i]  *  work2[i]  +  1);  int  s  =  Math.abs(work1[i]  *  work2[i]  +  1);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double    s    =    Math.abs(work1[i]    *    work2[i]    +    1);    int  s  =  Math.abs(work1[i]  *  work2[i]  +  1);	  	non-compiled	[CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	65	None	add
103	[BUG]  [BUGGY]  double  s  =  Math.abs(work1[i]  *  work2[i]  +  1);  double  s  =  Math.abs(work2[i]  *  work2[i]  +  1);  [CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]          AssertionFailedError    [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  s  =  Math.abs(work1[i]  *  work2[i]  +  1);  double  s  =  Math.abs(work2[i]  *  work2[i]  +  1);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double    s    =    Math.abs(work1[i]    *    work2[i]    +    1);    double  s  =  Math.abs(work2[i]  *  work2[i]  +  1);	  	non-compiled	[CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	65	None	add
104	[BUG]  [BUGGY]  double  s  =  Math.abs(work1[i]  *  work2[i]  +  1);  double  s  =  Math.abs(work1[i]  *  work2.[i]  +  1);  [CE]  <identifier>  expected  [FE]            AssertionFailedError    [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  s  =  Math.abs(work1[i]  *  work2[i]  +  1);  double  s  =  Math.abs(work1[i]  *  work2.[i]  +  1);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double    s    =    Math.abs(work1[i]    *    work2[i]    +    1);    double  s  =  Math.abs(work1[i]  *  work2.[i]  +  1);	  	non-compiled	[CE]  <identifier>  expected	65	None	add
105	[BUG]  [BUGGY]  double  s  =  Math.abs(work1[i]  *  work2[i]  +  sum,  sum);  [CE]  no  suitable  method  found  for  abs(double,double)  [FE]    AssertionFailedError    [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  s  =  Math.abs(work1[i]  *  work2[i]  +  sum,  sum);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  s  =  Math.abs(work1[i]  *  work2[i]  +  sum,  sum);	  double    s    =    Math.abs(work1[i]    *    work2[i]    +    sum);    	non-compiled	[CE]  no  suitable  method  found  for  abs(double,double)	64	None	replace
106	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  s  =  Math.abs(work1[i]  *  work2[i]  *  sum);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	add	double  s  =  Math.abs(work1[i]  *  work2[i]  *  sum);	  double    s    =    Math.abs(work1[i]    *    work2[i]    +    sum);    	compilable	  [FE]  AssertionFailedError  	64	13	replace
107	[BUG]  [BUGGY]  double  s  =  Math.abs(work1[i]  *  work2[i]  *  sum);  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  s  =  Math.abs(work1[i]  *  work2[i]  *  sum);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  s  =  Math.abs(work1[i]  *  work2[i]  *  sum);	  double    s    =    Math.abs(work1[i]    *    work2[i]    +    sum);    	compilable	  [FE]  AssertionFailedError  	64	13	replace
108	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  s  =  Math.abs(work2[i]  *  work1[i]  +  sum);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	add	double  s  =  Math.abs(work2[i]  *  work1[i]  +  sum);	  double    s    =    Math.abs(work1[i]    *    work2[i]    +    sum);    	compilable	  [FE]  AssertionFailedError  	64	13	replace
109	[BUG]  [BUGGY]  double  s  =  Math.abs(work2[i]  *  work1[i]  +  sum);  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  s  =  Math.abs(work2[i]  *  work1[i]  +  sum);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  s  =  Math.abs(work2[i]  *  work1[i]  +  sum);	  double    s    =    Math.abs(work1[i]    *    work2[i]    +    sum);    	compilable	  [FE]  AssertionFailedError  	64	13	replace
110	[BUG]  [BUGGY]  sum  +=  work3[i][j]  *  diag[i]];  [CE]  ';'  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum  +=  work3[i][j]  *  diag[i]];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	sum  +=  work3[i][j]  *  diag[i]];	  sum    +=    work1[i][j]    *    diag[i]];    	non-compiled	[CE]  ';'  expected	90	None	replace
111	[BUG]  [BUGGY]  sum2  +=  work1[i][j]  *  diag[i]];  [CE]  ';'  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum2  +=  work1[i][j]  *  diag[i]];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	sum2  +=  work1[i][j]  *  diag[i]];	  sum    +=    work1[i][j]    *    diag[i]];    	non-compiled	[CE]  ';'  expected	90	None	replace
112	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.sqrt(work1[i]  *  sum);  [CE]  ']'  expected  [FE]                AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  diagR[pj]  =  Math.sqrt(work1[i]  *  sum);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  diagR[pj]  =  Math.sqrt(work1[i]  *  sum);	  double    diagR[pj]    =    Math.sqrt(work1[i]],    sum);    	non-compiled	[CE]  ']'  expected	25	None	replace
113	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.sqrt(work1[i]  /  sum);  [CE]  ']'  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  diagR[pj]  =  Math.sqrt(work1[i]  /  sum);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  diagR[pj]  =  Math.sqrt(work1[i]  /  sum);	  double    diagR[pj]    =    Math.sqrt(work1[i]],    sum);    	non-compiled	[CE]  ']'  expected	25	None	replace
114	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum  +=  work3[i]  *  work2[i];  sum  +=  work3[i]  *  work2[i];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	add	sum    +=    work3[i]    *    work2[i];    sum  +=  work3[i]  *  work2[i];	  	compilable	  [FE]  AssertionFailedError  	44	6	add
115	[BUG]  [BUGGY]  sum  +=  work3[i]  *  work2[i];  sum  +=  work3[i]  *  work2[i];  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum  +=  work3[i]  *  work2[i];  sum  +=  work3[i]  *  work2[i];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	sum    +=    work3[i]    *    work2[i];    sum  +=  work3[i]  *  work2[i];	  	compilable	  [FE]  AssertionFailedError  	44	6	add
116	[BUG]  [BUGGY]  sum  +=  work3[i]  *  work2[i];  Sum  +=  work3[i]  *  work2[i];  [CE]  cannot  find  symbol  Sum  [FE]      AssertionFailedError    [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum  +=  work3[i]  *  work2[i];  Sum  +=  work3[i]  *  work2[i];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	sum    +=    work3[i]    *    work2[i];    Sum  +=  work3[i]  *  work2[i];	  	non-compiled	[CE]  cannot  find  symbol  Sum	44	None	add
117	[BUG]  [BUGGY]  sum  +=  work3[i]  *  work2[i];  double  sum  +=  work3[i]  *  work2[i];  [CE]  ';'  expected  [FE]        AssertionFailedError    [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum  +=  work3[i]  *  work2[i];  double  sum  +=  work3[i]  *  work2[i];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	sum    +=    work3[i]    *    work2[i];    double  sum  +=  work3[i]  *  work2[i];	  	non-compiled	[CE]  ';'  expected	44	None	add
118	[BUG]  [BUGGY]  sum  +=  work3[i]  *  work2[i];  total  +=  work3[i]  *  work2[i];  [CE]  cannot  find  symbol  total  [FE]          AssertionFailedError    [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum  +=  work3[i]  *  work2[i];  total  +=  work3[i]  *  work2[i];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	sum    +=    work3[i]    *    work2[i];    total  +=  work3[i]  *  work2[i];	  	non-compiled	[CE]  cannot  find  symbol  total	44	None	add
119	[BUG]  [BUGGY]  sum  +=  work3[i]  *  work2[i];  double[i]  *  work2[i];  [CE]  ']'  expected  [FE]            AssertionFailedError    [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum  +=  work3[i]  *  work2[i];  double[i]  *  work2[i];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	sum    +=    work3[i]    *    work2[i];    double[i]  *  work2[i];	  	non-compiled	[CE]  ']'  expected	44	None	add
120	[BUG]  [BUGGY]  sum  +=  work1[i][pj]  *  work3[i];  [CE]  array  required,  but  double  found  [FE]              AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum  +=  work1[i][pj]  *  work3[i];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	sum  +=  work1[i][pj]  *  work3[i];	  sum    +=    work3[i][pj]    *    work1[i]];    	non-compiled	[CE]  array  required,  but  double  found	30	None	replace
121	[BUG]  [BUGGY]  sum  +=  work1[i][pj]  *  work3;  [CE]  array  required,  but  double  found  [FE]                AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum  +=  work1[i][pj]  *  work3;  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	sum  +=  work1[i][pj]  *  work3;	  sum    +=    work3[i][pj]    *    work1[i]];    	non-compiled	[CE]  array  required,  but  double  found	30	None	replace
122	[BUG]  [BUGGY]  sum  +=  work1[i][pj]  *  diag[pj];  [CE]  array  required,  but  double  found  [FE]              AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum  +=  work1[i][pj]  *  diag[pj];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	sum  +=  work1[i][pj]  *  diag[pj];	  sum    +=    work1[i][pj]    *    diagR[pj];    	non-compiled	[CE]  array  required,  but  double  found	80	None	replace
123	[BUG]  [BUGGY]  sum  +=  work2[i][pj]  *  diagR[pj];  [CE]  array  required,  but  double  found  [FE]                AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum  +=  work2[i][pj]  *  diagR[pj];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	sum  +=  work2[i][pj]  *  diagR[pj];	  sum    +=    work1[i][pj]    *    diagR[pj];    	non-compiled	[CE]  array  required,  but  double  found	80	None	replace
124	[BUG]  [BUGGY]  sum  +=  work3[i][pj]  *  diagR[pj];  [CE]  array  required,  but  double  found  [FE]                  AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum  +=  work3[i][pj]  *  diagR[pj];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	sum  +=  work3[i][pj]  *  diagR[pj];	  sum    +=    work1[i][pj]    *    diagR[pj];    	non-compiled	[CE]  array  required,  but  double  found	80	None	replace
125	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum  +=  work3[i]  *  diagR[i];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	add	sum  +=  work3[i]  *  diagR[i];	  sum    +=    work3[i]    *    work2[i];    	compilable	  [FE]  AssertionFailedError  	45	8	replace
126	[BUG]  [BUGGY]  sum  +=  work3[i]  *  diagR[i];  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum  +=  work3[i]  *  diagR[i];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	sum  +=  work3[i]  *  diagR[i];	  sum    +=    work3[i]    *    work2[i];    	compilable	  [FE]  AssertionFailedError  	45	8	replace
127	[BUG]  [BUGGY]  double[]  work2[pj]  =  2;  [CE]  ']'  expected  [FE]            AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double[]  work2[pj]  =  2;  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double[]  work2[pj]  =  2;	  double[]    work2[pj]    =    0;    	non-compiled	[CE]  ']'  expected	22	None	replace
128	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  s  =  Math.abs(work1[i]  *  work2[i]  +  2);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	add	double  s  =  Math.abs(work1[i]  *  work2[i]  +  2);	  double    s    =    Math.abs(work1[i]    *    work2[i]    +    1);    	compilable	  [FE]  AssertionFailedError  	66	13	replace
129	[BUG]  [BUGGY]  double  s  =  Math.abs(work1[i]  *  work2[i]  +  2);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  s  =  Math.abs(work1[i]  *  work2[i]  +  2);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  s  =  Math.abs(work1[i]  *  work2[i]  +  2);	  double    s    =    Math.abs(work1[i]    *    work2[i]    +    1);    	compilable	  [FE]  AssertionFailedError  	66	13	replace
130	[BUG]  [BUGGY]  double  s  =  Math.min(sum,  work1),  sum);  [CE]  ';'  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  s  =  Math.min(sum,  work1),  sum);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  s  =  Math.min(sum,  work1),  sum);	  double    s    =    Math.min(work1,    work2),    sum);    	non-compiled	[CE]  ';'  expected	78	None	replace
131	[BUG]  [BUGGY]  double  s  =  Math.min(sum,  work1),  work2);  [CE]  ';'  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  s  =  Math.min(sum,  work1),  work2);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  s  =  Math.min(sum,  work1),  work2);	  double    s    =    Math.min(work1,    work2),    sum);    	non-compiled	[CE]  ';'  expected	78	None	replace
132	[BUG]  [BUGGY]  double  s  =  Math.min(work1,  work2),  sum  +  1;  [CE]  ';'  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  s  =  Math.min(work1,  work2),  sum  +  1;  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  s  =  Math.min(work1,  work2),  sum  +  1;	  double    s    =    Math.min(work1,    work2),    sum);    	non-compiled	[CE]  ';'  expected	78	None	replace
133	[BUG]  [BUGGY]  double  s  =  Math.min(sum,  work2),  sum);  [CE]  ';'  expected  [FE]                          AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  s  =  Math.min(sum,  work2),  sum);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  s  =  Math.min(sum,  work2),  sum);	  double    s    =    Math.min(work1,    work2),    sum);    	non-compiled	[CE]  ';'  expected	78	None	replace
134	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum  +=  work1[i]  *  work2[i];  sum  +=  work1[i]  *  work2[i];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	add	sum    +=    work1[i]    *    work2[i];    sum  +=  work1[i]  *  work2[i];	  	compilable	  [FE]  AssertionFailedError  	42	5	add
135	[BUG]  [BUGGY]  sum  +=  work1[i]  *  work2[i];  sum  +=  work1[i]  *  work2[i];  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum  +=  work1[i]  *  work2[i];  sum  +=  work1[i]  *  work2[i];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	sum    +=    work1[i]    *    work2[i];    sum  +=  work1[i]  *  work2[i];	  	compilable	  [FE]  AssertionFailedError  	42	5	add
136	[BUG]  [BUGGY]  sum  +=  work1[i]  *  work2[i];  Sum  +=  work1[i]  *  work2[i];  [CE]  cannot  find  symbol  Sum  [FE]      AssertionFailedError    [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum  +=  work1[i]  *  work2[i];  Sum  +=  work1[i]  *  work2[i];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	sum    +=    work1[i]    *    work2[i];    Sum  +=  work1[i]  *  work2[i];	  	non-compiled	[CE]  cannot  find  symbol  Sum	42	None	add
137	[BUG]  [BUGGY]  sum  +=  work1[i]  *  work2[i];  double  sum  +=  work1[i]  *  work2[i];  [CE]  ';'  expected  [FE]        AssertionFailedError    [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum  +=  work1[i]  *  work2[i];  double  sum  +=  work1[i]  *  work2[i];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	sum    +=    work1[i]    *    work2[i];    double  sum  +=  work1[i]  *  work2[i];	  	non-compiled	[CE]  ';'  expected	42	None	add
138	[BUG]  [BUGGY]  sum  +=  work1[i]  *  work2[i];  total  +=  work1[i]  *  work2[i];  [CE]  cannot  find  symbol  total  [FE]          AssertionFailedError    [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum  +=  work1[i]  *  work2[i];  total  +=  work1[i]  *  work2[i];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	sum    +=    work1[i]    *    work2[i];    total  +=  work1[i]  *  work2[i];	  	non-compiled	[CE]  cannot  find  symbol  total	42	None	add
139	[BUG]  [BUGGY]  sum  +=  work1[i]  *  work2[i];  int  work1[i]  *  work2[i];  [CE]  ']'  expected  [FE]            AssertionFailedError    [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum  +=  work1[i]  *  work2[i];  int  work1[i]  *  work2[i];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	sum    +=    work1[i]    *    work2[i];    int  work1[i]  *  work2[i];	  	non-compiled	[CE]  ']'  expected	42	None	add
140	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.sqrt(solvedDialog[i]  *  sum);  [CE]  ']'  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  diagR[pj]  =  Math.sqrt(solvedDialog[i]  *  sum);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  diagR[pj]  =  Math.sqrt(solvedDialog[i]  *  sum);	  double    diagR[pj]    =    Math.sqrt(solvedDialog[i]],    sum);    	non-compiled	[CE]  ']'  expected	27	None	replace
141	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.sqrt(solvedDialog[i]  -  1,  sum);  [CE]  ']'  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  diagR[pj]  =  Math.sqrt(solvedDialog[i]  -  1,  sum);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  diagR[pj]  =  Math.sqrt(solvedDialog[i]  -  1,  sum);	  double    diagR[pj]    =    Math.sqrt(solvedDialog[i]],    sum);    	non-compiled	[CE]  ']'  expected	27	None	replace
142	[BUG]  [BUGGY]  double[]  work1[pj]  =  Math.abs(work1[pj]);  [CE]  ']'  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double[]  work1[pj]  =  Math.abs(work1[pj]);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double[]  work1[pj]  =  Math.abs(work1[pj]);	  double[]    work1[pj]    =    Math.abs(diagR[pj]);    	non-compiled	[CE]  ']'  expected	59	None	replace
143	[BUG]  [BUGGY]  double[]  work1[pj]  =  Math.abs(work2[pj]);  [CE]  ']'  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double[]  work1[pj]  =  Math.abs(work2[pj]);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double[]  work1[pj]  =  Math.abs(work2[pj]);	  double[]    work1[pj]    =    Math.abs(diagR[pj]);    	non-compiled	[CE]  ']'  expected	59	None	replace
144	[BUG]  [BUGGY]  double[]  work1[pj]  =  Math.abs(diag[i]);  [CE]  ']'  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double[]  work1[pj]  =  Math.abs(diag[i]);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double[]  work1[pj]  =  Math.abs(diag[i]);	  double[]    work1[pj]    =    Math.abs(diagR[pj]);    	non-compiled	[CE]  ']'  expected	59	None	replace
145	[BUG]  [BUGGY]  sum  +=  work2[i][pj]  *  diagR[i];  [CE]  array  required,  but  double  found  [FE]                AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum  +=  work2[i][pj]  *  diagR[i];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	sum  +=  work2[i][pj]  *  diagR[i];	  sum    +=    work1[i][pj]    *    diagR[i];    	non-compiled	[CE]  array  required,  but  double  found	37	None	replace
146	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]              AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum  +=  work1[pj]  *  diag[i];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	add	sum  +=  work1[pj]  *  diag[i];	  sum    +=    work2[i][pj]    *    diag[i];    	compilable	  [FE]  AssertionFailedError  	36	6	replace
147	[BUG]  [BUGGY]  sum  +=  work1[pj]  *  diag[i];  [FE]  AssertionFailedError  [FE]              AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum  +=  work1[pj]  *  diag[i];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	sum  +=  work1[pj]  *  diag[i];	  sum    +=    work2[i][pj]    *    diag[i];    	compilable	  [FE]  AssertionFailedError  	36	6	replace
148	[BUG]  [BUGGY]  double[]  work2[pj]  =  Math.abs(work1[pj]);  [CE]  ']'  expected  [FE]                          AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double[]  work2[pj]  =  Math.abs(work1[pj]);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double[]  work2[pj]  =  Math.abs(work1[pj]);	  double[]    work2[pj]    =    Math.abs(diagR[pj]);    	non-compiled	[CE]  ']'  expected	62	None	replace
149	[BUG]  [BUGGY]  double[]  work2[pj]  =  Math.abs(work3[pj]);  [CE]  ']'  expected  [FE]                            AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double[]  work2[pj]  =  Math.abs(work3[pj]);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double[]  work2[pj]  =  Math.abs(work3[pj]);	  double[]    work2[pj]    =    Math.abs(diagR[pj]);    	non-compiled	[CE]  ']'  expected	62	None	replace
150	[BUG]  [BUGGY]  double[]  work2[pj]  =  Math.abs(work1.length[pj]);  [CE]  ']'  expected  [FE]                              AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double[]  work2[pj]  =  Math.abs(work1.length[pj]);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double[]  work2[pj]  =  Math.abs(work1.length[pj]);	  double[]    work2[pj]    =    Math.abs(diagR[pj]);    	non-compiled	[CE]  ']'  expected	62	None	replace
151	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum    +=    work2[i]    *    work1[i];    sum  +=  work2[i]  *  work1[i];  sum  +=  work2[i]  *  work1[i];  sum  +=  work2[i]  *  work1[i];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	add	sum        +=        work2[i]        *        work1[i];        sum    +=    work2[i]    *    work1[i];    sum  +=  work2[i]  *  work1[i];  sum  +=  work2[i]  *  work1[i];	  	compilable	  [FE]  AssertionFailedError  	12	5	add
152	[BUG]  [BUGGY]  sum    +=    work2[i]    *    work1[i];    sum  +=  work2[i]  *  work1[i];  sum  +=  work2[i]  *  work1[i];  sum  +=  work2[i]  *  work1[i];  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum    +=    work2[i]    *    work1[i];    sum  +=  work2[i]  *  work1[i];  sum  +=  work2[i]  *  work1[i];  sum  +=  work2[i]  *  work1[i];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	sum        +=        work2[i]        *        work1[i];        sum    +=    work2[i]    *    work1[i];    sum  +=  work2[i]  *  work1[i];  sum  +=  work2[i]  *  work1[i];	  	compilable	  [FE]  AssertionFailedError  	12	5	add
153	[BUG]  [BUGGY]  sum    +=    work2[i]    *    work1[i];    sum  +=  work2[i]  *  work1[i];  Sum  +=  work2[i]  *  work1[i];  sum  +=  work2[i]  *  work1[i];  [CE]  cannot  find  symbol  Sum  [FE]      AssertionFailedError    [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum    +=    work2[i]    *    work1[i];    sum  +=  work2[i]  *  work1[i];  Sum  +=  work2[i]  *  work1[i];  sum  +=  work2[i]  *  work1[i];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	sum        +=        work2[i]        *        work1[i];        sum    +=    work2[i]    *    work1[i];    Sum  +=  work2[i]  *  work1[i];  sum  +=  work2[i]  *  work1[i];	  	non-compiled	[CE]  cannot  find  symbol  Sum	12	None	add
154	[BUG]  [BUGGY]  sum    +=    work2[i]    *    work1[i];    sum  +=  work2[i]  *  work1[i];  for(int  i  =  0;  i  <  j;  ++i)  {  sum  +=  work2[i]  *  work1[i];  sum  +=  work2[i]  *  work1[i];  }  [CE]  variable  i  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]        AssertionFailedError    [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum    +=    work2[i]    *    work1[i];    sum  +=  work2[i]  *  work1[i];  for(int  i  =  0;  i  <  j;  ++i)  {  sum  +=  work2[i]  *  work1[i];  sum  +=  work2[i]  *  work1[i];  }  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	sum        +=        work2[i]        *        work1[i];        sum    +=    work2[i]    *    work1[i];    for(int  i  =  0;  i  <  j;  ++i)  {  sum  +=  work2[i]  *  work1[i];  sum  +=  work2[i]  *  work1[i];  }	  	non-compiled	[CE]  variable  i  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	12	None	add
155	[BUG]  [BUGGY]  sum    +=    work2[i]    *    work1[i];    sum  +=  work2[i]  *  work1[i];  total  +=  work2[i]  *  work1[i];  sum  +=  work2[i]  *  work1[i];  [CE]  cannot  find  symbol  total  [FE]          AssertionFailedError    [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum    +=    work2[i]    *    work1[i];    sum  +=  work2[i]  *  work1[i];  total  +=  work2[i]  *  work1[i];  sum  +=  work2[i]  *  work1[i];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	sum        +=        work2[i]        *        work1[i];        sum    +=    work2[i]    *    work1[i];    total  +=  work2[i]  *  work1[i];  sum  +=  work2[i]  *  work1[i];	  	non-compiled	[CE]  cannot  find  symbol  total	12	None	add
156	[BUG]  [BUGGY]  sum    +=    work2[i]    *    work1[i];    sum  +=  work2[i]  *  work1[i];  for(int  i  =  0;  i  <  j;  ++i)  {  sum  +=  work2[i]  *  work1[i];  sum  +=  work2[i]  *  work1[i];  [CE]  illegal  start  of  expression  [FE]            AssertionFailedError    [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum    +=    work2[i]    *    work1[i];    sum  +=  work2[i]  *  work1[i];  for(int  i  =  0;  i  <  j;  ++i)  {  sum  +=  work2[i]  *  work1[i];  sum  +=  work2[i]  *  work1[i];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	sum        +=        work2[i]        *        work1[i];        sum    +=    work2[i]    *    work1[i];    for(int  i  =  0;  i  <  j;  ++i)  {  sum  +=  work2[i]  *  work1[i];  sum  +=  work2[i]  *  work1[i];	  	non-compiled	[CE]  illegal  start  of  expression	12	None	add
157	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.abs(work2[pj]  *  work3[i]);  [CE]  ']'  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  diagR[pj]  =  Math.abs(work2[pj]  *  work3[i]);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  diagR[pj]  =  Math.abs(work2[pj]  *  work3[i]);	  double    diagR[pj]    =    Math.abs(work1[pj]    *    work3[i]);    	non-compiled	[CE]  ']'  expected	74	None	replace
158	[BUG]  [BUGGY]  double[]  work1[pj]  =  Math.abs(work1[i].doubleValue());  [CE]  ']'  expected  [FE]                AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double[]  work1[pj]  =  Math.abs(work1[i].doubleValue());  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double[]  work1[pj]  =  Math.abs(work1[i].doubleValue());	  double[]    work1[pj]    =    Math.abs(work1[pj].doubleValue());    	non-compiled	[CE]  ']'  expected	20	None	replace
159	[BUG]  [BUGGY]  double[]  work1[pj]  =  Math.abs(work1[pj].doubleValue()  +  1);  [CE]  ']'  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double[]  work1[pj]  =  Math.abs(work1[pj].doubleValue()  +  1);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double[]  work1[pj]  =  Math.abs(work1[pj].doubleValue()  +  1);	  double[]    work1[pj]    =    Math.abs(work1[pj].doubleValue());    	non-compiled	[CE]  ']'  expected	20	None	replace
160	[BUG]  [BUGGY]  double[]  work1[pj]  =  Math.abs(work2[pj].doubleValue());  [CE]  ']'  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double[]  work1[pj]  =  Math.abs(work2[pj].doubleValue());  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double[]  work1[pj]  =  Math.abs(work2[pj].doubleValue());	  double[]    work1[pj]    =    Math.abs(work1[pj].doubleValue());    	non-compiled	[CE]  ']'  expected	20	None	replace
161	[BUG]  [BUGGY]  double[]  work2[pj]  =  Math.abs(work1[pj].doubleValue());  [CE]  ']'  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double[]  work2[pj]  =  Math.abs(work1[pj].doubleValue());  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double[]  work2[pj]  =  Math.abs(work1[pj].doubleValue());	  double[]    work1[pj]    =    Math.abs(work1[pj].doubleValue());    	non-compiled	[CE]  ']'  expected	20	None	replace
162	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.sqrt(solvedDialog[i],  sum  +  1);  [CE]  ']'  expected  [FE]            AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  diagR[pj]  =  Math.sqrt(solvedDialog[i],  sum  +  1);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  diagR[pj]  =  Math.sqrt(solvedDialog[i],  sum  +  1);	  double    diagR[pj]    =    Math.sqrt(solvedDialog[i],    sum);    	non-compiled	[CE]  ']'  expected	88	None	replace
163	[BUG]  [BUGGY]  double[]  work1[pj]  =  Math.sqrt(solvedDialog[i],  sum);  [CE]  ']'  expected  [FE]              AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double[]  work1[pj]  =  Math.sqrt(solvedDialog[i],  sum);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double[]  work1[pj]  =  Math.sqrt(solvedDialog[i],  sum);	  double    diagR[pj]    =    Math.sqrt(solvedDialog[i],    sum);    	non-compiled	[CE]  ']'  expected	88	None	replace
164	[BUG]  [BUGGY]  double[]  work1[pj]  =  Math.abs(diag[pj]  *  dxNorm);  [CE]  ']'  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double[]  work1[pj]  =  Math.abs(diag[pj]  *  dxNorm);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double[]  work1[pj]  =  Math.abs(diag[pj]  *  dxNorm);	  double[]    work1[pj]    =    Math.abs(diag[pj]    /    dxNorm);    	non-compiled	[CE]  ']'  expected	9	None	replace
165	[BUG]  [BUGGY]  double[]  work1[pj]  =  Math.abs(work1[pj]  /  dxNorm);  [CE]  ']'  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double[]  work1[pj]  =  Math.abs(work1[pj]  /  dxNorm);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double[]  work1[pj]  =  Math.abs(work1[pj]  /  dxNorm);	  double[]    work1[pj]    =    Math.abs(diag[pj]    /    dxNorm);    	non-compiled	[CE]  ']'  expected	9	None	replace
166	[BUG]  [BUGGY]  double[]  work2[pj]  =  Math.abs(diag[pj]  /  dxNorm);  [CE]  ']'  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double[]  work2[pj]  =  Math.abs(diag[pj]  /  dxNorm);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double[]  work2[pj]  =  Math.abs(diag[pj]  /  dxNorm);	  double[]    work1[pj]    =    Math.abs(diag[pj]    /    dxNorm);    	non-compiled	[CE]  ']'  expected	9	None	replace
167	[BUG]  [BUGGY]  double[]  work1[pj]  =  Math.abs(work1[pj]  *  dxNorm);  [CE]  ']'  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double[]  work1[pj]  =  Math.abs(work1[pj]  *  dxNorm);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double[]  work1[pj]  =  Math.abs(work1[pj]  *  dxNorm);	  double[]    work1[pj]    =    Math.abs(diag[pj]    /    dxNorm);    	non-compiled	[CE]  ']'  expected	9	None	replace
168	[BUG]  [BUGGY]  double[]  work2[pj]  =  Math.abs(diagR[i]);  [CE]  ']'  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double[]  work2[pj]  =  Math.abs(diagR[i]);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double[]  work2[pj]  =  Math.abs(diagR[i]);	  double[]    diagR[pj]    =    Math.abs(diagR[i]);    	non-compiled	[CE]  ']'  expected	97	None	replace
169	[BUG]  [BUGGY]  double[]  diagR[pj]  =  Math.abs(work1[i]);  [CE]  ']'  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double[]  diagR[pj]  =  Math.abs(work1[i]);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double[]  diagR[pj]  =  Math.abs(work1[i]);	  double[]    diagR[pj]    =    Math.abs(diagR[i]);    	non-compiled	[CE]  ']'  expected	97	None	replace
170	[BUG]  [BUGGY]  double[]  diagR[pj]  =  Math.abs(diagR[i]  *  sum);  [CE]  ']'  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double[]  diagR[pj]  =  Math.abs(diagR[i]  *  sum);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double[]  diagR[pj]  =  Math.abs(diagR[i]  *  sum);	  double[]    diagR[pj]    =    Math.abs(diagR[i]);    	non-compiled	[CE]  ']'  expected	97	None	replace
171	[BUG]  [BUGGY]  double  s  =  Math.abs(work1[i]  *  work2)[i];  [CE]  bad  operand  types  for  binary  operator  '*'  [FE]              AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  s  =  Math.abs(work1[i]  *  work2)[i];  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  s  =  Math.abs(work1[i]  *  work2)[i];	          double    s    =    Math.abs(work1[i]    *    work2[i]);    double    s    =    Math.abs(work1[i]    *    work2)[i]);    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '*'	71	None	replace
172	[BUG]  [BUGGY]  double  s  =  Math.abs(work1[i]  *  work2)[i]);  [CE]  ';'  expected  [FE]                AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  s  =  Math.abs(work1[i]  *  work2)[i]);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  s  =  Math.abs(work1[i]  *  work2)[i]);	          double    s    =    Math.abs(work1[i]    *    work2[i]);    double    s    =    Math.abs(work1[i]    *    work2)[i]);    	non-compiled	[CE]  ';'  expected	71	None	replace
173	[BUG]  [BUGGY]  s  =  Math.abs(work1[i]  *  work2)[i];  [CE]  cannot  find  symbol  s  [FE]                  AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  s  =  Math.abs(work1[i]  *  work2)[i];  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	s  =  Math.abs(work1[i]  *  work2)[i];	          double    s    =    Math.abs(work1[i]    *    work2[i]);    double    s    =    Math.abs(work1[i]    *    work2)[i]);    	non-compiled	[CE]  cannot  find  symbol  s	71	None	replace
174	[BUG]  [BUGGY]  double[]  work2[pj]  =  Math.abs(work1[i]  /  diagR[i]);  [CE]  ']'  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double[]  work2[pj]  =  Math.abs(work1[i]  /  diagR[i]);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double[]  work2[pj]  =  Math.abs(work1[i]  /  diagR[i]);	  double[]    work1[pj]    =    Math.abs(work1[i]    /    diagR[i]);    	non-compiled	[CE]  ']'  expected	10	None	replace
175	[BUG]  [BUGGY]  double[]  work1[pj]  =  Math.abs(work2[i]  /  diagR[i]);  [CE]  ']'  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double[]  work1[pj]  =  Math.abs(work2[i]  /  diagR[i]);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double[]  work1[pj]  =  Math.abs(work2[i]  /  diagR[i]);	  double[]    work1[pj]    =    Math.abs(work1[i]    /    diagR[i]);    	non-compiled	[CE]  ']'  expected	10	None	replace
176	[BUG]  [BUGGY]  sum  +=  work3[i]  *  jacobian[i]];  [CE]  ';'  expected  [FE]              AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum  +=  work3[i]  *  jacobian[i]];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	sum  +=  work3[i]  *  jacobian[i]];	  sum    +=    work2[i]    *    jacobian[i]];    	non-compiled	[CE]  ';'  expected	56	None	replace
177	[BUG]  [BUGGY]  sum  +=  work1[i]  *  diagR[i]];  [CE]  ';'  expected  [FE]                AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum  +=  work1[i]  *  diagR[i]];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	sum  +=  work1[i]  *  diagR[i]];	  sum    +=    work2[i]    *    jacobian[i]];    	non-compiled	[CE]  ';'  expected	56	None	replace
178	[BUG]  [BUGGY]  sum  +=  work2[i]  *  diagR[i]];  [CE]  ';'  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum  +=  work2[i]  *  diagR[i]];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	sum  +=  work2[i]  *  diagR[i]];	  sum    +=    work2[i]    *    jacobian[i]];    	non-compiled	[CE]  ';'  expected	56	None	replace
179	[BUG]  [BUGGY]  double  s  =  Math.abs(work2[i]  *  work1[i]);  double  s  =  Math.abs(work2[i]  *  work1[i]);  [CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]    AssertionFailedError    [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  s  =  Math.abs(work2[i]  *  work1[i]);  double  s  =  Math.abs(work2[i]  *  work1[i]);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double    s    =    Math.abs(work2[i]    *    work1[i]);    double  s  =  Math.abs(work2[i]  *  work1[i]);	  	non-compiled	[CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	92	None	add
180	[BUG]  [BUGGY]  double  s  =  Math.abs(work2[i]  *  work1[i]);  double  s  =  Math.abs(work2[i]  *  work1)[i]);  [CE]  ';'  expected  [FE]      AssertionFailedError    [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  s  =  Math.abs(work2[i]  *  work1[i]);  double  s  =  Math.abs(work2[i]  *  work1)[i]);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double    s    =    Math.abs(work2[i]    *    work1[i]);    double  s  =  Math.abs(work2[i]  *  work1)[i]);	  	non-compiled	[CE]  ';'  expected	92	None	add
181	[BUG]  [BUGGY]  double  s  =  Math.abs(work2[i]  *  work1[i]);  Double  s  =  Math.abs(work2[i]  *  work1[i]);  [CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]        AssertionFailedError    [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  s  =  Math.abs(work2[i]  *  work1[i]);  Double  s  =  Math.abs(work2[i]  *  work1[i]);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double    s    =    Math.abs(work2[i]    *    work1[i]);    Double  s  =  Math.abs(work2[i]  *  work1[i]);	  	non-compiled	[CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	92	None	add
182	[BUG]  [BUGGY]  double  s  =  Math.abs(work2[i]  *  work1[i]);  int  s  =  Math.abs(work2[i]  *  work1[i]);  [CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]          AssertionFailedError    [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  s  =  Math.abs(work2[i]  *  work1[i]);  int  s  =  Math.abs(work2[i]  *  work1[i]);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double    s    =    Math.abs(work2[i]    *    work1[i]);    int  s  =  Math.abs(work2[i]  *  work1[i]);	  	non-compiled	[CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	92	None	add
183	[BUG]  [BUGGY]  double  s  =  Math.abs(work2[i]  *  work1[i]);  double  s  =  Math.abs(work2[i]  *  work1.[i]);  [CE]  <identifier>  expected  [FE]            AssertionFailedError    [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  s  =  Math.abs(work2[i]  *  work1[i]);  double  s  =  Math.abs(work2[i]  *  work1.[i]);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double    s    =    Math.abs(work2[i]    *    work1[i]);    double  s  =  Math.abs(work2[i]  *  work1.[i]);	  	non-compiled	[CE]  <identifier>  expected	92	None	add
184	[BUG]  [BUGGY]  double[]  work2[pj]  =  Math.abs(work1[i]  *  dxNorm);  [CE]  ']'  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double[]  work2[pj]  =  Math.abs(work1[i]  *  dxNorm);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double[]  work2[pj]  =  Math.abs(work1[i]  *  dxNorm);	  double[]    work2[pj]    =    Math.abs(work1[i]    /    dxNorm);    	non-compiled	[CE]  ']'  expected	11	None	replace
185	[BUG]  [BUGGY]  double[]  work2[pj]  =  Math.abs(diagR[pj]  /  dxNorm);  [CE]  ']'  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double[]  work2[pj]  =  Math.abs(diagR[pj]  /  dxNorm);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double[]  work2[pj]  =  Math.abs(diagR[pj]  /  dxNorm);	  double[]    work2[pj]    =    Math.abs(work1[i]    /    dxNorm);    	non-compiled	[CE]  ']'  expected	11	None	replace
186	[BUG]  [BUGGY]  double[]  diagR[pj]  =  Math.abs(diagR[pj].doubleValue();  [CE]  ']'  expected  [FE]            AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double[]  diagR[pj]  =  Math.abs(diagR[pj].doubleValue();  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double[]  diagR[pj]  =  Math.abs(diagR[pj].doubleValue();	  double[]    diagR[pj]    =    Math.abs(diagR[pj].doubleValue()    +    1);    	non-compiled	[CE]  ']'  expected	91	None	replace
187	[BUG]  [BUGGY]  double[]  work1[pj]  =  Math.abs(work1.length);  [CE]  ']'  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double[]  work1[pj]  =  Math.abs(work1.length);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double[]  work1[pj]  =  Math.abs(work1.length);	  double[]    work1[pj]    =    Math.abs(diagR[i]);    	non-compiled	[CE]  ']'  expected	60	None	replace
188	[BUG]  [BUGGY]  sum  +=  work[i][pj]  *  diagR[i]];  [CE]  ';'  expected  [FE]              AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum  +=  work[i][pj]  *  diagR[i]];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	sum  +=  work[i][pj]  *  diagR[i]];	  sum    +=    work[i][pj]    *    diag[i]];    	non-compiled	[CE]  ';'  expected	104	None	replace
189	[BUG]  [BUGGY]  sum  +=  work[i][pj]  *  diag[i];  [CE]  cannot  find  symbol  work  [FE]                AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum  +=  work[i][pj]  *  diag[i];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	sum  +=  work[i][pj]  *  diag[i];	  sum    +=    work[i][pj]    *    diag[i]];    	non-compiled	[CE]  cannot  find  symbol  work	104	None	replace
190	[BUG]  [BUGGY]  sum  +=  work[i][j]  *  diag[i]];  [CE]  ';'  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum  +=  work[i][j]  *  diag[i]];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	sum  +=  work[i][j]  *  diag[i]];	  sum    +=    work[i][pj]    *    diag[i]];    	non-compiled	[CE]  ';'  expected	104	None	replace
191	[BUG]  [BUGGY]  sum  +=  work[i][pj]  /  diag[i]];  [CE]  ';'  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum  +=  work[i][pj]  /  diag[i]];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	sum  +=  work[i][pj]  /  diag[i]];	  sum    +=    work[i][pj]    *    diag[i]];    	non-compiled	[CE]  ';'  expected	104	None	replace
192	[BUG]  [BUGGY]  double[]  diagR[pj]  =  Math.abs(diagR[i].computeMask()  +  1);  [CE]  ']'  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double[]  diagR[pj]  =  Math.abs(diagR[i].computeMask()  +  1);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double[]  diagR[pj]  =  Math.abs(diagR[i].computeMask()  +  1);	  double[]    diagR[pj]    =    Math.abs(diagR[i].computeMask());    	non-compiled	[CE]  ']'  expected	2	None	replace
193	[BUG]  [BUGGY]  double[]  work1[pj]  =  Math.abs(diagR[i].computeMask());  [CE]  ']'  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double[]  work1[pj]  =  Math.abs(diagR[i].computeMask());  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double[]  work1[pj]  =  Math.abs(diagR[i].computeMask());	  double[]    diagR[pj]    =    Math.abs(diagR[i].computeMask());    	non-compiled	[CE]  ']'  expected	2	None	replace
194	[BUG]  [BUGGY]  double[]  diagR[pj]  =  Math.abs(diagR[i].computeMask()  -  1);  [CE]  ']'  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double[]  diagR[pj]  =  Math.abs(diagR[i].computeMask()  -  1);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double[]  diagR[pj]  =  Math.abs(diagR[i].computeMask()  -  1);	  double[]    diagR[pj]    =    Math.abs(diagR[i].computeMask());    	non-compiled	[CE]  ']'  expected	2	None	replace
195	[BUG]  [BUGGY]  double[]  diagR[pj]  =  Math.abs(diagR[pj].computeMask();  [CE]  ']'  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double[]  diagR[pj]  =  Math.abs(diagR[pj].computeMask();  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double[]  diagR[pj]  =  Math.abs(diagR[pj].computeMask();	  double[]    diagR[pj]    =    Math.abs(diagR[pj].computeMask()    +    1);    	non-compiled	[CE]  ']'  expected	3	None	replace
196	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.sqrt(work1[i]  *  work2);  [CE]  ']'  expected  [FE]                AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  diagR[pj]  =  Math.sqrt(work1[i]  *  work2);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  diagR[pj]  =  Math.sqrt(work1[i]  *  work2);	  double    diagR[pj]    =    Math.sqrt(work1[i]);    	non-compiled	[CE]  ']'  expected	33	None	replace
197	[BUG]  [BUGGY]  double[]  workR[pj]  =  Math.abs(work1[pj]);  [CE]  ']'  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double[]  workR[pj]  =  Math.abs(work1[pj]);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double[]  workR[pj]  =  Math.abs(work1[pj]);	  double[]    workR[pj]    =    Math.abs(workR[pj]);    	non-compiled	[CE]  ']'  expected	112	None	replace
198	[BUG]  [BUGGY]  double[]  workR[pj]  =  Math.abs(workR[i]);  [CE]  ']'  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double[]  workR[pj]  =  Math.abs(workR[i]);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double[]  workR[pj]  =  Math.abs(workR[i]);	  double[]    workR[pj]    =    Math.abs(workR[pj]);    	non-compiled	[CE]  ']'  expected	112	None	replace
199	[BUG]  [BUGGY]  double[]  workR[pj]  =  Math.abs(work2[pj]);  [CE]  ']'  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double[]  workR[pj]  =  Math.abs(work2[pj]);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double[]  workR[pj]  =  Math.abs(work2[pj]);	  double[]    workR[pj]    =    Math.abs(workR[pj]);    	non-compiled	[CE]  ']'  expected	112	None	replace
200	[BUG]  [BUGGY]  double[]  workR[pj]  =  Math.abs(work1.length[pj]);  [CE]  ']'  expected  [FE]                          AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double[]  workR[pj]  =  Math.abs(work1.length[pj]);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double[]  workR[pj]  =  Math.abs(work1.length[pj]);	  double[]    workR[pj]    =    Math.abs(workR[pj]);    	non-compiled	[CE]  ']'  expected	112	None	replace
201	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.log(diagR[i]);  [CE]  ']'  expected  [FE]              AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  diagR[pj]  =  Math.log(diagR[i]);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  diagR[pj]  =  Math.log(diagR[i]);	  double    diagR[pj]    =    Math.sqrt(diagR[i]);    	non-compiled	[CE]  ']'  expected	98	None	replace
202	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]                AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  s  =  Math.abs(work2[i]  *  work2[i]);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	add	double  s  =  Math.abs(work2[i]  *  work2[i]);	          double    s    =    Math.abs(work1[i]    *    work2[i]);    double    s    =    Math.abs(work2[i]    *    work2[i]);    	compilable	  [FE]  AssertionFailedError  	72	13	replace
203	[BUG]  [BUGGY]  double  s  =  Math.abs(work2[i]  *  work2[i]);  [FE]  AssertionFailedError  [FE]                AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  s  =  Math.abs(work2[i]  *  work2[i]);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  s  =  Math.abs(work2[i]  *  work2[i]);	          double    s    =    Math.abs(work1[i]    *    work2[i]);    double    s    =    Math.abs(work2[i]    *    work2[i]);    	compilable	  [FE]  AssertionFailedError  	72	13	replace
204	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]                  AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  s  =  Math.abs(work3[i]  *  work2[i]);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	add	double  s  =  Math.abs(work3[i]  *  work2[i]);	          double    s    =    Math.abs(work1[i]    *    work2[i]);    double    s    =    Math.abs(work2[i]    *    work2[i]);    	compilable	  [FE]  AssertionFailedError  	72	13	replace
205	[BUG]  [BUGGY]  double  s  =  Math.abs(work3[i]  *  work2[i]);  [FE]  AssertionFailedError  [FE]                  AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  s  =  Math.abs(work3[i]  *  work2[i]);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  s  =  Math.abs(work3[i]  *  work2[i]);	          double    s    =    Math.abs(work1[i]    *    work2[i]);    double    s    =    Math.abs(work2[i]    *    work2[i]);    	compilable	  [FE]  AssertionFailedError  	72	13	replace
206	[BUG]  [BUGGY]  sum  +=  work1,  work2[i][pj]  *  jacobian[permutation[i]];  [CE]  ';'  expected  [FE]              AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum  +=  work1,  work2[i][pj]  *  jacobian[permutation[i]];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	sum  +=  work1,  work2[i][pj]  *  jacobian[permutation[i]];	  sum    +=    work2[i][pj]    *    jacobian[permutation[i]];    	non-compiled	[CE]  ';'  expected	39	None	replace
207	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  s  =  Math.abs(work2[i]  *  work3[i]);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	add	double  s  =  Math.abs(work2[i]  *  work3[i]);	  double    s    =    Math.abs(work2[i]    *    work1[i]);    	compilable	  [FE]  AssertionFailedError  	93	13	replace
208	[BUG]  [BUGGY]  double  s  =  Math.abs(work2[i]  *  work3[i]);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  s  =  Math.abs(work2[i]  *  work3[i]);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  s  =  Math.abs(work2[i]  *  work3[i]);	  double    s    =    Math.abs(work2[i]    *    work1[i]);    	compilable	  [FE]  AssertionFailedError  	93	13	replace
209	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  s  =  Math.abs(work3[i]  *  work1[i]);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	add	double  s  =  Math.abs(work3[i]  *  work1[i]);	  double    s    =    Math.abs(work2[i]    *    work1[i]);    	compilable	  [FE]  AssertionFailedError  	93	13	replace
210	[BUG]  [BUGGY]  double  s  =  Math.abs(work3[i]  *  work1[i]);  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  s  =  Math.abs(work3[i]  *  work1[i]);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  s  =  Math.abs(work3[i]  *  work1[i]);	  double    s    =    Math.abs(work2[i]    *    work1[i]);    	compilable	  [FE]  AssertionFailedError  	93	13	replace
211	[BUG]  [BUGGY]  double[]  work2[pj]  =  Math.abs(work1[i]  *  diagR[i]);  [CE]  ']'  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double[]  work2[pj]  =  Math.abs(work1[i]  *  diagR[i]);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double[]  work2[pj]  =  Math.abs(work1[i]  *  diagR[i]);	  double[]    work1[pj]    =    Math.abs(work2[i]    *    diagR[i]);    	non-compiled	[CE]  ']'  expected	111	None	replace
212	[BUG]  [BUGGY]  double[]  work1[pj]  =  Math.abs(work2[i]  *  diagR[i]  +  1);  [CE]  ']'  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double[]  work1[pj]  =  Math.abs(work2[i]  *  diagR[i]  +  1);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double[]  work1[pj]  =  Math.abs(work2[i]  *  diagR[i]  +  1);	  double[]    work1[pj]    =    Math.abs(work2[i]    *    diagR[i]);    	non-compiled	[CE]  ']'  expected	111	None	replace
213	[BUG]  [BUGGY]  Sum  +=  work2[i]  *  work1[i];  [CE]  cannot  find  symbol  Sum  [FE]          AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  Sum  +=  work2[i]  *  work1[i];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	Sum  +=  work2[i]  *  work1[i];	  sum    +=    work2[i]    *    work1[i];    Sum    +=    work2[i]    *    work1[i];    	non-compiled	[CE]  cannot  find  symbol  Sum	14	None	replace
214	[BUG]  [BUGGY]  Sum  +=  work1[i]  *  work2[i];  [CE]  cannot  find  symbol  Sum  [FE]            AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  Sum  +=  work1[i]  *  work2[i];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	Sum  +=  work1[i]  *  work2[i];	  sum    +=    work2[i]    *    work1[i];    Sum    +=    work2[i]    *    work1[i];    	non-compiled	[CE]  cannot  find  symbol  Sum	14	None	replace
215	[BUG]  [BUGGY]  Sum  +=  work3[i]  *  work1[i];  [CE]  cannot  find  symbol  Sum  [FE]              AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  Sum  +=  work3[i]  *  work1[i];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	Sum  +=  work3[i]  *  work1[i];	  sum    +=    work2[i]    *    work1[i];    Sum    +=    work2[i]    *    work1[i];    	non-compiled	[CE]  cannot  find  symbol  Sum	14	None	replace
216	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.sqrt(work1[i]  -  sum);  [CE]  ']'  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  diagR[pj]  =  Math.sqrt(work1[i]  -  sum);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  diagR[pj]  =  Math.sqrt(work1[i]  -  sum);	  double    diagR[pj]    =    Math.sqrt(diagR[i]    -    sum);    	non-compiled	[CE]  ']'  expected	83	None	replace
217	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.sqrt(work1[pj]  -  sum);  [CE]  ']'  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  diagR[pj]  =  Math.sqrt(work1[pj]  -  sum);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  diagR[pj]  =  Math.sqrt(work1[pj]  -  sum);	  double    diagR[pj]    =    Math.sqrt(diagR[i]    -    sum);    	non-compiled	[CE]  ']'  expected	83	None	replace
218	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  Double  s  =  Math.abs(work1[i]  *  work2[i]);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	add	Double  s  =  Math.abs(work1[i]  *  work2[i]);	          double    s    =    Math.abs(work1[i]    *    work2[i]);    Double    s    =    Math.abs(work1[i]    *    work2[i]);    	compilable	  [FE]  AssertionFailedError  	69	13	replace
219	[BUG]  [BUGGY]  Double  s  =  Math.abs(work1[i]  *  work2[i]);  [FE]  AssertionFailedError  [FE]          AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  Double  s  =  Math.abs(work1[i]  *  work2[i]);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	Double  s  =  Math.abs(work1[i]  *  work2[i]);	          double    s    =    Math.abs(work1[i]    *    work2[i]);    Double    s    =    Math.abs(work1[i]    *    work2[i]);    	compilable	  [FE]  AssertionFailedError  	69	13	replace
220	[BUG]  [BUGGY]  double  diagR[j]  =  Math.abs(work1[i]  *  work2[i]  +  1);  [CE]  ']'  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  diagR[j]  =  Math.abs(work1[i]  *  work2[i]  +  1);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  diagR[j]  =  Math.abs(work1[i]  *  work2[i]  +  1);	  double    diagR[j]    =    Math.abs(work1[i]    *    work2[i]);    	non-compiled	[CE]  ']'  expected	75	None	replace
221	[BUG]  [BUGGY]  double  diagR[j]  =  Math.abs(work1[i]  *  work3[i]);  [CE]  ']'  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  diagR[j]  =  Math.abs(work1[i]  *  work3[i]);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  diagR[j]  =  Math.abs(work1[i]  *  work3[i]);	  double    diagR[j]    =    Math.abs(work1[i]    *    work2[i]);    	non-compiled	[CE]  ']'  expected	75	None	replace
222	[BUG]  [BUGGY]  double  diagR[j]  =  Math.abs(work1[i]  *  work2[i]  +  sum);  [CE]  ']'  expected  [FE]                          AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  diagR[j]  =  Math.abs(work1[i]  *  work2[i]  +  sum);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  diagR[j]  =  Math.abs(work1[i]  *  work2[i]  +  sum);	  double    diagR[j]    =    Math.abs(work1[i]    *    work2[i]);    	non-compiled	[CE]  ']'  expected	75	None	replace
223	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.sqrt(work1[i],  sum2);  [CE]  ']'  expected  [FE]            AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  diagR[pj]  =  Math.sqrt(work1[i],  sum2);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  diagR[pj]  =  Math.sqrt(work1[i],  sum2);	  double    diagR[pj]    =    Math.sqrt(diagR[i],    sum2);    	non-compiled	[CE]  ']'  expected	114	None	replace
224	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.sqrt(diagR[i],  work3);  [CE]  ']'  expected  [FE]              AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  diagR[pj]  =  Math.sqrt(diagR[i],  work3);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  diagR[pj]  =  Math.sqrt(diagR[i],  work3);	  double    diagR[pj]    =    Math.sqrt(diagR[i],    sum2);    	non-compiled	[CE]  ']'  expected	114	None	replace
225	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.sqrt(diagR[i],  work3;  [CE]  ']'  expected  [FE]                AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  diagR[pj]  =  Math.sqrt(diagR[i],  work3;  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  diagR[pj]  =  Math.sqrt(diagR[i],  work3;	  double    diagR[pj]    =    Math.sqrt(diagR[i],    sum2);    	non-compiled	[CE]  ']'  expected	114	None	replace
226	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.sqrt(diagR[i],  sum  +  1);  [CE]  ']'  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  diagR[pj]  =  Math.sqrt(diagR[i],  sum  +  1);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  diagR[pj]  =  Math.sqrt(diagR[i],  sum  +  1);	  double    diagR[pj]    =    Math.sqrt(diagR[i],    sum);    	non-compiled	[CE]  ']'  expected	54	None	replace
227	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.sqrt(diagR[i],  sum  +  2);  [CE]  ']'  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  diagR[pj]  =  Math.sqrt(diagR[i],  sum  +  2);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  diagR[pj]  =  Math.sqrt(diagR[i],  sum  +  2);	  double    diagR[pj]    =    Math.sqrt(diagR[i],    sum);    	non-compiled	[CE]  ']'  expected	54	None	replace
228	[BUG]  [BUGGY]  double  s  =  Math.min(work2,  work1),  work3;  [CE]  no  suitable  method  found  for  min(double[],double[])  [FE]                AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  s  =  Math.min(work2,  work1),  work3;  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  s  =  Math.min(work2,  work1),  work3;	  double    s    =    Math.min(work1,    work2),    work3;    	non-compiled	[CE]  no  suitable  method  found  for  min(double[],double[])	106	None	replace
229	[BUG]  [BUGGY]  double  s  =  Math.min(work1,  work2),  sum2;  [CE]  no  suitable  method  found  for  min(double[],double[])  [FE]                  AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  s  =  Math.min(work1,  work2),  sum2;  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  s  =  Math.min(work1,  work2),  sum2;	  double    s    =    Math.min(work1,    work2),    work3;    	non-compiled	[CE]  no  suitable  method  found  for  min(double[],double[])	106	None	replace
230	[BUG]  [BUGGY]  double  s  =  Math.min(work1,  work2),  sum2,  work3;  [CE]  no  suitable  method  found  for  min(double[],double[])  [FE]                    AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  s  =  Math.min(work1,  work2),  sum2,  work3;  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  s  =  Math.min(work1,  work2),  sum2,  work3;	  double    s    =    Math.min(work1,    work2),    work3;    	non-compiled	[CE]  no  suitable  method  found  for  min(double[],double[])	106	None	replace
231	[BUG]  [BUGGY]  double  s  =  Math.abs(work1[i]  *  work2[i]  +  sum);  double  s  =  Math.abs(work1[i]  *  work2[i]  +  sum);  [CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]    AssertionFailedError    [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  s  =  Math.abs(work1[i]  *  work2[i]  +  sum);  double  s  =  Math.abs(work1[i]  *  work2[i]  +  sum);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double    s    =    Math.abs(work1[i]    *    work2[i]    +    sum);    double  s  =  Math.abs(work1[i]  *  work2[i]  +  sum);	  	non-compiled	[CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	63	None	add
232	[BUG]  [BUGGY]  double  s  =  Math.abs(work1[i]  *  work2[i]  +  sum);  Double  s  =  Math.abs(work1[i]  *  work2[i]  +  sum);  [CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]      AssertionFailedError    [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  s  =  Math.abs(work1[i]  *  work2[i]  +  sum);  Double  s  =  Math.abs(work1[i]  *  work2[i]  +  sum);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double    s    =    Math.abs(work1[i]    *    work2[i]    +    sum);    Double  s  =  Math.abs(work1[i]  *  work2[i]  +  sum);	  	non-compiled	[CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	63	None	add
233	[BUG]  [BUGGY]  double  s  =  Math.abs(work1[i]  *  work2[i]  +  sum);  int  s  =  Math.abs(work1[i]  *  work2[i]  +  sum);  [CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]        AssertionFailedError    [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  s  =  Math.abs(work1[i]  *  work2[i]  +  sum);  int  s  =  Math.abs(work1[i]  *  work2[i]  +  sum);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double    s    =    Math.abs(work1[i]    *    work2[i]    +    sum);    int  s  =  Math.abs(work1[i]  *  work2[i]  +  sum);	  	non-compiled	[CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	63	None	add
234	[BUG]  [BUGGY]  double  s  =  Math.abs(work1[i]  *  work2[i]  +  sum);  double  s  =  Math.abs(work1[i]  *  work2[i]  +  Sum);  [CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]          AssertionFailedError    [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  s  =  Math.abs(work1[i]  *  work2[i]  +  sum);  double  s  =  Math.abs(work1[i]  *  work2[i]  +  Sum);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double    s    =    Math.abs(work1[i]    *    work2[i]    +    sum);    double  s  =  Math.abs(work1[i]  *  work2[i]  +  Sum);	  	non-compiled	[CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	63	None	add
235	[BUG]  [BUGGY]  double  s  =  Math.abs(work1[i]  *  work2[i]  +  sum);  double  s  =  Math.abs(work1[i]  *  work2.[i]  +  sum);  [CE]  <identifier>  expected  [FE]            AssertionFailedError    [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  s  =  Math.abs(work1[i]  *  work2[i]  +  sum);  double  s  =  Math.abs(work1[i]  *  work2.[i]  +  sum);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double    s    =    Math.abs(work1[i]    *    work2[i]    +    sum);    double  s  =  Math.abs(work1[i]  *  work2.[i]  +  sum);	  	non-compiled	[CE]  <identifier>  expected	63	None	add
236	[BUG]  [BUGGY]  double[]  work1[pj]  =  Math.abs(work1[i]  -  1);  [CE]  ']'  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double[]  work1[pj]  =  Math.abs(work1[i]  -  1);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double[]  work1[pj]  =  Math.abs(work1[i]  -  1);	  double[]    work1[pj]    =    Math.abs(work1[i]);    	non-compiled	[CE]  ']'  expected	4	None	replace
237	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum  +=  work3[i]  *  work1[i];  sum  +=  work3[i]  *  work1[i];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	add	sum    +=    work3[i]    *    work1[i];    sum  +=  work3[i]  *  work1[i];	  	compilable	  [FE]  AssertionFailedError  	47	6	add
238	[BUG]  [BUGGY]  sum  +=  work3[i]  *  work1[i];  sum  +=  work3[i]  *  work1[i];  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum  +=  work3[i]  *  work1[i];  sum  +=  work3[i]  *  work1[i];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	sum    +=    work3[i]    *    work1[i];    sum  +=  work3[i]  *  work1[i];	  	compilable	  [FE]  AssertionFailedError  	47	6	add
239	[BUG]  [BUGGY]  sum  +=  work3[i]  *  work1[i];  Sum  +=  work3[i]  *  work1[i];  [CE]  cannot  find  symbol  Sum  [FE]      AssertionFailedError    [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum  +=  work3[i]  *  work1[i];  Sum  +=  work3[i]  *  work1[i];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	sum    +=    work3[i]    *    work1[i];    Sum  +=  work3[i]  *  work1[i];	  	non-compiled	[CE]  cannot  find  symbol  Sum	47	None	add
240	[BUG]  [BUGGY]  sum  +=  work3[i]  *  work1[i];  double  sum  +=  work3[i]  *  work1[i];  [CE]  ';'  expected  [FE]        AssertionFailedError    [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum  +=  work3[i]  *  work1[i];  double  sum  +=  work3[i]  *  work1[i];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	sum    +=    work3[i]    *    work1[i];    double  sum  +=  work3[i]  *  work1[i];	  	non-compiled	[CE]  ';'  expected	47	None	add
241	[BUG]  [BUGGY]  sum  +=  work3[i]  *  work1[i];  total  +=  work3[i]  *  work1[i];  [CE]  cannot  find  symbol  total  [FE]          AssertionFailedError    [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum  +=  work3[i]  *  work1[i];  total  +=  work3[i]  *  work1[i];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	sum    +=    work3[i]    *    work1[i];    total  +=  work3[i]  *  work1[i];	  	non-compiled	[CE]  cannot  find  symbol  total	47	None	add
242	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum  +=  work3[i]  *  work1[i];  sum  +=  work3[i]  *  work2[i];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	add	sum    +=    work3[i]    *    work1[i];    sum  +=  work3[i]  *  work2[i];	  	compilable	  [FE]  AssertionFailedError  	47	6	add
243	[BUG]  [BUGGY]  sum  +=  work3[i]  *  work1[i];  sum  +=  work3[i]  *  work2[i];  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum  +=  work3[i]  *  work1[i];  sum  +=  work3[i]  *  work2[i];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	sum    +=    work3[i]    *    work1[i];    sum  +=  work3[i]  *  work2[i];	  	compilable	  [FE]  AssertionFailedError  	47	6	add
244	[BUG]  [BUGGY]  double  s  =  Math.min(sum,  work1),  work2;  [CE]  no  suitable  method  found  for  min(double,double[])  [FE]                AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  s  =  Math.min(sum,  work1),  work2;  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  s  =  Math.min(sum,  work1),  work2;	  double    s    =    Math.min(work1,    work2),    sum;    	non-compiled	[CE]  no  suitable  method  found  for  min(double,double[])	76	None	replace
245	[BUG]  [BUGGY]  double  s  =  Math.min(sum,  work1),  work2,  sum;  [CE]  no  suitable  method  found  for  min(double,double[])  [FE]                  AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  s  =  Math.min(sum,  work1),  work2,  sum;  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  s  =  Math.min(sum,  work1),  work2,  sum;	  double    s    =    Math.min(work1,    work2),    sum;    	non-compiled	[CE]  no  suitable  method  found  for  min(double,double[])	76	None	replace
246	[BUG]  [BUGGY]  double  s  =  Math.min(sum,  work2),  work1;  [CE]  no  suitable  method  found  for  min(double,double[])  [FE]                    AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  s  =  Math.min(sum,  work2),  work1;  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  s  =  Math.min(sum,  work2),  work1;	  double    s    =    Math.min(work1,    work2),    sum;    	non-compiled	[CE]  no  suitable  method  found  for  min(double,double[])	76	None	replace
247	[BUG]  [BUGGY]  double[]  work2[pj]  =  Math.abs(work3[i]);  [CE]  ']'  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double[]  work2[pj]  =  Math.abs(work3[i]);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double[]  work2[pj]  =  Math.abs(work3[i]);	  double[]    work2[pj]    =    Math.abs(work1[i]);    	non-compiled	[CE]  ']'  expected	5	None	replace
248	[BUG]  [BUGGY]  double[]  work2[pj]  =  Math.abs(work1[i]  *  sum);  [CE]  ']'  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double[]  work2[pj]  =  Math.abs(work1[i]  *  sum);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double[]  work2[pj]  =  Math.abs(work1[i]  *  sum);	  double[]    work2[pj]    =    Math.abs(work1[i]);    	non-compiled	[CE]  ']'  expected	5	None	replace
249	[BUG]  [BUGGY]  double[]  work2[pj]  =  Math.abs(work1[i]  -  1);  [CE]  ']'  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double[]  work2[pj]  =  Math.abs(work1[i]  -  1);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double[]  work2[pj]  =  Math.abs(work1[i]  -  1);	  double[]    work2[pj]    =    Math.abs(work1[i]);    	non-compiled	[CE]  ']'  expected	5	None	replace
250	[BUG]  [BUGGY]  int  s  =  Math.abs(work1[i]  *  work2[i]);  [CE]  possible  loss  of  precision  [FE]            AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  int  s  =  Math.abs(work1[i]  *  work2[i]);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	int  s  =  Math.abs(work1[i]  *  work2[i]);	          double    s    =    Math.abs(work1[i]    *    work2[i]);    int    s    =    Math.abs(work1[i]    *    work2[i]);    	non-compiled	[CE]  possible  loss  of  precision	70	None	replace
251	[BUG]  [BUGGY]  Integer  s  =  Math.abs(work1[i]  *  work2[i]);  [CE]  incompatible  types  [FE]              AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  Integer  s  =  Math.abs(work1[i]  *  work2[i]);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	Integer  s  =  Math.abs(work1[i]  *  work2[i]);	          double    s    =    Math.abs(work1[i]    *    work2[i]);    int    s    =    Math.abs(work1[i]    *    work2[i]);    	non-compiled	[CE]  incompatible  types	70	None	replace
252	[BUG]  [BUGGY]  double[]  diagR[pj]  =  Math.abs(diagR[i].doubleValue()  +  1);  [CE]  ']'  expected  [FE]              AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double[]  diagR[pj]  =  Math.abs(diagR[i].doubleValue()  +  1);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double[]  diagR[pj]  =  Math.abs(diagR[i].doubleValue()  +  1);	  double[]    diagR[pj]    =    Math.abs(diagR[i].doubleValue());    	non-compiled	[CE]  ']'  expected	19	None	replace
253	[BUG]  [BUGGY]  double[]  work2[pj]  =  Math.abs(work1.length[pj].doubleValue());  [CE]  ']'  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double[]  work2[pj]  =  Math.abs(work1.length[pj].doubleValue());  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double[]  work2[pj]  =  Math.abs(work1.length[pj].doubleValue());	  double[]    work2[pj]    =    Math.abs(diagR[pj].doubleValue());    	non-compiled	[CE]  ']'  expected	21	None	replace
254	[BUG]  [BUGGY]  double[]  work2[pj]  =  Math.abs(diagR[pj].doubleValue()  +  1);  [CE]  ']'  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double[]  work2[pj]  =  Math.abs(diagR[pj].doubleValue()  +  1);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double[]  work2[pj]  =  Math.abs(diagR[pj].doubleValue()  +  1);	  double[]    work2[pj]    =    Math.abs(diagR[pj].doubleValue());    	non-compiled	[CE]  ']'  expected	21	None	replace
255	[BUG]  [BUGGY]  double[]  work2[pj]  =  Math.abs(diagR[i].doubleValue());  [CE]  ']'  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double[]  work2[pj]  =  Math.abs(diagR[i].doubleValue());  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double[]  work2[pj]  =  Math.abs(diagR[i].doubleValue());	  double[]    work2[pj]    =    Math.abs(diagR[pj].doubleValue());    	non-compiled	[CE]  ']'  expected	21	None	replace
256	[BUG]  [BUGGY]  sum  +=  work1[i]  *  diag[i]];  [CE]  ';'  expected  [FE]                AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum  +=  work1[i]  *  diag[i]];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	sum  +=  work1[i]  *  diag[i]];	  sum    +=    work2[i]    *    diag[i]];    	non-compiled	[CE]  ';'  expected	57	None	replace
257	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]                  AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum  +=  work1[i]  *  diag[i];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	add	sum  +=  work1[i]  *  diag[i];	  sum    +=    work2[i]    *    diag[i]];    	compilable	  [FE]  AssertionFailedError  	57	5	replace
258	[BUG]  [BUGGY]  sum  +=  work1[i]  *  diag[i];  [FE]  AssertionFailedError  [FE]                  AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum  +=  work1[i]  *  diag[i];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	sum  +=  work1[i]  *  diag[i];	  sum    +=    work2[i]    *    diag[i]];    	compilable	  [FE]  AssertionFailedError  	57	5	replace
259	[BUG]  [BUGGY]  sum  +=  work3[i]  *  diag[i]];  [CE]  ';'  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum  +=  work3[i]  *  diag[i]];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	sum  +=  work3[i]  *  diag[i]];	  sum    +=    work2[i]    *    diag[i]];    	non-compiled	[CE]  ';'  expected	57	None	replace
260	[BUG]  [BUGGY]  double[]  work2[pj]  =  Math.abs(work2[i]  /  dxNorm);  [CE]  ']'  expected  [FE]              AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double[]  work2[pj]  =  Math.abs(work2[i]  /  dxNorm);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double[]  work2[pj]  =  Math.abs(work2[i]  /  dxNorm);	  double[]    work2[pj]    =    Math.abs(work2[i]    *    dxNorm);    	non-compiled	[CE]  ']'  expected	79	None	replace
261	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum2  +=  work1[i]  *  work2[i];  sum2  +=  work1[i]  *  work2[i];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	add	sum2    +=    work1[i]    *    work2[i];    sum2  +=  work1[i]  *  work2[i];	  	compilable	  [FE]  AssertionFailedError  	94	6	add
262	[BUG]  [BUGGY]  sum2  +=  work1[i]  *  work2[i];  sum2  +=  work1[i]  *  work2[i];  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum2  +=  work1[i]  *  work2[i];  sum2  +=  work1[i]  *  work2[i];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	sum2    +=    work1[i]    *    work2[i];    sum2  +=  work1[i]  *  work2[i];	  	compilable	  [FE]  AssertionFailedError  	94	6	add
263	[BUG]  [BUGGY]  sum2  +=  work1[i]  *  work2[i];  Sum2  +=  work1[i]  *  work2[i];  [CE]  cannot  find  symbol  Sum2  [FE]      AssertionFailedError    [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum2  +=  work1[i]  *  work2[i];  Sum2  +=  work1[i]  *  work2[i];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	sum2    +=    work1[i]    *    work2[i];    Sum2  +=  work1[i]  *  work2[i];	  	non-compiled	[CE]  cannot  find  symbol  Sum2	94	None	add
264	[BUG]  [BUGGY]  sum2  +=  work1[i]  *  work2[i];  total2  +=  work1[i]  *  work2[i];  [CE]  cannot  find  symbol  total2  [FE]        AssertionFailedError    [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum2  +=  work1[i]  *  work2[i];  total2  +=  work1[i]  *  work2[i];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	sum2    +=    work1[i]    *    work2[i];    total2  +=  work1[i]  *  work2[i];	  	non-compiled	[CE]  cannot  find  symbol  total2	94	None	add
265	[BUG]  [BUGGY]  sum2  +=  work1[i]  *  work2[i];  double[]  work1[i]  *  work2[i];  [CE]  ']'  expected  [FE]          AssertionFailedError    [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum2  +=  work1[i]  *  work2[i];  double[]  work1[i]  *  work2[i];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	sum2    +=    work1[i]    *    work2[i];    double[]  work1[i]  *  work2[i];	  	non-compiled	[CE]  ']'  expected	94	None	add
266	[BUG]  [BUGGY]  sum2  +=  work1[i]  *  work2[i];  int  work1[i]  *  work2[i];  [CE]  ']'  expected  [FE]            AssertionFailedError    [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum2  +=  work1[i]  *  work2[i];  int  work1[i]  *  work2[i];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	sum2    +=    work1[i]    *    work2[i];    int  work1[i]  *  work2[i];	  	non-compiled	[CE]  ']'  expected	94	None	add
267	[BUG]  [BUGGY]  sum  +=  work1[i][pj]  *  work2[i];  [CE]  array  required,  but  double  found  [FE]            AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum  +=  work1[i][pj]  *  work2[i];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	sum  +=  work1[i][pj]  *  work2[i];	  sum    +=    work2[i][pj]    *    work1[i]];    	non-compiled	[CE]  array  required,  but  double  found	107	None	replace
268	[BUG]  [BUGGY]  sum  +=  work3[i][pj]  *  work2[i]];  [CE]  ';'  expected  [FE]              AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum  +=  work3[i][pj]  *  work2[i]];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	sum  +=  work3[i][pj]  *  work2[i]];	  sum    +=    work2[i][pj]    *    work1[i]];    	non-compiled	[CE]  ';'  expected	107	None	replace
269	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.sqrt(diagR[0],  sum2);  [CE]  ']'  expected  [FE]            AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  diagR[pj]  =  Math.sqrt(diagR[0],  sum2);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  diagR[pj]  =  Math.sqrt(diagR[0],  sum2);	  double    diagR[pj]    =    Math.sqrt(diagR[i],    sum2);    	non-compiled	[CE]  ']'  expected	114	None	replace
270	[BUG]  [BUGGY]  sum  +=  work2[i][pj]  *  work3[i]];  [CE]  ';'  expected  [FE]              AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum  +=  work2[i][pj]  *  work3[i]];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	sum  +=  work2[i][pj]  *  work3[i]];	  sum    +=    work3[i][pj]    *    work1[i]];    	non-compiled	[CE]  ';'  expected	30	None	replace
271	[BUG]  [BUGGY]  double  s  =  Math.abs(sum2[i]  *  work2[i],  work1);  [CE]  array  required,  but  double  found  [FE]            AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  s  =  Math.abs(sum2[i]  *  work2[i],  work1);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  s  =  Math.abs(sum2[i]  *  work2[i],  work1);	  double    s    =    Math.abs(work1[i]    *    work2[i],    sum);    	non-compiled	[CE]  array  required,  but  double  found	67	None	replace
272	[BUG]  [BUGGY]  double  s  =  Math.abs(sum1[i]  *  work2[i],  work1);  [CE]  cannot  find  symbol  sum1  [FE]              AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  s  =  Math.abs(sum1[i]  *  work2[i],  work1);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  s  =  Math.abs(sum1[i]  *  work2[i],  work1);	  double    s    =    Math.abs(work1[i]    *    work2[i],    sum);    	non-compiled	[CE]  cannot  find  symbol  sum1	67	None	replace
273	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.sqrt(diag[i]  /  dxNorm);  [CE]  ']'  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  diagR[pj]  =  Math.sqrt(diag[i]  /  dxNorm);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  diagR[pj]  =  Math.sqrt(diag[i]  /  dxNorm);	  double    diagR[pj]    =    Math.sqrt(diag[i]],    sum);    	non-compiled	[CE]  ']'  expected	26	None	replace
274	[BUG]  [BUGGY]  sum  +=  work2[i][j]  *  diag[i]];  [CE]  ';'  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum  +=  work2[i][j]  *  diag[i]];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	sum  +=  work2[i][j]  *  diag[i]];	  sum    +=    work1[i][j]    *    diag[i]];    	non-compiled	[CE]  ';'  expected	90	None	replace
275	[BUG]  [BUGGY]  sum  +=  work3[i]  *  work2;  [CE]  bad  operand  types  for  binary  operator  '*'  [FE]            AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum  +=  work3[i]  *  work2;  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	sum  +=  work3[i]  *  work2;	  sum    +=    work2[i]    *    work3;    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '*'	46	None	replace
276	[BUG]  [BUGGY]  sum  +=  work3[i]  *  work1[i];  double  work3[i]  *  work1[i];  [CE]  ']'  expected  [FE]    AssertionFailedError    [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum  +=  work3[i]  *  work1[i];  double  work3[i]  *  work1[i];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	sum    +=    work3[i]    *    work1[i];    double  work3[i]  *  work1[i];	  	non-compiled	[CE]  ']'  expected	47	None	add
277	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum  +=  work2[i]  *  work3[j];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	add	sum  +=  work2[i]  *  work3[j];	  sum    +=    work2[i]    *    work3[i];    	compilable	  [FE]  AssertionFailedError  	102	9	replace
278	[BUG]  [BUGGY]  sum  +=  work2[i]  *  work3[j];  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum  +=  work2[i]  *  work3[j];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	sum  +=  work2[i]  *  work3[j];	  sum    +=    work2[i]    *    work3[i];    	compilable	  [FE]  AssertionFailedError  	102	9	replace
279	[BUG]  [BUGGY]  double  diagR[j]  =  Math.abs(work2[i]  *  work1[i]);  [CE]  ']'  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  diagR[j]  =  Math.abs(work2[i]  *  work1[i]);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  diagR[j]  =  Math.abs(work2[i]  *  work1[i]);	  double    diagR[j]    =    Math.abs(work1[i]    *    work2[i]);    	non-compiled	[CE]  ']'  expected	75	None	replace
280	[BUG]  [BUGGY]  double[]  diagR[pj]  =  Math.abs(diagR[i].doubleValue()  +  2);  [CE]  ']'  expected  [FE]              AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double[]  diagR[pj]  =  Math.abs(diagR[i].doubleValue()  +  2);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double[]  diagR[pj]  =  Math.abs(diagR[i].doubleValue()  +  2);	  double[]    diagR[pj]    =    Math.abs(diagR[i].doubleValue());    	non-compiled	[CE]  ']'  expected	19	None	replace
281	[BUG]  [BUGGY]  sum  +=  work3[i]  *  work2[i];  double  work3[i]  *  work2[i];  [CE]  ']'  expected  [FE]    AssertionFailedError    [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum  +=  work3[i]  *  work2[i];  double  work3[i]  *  work2[i];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	sum    +=    work3[i]    *    work2[i];    double  work3[i]  *  work2[i];	  	non-compiled	[CE]  ']'  expected	44	None	add
282	[BUG]  [BUGGY]  double[]  work1[pj]  =  Math.abs(work1[pj].doubleValue()  +  i);  [CE]  ']'  expected  [FE]                AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double[]  work1[pj]  =  Math.abs(work1[pj].doubleValue()  +  i);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double[]  work1[pj]  =  Math.abs(work1[pj].doubleValue()  +  i);	  double[]    work1[pj]    =    Math.abs(work1[pj].doubleValue());    	non-compiled	[CE]  ']'  expected	20	None	replace
283	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.sqrt(work2[i]  *  work3);  [CE]  ']'  expected  [FE]                AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  diagR[pj]  =  Math.sqrt(work2[i]  *  work3);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  diagR[pj]  =  Math.sqrt(work2[i]  *  work3);	  double    diagR[pj]    =    Math.sqrt(work2[i]);    	non-compiled	[CE]  ']'  expected	99	None	replace
284	[BUG]  [BUGGY]  double  s  =  Math.min(sum2,  work1),  work2;  [CE]  no  suitable  method  found  for  min(double,double[])  [FE]                AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  s  =  Math.min(sum2,  work1),  work2;  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  s  =  Math.min(sum2,  work1),  work2;	  double    s    =    Math.min(work1,    work2),    sum;    	non-compiled	[CE]  no  suitable  method  found  for  min(double,double[])	76	None	replace
285	[BUG]  [BUGGY]  double  s  =  Math.min(sum,  work1),  work2.length;  [CE]  ';'  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  s  =  Math.min(sum,  work1),  work2.length;  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  s  =  Math.min(sum,  work1),  work2.length;	  double    s    =    Math.min(work1,    work2),    sum;    	non-compiled	[CE]  ';'  expected	76	None	replace
286	[BUG]  [BUGGY]  sum  +=  work3[i]  *  jacobian[i];  [CE]  bad  operand  types  for  binary  operator  '*'  [FE]              AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum  +=  work3[i]  *  jacobian[i];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	sum  +=  work3[i]  *  jacobian[i];	  sum    +=    work2[i]    *    jacobian[i]];    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '*'	56	None	replace
287	[BUG]  [BUGGY]  double[]  workR[pj]  =  Math.abs(workR[pj].computeMask()  +  i);  [CE]  ']'  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double[]  workR[pj]  =  Math.abs(workR[pj].computeMask()  +  i);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double[]  workR[pj]  =  Math.abs(workR[pj].computeMask()  +  i);	  double[]    workR[pj]    =    Math.abs(workR[pj].computeMask());    	non-compiled	[CE]  ']'  expected	113	None	replace
288	[BUG]  [BUGGY]  sum  +=  work3[i][pj]  *  work1[i];  [CE]  array  required,  but  double  found  [FE]              AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum  +=  work3[i][pj]  *  work1[i];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	sum  +=  work3[i][pj]  *  work1[i];	  sum    +=    work1[i][pj]    *    work3[i]];    	non-compiled	[CE]  array  required,  but  double  found	108	None	replace
289	[BUG]  [BUGGY]  sum  +=  workR[i][pj]  *  diag[i];  [CE]  cannot  find  symbol  workR  [FE]              AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum  +=  workR[i][pj]  *  diag[i];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	sum  +=  workR[i][pj]  *  diag[i];	  sum    +=    work2[i][pj]    *    diag[i];    	non-compiled	[CE]  cannot  find  symbol  workR	36	None	replace
290	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.sqrt(diag[0],  sum);  [CE]  ']'  expected  [FE]            AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  diagR[pj]  =  Math.sqrt(diag[0],  sum);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  diagR[pj]  =  Math.sqrt(diag[0],  sum);	  double    diagR[pj]    =    Math.sqrt(diag[i],    sum);    	non-compiled	[CE]  ']'  expected	51	None	replace
291	[BUG]  [BUGGY]  double  s  =  Math.min(work2,  work2);  [CE]  no  suitable  method  found  for  min(double[],double[])  [FE]                  AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  s  =  Math.min(work2,  work2);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  s  =  Math.min(work2,  work2);	  double    s    =    Math.min(work2,    work1);    	non-compiled	[CE]  no  suitable  method  found  for  min(double[],double[])	77	None	replace
292	[BUG]  [BUGGY]  double  s  =  Math.min(work3,  work1);  [CE]  no  suitable  method  found  for  min(double[],double[])  [FE]                    AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  s  =  Math.min(work3,  work1);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  s  =  Math.min(work3,  work1);	  double    s    =    Math.min(work2,    work1);    	non-compiled	[CE]  no  suitable  method  found  for  min(double[],double[])	77	None	replace
293	[BUG]  [BUGGY]  double[]  work1[pj]  =  Math.abs(work1[i]  *  diagR[i]  +  1);  [CE]  ']'  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double[]  work1[pj]  =  Math.abs(work1[i]  *  diagR[i]  +  1);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double[]  work1[pj]  =  Math.abs(work1[i]  *  diagR[i]  +  1);	  double[]    work1[pj]    =    Math.abs(work2[i]    *    diagR[i]);    	non-compiled	[CE]  ']'  expected	111	None	replace
294	[BUG]  [BUGGY]  sum    +=    work2[i]    *    work1[i];    sum  +=  work2[i]  *  work1[i];  Sum2[i]  *  work2[i];  sum  +=  work2[i]  *  work1[i];  [CE]  not  a  statement  [FE]    AssertionFailedError    [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum    +=    work2[i]    *    work1[i];    sum  +=  work2[i]  *  work1[i];  Sum2[i]  *  work2[i];  sum  +=  work2[i]  *  work1[i];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	sum        +=        work2[i]        *        work1[i];        sum    +=    work2[i]    *    work1[i];    Sum2[i]  *  work2[i];  sum  +=  work2[i]  *  work1[i];	  	non-compiled	[CE]  not  a  statement	12	None	add
295	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum    +=    work2[i]    *    work1[i];    sum  +=  work2[i]  *  work1[i];  sum  -=  work2[i]  *  work1[i];  sum  +=  work2[i]  *  work1[i];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	add	sum        +=        work2[i]        *        work1[i];        sum    +=    work2[i]    *    work1[i];    sum  -=  work2[i]  *  work1[i];  sum  +=  work2[i]  *  work1[i];	  	compilable	  [FE]  AssertionFailedError  	12	5	add
296	[BUG]  [BUGGY]  sum    +=    work2[i]    *    work1[i];    sum  +=  work2[i]  *  work1[i];  sum  -=  work2[i]  *  work1[i];  sum  +=  work2[i]  *  work1[i];  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum    +=    work2[i]    *    work1[i];    sum  +=  work2[i]  *  work1[i];  sum  -=  work2[i]  *  work1[i];  sum  +=  work2[i]  *  work1[i];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	sum        +=        work2[i]        *        work1[i];        sum    +=    work2[i]    *    work1[i];    sum  -=  work2[i]  *  work1[i];  sum  +=  work2[i]  *  work1[i];	  	compilable	  [FE]  AssertionFailedError  	12	5	add
297	[BUG]  [BUGGY]  sum    +=    work2[i]    *    work1[i];    sum  +=  work2[i]  *  work1[i];  Sum2[i]  *  work1[i];  sum  +=  work2[i]  *  work1[i];  [CE]  not  a  statement  [FE]        AssertionFailedError    [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum    +=    work2[i]    *    work1[i];    sum  +=  work2[i]  *  work1[i];  Sum2[i]  *  work1[i];  sum  +=  work2[i]  *  work1[i];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	sum        +=        work2[i]        *        work1[i];        sum    +=    work2[i]    *    work1[i];    Sum2[i]  *  work1[i];  sum  +=  work2[i]  *  work1[i];	  	non-compiled	[CE]  not  a  statement	12	None	add
298	[BUG]  [BUGGY]  sum  +=  work2[i][j]  *  diag[i];  [CE]  array  required,  but  double  found  [FE]              AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum  +=  work2[i][j]  *  diag[i];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	sum  +=  work2[i][j]  *  diag[i];	  sum    +=    work1[i][j]    *    diag[i];    	non-compiled	[CE]  array  required,  but  double  found	109	None	replace
299	[BUG]  [BUGGY]  sum  +=  diag[i][j]  *  work1[i];  [CE]  array  required,  but  double  found  [FE]                AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum  +=  diag[i][j]  *  work1[i];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	sum  +=  diag[i][j]  *  work1[i];	  sum    +=    work1[i][j]    *    diag[i];    	non-compiled	[CE]  array  required,  but  double  found	109	None	replace
300	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.abs(work2[i]  *  work1[i]);  [CE]  ']'  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  diagR[pj]  =  Math.abs(work2[i]  *  work1[i]);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  diagR[pj]  =  Math.abs(work2[i]  *  work1[i]);	  double    diagR[pj]    =    Math.abs(work1[i]    *    work2[i]);    	non-compiled	[CE]  ']'  expected	73	None	replace
301	[BUG]  [BUGGY]  double  s  =  Math.min(work3,  work2),  work3;  [CE]  no  suitable  method  found  for  min(double[],double[])  [FE]                AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  s  =  Math.min(work3,  work2),  work3;  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  s  =  Math.min(work3,  work2),  work3;	  double    s    =    Math.min(work1,    work2),    work3;    	non-compiled	[CE]  no  suitable  method  found  for  min(double[],double[])	106	None	replace
302	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.sqrt(work2[i],  sum);  [CE]  ']'  expected  [FE]              AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  diagR[pj]  =  Math.sqrt(work2[i],  sum);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  diagR[pj]  =  Math.sqrt(work2[i],  sum);	  double    diagR[pj]    =    Math.sqrt(work1[i],    sum);    	non-compiled	[CE]  ']'  expected	52	None	replace
303	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.sqrt(work1[i],  work2);  [CE]  ']'  expected  [FE]                AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  diagR[pj]  =  Math.sqrt(work1[i],  work2);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  diagR[pj]  =  Math.sqrt(work1[i],  work2);	  double    diagR[pj]    =    Math.sqrt(work1[i],    sum);    	non-compiled	[CE]  ']'  expected	52	None	replace
304	[BUG]  [BUGGY]  double  s  =  Math.abs(work1[i]  *  work2[i]  +  1);  double  s  =  Math.abs(work1[i]  *  work2)[i]  +  1);  [CE]  ';'  expected  [FE]    AssertionFailedError    [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  s  =  Math.abs(work1[i]  *  work2[i]  +  1);  double  s  =  Math.abs(work1[i]  *  work2)[i]  +  1);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double    s    =    Math.abs(work1[i]    *    work2[i]    +    1);    double  s  =  Math.abs(work1[i]  *  work2)[i]  +  1);	  	non-compiled	[CE]  ';'  expected	65	None	add
305	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  s  =  Math.abs(work1.length  *  work2[i]);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	add	double  s  =  Math.abs(work1.length  *  work2[i]);	          double    s    =    Math.abs(work1[i]    *    work2[i]);    double    s    =    Math.abs(work1[i]    *    work2[i]);    	compilable	  [FE]  AssertionFailedError  	68	13	replace
306	[BUG]  [BUGGY]  double  s  =  Math.abs(work1.length  *  work2[i]);  [FE]  AssertionFailedError  [FE]        AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  s  =  Math.abs(work1.length  *  work2[i]);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  s  =  Math.abs(work1.length  *  work2[i]);	          double    s    =    Math.abs(work1[i]    *    work2[i]);    double    s    =    Math.abs(work1[i]    *    work2[i]);    	compilable	  [FE]  AssertionFailedError  	68	13	replace
307	[BUG]  [BUGGY]  sum  +=  work1,  work2[i][pj]  *  diag[i]];  [CE]  ';'  expected  [FE]                AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum  +=  work1,  work2[i][pj]  *  diag[i]];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	sum  +=  work1,  work2[i][pj]  *  diag[i]];	  sum    +=    work1,    work1[i][pj]    *    diag[i]];    	non-compiled	[CE]  ';'  expected	40	None	replace
308	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.sqrt(diagR[0]  -  sum);  [CE]  ']'  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  diagR[pj]  =  Math.sqrt(diagR[0]  -  sum);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  diagR[pj]  =  Math.sqrt(diagR[0]  -  sum);	  double    diagR[pj]    =    Math.sqrt(diagR[i]    -    sum);    	non-compiled	[CE]  ']'  expected	83	None	replace
309	[BUG]  [BUGGY]  double[]  work1[pj]  =  Math.abs(diagR[pj].doubleValue()  +  i);  [CE]  ']'  expected  [FE]            AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double[]  work1[pj]  =  Math.abs(diagR[pj].doubleValue()  +  i);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double[]  work1[pj]  =  Math.abs(diagR[pj].doubleValue()  +  i);	  double[]    work1[pj]    =    Math.abs(diagR[pj].doubleValue());    	non-compiled	[CE]  ']'  expected	18	None	replace
310	[BUG]  [BUGGY]  double[]  work1[pj]  =  Math.abs(diagR[pj].doubleValue()  +  1);  [CE]  ']'  expected  [FE]              AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double[]  work1[pj]  =  Math.abs(diagR[pj].doubleValue()  +  1);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double[]  work1[pj]  =  Math.abs(diagR[pj].doubleValue()  +  1);	  double[]    work1[pj]    =    Math.abs(diagR[pj].doubleValue());    	non-compiled	[CE]  ']'  expected	18	None	replace
311	[BUG]  [BUGGY]  double[]  work1[pj]  =  Math.abs(work1.length[pj].doubleValue());  [CE]  ']'  expected  [FE]                AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double[]  work1[pj]  =  Math.abs(work1.length[pj].doubleValue());  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double[]  work1[pj]  =  Math.abs(work1.length[pj].doubleValue());	  double[]    work1[pj]    =    Math.abs(diagR[pj].doubleValue());    	non-compiled	[CE]  ']'  expected	18	None	replace
312	[BUG]  [BUGGY]  double[]  work1[pj]  =  Math.abs(work1[i]  +  diag[i]);  [CE]  ']'  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double[]  work1[pj]  =  Math.abs(work1[i]  +  diag[i]);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double[]  work1[pj]  =  Math.abs(work1[i]  +  diag[i]);	  double[]    work1[pj]    =    Math.abs(work1[i]);    	non-compiled	[CE]  ']'  expected	4	None	replace
313	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.sqrt(work3,  solvedCols[i]]);  [CE]  ']'  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  diagR[pj]  =  Math.sqrt(work3,  solvedCols[i]]);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  diagR[pj]  =  Math.sqrt(work3,  solvedCols[i]]);	  double    diagR[pj]    =    Math.sqrt(work1,    solvedCols[i]]);    	non-compiled	[CE]  ']'  expected	34	None	replace
314	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.sqrt(work2,  solvedCols[i]]);  [CE]  ']'  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  diagR[pj]  =  Math.sqrt(work2,  solvedCols[i]]);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  diagR[pj]  =  Math.sqrt(work2,  solvedCols[i]]);	  double    diagR[pj]    =    Math.sqrt(work1,    solvedCols[i]]);    	non-compiled	[CE]  ']'  expected	34	None	replace
315	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.sqrt(diag[i]  -  sum);  [CE]  ']'  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  diagR[pj]  =  Math.sqrt(diag[i]  -  sum);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  diagR[pj]  =  Math.sqrt(diag[i]  -  sum);	  double    diagR[pj]    =    Math.sqrt(solvedDialog[i]],    sum);    	non-compiled	[CE]  ']'  expected	27	None	replace
316	[BUG]  [BUGGY]  double[]  work1[pj]  =  Math.abs(diagR[pj].computeMask()  -  1);  [CE]  ']'  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double[]  work1[pj]  =  Math.abs(diagR[pj].computeMask()  -  1);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double[]  work1[pj]  =  Math.abs(diagR[pj].computeMask()  -  1);	  double[]    work1[pj]    =    Math.abs(diagR[pj].computeMask());    	non-compiled	[CE]  ']'  expected	1	None	replace
317	[BUG]  [BUGGY]  sum2  +=  work1[i]  *  work2[i];  double  sum2  +=  work1[i]  *  work2[i];  [CE]  ';'  expected  [FE]    AssertionFailedError    [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum2  +=  work1[i]  *  work2[i];  double  sum2  +=  work1[i]  *  work2[i];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	sum2    +=    work1[i]    *    work2[i];    double  sum2  +=  work1[i]  *  work2[i];	  	non-compiled	[CE]  ';'  expected	94	None	add
318	[BUG]  [BUGGY]  double[]  work2[pj]  =  Math.abs(work2[pj]);  [CE]  ']'  expected  [FE]                          AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double[]  work2[pj]  =  Math.abs(work2[pj]);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double[]  work2[pj]  =  Math.abs(work2[pj]);	  double[]    work2[pj]    =    Math.abs(diagR[pj]);    	non-compiled	[CE]  ']'  expected	62	None	replace
319	[BUG]  [BUGGY]  sum  +=  work3[i][pj]  *  work2[i];  [CE]  array  required,  but  double  found  [FE]            AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum  +=  work3[i][pj]  *  work2[i];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	sum  +=  work3[i][pj]  *  work2[i];	  sum    +=    work1[i][pj]    *    work2[i]];    	non-compiled	[CE]  array  required,  but  double  found	29	None	replace
320	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  s  =  Math.abs(work1[i]  *  work2[i]  /  sum);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	add	double  s  =  Math.abs(work1[i]  *  work2[i]  /  sum);	  double    s    =    Math.abs(work1[i]    *    work2[i]    +    sum);    	compilable	  [FE]  AssertionFailedError  	64	13	replace
321	[BUG]  [BUGGY]  double  s  =  Math.abs(work1[i]  *  work2[i]  /  sum);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  s  =  Math.abs(work1[i]  *  work2[i]  /  sum);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  s  =  Math.abs(work1[i]  *  work2[i]  /  sum);	  double    s    =    Math.abs(work1[i]    *    work2[i]    +    sum);    	compilable	  [FE]  AssertionFailedError  	64	13	replace
322	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.sqrt(diagR[0]);  [CE]  ']'  expected  [FE]              AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  diagR[pj]  =  Math.sqrt(diagR[0]);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  diagR[pj]  =  Math.sqrt(diagR[0]);	  double    diagR[pj]    =    Math.sqrt(diagR[i]);    	non-compiled	[CE]  ']'  expected	98	None	replace
323	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.sqrt(diagR[i]  +  work3);  [CE]  ']'  expected  [FE]                AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  diagR[pj]  =  Math.sqrt(diagR[i]  +  work3);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  diagR[pj]  =  Math.sqrt(diagR[i]  +  work3);	  double    diagR[pj]    =    Math.sqrt(diagR[i]);    	non-compiled	[CE]  ']'  expected	98	None	replace
324	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.sqrt(diagR[0],  sum);  [CE]  ']'  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  diagR[pj]  =  Math.sqrt(diagR[0],  sum);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  diagR[pj]  =  Math.sqrt(diagR[0],  sum);	  double    diagR[pj]    =    Math.sqrt(diagR[i],    sum);    	non-compiled	[CE]  ']'  expected	54	None	replace
325	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.sqrt(diagR[i],  diagR[i]);  [CE]  ']'  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  diagR[pj]  =  Math.sqrt(diagR[i],  diagR[i]);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  diagR[pj]  =  Math.sqrt(diagR[i],  diagR[i]);	  double    diagR[pj]    =    Math.sqrt(diagR[i],    sum);    	non-compiled	[CE]  ']'  expected	54	None	replace
326	[BUG]  [BUGGY]  double[]  diagR[pj]  =  Math.abs(diagR[i].computeJava2D());  [CE]  ']'  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double[]  diagR[pj]  =  Math.abs(diagR[i].computeJava2D());  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double[]  diagR[pj]  =  Math.abs(diagR[i].computeJava2D());	  double[]    diagR[pj]    =    Math.abs(diagR[i].computeMask());    	non-compiled	[CE]  ']'  expected	2	None	replace
327	[BUG]  [BUGGY]  double[]  work1[pj]  =  Math.abs(work1[i]  *  diag[i]);  [CE]  ']'  expected  [FE]                AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double[]  work1[pj]  =  Math.abs(work1[i]  *  diag[i]);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double[]  work1[pj]  =  Math.abs(work1[i]  *  diag[i]);	  double[]    work1[pj]    =    Math.abs(work1[i]    *    dxNorm);    	non-compiled	[CE]  ']'  expected	8	None	replace
328	[BUG]  [BUGGY]  sum  +=  workR[i][pj]  *  diag[i]];  [CE]  ';'  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum  +=  workR[i][pj]  *  diag[i]];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	sum  +=  workR[i][pj]  *  diag[i]];	  sum    +=    work3[i][pj]    *    diag[i]];    	non-compiled	[CE]  ';'  expected	58	None	replace
329	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]                AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum  +=  work3[i]  *  diag[i];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	add	sum  +=  work3[i]  *  diag[i];	  sum    +=    work2[i]    *    diag[i]];    	compilable	  [FE]  AssertionFailedError  	57	7	replace
330	[BUG]  [BUGGY]  sum  +=  work3[i]  *  diag[i];  [FE]  AssertionFailedError  [FE]                AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum  +=  work3[i]  *  diag[i];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	sum  +=  work3[i]  *  diag[i];	  sum    +=    work2[i]    *    diag[i]];    	compilable	  [FE]  AssertionFailedError  	57	7	replace
331	[BUG]  [BUGGY]  sum  +=  work3[i][pj]  *  diag[i]  /  dxNorm;  [CE]  array  required,  but  double  found  [FE]                AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum  +=  work3[i][pj]  *  diag[i]  /  dxNorm;  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	sum  +=  work3[i][pj]  *  diag[i]  /  dxNorm;	  sum    +=    work1[i][pj]    *    diag[i]    /    dxNorm;    	non-compiled	[CE]  array  required,  but  double  found	105	None	replace
332	[BUG]  [BUGGY]  sum  +=  workR[i][pj]  *  diag[i]  /  dxNorm;  [CE]  cannot  find  symbol  workR  [FE]                  AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum  +=  workR[i][pj]  *  diag[i]  /  dxNorm;  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	sum  +=  workR[i][pj]  *  diag[i]  /  dxNorm;	  sum    +=    work1[i][pj]    *    diag[i]    /    dxNorm;    	non-compiled	[CE]  cannot  find  symbol  workR	105	None	replace
333	[BUG]  [BUGGY]  sum  +=  work3[i][pj]  *  jacobian[permutation[i]];  [CE]  array  required,  but  double  found  [FE]              AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum  +=  work3[i][pj]  *  jacobian[permutation[i]];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	sum  +=  work3[i][pj]  *  jacobian[permutation[i]];	  sum    +=    work2[i][pj]    *    jacobian[permutation[i]];    	non-compiled	[CE]  array  required,  but  double  found	39	None	replace
334	[BUG]  [BUGGY]  double[]  work2[pj]  =  Math.abs(work3[pj].doubleValue());  [CE]  ']'  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double[]  work2[pj]  =  Math.abs(work3[pj].doubleValue());  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double[]  work2[pj]  =  Math.abs(work3[pj].doubleValue());	  double[]    work2[pj]    =    Math.abs(diagR[pj].doubleValue());    	non-compiled	[CE]  ']'  expected	21	None	replace
335	[BUG]  [BUGGY]  double[]  work2[pj]  =  Math.abs(diagR[pj].doubleValue()  +  i);  [CE]  ']'  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double[]  work2[pj]  =  Math.abs(diagR[pj].doubleValue()  +  i);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double[]  work2[pj]  =  Math.abs(diagR[pj].doubleValue()  +  i);	  double[]    work2[pj]    =    Math.abs(diagR[pj].doubleValue());    	non-compiled	[CE]  ']'  expected	21	None	replace
336	[BUG]  [BUGGY]  sum  +=  work1,  work1[i][pj]  *  diag[i];  [CE]  ';'  expected  [FE]              AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum  +=  work1,  work1[i][pj]  *  diag[i];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	sum  +=  work1,  work1[i][pj]  *  diag[i];	  sum    +=    diag[i][pj]    *    work1[i];    	non-compiled	[CE]  ';'  expected	87	None	replace
337	[BUG]  [BUGGY]  sum  +=  work[i][pj]  *  diagR[i];  [CE]  cannot  find  symbol  work  [FE]                AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum  +=  work[i][pj]  *  diagR[i];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	sum  +=  work[i][pj]  *  diagR[i];	  sum    +=    diag[i][pj]    *    work1[i];    	non-compiled	[CE]  cannot  find  symbol  work	87	None	replace
338	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.sqrt(work2[i]],  sum);  [CE]  ']'  expected  [FE]                AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  diagR[pj]  =  Math.sqrt(work2[i]],  sum);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  diagR[pj]  =  Math.sqrt(work2[i]],  sum);	  double    diagR[pj]    =    Math.sqrt(work1[i]],    sum);    	non-compiled	[CE]  ']'  expected	25	None	replace
339	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.sqrt(work1[i]  /  dxNorm);  [CE]  ']'  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  diagR[pj]  =  Math.sqrt(work1[i]  /  dxNorm);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  diagR[pj]  =  Math.sqrt(work1[i]  /  dxNorm);	  double    diagR[pj]    =    Math.sqrt(work1[i]],    sum);    	non-compiled	[CE]  ']'  expected	25	None	replace
340	[BUG]  [BUGGY]  sum  +=  work1[i]  *  work2[i];  double  work1[i]  *  work2[i];  [CE]  ']'  expected  [FE]    AssertionFailedError    [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum  +=  work1[i]  *  work2[i];  double  work1[i]  *  work2[i];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	sum    +=    work1[i]    *    work2[i];    double  work1[i]  *  work2[i];	  	non-compiled	[CE]  ']'  expected	42	None	add
341	[BUG]  [BUGGY]  double[]  diagR[pj]  =  Math.abs(work2[pj]);  [CE]  ']'  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double[]  diagR[pj]  =  Math.abs(work2[pj]);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double[]  diagR[pj]  =  Math.abs(work2[pj]);	  double[]    diagR[pj]    =    Math.abs(work1[pj]);    	non-compiled	[CE]  ']'  expected	61	None	replace
342	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.abs(work1.work2[pj]  *  work2[i]);  [CE]  ']'  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  diagR[pj]  =  Math.abs(work1.work2[pj]  *  work2[i]);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  diagR[pj]  =  Math.abs(work1.work2[pj]  *  work2[i]);	  double    diagR[pj]    =    Math.abs(work2[pj]    *    work1[i]);    	non-compiled	[CE]  ']'  expected	85	None	replace
343	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.abs(work3[pj]  *  work1[i]);  [CE]  ']'  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  diagR[pj]  =  Math.abs(work3[pj]  *  work1[i]);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  diagR[pj]  =  Math.abs(work3[pj]  *  work1[i]);	  double    diagR[pj]    =    Math.abs(work2[pj]    *    work1[i]);    	non-compiled	[CE]  ']'  expected	85	None	replace
344	[BUG]  [BUGGY]  double[]  work2[pj]  =  Math.abs(work3[i]  /  dxNorm);  [CE]  ']'  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double[]  work2[pj]  =  Math.abs(work3[i]  /  dxNorm);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double[]  work2[pj]  =  Math.abs(work3[i]  /  dxNorm);	  double[]    work2[pj]    =    Math.abs(work1[i]    /    dxNorm);    	non-compiled	[CE]  ']'  expected	11	None	replace
345	[BUG]  [BUGGY]  double[]  work2[pj]  =  Math.abs(work1[0]  /  dxNorm);  [CE]  ']'  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double[]  work2[pj]  =  Math.abs(work1[0]  /  dxNorm);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double[]  work2[pj]  =  Math.abs(work1[0]  /  dxNorm);	  double[]    work2[pj]    =    Math.abs(work1[i]    /    dxNorm);    	non-compiled	[CE]  ']'  expected	11	None	replace
346	[BUG]  [BUGGY]  double[]  workR[pj]  =  Math.abs(workR[0]);  [CE]  ']'  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double[]  workR[pj]  =  Math.abs(workR[0]);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double[]  workR[pj]  =  Math.abs(workR[0]);	  double[]    workR[pj]    =    Math.abs(workR[pj]);    	non-compiled	[CE]  ']'  expected	112	None	replace
347	[BUG]  [BUGGY]  double[]  work1[pj]  =  Math.abs(work2[i]  *  diag[i]);  [CE]  ']'  expected  [FE]              AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double[]  work1[pj]  =  Math.abs(work2[i]  *  diag[i]);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double[]  work1[pj]  =  Math.abs(work2[i]  *  diag[i]);	  double[]    work1[pj]    =    Math.abs(work2[i]    *    dxNorm);    	non-compiled	[CE]  ']'  expected	41	None	replace
348	[BUG]  [BUGGY]  double[]  work1[pj]  =  Math.abs(work1[i]  *  work2[i]];  [CE]  ']'  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double[]  work1[pj]  =  Math.abs(work1[i]  *  work2[i]];  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double[]  work1[pj]  =  Math.abs(work1[i]  *  work2[i]];	  double[]    work1[pj]    =    Math.abs(work2[i]    *    work3);    	non-compiled	[CE]  ']'  expected	110	None	replace
349	[BUG]  [BUGGY]  double[]  work2[pj]  =  Math.abs(work1[i]  *  work3);  [CE]  ']'  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double[]  work2[pj]  =  Math.abs(work1[i]  *  work3);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double[]  work2[pj]  =  Math.abs(work1[i]  *  work3);	  double[]    work1[pj]    =    Math.abs(work2[i]    *    work3);    	non-compiled	[CE]  ']'  expected	110	None	replace
350	[BUG]  [BUGGY]  double[]  diagR[pj]  =  Math.abs(diagR[pj].doubleValue()).doubleValue();  [CE]  ']'  expected  [FE]            AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double[]  diagR[pj]  =  Math.abs(diagR[pj].doubleValue()).doubleValue();  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double[]  diagR[pj]  =  Math.abs(diagR[pj].doubleValue()).doubleValue();	  double[]    diagR[pj]    =    Math.abs(diagR[pj].doubleValue()    +    1);    	non-compiled	[CE]  ']'  expected	91	None	replace
351	[BUG]  [BUGGY]  double[]  workR[pj]  =  Math.abs(diagR[pj].doubleValue());  [CE]  ']'  expected  [FE]              AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double[]  workR[pj]  =  Math.abs(diagR[pj].doubleValue());  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double[]  workR[pj]  =  Math.abs(diagR[pj].doubleValue());	  double[]    diagR[pj]    =    Math.abs(diagR[pj].doubleValue()    +    1);    	non-compiled	[CE]  ']'  expected	91	None	replace
352	[BUG]  [BUGGY]  sum  +=  work[i][0]  *  diag[i]];  [CE]  ';'  expected  [FE]              AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum  +=  work[i][0]  *  diag[i]];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	sum  +=  work[i][0]  *  diag[i]];	  sum    +=    work[i][pj]    *    diag[i]];    	non-compiled	[CE]  ';'  expected	104	None	replace
353	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  s  =  Math.abs(work1[i]  *  work2[i]  +  0);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	add	double  s  =  Math.abs(work1[i]  *  work2[i]  +  0);	  double    s    =    Math.abs(work1[i]    *    work2[i]    +    1);    	compilable	  [FE]  AssertionFailedError  	66	13	replace
354	[BUG]  [BUGGY]  double  s  =  Math.abs(work1[i]  *  work2[i]  +  0);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  s  =  Math.abs(work1[i]  *  work2[i]  +  0);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  s  =  Math.abs(work1[i]  *  work2[i]  +  0);	  double    s    =    Math.abs(work1[i]    *    work2[i]    +    1);    	compilable	  [FE]  AssertionFailedError  	66	13	replace
355	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  s  =  Math.abs(work1[i]  *  work2[i]  +  1.0);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	add	double  s  =  Math.abs(work1[i]  *  work2[i]  +  1.0);	  double    s    =    Math.abs(work1[i]    *    work2[i]    +    1);    	compilable	  [FE]  AssertionFailedError  	66	13	replace
356	[BUG]  [BUGGY]  double  s  =  Math.abs(work1[i]  *  work2[i]  +  1.0);  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  s  =  Math.abs(work1[i]  *  work2[i]  +  1.0);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  s  =  Math.abs(work1[i]  *  work2[i]  +  1.0);	  double    s    =    Math.abs(work1[i]    *    work2[i]    +    1);    	compilable	  [FE]  AssertionFailedError  	66	13	replace
357	[BUG]  [BUGGY]  Double[]  diagR[pj]  =  Math.abs(diagR[pj].computeMask());  [CE]  ']'  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  Double[]  diagR[pj]  =  Math.abs(diagR[pj].computeMask());  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	Double[]  diagR[pj]  =  Math.abs(diagR[pj].computeMask());	  double[]    diagR[pj]    =    Math.abs(diagR[pj].computeMask()    +    1);    	non-compiled	[CE]  ']'  expected	3	None	replace
358	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.sqrt(work2.length[i]]);  [CE]  ']'  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  diagR[pj]  =  Math.sqrt(work2.length[i]]);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  diagR[pj]  =  Math.sqrt(work2.length[i]]);	  double    diagR[pj]    =    Math.sqrt(work1.length[i]]);    	non-compiled	[CE]  ']'  expected	35	None	replace
359	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.sqrt(work1.length,  work2[i]]);  [CE]  ']'  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  diagR[pj]  =  Math.sqrt(work1.length,  work2[i]]);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  diagR[pj]  =  Math.sqrt(work1.length,  work2[i]]);	  double    diagR[pj]    =    Math.sqrt(work1.length[i]]);    	non-compiled	[CE]  ']'  expected	35	None	replace
360	[BUG]  [BUGGY]  double[]  work2[pj]  =  Math.abs(work2[i]  *  diag[i]);  [CE]  ']'  expected  [FE]              AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double[]  work2[pj]  =  Math.abs(work2[i]  *  diag[i]);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double[]  work2[pj]  =  Math.abs(work2[i]  *  diag[i]);	  double[]    work2[pj]    =    Math.abs(work2[i]    *    dxNorm);    	non-compiled	[CE]  ']'  expected	79	None	replace
361	[BUG]  [BUGGY]  double[]  work2[pj]  =  Math.abs(work2[i]  *  sum);  [CE]  ']'  expected  [FE]                AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double[]  work2[pj]  =  Math.abs(work2[i]  *  sum);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double[]  work2[pj]  =  Math.abs(work2[i]  *  sum);	  double[]    work2[pj]    =    Math.abs(work2[i]    *    dxNorm);    	non-compiled	[CE]  ']'  expected	79	None	replace
362	[BUG]  [BUGGY]  double[]  work2[pj]  =  Math.abs(work1[i]  *  diag[i]);  [CE]  ']'  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double[]  work2[pj]  =  Math.abs(work1[i]  *  diag[i]);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double[]  work2[pj]  =  Math.abs(work1[i]  *  diag[i]);	  double[]    work2[pj]    =    Math.abs(work2[i]    *    dxNorm);    	non-compiled	[CE]  ']'  expected	79	None	replace
363	[BUG]  [BUGGY]  double[]  work2[pj]  =  Math.abs(work2[i]);  [CE]  ']'  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double[]  work2[pj]  =  Math.abs(work2[i]);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double[]  work2[pj]  =  Math.abs(work2[i]);	  double[]    work2[pj]    =    Math.abs(work1[i]);    	non-compiled	[CE]  ']'  expected	5	None	replace
364	[BUG]  [BUGGY]  double[]  work2[pj]  =  Math.abs(work2[i]  +  diagR[i]);  [CE]  ']'  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double[]  work2[pj]  =  Math.abs(work2[i]  +  diagR[i]);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double[]  work2[pj]  =  Math.abs(work2[i]  +  diagR[i]);	  double[]    work2[pj]    =    Math.abs(work1[i]);    	non-compiled	[CE]  ']'  expected	5	None	replace
365	[BUG]  [BUGGY]  sum  +=  work2[i]  *  work3[i];  double  work2[i]  *  work3[i];  [CE]  ']'  expected  [FE]    AssertionFailedError    [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum  +=  work2[i]  *  work3[i];  double  work2[i]  *  work3[i];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	sum    +=    work2[i]    *    work3[i];    double  work2[i]  *  work3[i];	  	non-compiled	[CE]  ']'  expected	101	None	add
366	[BUG]  [BUGGY]  Sum  +=  work2[i]  *  work3[i];  [CE]  cannot  find  symbol  Sum  [FE]          AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  Sum  +=  work2[i]  *  work3[i];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	Sum  +=  work2[i]  *  work3[i];	  sum    +=    work2[i]    *    work1[i];    Sum    +=    work2[i]    *    work1[i];    	non-compiled	[CE]  cannot  find  symbol  Sum	14	None	replace
367	[BUG]  [BUGGY]  double  s  =  Math.min(sum,  work2),  work1);  [CE]  ';'  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  s  =  Math.min(sum,  work2),  work1);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  s  =  Math.min(sum,  work2),  work1);	  double    s    =    Math.min(work1,    work2),    sum);    	non-compiled	[CE]  ';'  expected	78	None	replace
368	[BUG]  [BUGGY]  double  s  =  Math.min(work2,  work3),  sum);  [CE]  ';'  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  s  =  Math.min(work2,  work3),  sum);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  s  =  Math.min(work2,  work3),  sum);	  double    s    =    Math.min(work1,    work2),    sum);    	non-compiled	[CE]  ';'  expected	78	None	replace
369	[BUG]  [BUGGY]  double  work2[pj]  =  Math.abs(work1[i]  *  work2[i]);  [CE]  ']'  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  work2[pj]  =  Math.abs(work1[i]  *  work2[i]);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  work2[pj]  =  Math.abs(work1[i]  *  work2[i]);	  double    diagR[pj]    =    Math.abs(work1[i]    *    work2[i]);    	non-compiled	[CE]  ']'  expected	73	None	replace
370	[BUG]  [BUGGY]  double[]  workR[pj]  =  Math.abs(workR[i].computeMask());  [CE]  ']'  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double[]  workR[pj]  =  Math.abs(workR[i].computeMask());  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double[]  workR[pj]  =  Math.abs(workR[i].computeMask());	  double[]    workR[pj]    =    Math.abs(workR[pj].computeMask());    	non-compiled	[CE]  ']'  expected	113	None	replace
371	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.sqrt(diag[i],  sum2);  [CE]  ']'  expected  [FE]            AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  diagR[pj]  =  Math.sqrt(diag[i],  sum2);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  diagR[pj]  =  Math.sqrt(diag[i],  sum2);	  double    diagR[pj]    =    Math.sqrt(solvedDialog[i],    sum);    	non-compiled	[CE]  ']'  expected	88	None	replace
372	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum  +=  work3[i]  *  work2[i];  double  s  =  work3[i]  *  work2[i];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	add	sum    +=    work3[i]    *    work2[i];    double  s  =  work3[i]  *  work2[i];	  	compilable	  [FE]  AssertionFailedError  	44	6	add
373	[BUG]  [BUGGY]  sum  +=  work3[i]  *  work2[i];  double  s  =  work3[i]  *  work2[i];  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum  +=  work3[i]  *  work2[i];  double  s  =  work3[i]  *  work2[i];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	sum    +=    work3[i]    *    work2[i];    double  s  =  work3[i]  *  work2[i];	  	compilable	  [FE]  AssertionFailedError  	44	6	add
374	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.sqrt(work1[i]  *  work2[i]],  sum);  [CE]  ']'  expected  [FE]                AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  diagR[pj]  =  Math.sqrt(work1[i]  *  work2[i]],  sum);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  diagR[pj]  =  Math.sqrt(work1[i]  *  work2[i]],  sum);	  double    diagR[pj]    =    Math.sqrt(work1[i]],    sum);    	non-compiled	[CE]  ']'  expected	25	None	replace
375	[BUG]  [BUGGY]  double[]  work1[pj]  =  Math.abs(work1[i]  *  work2[i]);  [CE]  ']'  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double[]  work1[pj]  =  Math.abs(work1[i]  *  work2[i]);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double[]  work1[pj]  =  Math.abs(work1[i]  *  work2[i]);	  double[]    work1[pj]    =    Math.abs(work2[i]    *    work3);    	non-compiled	[CE]  ']'  expected	110	None	replace
376	[BUG]  [BUGGY]  double[]  work1[pj]  =  Math.abs(work1[i]  /  work3);  [CE]  ']'  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double[]  work1[pj]  =  Math.abs(work1[i]  /  work3);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double[]  work1[pj]  =  Math.abs(work1[i]  /  work3);	  double[]    work1[pj]    =    Math.abs(work2[i]    *    work3);    	non-compiled	[CE]  ']'  expected	110	None	replace
377	[BUG]  [BUGGY]  double  s  =  Math.min(work1,  work2),  work3,  work2;  [CE]  no  suitable  method  found  for  min(double[],double[])  [FE]                AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  s  =  Math.min(work1,  work2),  work3,  work2;  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  s  =  Math.min(work1,  work2),  work3,  work2;	  double    s    =    Math.min(work1,    work2),    work3;    	non-compiled	[CE]  no  suitable  method  found  for  min(double[],double[])	106	None	replace
378	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.sqrt(diagR[i]  /  1,  sum);  [CE]  ']'  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  diagR[pj]  =  Math.sqrt(diagR[i]  /  1,  sum);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  diagR[pj]  =  Math.sqrt(diagR[i]  /  1,  sum);	  double    diagR[pj]    =    Math.sqrt(solvedCols[i]    -    1,    sum);    	non-compiled	[CE]  ']'  expected	28	None	replace
379	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.sqrt(work1[pj]  -  1,  sum);  [CE]  ']'  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  diagR[pj]  =  Math.sqrt(work1[pj]  -  1,  sum);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  diagR[pj]  =  Math.sqrt(work1[pj]  -  1,  sum);	  double    diagR[pj]    =    Math.sqrt(solvedCols[i]    -    1,    sum);    	non-compiled	[CE]  ']'  expected	28	None	replace
380	[BUG]  [BUGGY]  double  s  =  Math.abs(work1[i]  *  work2[i]  +  sum);  double  s  =  Math.abs(work2[i]  *  work2[i]  +  sum);  [CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]    AssertionFailedError    [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  s  =  Math.abs(work1[i]  *  work2[i]  +  sum);  double  s  =  Math.abs(work2[i]  *  work2[i]  +  sum);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double    s    =    Math.abs(work1[i]    *    work2[i]    +    sum);    double  s  =  Math.abs(work2[i]  *  work2[i]  +  sum);	  	non-compiled	[CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	63	None	add
381	[BUG]  [BUGGY]  double  s  =  Math.abs(work1[i]  *  work2[i],  sum  +=  jacobian[i][pj]  *  work1[i]];  [CE]  ')'  expected  [FE]            AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  s  =  Math.abs(work1[i]  *  work2[i],  sum  +=  jacobian[i][pj]  *  work1[i]];  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  s  =  Math.abs(work1[i]  *  work2[i],  sum  +=  jacobian[i][pj]  *  work1[i]];	  double    s    =    Math.abs(work1[i]    *    work2[i],    sum);    	non-compiled	[CE]  ')'  expected	67	None	replace
382	[BUG]  [BUGGY]  double  s  =  Math.abs(work1[i]  *  work2[i],  sum  +=  jacobian[i][pj]);  [CE]  no  suitable  method  found  for  abs(double,double)  [FE]              AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  s  =  Math.abs(work1[i]  *  work2[i],  sum  +=  jacobian[i][pj]);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  s  =  Math.abs(work1[i]  *  work2[i],  sum  +=  jacobian[i][pj]);	  double    s    =    Math.abs(work1[i]    *    work2[i],    sum);    	non-compiled	[CE]  no  suitable  method  found  for  abs(double,double)	67	None	replace
383	[BUG]  [BUGGY]  double[]  diagnosticR[pj]  =  Math.abs(diagR[pj].computeMask());  [CE]  ']'  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double[]  diagnosticR[pj]  =  Math.abs(diagR[pj].computeMask());  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double[]  diagnosticR[pj]  =  Math.abs(diagR[pj].computeMask());	  double[]    diagR[pj]    =    Math.abs(diagR[pj].computeMask()    +    1);    	non-compiled	[CE]  ']'  expected	3	None	replace
384	[BUG]  [BUGGY]  double[]  workR[pj]  =  Math.abs(diagR[pj].computeMask());  [CE]  ']'  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double[]  workR[pj]  =  Math.abs(diagR[pj].computeMask());  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double[]  workR[pj]  =  Math.abs(diagR[pj].computeMask());	  double[]    diagR[pj]    =    Math.abs(diagR[pj].computeMask()    +    1);    	non-compiled	[CE]  ']'  expected	3	None	replace
385	[BUG]  [BUGGY]  sum  +=  work1,  work[i][pj]  *  diag[i];  [CE]  ';'  expected  [FE]              AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum  +=  work1,  work[i][pj]  *  diag[i];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	sum  +=  work1,  work[i][pj]  *  diag[i];	  sum    +=    diag[i][pj]    *    work1[i];    	non-compiled	[CE]  ';'  expected	87	None	replace
386	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]                AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum  +=  work2[pj]  *  diag[i];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	add	sum  +=  work2[pj]  *  diag[i];	  sum    +=    diag[i][pj]    *    work1[i];    	compilable	  [FE]  AssertionFailedError  	87	8	replace
387	[BUG]  [BUGGY]  sum  +=  work2[pj]  *  diag[i];  [FE]  AssertionFailedError  [FE]                AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum  +=  work2[pj]  *  diag[i];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	sum  +=  work2[pj]  *  diag[i];	  sum    +=    diag[i][pj]    *    work1[i];    	compilable	  [FE]  AssertionFailedError  	87	8	replace
388	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.sqrt(work1.length,  work2.length);  [CE]  ']'  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  diagR[pj]  =  Math.sqrt(work1.length,  work2.length);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  diagR[pj]  =  Math.sqrt(work1.length,  work2.length);	  double    diagR[pj]    =    Math.sqrt(work1.length[i]]);    	non-compiled	[CE]  ']'  expected	35	None	replace
389	[BUG]  [BUGGY]  sum  +=  work1[i][j]  *  diag[i]  /  dxNorm;  [CE]  array  required,  but  double  found  [FE]                  AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum  +=  work1[i][j]  *  diag[i]  /  dxNorm;  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	sum  +=  work1[i][j]  *  diag[i]  /  dxNorm;	  sum    +=    work1[i][j]    *    diag[i]];    	non-compiled	[CE]  array  required,  but  double  found	90	None	replace
390	[BUG]  [BUGGY]  double[]  diagnosticR[pj]  =  Math.abs(diagR[pj].doubleValue());  [CE]  ']'  expected  [FE]            AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double[]  diagnosticR[pj]  =  Math.abs(diagR[pj].doubleValue());  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double[]  diagnosticR[pj]  =  Math.abs(diagR[pj].doubleValue());	  double[]    diagR[pj]    =    Math.abs(diagR[pj].doubleValue()    +    1);    	non-compiled	[CE]  ']'  expected	91	None	replace
391	[BUG]  [BUGGY]  double  s  =  Math.abs(work2[i]  *  work1[i]);  double  s  =  Math.abs(work2[i]  *  work3[i]);  [CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]    AssertionFailedError    [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  s  =  Math.abs(work2[i]  *  work1[i]);  double  s  =  Math.abs(work2[i]  *  work3[i]);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double    s    =    Math.abs(work2[i]    *    work1[i]);    double  s  =  Math.abs(work2[i]  *  work3[i]);	  	non-compiled	[CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	92	None	add
392	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.sqrt(work1,  work2,  work3[i]]);  [CE]  ']'  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  diagR[pj]  =  Math.sqrt(work1,  work2,  work3[i]]);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  diagR[pj]  =  Math.sqrt(work1,  work2,  work3[i]]);	  double    diagR[pj]    =    Math.sqrt(work1,    solvedCols[i]]);    	non-compiled	[CE]  ']'  expected	34	None	replace
393	[BUG]  [BUGGY]  sum  +=  work1[i][j]  *  work3[i]];  [CE]  ';'  expected  [FE]              AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum  +=  work1[i][j]  *  work3[i]];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	sum  +=  work1[i][j]  *  work3[i]];	  sum    +=    work1[i][pj]    *    work3[i]];    	non-compiled	[CE]  ';'  expected	108	None	replace
394	[BUG]  [BUGGY]  double[]  work1[pj]  =  Math.abs(work1[i]  /  sum);  [CE]  ']'  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double[]  work1[pj]  =  Math.abs(work1[i]  /  sum);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double[]  work1[pj]  =  Math.abs(work1[i]  /  sum);	  double[]    work1[pj]    =    Math.abs(work2[i]    *    sum);    	non-compiled	[CE]  ']'  expected	6	None	replace
395	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum  +=  work1[i]  *  work2[i];  double  s  =  work1[i]  *  work2[i];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	add	sum    +=    work1[i]    *    work2[i];    double  s  =  work1[i]  *  work2[i];	  	compilable	  [FE]  AssertionFailedError  	42	6	add
396	[BUG]  [BUGGY]  sum  +=  work1[i]  *  work2[i];  double  s  =  work1[i]  *  work2[i];  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum  +=  work1[i]  *  work2[i];  double  s  =  work1[i]  *  work2[i];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	sum    +=    work1[i]    *    work2[i];    double  s  =  work1[i]  *  work2[i];	  	compilable	  [FE]  AssertionFailedError  	42	6	add
397	[BUG]  [BUGGY]  sum  +=  work1[i][j]  *  diagR[i]];  [CE]  ';'  expected  [FE]                AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum  +=  work1[i][j]  *  diagR[i]];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	sum  +=  work1[i][j]  *  diagR[i]];	  sum    +=    work1[i][pj]    *    diagR[i]];    	non-compiled	[CE]  ';'  expected	31	None	replace
398	[BUG]  [BUGGY]  sum  +=  work[i][pj]  *  diagR[pj];  [CE]  cannot  find  symbol  work  [FE]              AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum  +=  work[i][pj]  *  diagR[pj];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	sum  +=  work[i][pj]  *  diagR[pj];	  sum    +=    work1[i][pj]    *    diagR[pj];    	non-compiled	[CE]  cannot  find  symbol  work	80	None	replace
399	[BUG]  [BUGGY]  double[]  work2[pj]  =  Math.abs(work2[i]  *  diagR[i]);  [CE]  ']'  expected  [FE]              AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double[]  work2[pj]  =  Math.abs(work2[i]  *  diagR[i]);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double[]  work2[pj]  =  Math.abs(work2[i]  *  diagR[i]);	  double[]    work2[pj]    =    Math.abs(work2[i]    *    dxNorm);    	non-compiled	[CE]  ']'  expected	79	None	replace
400	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  s  =  Math.abs(work1[i]  *  work2[i]  +  j);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	add	double  s  =  Math.abs(work1[i]  *  work2[i]  +  j);	  double    s    =    Math.abs(work1[i]    *    work2[i]    +    1);    	compilable	  [FE]  AssertionFailedError  	66	13	replace
401	[BUG]  [BUGGY]  double  s  =  Math.abs(work1[i]  *  work2[i]  +  j);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  s  =  Math.abs(work1[i]  *  work2[i]  +  j);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  s  =  Math.abs(work1[i]  *  work2[i]  +  j);	  double    s    =    Math.abs(work1[i]    *    work2[i]    +    1);    	compilable	  [FE]  AssertionFailedError  	66	13	replace
402	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum2  +=  work1[i]  *  work2[i];  sum2  -=  work1[i]  *  work2[i];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	add	sum2    +=    work1[i]    *    work2[i];    sum2  -=  work1[i]  *  work2[i];	  	compilable	  [FE]  AssertionFailedError  	94	2	add
403	[BUG]  [BUGGY]  sum2  +=  work1[i]  *  work2[i];  sum2  -=  work1[i]  *  work2[i];  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum2  +=  work1[i]  *  work2[i];  sum2  -=  work1[i]  *  work2[i];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	sum2    +=    work1[i]    *    work2[i];    sum2  -=  work1[i]  *  work2[i];	  	compilable	  [FE]  AssertionFailedError  	94	2	add
404	[BUG]  [BUGGY]  sum2  +=  work1[i]  *  work2[i];  double  pj  =  work1[i]  *  work2[i];  [CE]  variable  pj  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]      AssertionFailedError    [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum2  +=  work1[i]  *  work2[i];  double  pj  =  work1[i]  *  work2[i];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	sum2    +=    work1[i]    *    work2[i];    double  pj  =  work1[i]  *  work2[i];	  	non-compiled	[CE]  variable  pj  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	94	None	add
405	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.sqrt(diagR[i]  *  work3);  [CE]  ']'  expected  [FE]              AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  diagR[pj]  =  Math.sqrt(diagR[i]  *  work3);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  diagR[pj]  =  Math.sqrt(diagR[i]  *  work3);	  double    diagR[pj]    =    Math.sqrt(diagR[i]);    	non-compiled	[CE]  ']'  expected	98	None	replace
406	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.sqrt(diagR[i]  *  sum2);  [CE]  ']'  expected  [FE]                AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  diagR[pj]  =  Math.sqrt(diagR[i]  *  sum2);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  diagR[pj]  =  Math.sqrt(diagR[i]  *  sum2);	  double    diagR[pj]    =    Math.sqrt(diagR[i]);    	non-compiled	[CE]  ']'  expected	98	None	replace
407	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum    +=    work2[i]    *    work1[i];    sum  +=  work2[i]  *  work1[i];  sum  +=  work1[i]  *  work2[i];  sum  +=  work2[i]  *  work1[i];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	add	sum        +=        work2[i]        *        work1[i];        sum    +=    work2[i]    *    work1[i];    sum  +=  work1[i]  *  work2[i];  sum  +=  work2[i]  *  work1[i];	  	compilable	  [FE]  AssertionFailedError  	12	5	add
408	[BUG]  [BUGGY]  sum    +=    work2[i]    *    work1[i];    sum  +=  work2[i]  *  work1[i];  sum  +=  work1[i]  *  work2[i];  sum  +=  work2[i]  *  work1[i];  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum    +=    work2[i]    *    work1[i];    sum  +=  work2[i]  *  work1[i];  sum  +=  work1[i]  *  work2[i];  sum  +=  work2[i]  *  work1[i];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	sum        +=        work2[i]        *        work1[i];        sum    +=    work2[i]    *    work1[i];    sum  +=  work1[i]  *  work2[i];  sum  +=  work2[i]  *  work1[i];	  	compilable	  [FE]  AssertionFailedError  	12	5	add
409	[BUG]  [BUGGY]  double  s  =  Math.abs(work1,  work2[i]  *  work1[i]);  [CE]  no  suitable  method  found  for  abs(double[],double)  [FE]    AssertionFailedError    [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  s  =  Math.abs(work1,  work2[i]  *  work1[i]);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  s  =  Math.abs(work1,  work2[i]  *  work1[i]);	  double    s    =    Math.abs(work2[i]    *    work1[i]);    	non-compiled	[CE]  no  suitable  method  found  for  abs(double[],double)	93	None	replace
410	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum2  +=  work1[i]  *  diag[i];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	add	sum2  +=  work1[i]  *  diag[i];	  sum2    +=    work1[i]    *    work2[i];    	compilable	  [FE]  AssertionFailedError  	95	11	replace
411	[BUG]  [BUGGY]  sum2  +=  work1[i]  *  diag[i];  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum2  +=  work1[i]  *  diag[i];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	sum2  +=  work1[i]  *  diag[i];	  sum2    +=    work1[i]    *    work2[i];    	compilable	  [FE]  AssertionFailedError  	95	11	replace
412	[BUG]  [BUGGY]  double  s  =  Math.min(work2,  work1),  sum);  [CE]  ';'  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  s  =  Math.min(work2,  work1),  sum);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  s  =  Math.min(work2,  work1),  sum);	  double    s    =    Math.min(work1,    work2),    sum);    	non-compiled	[CE]  ';'  expected	78	None	replace
413	[BUG]  [BUGGY]  double  s  =  Math.min(work3,  work2),  sum);  [CE]  ';'  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  s  =  Math.min(work3,  work2),  sum);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  s  =  Math.min(work3,  work2),  sum);	  double    s    =    Math.min(work1,    work2),    sum);    	non-compiled	[CE]  ';'  expected	78	None	replace
414	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  s  =  Math.abs(work1[i]  *  work2[i]  *  sum2);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	add	double  s  =  Math.abs(work1[i]  *  work2[i]  *  sum2);	  double    s    =    Math.abs(work1[i]    *    work2[i]    +    sum);    	compilable	  [FE]  AssertionFailedError  	64	13	replace
415	[BUG]  [BUGGY]  double  s  =  Math.abs(work1[i]  *  work2[i]  *  sum2);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double  s  =  Math.abs(work1[i]  *  work2[i]  *  sum2);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double  s  =  Math.abs(work1[i]  *  work2[i]  *  sum2);	  double    s    =    Math.abs(work1[i]    *    work2[i]    +    sum);    	compilable	  [FE]  AssertionFailedError  	64	13	replace
416	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum  +=  work2[i]  *  work3[i];  double  s  =  work2[i]  *  work3[i];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	add	sum    +=    work2[i]    *    work3[i];    double  s  =  work2[i]  *  work3[i];	  	compilable	  [FE]  AssertionFailedError  	101	6	add
417	[BUG]  [BUGGY]  sum  +=  work2[i]  *  work3[i];  double  s  =  work2[i]  *  work3[i];  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum  +=  work2[i]  *  work3[i];  double  s  =  work2[i]  *  work3[i];  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	sum    +=    work2[i]    *    work3[i];    double  s  =  work2[i]  *  work3[i];	  	compilable	  [FE]  AssertionFailedError  	101	6	add
418	[BUG]  [BUGGY]  double[]  work2[pj]  =  Math.abs(work3[pj]  /  dxNorm);  [CE]  ']'  expected  [FE]            AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  double[]  work2[pj]  =  Math.abs(work3[pj]  /  dxNorm);  [BUGGY]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	double[]  work2[pj]  =  Math.abs(work3[pj]  /  dxNorm);	  double[]    work2[pj]    =    0;    	non-compiled	[CE]  ']'  expected	22	None	replace
419	[BUG]  [BUGGY]  sum  +=  work[i][pj]  *  diag[i]  /  dxNorm;  [CE]  cannot  find  symbol  work  [FE]              AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum  +=  work[i][pj]  *  diag[i]  /  dxNorm;  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	sum  +=  work[i][pj]  *  diag[i]  /  dxNorm;	  sum    +=    work[i][pj]    *    diag[i]];    	non-compiled	[CE]  cannot  find  symbol  work	104	None	replace
420	[BUG]  [BUGGY]  sum  +=  work[i][pj]  *  diag[i]  -  1;  [CE]  cannot  find  symbol  work  [FE]                AssertionFailedError      [CONTEXT]      if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {      [BUGGY]  sum  +=  work[i][pj]  *  diag[i]  -  1;  [BUGGY]      }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	539	539	2	replace	sum  +=  work[i][pj]  *  diag[i]  -  1;	  sum    +=    work[i][pj]    *    diag[i]];    	non-compiled	[CE]  cannot  find  symbol  work	104	None	replace
