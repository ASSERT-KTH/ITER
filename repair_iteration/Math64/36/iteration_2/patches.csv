bugid	buggy	buggy_class	suspiciousness	buggy_line	endbuggycode	original_failing_test_number	action	patch	original_buggy	execution_result	diagnosis	previous_bug_id	new_failing_test_number	this_action
1	[BUG]  [BUGGY]  lmPar  =  Math.min(gNorm,  Math.max(paru,  parl));  [CE]  illegal  start  of  type  [FE]        AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  lmPar  =  Math.min(gNorm,  Math.max(paru,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	lmPar  =  Math.min(gNorm,  Math.max(paru,  parl));	  lmPar    =    Math.min(sum2,    Math.max(paru,    parl));    	non-compiled	[CE]  illegal  start  of  type	116	None	replace
2	[BUG]  [BUGGY]  double  sPar  =  Math.sqrt(sum1);  [CE]  illegal  start  of  type  [FE]                    AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  double  sPar  =  Math.sqrt(sum1);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	double  sPar  =  Math.sqrt(sum1);	  double    sPar    =    Math.sqrt(lmPar);    	non-compiled	[CE]  illegal  start  of  type	76	None	replace
3	[BUG]  [BUGGY]  double  sPar  =  Math.sqrt(lmPar,  parl);  [CE]  illegal  start  of  type  [FE]                      AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  double  sPar  =  Math.sqrt(lmPar,  parl);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	double  sPar  =  Math.sqrt(lmPar,  parl);	  double    sPar    =    Math.sqrt(lmPar);    	non-compiled	[CE]  illegal  start  of  type	76	None	replace
4	[BUG]  [BUGGY]  double  sPar  =  Math.sqrt(paru);  [CE]  illegal  start  of  type  [FE]                        AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  double  sPar  =  Math.sqrt(paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	double  sPar  =  Math.sqrt(paru);	  double    sPar    =    Math.sqrt(lmPar);    	non-compiled	[CE]  illegal  start  of  type	76	None	replace
5	[BUG]  [BUGGY]  lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  [CE]  illegal  start  of  type  [FE]        AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	lmPar  =  Math.max(2.252e-308,  0.001  *  paru);	  lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    	non-compiled	[CE]  illegal  start  of  type	9	None	replace
6	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]              AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  if(gNorm  >=  0.0)  {  [BUGGY]      lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	add	if(gNorm  >=  0.0)  {	  if(dxNorm    >=    0.0)    {    if(dxNorm    ==    0.0)    {    	compilable	  [FE]  AssertionFailedError  	42	5	replace
7	[BUG]  [BUGGY]  if(gNorm  >=  0.0)  {  [FE]  AssertionFailedError  [FE]              AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  if(gNorm  >=  0.0)  {  [BUGGY]      lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	if(gNorm  >=  0.0)  {	  if(dxNorm    >=    0.0)    {    if(dxNorm    ==    0.0)    {    	compilable	  [FE]  AssertionFailedError  	42	5	replace
8	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]                AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  if(lmPar  ==  0.0)  {  [BUGGY]      lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	add	if(lmPar  ==  0.0)  {	  if(dxNorm    >=    0.0)    {    if(dxNorm    ==    0.0)    {    	compilable	  [FE]  AssertionFailedError  	42	2	replace
9	[BUG]  [BUGGY]  if(lmPar  ==  0.0)  {  [FE]  AssertionFailedError  [FE]                AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  if(lmPar  ==  0.0)  {  [BUGGY]      lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	if(lmPar  ==  0.0)  {	  if(dxNorm    >=    0.0)    {    if(dxNorm    ==    0.0)    {    	compilable	  [FE]  AssertionFailedError  	42	2	replace
10	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]                  AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  if(lmPar  >=  0.0)  {  [BUGGY]      lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	add	if(lmPar  >=  0.0)  {	  if(dxNorm    >=    0.0)    {    if(dxNorm    ==    0.0)    {    	compilable	  [FE]  AssertionFailedError  	42	5	replace
11	[BUG]  [BUGGY]  if(lmPar  >=  0.0)  {  [FE]  AssertionFailedError  [FE]                  AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  if(lmPar  >=  0.0)  {  [BUGGY]      lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	if(lmPar  >=  0.0)  {	  if(dxNorm    >=    0.0)    {    if(dxNorm    ==    0.0)    {    	compilable	  [FE]  AssertionFailedError  	42	5	replace
12	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]                    AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  if(lmPar  <  0.0)  {  [BUGGY]      lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	add	if(lmPar  <  0.0)  {	  if(dxNorm    >=    0.0)    {    if(dxNorm    ==    0.0)    {    	compilable	  [FE]  AssertionFailedError  	42	2	replace
13	[BUG]  [BUGGY]  if(lmPar  <  0.0)  {  [FE]  AssertionFailedError  [FE]                    AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  if(lmPar  <  0.0)  {  [BUGGY]      lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	if(lmPar  <  0.0)  {	  if(dxNorm    >=    0.0)    {    if(dxNorm    ==    0.0)    {    	compilable	  [FE]  AssertionFailedError  	42	2	replace
14	[BUG]  [BUGGY]  paru  =  Math.min(paru,  Math.max(dxNorm,  parl));  [CE]  illegal  start  of  type  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  paru  =  Math.min(paru,  Math.max(dxNorm,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	paru  =  Math.min(paru,  Math.max(dxNorm,  parl));	          lmPar    =    Math.min(paru,    Math.max(dxNorm,    parl));    paru    =    Math.min(paru,    Math.max(dxNorm,    parl));    	non-compiled	[CE]  illegal  start  of  type	15	None	replace
15	[BUG]  [BUGGY]  if(sum2)  {  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  paru  =  Math.min(paru,  Math.max(dxNorm,  parl));  }  [CE]  illegal  start  of  type  [FE]      AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  if(sum2)  {  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  paru  =  Math.min(paru,  Math.max(dxNorm,  parl));  }  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	if(sum2)  {  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  paru  =  Math.min(paru,  Math.max(dxNorm,  parl));  }	          lmPar    =    Math.min(paru,    Math.max(dxNorm,    parl));    paru    =    Math.min(paru,    Math.max(dxNorm,    parl));    	non-compiled	[CE]  illegal  start  of  type	15	None	replace
16	[BUG]  [BUGGY]  paru  =  Math.min(paru,  Math.max(delta,  parl));  [CE]  illegal  start  of  type  [FE]        AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  paru  =  Math.min(paru,  Math.max(delta,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	paru  =  Math.min(paru,  Math.max(delta,  parl));	          lmPar    =    Math.min(paru,    Math.max(dxNorm,    parl));    paru    =    Math.min(paru,    Math.max(dxNorm,    parl));    	non-compiled	[CE]  illegal  start  of  type	15	None	replace
17	[BUG]  [BUGGY]  if(sum2)  {  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  paru  =  Math.min(paru,  Math.max(dxNorm,  parl));  }  else  {  throw  new  IllegalArgumentException( " ");  }  [CE]  illegal  start  of  type  [FE]          AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  if(sum2)  {  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  paru  =  Math.min(paru,  Math.max(dxNorm,  parl));  }  else  {  throw  new  IllegalArgumentException( " ");  }  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	if(sum2)  {  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  paru  =  Math.min(paru,  Math.max(dxNorm,  parl));  }  else  {  throw  new  IllegalArgumentException( " ");  }	          lmPar    =    Math.min(paru,    Math.max(dxNorm,    parl));    paru    =    Math.min(paru,    Math.max(dxNorm,    parl));    	non-compiled	[CE]  illegal  start  of  type	15	None	replace
18	[BUG]  [BUGGY]  if(gNorm  ==  null)  {  [CE]  incomparable  types:  double  and  <null>  [FE]                AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  if(gNorm  ==  null)  {  [BUGGY]      lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	if(gNorm  ==  null)  {	  if(dxNorm    ==    null)    {    	non-compiled	[CE]  incomparable  types:  double  and  <null>	94	None	replace
19	[BUG]  [BUGGY]  lmPar  =  Math.max(paru,  Math.max(gNorm,  0.0));  [CE]  illegal  start  of  type  [FE]        AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  lmPar  =  Math.max(paru,  Math.max(gNorm,  0.0));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	lmPar  =  Math.max(paru,  Math.max(gNorm,  0.0));	  lmPar    =    Math.max(paru,    Math.max(delta,    0.0));    	non-compiled	[CE]  illegal  start  of  type	117	None	replace
20	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.max(2.251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	add	                lmPar        =        Math.max(2.251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	49	5	add
21	[BUG]  [BUGGY]          lmPar    =    Math.max(2.251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.max(2.251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.max(2.251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	49	5	add
22	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.max(2.251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	add	                lmPar        =        Math.max(2.251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	49	5	add
23	[BUG]  [BUGGY]          lmPar    =    Math.max(2.251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.max(2.251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.max(2.251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	49	5	add
24	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.max(2.251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	add	                lmPar        =        Math.max(2.251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	49	5	add
25	[BUG]  [BUGGY]          lmPar    =    Math.max(2.251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.max(2.251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.max(2.251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	49	5	add
26	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.max(2.251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.250e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	add	                lmPar        =        Math.max(2.251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.250e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	49	5	add
27	[BUG]  [BUGGY]          lmPar    =    Math.max(2.251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.250e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.max(2.251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.250e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.max(2.251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.250e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	49	5	add
28	[BUG]  [BUGGY]  LmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  [CE]  illegal  start  of  type  [FE]            AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  LmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	LmPar  =  Math.min(paru,  Math.max(gNorm,  parl));	          lmPar    =    Math.min(paru,    Math.max(gNorm,    parl));    LmPar    =    Math.min(paru,    Math.max(gNorm,    parl));    	non-compiled	[CE]  illegal  start  of  type	20	None	replace
29	[BUG]  [BUGGY]  paru  =  Math.min(paru,  Math.max(gNorm,  parl));  [CE]  illegal  start  of  type  [FE]              AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  paru  =  Math.min(paru,  Math.max(gNorm,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	paru  =  Math.min(paru,  Math.max(gNorm,  parl));	          lmPar    =    Math.min(paru,    Math.max(gNorm,    parl));    LmPar    =    Math.min(paru,    Math.max(gNorm,    parl));    	non-compiled	[CE]  illegal  start  of  type	20	None	replace
30	[BUG]  [BUGGY]  paru  =  Math.min(delta,  Math.max(dxNorm,  parl));  [CE]  illegal  start  of  type  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  paru  =  Math.min(delta,  Math.max(dxNorm,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	paru  =  Math.min(delta,  Math.max(dxNorm,  parl));	          lmPar    =    Math.min(delta,    Math.max(dxNorm,    parl));    paru    =    Math.min(delta,    Math.max(dxNorm,    parl));    	non-compiled	[CE]  illegal  start  of  type	101	None	replace
31	[BUG]  [BUGGY]  paru  =  Math.min(delta,  Math.max(parl));  [CE]  illegal  start  of  type  [FE]      AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  paru  =  Math.min(delta,  Math.max(parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	paru  =  Math.min(delta,  Math.max(parl));	          lmPar    =    Math.min(delta,    Math.max(dxNorm,    parl));    paru    =    Math.min(delta,    Math.max(dxNorm,    parl));    	non-compiled	[CE]  illegal  start  of  type	101	None	replace
32	[BUG]  [BUGGY]  Paru  paru  =  Math.min(delta,  Math.max(parl));  [CE]  illegal  start  of  type  [FE]        AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  Paru  paru  =  Math.min(delta,  Math.max(parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	Paru  paru  =  Math.min(delta,  Math.max(parl));	          lmPar    =    Math.min(delta,    Math.max(dxNorm,    parl));    paru    =    Math.min(delta,    Math.max(dxNorm,    parl));    	non-compiled	[CE]  illegal  start  of  type	101	None	replace
33	[BUG]  [BUGGY]  LmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  [CE]  illegal  start  of  type  [FE]          AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  LmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	LmPar  =  Math.min(paru,  Math.max(lmPar,  parl));	          lmPar    =    Math.min(paru,    Math.max(lmPar,    parl));    LmPar    =    Math.min(paru,    Math.max(lmPar,    parl));    	non-compiled	[CE]  illegal  start  of  type	88	None	replace
34	[BUG]  [BUGGY]  lmPar  =  Math.min(paru,  Math.max(delta,  lmPar));  [CE]  illegal  start  of  type  [FE]            AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  lmPar  =  Math.min(paru,  Math.max(delta,  lmPar));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	lmPar  =  Math.min(paru,  Math.max(delta,  lmPar));	          lmPar    =    Math.min(paru,    Math.max(lmPar,    parl));    LmPar    =    Math.min(paru,    Math.max(lmPar,    parl));    	non-compiled	[CE]  illegal  start  of  type	88	None	replace
35	[BUG]  [BUGGY]  lmPar  =  Math.max(paru,  Math.max(gNorm,  parl));  [CE]  illegal  start  of  type  [FE]        AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  lmPar  =  Math.max(paru,  Math.max(gNorm,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	lmPar  =  Math.max(paru,  Math.max(gNorm,  parl));	  lmPar    =    Math.max(paru,    Math.max(dxNorm,    parl));    	non-compiled	[CE]  illegal  start  of  type	125	None	replace
36	[BUG]  [BUGGY]  lmPar  =  Math.max(paru,  Math.max(lmPar,  parl));  [CE]  illegal  start  of  type  [FE]          AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  lmPar  =  Math.max(paru,  Math.max(lmPar,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	lmPar  =  Math.max(paru,  Math.max(lmPar,  parl));	  lmPar    =    Math.max(paru,    Math.max(dxNorm,    parl));    	non-compiled	[CE]  illegal  start  of  type	125	None	replace
37	[BUG]  [BUGGY]  double  dxNorm  =  Math.sqrt(paru);  [CE]  illegal  start  of  type  [FE]                AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  double  dxNorm  =  Math.sqrt(paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	double  dxNorm  =  Math.sqrt(paru);	  double    dxNorm    =    Math.sqrt(sum2);    	non-compiled	[CE]  illegal  start  of  type	74	None	replace
38	[BUG]  [BUGGY]  double  dxNorm  =  Math.sqrt(gNorm);  [CE]  illegal  start  of  type  [FE]                  AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  double  dxNorm  =  Math.sqrt(gNorm);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	double  dxNorm  =  Math.sqrt(gNorm);	  double    dxNorm    =    Math.sqrt(sum2);    	non-compiled	[CE]  illegal  start  of  type	74	None	replace
39	[BUG]  [BUGGY]  double  dxNorm  =  Math.sqrt(sum);  [CE]  illegal  start  of  type  [FE]                    AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  double  dxNorm  =  Math.sqrt(sum);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	double  dxNorm  =  Math.sqrt(sum);	  double    dxNorm    =    Math.sqrt(sum2);    	non-compiled	[CE]  illegal  start  of  type	74	None	replace
40	[BUG]  [BUGGY]          lmPar    =    Math.min(paru,    Math.max(gNorm,    parl));    double  lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  double  lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  [CE]  variable  lmPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.min(paru,    Math.max(gNorm,    parl));    double  lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  double  lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.min(paru,        Math.max(gNorm,        parl));        double    lmPar    =    Math.min(paru,    Math.max(gNorm,    parl));    lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  double  lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));	  	non-compiled	[CE]  variable  lmPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	112	None	add
41	[BUG]  [BUGGY]          lmPar    =    Math.min(paru,    Math.max(gNorm,    parl));    double  lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  double  lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  double  lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  [CE]  variable  lmPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]      AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.min(paru,    Math.max(gNorm,    parl));    double  lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  double  lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  double  lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.min(paru,        Math.max(gNorm,        parl));        double    lmPar    =    Math.min(paru,    Math.max(gNorm,    parl));    double  lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  double  lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));	  	non-compiled	[CE]  variable  lmPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	112	None	add
42	[BUG]  [BUGGY]          lmPar    =    Math.min(paru,    Math.max(gNorm,    parl));    double  lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  paru  =  Math.min(paru,  Math.max(gNorm,  parl));  double  lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  [CE]  variable  lmPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]        AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.min(paru,    Math.max(gNorm,    parl));    double  lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  paru  =  Math.min(paru,  Math.max(gNorm,  parl));  double  lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.min(paru,        Math.max(gNorm,        parl));        double    lmPar    =    Math.min(paru,    Math.max(gNorm,    parl));    paru  =  Math.min(paru,  Math.max(gNorm,  parl));  double  lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));	  	non-compiled	[CE]  variable  lmPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	112	None	add
43	[BUG]  [BUGGY]          lmPar    =    Math.min(paru,    Math.max(gNorm,    parl));    double  lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  Math  lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  double  lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  [CE]  variable  lmPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]          AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.min(paru,    Math.max(gNorm,    parl));    double  lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  Math  lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  double  lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.min(paru,        Math.max(gNorm,        parl));        double    lmPar    =    Math.min(paru,    Math.max(gNorm,    parl));    Math  lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  double  lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));	  	non-compiled	[CE]  variable  lmPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	112	None	add
44	[BUG]  [BUGGY]  lmPar  =  Math.max(2.51e-308,  0.001  *  paru);  [CE]  illegal  start  of  type  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  lmPar  =  Math.max(2.51e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	lmPar  =  Math.max(2.51e-308,  0.001  *  paru);	          lmPar    =    Math.max(2.251e-308,    0.001    *    paru);    lmPar    =    Math.max(2.51e-308,    0.001    *    paru);    	non-compiled	[CE]  illegal  start  of  type	52	None	replace
45	[BUG]  [BUGGY]  lmPar  =  Math.max(2.52e-308,  0.001  *  paru);  [CE]  illegal  start  of  type  [FE]      AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  lmPar  =  Math.max(2.52e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	lmPar  =  Math.max(2.52e-308,  0.001  *  paru);	          lmPar    =    Math.max(2.251e-308,    0.001    *    paru);    lmPar    =    Math.max(2.51e-308,    0.001    *    paru);    	non-compiled	[CE]  illegal  start  of  type	52	None	replace
46	[BUG]  [BUGGY]  lmPar  =  Math.min(paru,  Math.max(1.0,  delta));  [CE]  illegal  start  of  type  [FE]            AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  lmPar  =  Math.min(paru,  Math.max(1.0,  delta));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	lmPar  =  Math.min(paru,  Math.max(1.0,  delta));	  lmPar    =    Math.min(delta,    Math.max(1.0,    parl));    	non-compiled	[CE]  illegal  start  of  type	120	None	replace
47	[BUG]  [BUGGY]  lmPar  =  Math.min(paru,  Math.max(delta,  1.0));  [CE]  illegal  start  of  type  [FE]              AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  lmPar  =  Math.min(paru,  Math.max(delta,  1.0));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	lmPar  =  Math.min(paru,  Math.max(delta,  1.0));	  lmPar    =    Math.min(delta,    Math.max(1.0,    parl));    	non-compiled	[CE]  illegal  start  of  type	120	None	replace
48	[BUG]  [BUGGY]  lmPar  =  Math.min(paru,  Math.max(2.0,  parl));  [CE]  illegal  start  of  type  [FE]                AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  lmPar  =  Math.min(paru,  Math.max(2.0,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	lmPar  =  Math.min(paru,  Math.max(2.0,  parl));	  lmPar    =    Math.min(delta,    Math.max(1.0,    parl));    	non-compiled	[CE]  illegal  start  of  type	120	None	replace
49	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	add	                lmPar        =        Math.max(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	68	5	add
50	[BUG]  [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.max(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	68	5	add
51	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	add	                lmPar        =        Math.max(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	68	5	add
52	[BUG]  [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.max(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	68	5	add
53	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	add	                lmPar        =        Math.max(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	68	5	add
54	[BUG]  [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.max(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	68	5	add
55	[BUG]  [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  Paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  [CE]  cannot  find  symbol  Paru  [FE]          AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  Paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.max(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2251e-308,  0.001  *  Paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);	  	non-compiled	[CE]  cannot  find  symbol  Paru	68	None	add
56	[BUG]  [BUGGY]  paru  =  Math.max(2.0,  Math.max(1.0,  parl));  [CE]  illegal  start  of  type  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  paru  =  Math.max(2.0,  Math.max(1.0,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	paru  =  Math.max(2.0,  Math.max(1.0,  parl));	          lmPar    =    Math.max(2.0,    Math.max(1.0,    parl));    paru    =    Math.max(2.0,    Math.max(1.0,    parl));    	non-compiled	[CE]  illegal  start  of  type	127	None	replace
57	[BUG]  [BUGGY]  lmPar  =  Math.max(0.0,  Math.max(1.0,  parl));  paru  =  Math.max(0.0,  Math.max(1.0,  parl));  [CE]  illegal  start  of  type  [FE]      AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  lmPar  =  Math.max(0.0,  Math.max(1.0,  parl));  paru  =  Math.max(0.0,  Math.max(1.0,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	lmPar  =  Math.max(0.0,  Math.max(1.0,  parl));  paru  =  Math.max(0.0,  Math.max(1.0,  parl));	          lmPar    =    Math.max(2.0,    Math.max(1.0,    parl));    paru    =    Math.max(2.0,    Math.max(1.0,    parl));    	non-compiled	[CE]  illegal  start  of  type	127	None	replace
58	[BUG]  [BUGGY]  paru  =  Math.min(paru,  Math.max(lmPar,  parl));  [CE]  illegal  start  of  type  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  paru  =  Math.min(paru,  Math.max(lmPar,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	paru  =  Math.min(paru,  Math.max(lmPar,  parl));	          lmPar    =    Math.min(paru,    Math.max(lmPar,    parl));    paru    =    Math.min(paru,    Math.max(lmPar,    parl));    	non-compiled	[CE]  illegal  start  of  type	91	None	replace
59	[BUG]  [BUGGY]  Parser  paru  =  Math.min(paru,  Math.max(lmPar,  parl));  [CE]  illegal  start  of  type  [FE]      AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  Parser  paru  =  Math.min(paru,  Math.max(lmPar,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	Parser  paru  =  Math.min(paru,  Math.max(lmPar,  parl));	          lmPar    =    Math.min(paru,    Math.max(lmPar,    parl));    paru    =    Math.min(paru,    Math.max(lmPar,    parl));    	non-compiled	[CE]  illegal  start  of  type	91	None	replace
60	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.min(paru,    Math.max(dxNorm,    parl));    paru  =  Math.min(paru,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  paru  =  Math.min(paru,  Math.max(dxNorm,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	add	                lmPar        =        Math.min(paru,        Math.max(dxNorm,        parl));        paru    =    Math.min(paru,    Math.max(dxNorm,    parl));    lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  paru  =  Math.min(paru,  Math.max(dxNorm,  parl));	  	compilable	  [FE]  AssertionFailedError  	14	6	add
61	[BUG]  [BUGGY]          lmPar    =    Math.min(paru,    Math.max(dxNorm,    parl));    paru  =  Math.min(paru,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  paru  =  Math.min(paru,  Math.max(dxNorm,  parl));  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.min(paru,    Math.max(dxNorm,    parl));    paru  =  Math.min(paru,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  paru  =  Math.min(paru,  Math.max(dxNorm,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.min(paru,        Math.max(dxNorm,        parl));        paru    =    Math.min(paru,    Math.max(dxNorm,    parl));    lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  paru  =  Math.min(paru,  Math.max(dxNorm,  parl));	  	compilable	  [FE]  AssertionFailedError  	14	6	add
62	[BUG]  [BUGGY]          lmPar    =    Math.min(paru,    Math.max(dxNorm,    parl));    paru  =  Math.min(paru,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(dyNorm,  parl));  paru  =  Math.min(paru,  Math.max(dxNorm,  parl));  [CE]  cannot  find  symbol  dyNorm  [FE]      AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.min(paru,    Math.max(dxNorm,    parl));    paru  =  Math.min(paru,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(dyNorm,  parl));  paru  =  Math.min(paru,  Math.max(dxNorm,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.min(paru,        Math.max(dxNorm,        parl));        paru    =    Math.min(paru,    Math.max(dxNorm,    parl));    lmPar  =  Math.min(paru,  Math.max(dyNorm,  parl));  paru  =  Math.min(paru,  Math.max(dxNorm,  parl));	  	non-compiled	[CE]  cannot  find  symbol  dyNorm	14	None	add
63	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.min(paru,    Math.max(dxNorm,    parl));    paru  =  Math.min(paru,  Math.max(dxNorm,  parl));  paru  =  Math.min(paru,  Math.max(dxNorm,  parl));  paru  =  Math.min(paru,  Math.max(dxNorm,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	add	                lmPar        =        Math.min(paru,        Math.max(dxNorm,        parl));        paru    =    Math.min(paru,    Math.max(dxNorm,    parl));    paru  =  Math.min(paru,  Math.max(dxNorm,  parl));  paru  =  Math.min(paru,  Math.max(dxNorm,  parl));	  	compilable	  [FE]  AssertionFailedError  	14	6	add
64	[BUG]  [BUGGY]          lmPar    =    Math.min(paru,    Math.max(dxNorm,    parl));    paru  =  Math.min(paru,  Math.max(dxNorm,  parl));  paru  =  Math.min(paru,  Math.max(dxNorm,  parl));  paru  =  Math.min(paru,  Math.max(dxNorm,  parl));  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.min(paru,    Math.max(dxNorm,    parl));    paru  =  Math.min(paru,  Math.max(dxNorm,  parl));  paru  =  Math.min(paru,  Math.max(dxNorm,  parl));  paru  =  Math.min(paru,  Math.max(dxNorm,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.min(paru,        Math.max(dxNorm,        parl));        paru    =    Math.min(paru,    Math.max(dxNorm,    parl));    paru  =  Math.min(paru,  Math.max(dxNorm,  parl));  paru  =  Math.min(paru,  Math.max(dxNorm,  parl));	  	compilable	  [FE]  AssertionFailedError  	14	6	add
65	[BUG]  [BUGGY]          lmPar    =    Math.min(paru,    Math.max(dxNorm,    parl));    paru  =  Math.min(paru,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  paru  =  Math.min(paru,  Math.max(dyNorm,  parl));  [CE]  cannot  find  symbol  dyNorm  [FE]          AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.min(paru,    Math.max(dxNorm,    parl));    paru  =  Math.min(paru,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  paru  =  Math.min(paru,  Math.max(dyNorm,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.min(paru,        Math.max(dxNorm,        parl));        paru    =    Math.min(paru,    Math.max(dxNorm,    parl));    lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  paru  =  Math.min(paru,  Math.max(dyNorm,  parl));	  	non-compiled	[CE]  cannot  find  symbol  dyNorm	14	None	add
66	[BUG]  [BUGGY]  if(dxNorm  <  0.0)  {  if(dxNorm  <  0.0)  {  [CE]  illegal  start  of  expression  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  if(dxNorm  <  0.0)  {  if(dxNorm  <  0.0)  {  [BUGGY]      lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	if(dxNorm    <    0.0)    {    if(dxNorm  <  0.0)  {	  	non-compiled	[CE]  illegal  start  of  expression	31	None	add
67	[BUG]  [BUGGY]  if(dxNorm  <  0.0)  {  If(dxNorm  <  0.0)  {  [CE]  ';'  expected  [FE]      AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  if(dxNorm  <  0.0)  {  If(dxNorm  <  0.0)  {  [BUGGY]      lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	if(dxNorm    <    0.0)    {    If(dxNorm  <  0.0)  {	  	non-compiled	[CE]  ';'  expected	31	None	add
68	[BUG]  [BUGGY]  if(dxNorm  <  0.0)  {  if(dxNorm  >=  0.0)  {  [CE]  illegal  start  of  expression  [FE]        AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  if(dxNorm  <  0.0)  {  if(dxNorm  >=  0.0)  {  [BUGGY]      lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	if(dxNorm    <    0.0)    {    if(dxNorm  >=  0.0)  {	  	non-compiled	[CE]  illegal  start  of  expression	31	None	add
69	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.min(paru,    Math.max(gNorm,    parl));    paru  =  Math.min(paru,  Math.max(gNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  paru  =  Math.min(paru,  Math.max(gNorm,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	add	                lmPar        =        Math.min(paru,        Math.max(gNorm,        parl));        paru    =    Math.min(paru,    Math.max(gNorm,    parl));    lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  paru  =  Math.min(paru,  Math.max(gNorm,  parl));	  	compilable	  [FE]  AssertionFailedError  	18	5	add
70	[BUG]  [BUGGY]          lmPar    =    Math.min(paru,    Math.max(gNorm,    parl));    paru  =  Math.min(paru,  Math.max(gNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  paru  =  Math.min(paru,  Math.max(gNorm,  parl));  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.min(paru,    Math.max(gNorm,    parl));    paru  =  Math.min(paru,  Math.max(gNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  paru  =  Math.min(paru,  Math.max(gNorm,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.min(paru,        Math.max(gNorm,        parl));        paru    =    Math.min(paru,    Math.max(gNorm,    parl));    lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  paru  =  Math.min(paru,  Math.max(gNorm,  parl));	  	compilable	  [FE]  AssertionFailedError  	18	5	add
71	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.min(paru,    Math.max(gNorm,    parl));    paru  =  Math.min(paru,  Math.max(gNorm,  parl));  paru  =  Math.min(paru,  Math.max(gNorm,  parl));  paru  =  Math.min(paru,  Math.max(gNorm,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	add	                lmPar        =        Math.min(paru,        Math.max(gNorm,        parl));        paru    =    Math.min(paru,    Math.max(gNorm,    parl));    paru  =  Math.min(paru,  Math.max(gNorm,  parl));  paru  =  Math.min(paru,  Math.max(gNorm,  parl));	  	compilable	  [FE]  AssertionFailedError  	18	5	add
72	[BUG]  [BUGGY]          lmPar    =    Math.min(paru,    Math.max(gNorm,    parl));    paru  =  Math.min(paru,  Math.max(gNorm,  parl));  paru  =  Math.min(paru,  Math.max(gNorm,  parl));  paru  =  Math.min(paru,  Math.max(gNorm,  parl));  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.min(paru,    Math.max(gNorm,    parl));    paru  =  Math.min(paru,  Math.max(gNorm,  parl));  paru  =  Math.min(paru,  Math.max(gNorm,  parl));  paru  =  Math.min(paru,  Math.max(gNorm,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.min(paru,        Math.max(gNorm,        parl));        paru    =    Math.min(paru,    Math.max(gNorm,    parl));    paru  =  Math.min(paru,  Math.max(gNorm,  parl));  paru  =  Math.min(paru,  Math.max(gNorm,  parl));	  	compilable	  [FE]  AssertionFailedError  	18	5	add
73	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.min(paru,    Math.max(gNorm,    parl));    paru  =  Math.min(paru,  Math.max(gNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  paru  =  Math.min(paru,  Math.max(gNorm,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	add	                lmPar        =        Math.min(paru,        Math.max(gNorm,        parl));        paru    =    Math.min(paru,    Math.max(gNorm,    parl));    lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  paru  =  Math.min(paru,  Math.max(gNorm,  parl));	  	compilable	  [FE]  AssertionFailedError  	18	5	add
74	[BUG]  [BUGGY]          lmPar    =    Math.min(paru,    Math.max(gNorm,    parl));    paru  =  Math.min(paru,  Math.max(gNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  paru  =  Math.min(paru,  Math.max(gNorm,  parl));  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.min(paru,    Math.max(gNorm,    parl));    paru  =  Math.min(paru,  Math.max(gNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  paru  =  Math.min(paru,  Math.max(gNorm,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.min(paru,        Math.max(gNorm,        parl));        paru    =    Math.min(paru,    Math.max(gNorm,    parl));    lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  paru  =  Math.min(paru,  Math.max(gNorm,  parl));	  	compilable	  [FE]  AssertionFailedError  	18	5	add
75	[BUG]  [BUGGY]  double  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  [CE]  illegal  start  of  type  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  double  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	double  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));	          lmPar    =    Math.min(delta,    Math.max(dxNorm,    parl));    double    lmPar    =    Math.min(delta,    Math.max(dxNorm,    parl));    	non-compiled	[CE]  illegal  start  of  type	99	None	replace
76	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]            AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  if(gNorm  ==  0.0)  {  [BUGGY]      lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	add	if(gNorm  ==  0.0)  {	  if(dxNorm    ==    0)    {    if(dxNorm    >=    0)    {    	compilable	  [FE]  AssertionFailedError  	6	2	replace
77	[BUG]  [BUGGY]  if(gNorm  ==  0.0)  {  [FE]  AssertionFailedError  [FE]            AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  if(gNorm  ==  0.0)  {  [BUGGY]      lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	if(gNorm  ==  0.0)  {	  if(dxNorm    ==    0)    {    if(dxNorm    >=    0)    {    	compilable	  [FE]  AssertionFailedError  	6	2	replace
78	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]              AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  if(gNorm!=  0.0)  {  [BUGGY]      lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	add	if(gNorm!=  0.0)  {	  if(dxNorm    ==    0)    {    if(dxNorm    >=    0)    {    	compilable	  [FE]  AssertionFailedError  	6	5	replace
79	[BUG]  [BUGGY]  if(gNorm!=  0.0)  {  [FE]  AssertionFailedError  [FE]              AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  if(gNorm!=  0.0)  {  [BUGGY]      lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	if(gNorm!=  0.0)  {	  if(dxNorm    ==    0)    {    if(dxNorm    >=    0)    {    	compilable	  [FE]  AssertionFailedError  	6	5	replace
80	[BUG]  [BUGGY]  if(sum2)  {  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  }  [CE]  illegal  start  of  type  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  if(sum2)  {  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  }  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	if(sum2)  {  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  }	          lmPar    =    Math.min(paru,    Math.max(dxNorm,    parl));    lmPar    =    Math.min(paru,    Math.max(dxNorm,    parl));    	non-compiled	[CE]  illegal  start  of  type	11	None	replace
81	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.max(2.251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.51e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.51e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	add	                lmPar        =        Math.max(2.251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.51e-308,    0.001    *    paru);    lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.51e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	51	5	add
82	[BUG]  [BUGGY]          lmPar    =    Math.max(2.251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.51e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.51e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.max(2.251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.51e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.51e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.max(2.251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.51e-308,    0.001    *    paru);    lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.51e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	51	5	add
83	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.max(2.251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.51e-308,  0.001  *  paru);  lmPar  =  Math.max(2.51e-308,  0.001  *  paru);  lmPar  =  Math.max(2.51e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	add	                lmPar        =        Math.max(2.251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.51e-308,    0.001    *    paru);    lmPar  =  Math.max(2.51e-308,  0.001  *  paru);  lmPar  =  Math.max(2.51e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	51	5	add
84	[BUG]  [BUGGY]          lmPar    =    Math.max(2.251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.51e-308,  0.001  *  paru);  lmPar  =  Math.max(2.51e-308,  0.001  *  paru);  lmPar  =  Math.max(2.51e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.max(2.251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.51e-308,  0.001  *  paru);  lmPar  =  Math.max(2.51e-308,  0.001  *  paru);  lmPar  =  Math.max(2.51e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.max(2.251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.51e-308,    0.001    *    paru);    lmPar  =  Math.max(2.51e-308,  0.001  *  paru);  lmPar  =  Math.max(2.51e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	51	5	add
85	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.max(2.251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.51e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.52e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	add	                lmPar        =        Math.max(2.251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.51e-308,    0.001    *    paru);    lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.52e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	51	5	add
86	[BUG]  [BUGGY]          lmPar    =    Math.max(2.251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.51e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.52e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.max(2.251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.51e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.52e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.max(2.251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.51e-308,    0.001    *    paru);    lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.52e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	51	5	add
87	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.max(2.251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.51e-308,  0.001  *  paru);  lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.51e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	add	                lmPar        =        Math.max(2.251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.51e-308,    0.001    *    paru);    lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.51e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	51	5	add
88	[BUG]  [BUGGY]          lmPar    =    Math.max(2.251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.51e-308,  0.001  *  paru);  lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.51e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.max(2.251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.51e-308,  0.001  *  paru);  lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.51e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.max(2.251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.51e-308,    0.001    *    paru);    lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.51e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	51	5	add
89	[BUG]  [BUGGY]  double  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  [CE]  illegal  start  of  type  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  double  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	double  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));	          lmPar    =    Math.min(paru,    Math.max(dxNorm,    parl));    double    lmPar    =    Math.min(paru,    Math.max(dxNorm,    parl));    	non-compiled	[CE]  illegal  start  of  type	96	None	replace
90	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.min(delta,    Math.max(dxNorm,    parl));    paru  =  Math.min(delta,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  paru  =  Math.min(delta,  Math.max(dxNorm,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	add	                lmPar        =        Math.min(delta,        Math.max(dxNorm,        parl));        paru    =    Math.min(delta,    Math.max(dxNorm,    parl));    lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  paru  =  Math.min(delta,  Math.max(dxNorm,  parl));	  	compilable	  [FE]  AssertionFailedError  	100	5	add
91	[BUG]  [BUGGY]          lmPar    =    Math.min(delta,    Math.max(dxNorm,    parl));    paru  =  Math.min(delta,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  paru  =  Math.min(delta,  Math.max(dxNorm,  parl));  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.min(delta,    Math.max(dxNorm,    parl));    paru  =  Math.min(delta,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  paru  =  Math.min(delta,  Math.max(dxNorm,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.min(delta,        Math.max(dxNorm,        parl));        paru    =    Math.min(delta,    Math.max(dxNorm,    parl));    lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  paru  =  Math.min(delta,  Math.max(dxNorm,  parl));	  	compilable	  [FE]  AssertionFailedError  	100	5	add
92	[BUG]  [BUGGY]          lmPar    =    Math.min(delta,    Math.max(dxNorm,    parl));    paru  =  Math.min(delta,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(delta,  Math.max(dyNorm,  parl));  paru  =  Math.min(delta,  Math.max(dxNorm,  parl));  [CE]  cannot  find  symbol  dyNorm  [FE]      AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.min(delta,    Math.max(dxNorm,    parl));    paru  =  Math.min(delta,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(delta,  Math.max(dyNorm,  parl));  paru  =  Math.min(delta,  Math.max(dxNorm,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.min(delta,        Math.max(dxNorm,        parl));        paru    =    Math.min(delta,    Math.max(dxNorm,    parl));    lmPar  =  Math.min(delta,  Math.max(dyNorm,  parl));  paru  =  Math.min(delta,  Math.max(dxNorm,  parl));	  	non-compiled	[CE]  cannot  find  symbol  dyNorm	100	None	add
93	[BUG]  [BUGGY]          lmPar    =    Math.min(delta,    Math.max(dxNorm,    parl));    paru  =  Math.min(delta,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  paru  =  Math.min(delta,  Math.max(dyNorm,  parl));  [CE]  cannot  find  symbol  dyNorm  [FE]        AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.min(delta,    Math.max(dxNorm,    parl));    paru  =  Math.min(delta,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  paru  =  Math.min(delta,  Math.max(dyNorm,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.min(delta,        Math.max(dxNorm,        parl));        paru    =    Math.min(delta,    Math.max(dxNorm,    parl));    lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  paru  =  Math.min(delta,  Math.max(dyNorm,  parl));	  	non-compiled	[CE]  cannot  find  symbol  dyNorm	100	None	add
94	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.min(delta,    Math.max(dxNorm,    parl));    paru  =  Math.min(delta,  Math.max(dxNorm,  parl));  paru  =  Math.min(delta,  Math.max(dxNorm,  parl));  paru  =  Math.min(delta,  Math.max(dxNorm,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	add	                lmPar        =        Math.min(delta,        Math.max(dxNorm,        parl));        paru    =    Math.min(delta,    Math.max(dxNorm,    parl));    paru  =  Math.min(delta,  Math.max(dxNorm,  parl));  paru  =  Math.min(delta,  Math.max(dxNorm,  parl));	  	compilable	  [FE]  AssertionFailedError  	100	5	add
95	[BUG]  [BUGGY]          lmPar    =    Math.min(delta,    Math.max(dxNorm,    parl));    paru  =  Math.min(delta,  Math.max(dxNorm,  parl));  paru  =  Math.min(delta,  Math.max(dxNorm,  parl));  paru  =  Math.min(delta,  Math.max(dxNorm,  parl));  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.min(delta,    Math.max(dxNorm,    parl));    paru  =  Math.min(delta,  Math.max(dxNorm,  parl));  paru  =  Math.min(delta,  Math.max(dxNorm,  parl));  paru  =  Math.min(delta,  Math.max(dxNorm,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.min(delta,        Math.max(dxNorm,        parl));        paru    =    Math.min(delta,    Math.max(dxNorm,    parl));    paru  =  Math.min(delta,  Math.max(dxNorm,  parl));  paru  =  Math.min(delta,  Math.max(dxNorm,  parl));	  	compilable	  [FE]  AssertionFailedError  	100	5	add
96	[BUG]  [BUGGY]  if(dxNorm!=  0.0  ||  dxNorm!=  0.0)  {  if(dxNorm!=  0.0  ||  dxNorm!=  0.0)  {  [CE]  illegal  start  of  expression  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  if(dxNorm!=  0.0  ||  dxNorm!=  0.0)  {  if(dxNorm!=  0.0  ||  dxNorm!=  0.0)  {  [BUGGY]      lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	if(dxNorm!=    0.0    ||    dxNorm!=    0.0)    {    if(dxNorm!=  0.0  ||  dxNorm!=  0.0)  {	  	non-compiled	[CE]  illegal  start  of  expression	129	None	add
97	[BUG]  [BUGGY]  if(dxNorm!=  0.0  ||  dxNorm!=  0.0)  {  if(dxNorm!=  0.0  ||  dxNorm  >=  0.0)  {  [CE]  illegal  start  of  expression  [FE]      AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  if(dxNorm!=  0.0  ||  dxNorm!=  0.0)  {  if(dxNorm!=  0.0  ||  dxNorm  >=  0.0)  {  [BUGGY]      lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	if(dxNorm!=    0.0    ||    dxNorm!=    0.0)    {    if(dxNorm!=  0.0  ||  dxNorm  >=  0.0)  {	  	non-compiled	[CE]  illegal  start  of  expression	129	None	add
98	[BUG]  [BUGGY]  if(dxNorm!=  0.0  ||  dxNorm!=  0.0)  {  if(dxNorm!=  0.0  ||  dxNorm  ==  0.0)  {  [CE]  illegal  start  of  expression  [FE]        AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  if(dxNorm!=  0.0  ||  dxNorm!=  0.0)  {  if(dxNorm!=  0.0  ||  dxNorm  ==  0.0)  {  [BUGGY]      lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	if(dxNorm!=    0.0    ||    dxNorm!=    0.0)    {    if(dxNorm!=  0.0  ||  dxNorm  ==  0.0)  {	  	non-compiled	[CE]  illegal  start  of  expression	129	None	add
99	[BUG]  [BUGGY]  if(dxNorm!=  0.0  ||  dxNorm!=  0.0)  {  if(dxNorm  ==  0.0  ||  dxNorm!=  0.0)  {  [CE]  illegal  start  of  expression  [FE]          AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  if(dxNorm!=  0.0  ||  dxNorm!=  0.0)  {  if(dxNorm  ==  0.0  ||  dxNorm!=  0.0)  {  [BUGGY]      lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	if(dxNorm!=    0.0    ||    dxNorm!=    0.0)    {    if(dxNorm  ==  0.0  ||  dxNorm!=  0.0)  {	  	non-compiled	[CE]  illegal  start  of  expression	129	None	add
100	[BUG]  [BUGGY]  if(dxNorm!=  0.0  ||  dxNorm!=  0.0)  {  if(dxNorm  >=  0.0  ||  dxNorm!=  0.0)  {  [CE]  illegal  start  of  expression  [FE]            AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  if(dxNorm!=  0.0  ||  dxNorm!=  0.0)  {  if(dxNorm  >=  0.0  ||  dxNorm!=  0.0)  {  [BUGGY]      lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	if(dxNorm!=    0.0    ||    dxNorm!=    0.0)    {    if(dxNorm  >=  0.0  ||  dxNorm!=  0.0)  {	  	non-compiled	[CE]  illegal  start  of  expression	129	None	add
101	[BUG]  [BUGGY]  if(lmPar  >=  null)  {  [CE]  bad  operand  types  for  binary  operator  '>='  [FE]            AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  if(lmPar  >=  null)  {  [BUGGY]      lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	if(lmPar  >=  null)  {	  if(lmPar!=    null)    {    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '>='	103	None	replace
102	[BUG]  [BUGGY]          lmPar    =    Math.min(paru,    Math.max(dxNorm,    parl));    double  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  double  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  [CE]  variable  lmPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.min(paru,    Math.max(dxNorm,    parl));    double  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  double  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.min(paru,        Math.max(dxNorm,        parl));        double    lmPar    =    Math.min(paru,    Math.max(dxNorm,    parl));    lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  double  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));	  	non-compiled	[CE]  variable  lmPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	95	None	add
103	[BUG]  [BUGGY]          lmPar    =    Math.min(paru,    Math.max(dxNorm,    parl));    double  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  double  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  double  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  [CE]  variable  lmPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]      AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.min(paru,    Math.max(dxNorm,    parl));    double  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  double  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  double  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.min(paru,        Math.max(dxNorm,        parl));        double    lmPar    =    Math.min(paru,    Math.max(dxNorm,    parl));    double  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  double  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));	  	non-compiled	[CE]  variable  lmPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	95	None	add
104	[BUG]  [BUGGY]          lmPar    =    Math.min(paru,    Math.max(dxNorm,    parl));    double  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  double  lmPar  =  Math.min(paru,  Math.max(dyNorm,  parl));  [CE]  variable  lmPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]        AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.min(paru,    Math.max(dxNorm,    parl));    double  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  double  lmPar  =  Math.min(paru,  Math.max(dyNorm,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.min(paru,        Math.max(dxNorm,        parl));        double    lmPar    =    Math.min(paru,    Math.max(dxNorm,    parl));    lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  double  lmPar  =  Math.min(paru,  Math.max(dyNorm,  parl));	  	non-compiled	[CE]  variable  lmPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	95	None	add
105	[BUG]  [BUGGY]          lmPar    =    Math.min(paru,    Math.max(dxNorm,    parl));    double  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(dyNorm,  parl));  double  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  [CE]  cannot  find  symbol  dyNorm  [FE]          AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.min(paru,    Math.max(dxNorm,    parl));    double  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(dyNorm,  parl));  double  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.min(paru,        Math.max(dxNorm,        parl));        double    lmPar    =    Math.min(paru,    Math.max(dxNorm,    parl));    lmPar  =  Math.min(paru,  Math.max(dyNorm,  parl));  double  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));	  	non-compiled	[CE]  cannot  find  symbol  dyNorm	95	None	add
106	[BUG]  [BUGGY]          lmPar    =    Math.min(paru,    Math.max(dxNorm,    parl));    double  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  double  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  double  lmPar  =  Math.min(paru,  Math.max(dyNorm,  parl));  [CE]  variable  lmPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]            AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.min(paru,    Math.max(dxNorm,    parl));    double  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  double  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  double  lmPar  =  Math.min(paru,  Math.max(dyNorm,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.min(paru,        Math.max(dxNorm,        parl));        double    lmPar    =    Math.min(paru,    Math.max(dxNorm,    parl));    double  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  double  lmPar  =  Math.min(paru,  Math.max(dyNorm,  parl));	  	non-compiled	[CE]  variable  lmPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	95	None	add
107	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	add	                lmPar        =        Math.max(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	72	5	add
108	[BUG]  [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.max(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	72	5	add
109	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	add	                lmPar        =        Math.max(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	72	5	add
110	[BUG]  [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.max(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	72	5	add
111	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	add	                lmPar        =        Math.max(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	72	5	add
112	[BUG]  [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.max(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	72	5	add
113	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	add	                lmPar        =        Math.max(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	72	5	add
114	[BUG]  [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.max(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	72	5	add
115	[BUG]  [BUGGY]  if(dxNorm  >  0.0)  {  If(dxNorm  >=  0.0)  {  [CE]  ';'  expected  [FE]        AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  if(dxNorm  >  0.0)  {  If(dxNorm  >=  0.0)  {  [BUGGY]      lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	if(dxNorm  >  0.0)  {  If(dxNorm  >=  0.0)  {	  if(dxNorm    >=    0.0)    {    If(dxNorm    >=    0.0)    {    	non-compiled	[CE]  ';'  expected	111	None	replace
116	[BUG]  [BUGGY]  if(lmPar!=  0.0)  {  if(lmPar!=  0.0)  {  [CE]  illegal  start  of  expression  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  if(lmPar!=  0.0)  {  if(lmPar!=  0.0)  {  [BUGGY]      lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	if(lmPar!=    0.0)    {    if(lmPar!=  0.0)  {	  	non-compiled	[CE]  illegal  start  of  expression	58	None	add
117	[BUG]  [BUGGY]  if(lmPar!=  0.0)  {  if(lmPar  >=  0.0)  {  [CE]  illegal  start  of  expression  [FE]      AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  if(lmPar!=  0.0)  {  if(lmPar  >=  0.0)  {  [BUGGY]      lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	if(lmPar!=    0.0)    {    if(lmPar  >=  0.0)  {	  	non-compiled	[CE]  illegal  start  of  expression	58	None	add
118	[BUG]  [BUGGY]  if(lmPar!=  0.0)  {  if(lmPar  >>  0.0)  {  [CE]  illegal  start  of  expression  [FE]        AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  if(lmPar!=  0.0)  {  if(lmPar  >>  0.0)  {  [BUGGY]      lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	if(lmPar!=    0.0)    {    if(lmPar  >>  0.0)  {	  	non-compiled	[CE]  illegal  start  of  expression	58	None	add
119	[BUG]  [BUGGY]  if(lmPar!=  0.0)  {  if(lmPar  ==  0.0)  {  [CE]  illegal  start  of  expression  [FE]          AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  if(lmPar!=  0.0)  {  if(lmPar  ==  0.0)  {  [BUGGY]      lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	if(lmPar!=    0.0)    {    if(lmPar  ==  0.0)  {	  	non-compiled	[CE]  illegal  start  of  expression	58	None	add
120	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.max(2.0,    Math.max(1.0,    parl));    lmPar  =  Math.max(2.0,  Math.max(1.0,  parl));  lmPar  =  Math.max(2.0,  Math.max(1.0,  parl));  lmPar  =  Math.max(2.0,  Math.max(1.0,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	add	                lmPar        =        Math.max(2.0,        Math.max(1.0,        parl));        lmPar    =    Math.max(2.0,    Math.max(1.0,    parl));    lmPar  =  Math.max(2.0,  Math.max(1.0,  parl));  lmPar  =  Math.max(2.0,  Math.max(1.0,  parl));	  	compilable	  [FE]  AssertionFailedError  	61	5	add
121	[BUG]  [BUGGY]          lmPar    =    Math.max(2.0,    Math.max(1.0,    parl));    lmPar  =  Math.max(2.0,  Math.max(1.0,  parl));  lmPar  =  Math.max(2.0,  Math.max(1.0,  parl));  lmPar  =  Math.max(2.0,  Math.max(1.0,  parl));  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.max(2.0,    Math.max(1.0,    parl));    lmPar  =  Math.max(2.0,  Math.max(1.0,  parl));  lmPar  =  Math.max(2.0,  Math.max(1.0,  parl));  lmPar  =  Math.max(2.0,  Math.max(1.0,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.max(2.0,        Math.max(1.0,        parl));        lmPar    =    Math.max(2.0,    Math.max(1.0,    parl));    lmPar  =  Math.max(2.0,  Math.max(1.0,  parl));  lmPar  =  Math.max(2.0,  Math.max(1.0,  parl));	  	compilable	  [FE]  AssertionFailedError  	61	5	add
122	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.max(2.0,    Math.max(1.0,    parl));    lmPar  =  Math.max(2.0,  Math.max(1.0,  parl));  lmPar  =  Math.max(1.0,  Math.max(1.0,  parl));  lmPar  =  Math.max(2.0,  Math.max(1.0,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	add	                lmPar        =        Math.max(2.0,        Math.max(1.0,        parl));        lmPar    =    Math.max(2.0,    Math.max(1.0,    parl));    lmPar  =  Math.max(1.0,  Math.max(1.0,  parl));  lmPar  =  Math.max(2.0,  Math.max(1.0,  parl));	  	compilable	  [FE]  AssertionFailedError  	61	5	add
123	[BUG]  [BUGGY]          lmPar    =    Math.max(2.0,    Math.max(1.0,    parl));    lmPar  =  Math.max(2.0,  Math.max(1.0,  parl));  lmPar  =  Math.max(1.0,  Math.max(1.0,  parl));  lmPar  =  Math.max(2.0,  Math.max(1.0,  parl));  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.max(2.0,    Math.max(1.0,    parl));    lmPar  =  Math.max(2.0,  Math.max(1.0,  parl));  lmPar  =  Math.max(1.0,  Math.max(1.0,  parl));  lmPar  =  Math.max(2.0,  Math.max(1.0,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.max(2.0,        Math.max(1.0,        parl));        lmPar    =    Math.max(2.0,    Math.max(1.0,    parl));    lmPar  =  Math.max(1.0,  Math.max(1.0,  parl));  lmPar  =  Math.max(2.0,  Math.max(1.0,  parl));	  	compilable	  [FE]  AssertionFailedError  	61	5	add
124	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.max(2.0,    Math.max(1.0,    parl));    lmPar  =  Math.max(2.0,  Math.max(1.0,  parl));  lmPar  =  Math.min(2.0,  Math.max(1.0,  parl));  lmPar  =  Math.max(2.0,  Math.max(1.0,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	add	                lmPar        =        Math.max(2.0,        Math.max(1.0,        parl));        lmPar    =    Math.max(2.0,    Math.max(1.0,    parl));    lmPar  =  Math.min(2.0,  Math.max(1.0,  parl));  lmPar  =  Math.max(2.0,  Math.max(1.0,  parl));	  	compilable	  [FE]  AssertionFailedError  	61	5	add
125	[BUG]  [BUGGY]          lmPar    =    Math.max(2.0,    Math.max(1.0,    parl));    lmPar  =  Math.max(2.0,  Math.max(1.0,  parl));  lmPar  =  Math.min(2.0,  Math.max(1.0,  parl));  lmPar  =  Math.max(2.0,  Math.max(1.0,  parl));  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.max(2.0,    Math.max(1.0,    parl));    lmPar  =  Math.max(2.0,  Math.max(1.0,  parl));  lmPar  =  Math.min(2.0,  Math.max(1.0,  parl));  lmPar  =  Math.max(2.0,  Math.max(1.0,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.max(2.0,        Math.max(1.0,        parl));        lmPar    =    Math.max(2.0,    Math.max(1.0,    parl));    lmPar  =  Math.min(2.0,  Math.max(1.0,  parl));  lmPar  =  Math.max(2.0,  Math.max(1.0,  parl));	  	compilable	  [FE]  AssertionFailedError  	61	5	add
126	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.max(2.0,    Math.max(1.0,    parl));    lmPar  =  Math.max(2.0,  Math.max(1.0,  parl));  lmPar  =  Math.max(2.0,  Math.max(0.0,  parl));  lmPar  =  Math.max(2.0,  Math.max(1.0,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	add	                lmPar        =        Math.max(2.0,        Math.max(1.0,        parl));        lmPar    =    Math.max(2.0,    Math.max(1.0,    parl));    lmPar  =  Math.max(2.0,  Math.max(0.0,  parl));  lmPar  =  Math.max(2.0,  Math.max(1.0,  parl));	  	compilable	  [FE]  AssertionFailedError  	61	5	add
127	[BUG]  [BUGGY]          lmPar    =    Math.max(2.0,    Math.max(1.0,    parl));    lmPar  =  Math.max(2.0,  Math.max(1.0,  parl));  lmPar  =  Math.max(2.0,  Math.max(0.0,  parl));  lmPar  =  Math.max(2.0,  Math.max(1.0,  parl));  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.max(2.0,    Math.max(1.0,    parl));    lmPar  =  Math.max(2.0,  Math.max(1.0,  parl));  lmPar  =  Math.max(2.0,  Math.max(0.0,  parl));  lmPar  =  Math.max(2.0,  Math.max(1.0,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.max(2.0,        Math.max(1.0,        parl));        lmPar    =    Math.max(2.0,    Math.max(1.0,    parl));    lmPar  =  Math.max(2.0,  Math.max(0.0,  parl));  lmPar  =  Math.max(2.0,  Math.max(1.0,  parl));	  	compilable	  [FE]  AssertionFailedError  	61	5	add
128	[BUG]  [BUGGY]  LmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  [CE]  illegal  start  of  type  [FE]            AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  LmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	LmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));	          lmPar    =    Math.min(paru,    Math.max(dxNorm,    parl));    LmPar    =    Math.min(paru,    Math.max(dxNorm,    parl));    	non-compiled	[CE]  illegal  start  of  type	13	None	replace
129	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  if(gNorm  ==  0)  {  [BUGGY]      lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	add	if(gNorm  ==  0)  {	  if(dxNorm    ==    0)    {    if(dxNorm    ==    0)    {    	compilable	  [FE]  AssertionFailedError  	4	2	replace
130	[BUG]  [BUGGY]  if(gNorm  ==  0)  {  [FE]  AssertionFailedError  [FE]        AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  if(gNorm  ==  0)  {  [BUGGY]      lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	if(gNorm  ==  0)  {	  if(dxNorm    ==    0)    {    if(dxNorm    ==    0)    {    	compilable	  [FE]  AssertionFailedError  	4	2	replace
131	[BUG]  [BUGGY]  if(sum2)  {  lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  paru  =  Math.min(paru,  Math.max(gNorm,  parl));  }  [CE]  illegal  start  of  type  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  if(sum2)  {  lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  paru  =  Math.min(paru,  Math.max(gNorm,  parl));  }  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	if(sum2)  {  lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  paru  =  Math.min(paru,  Math.max(gNorm,  parl));  }	          lmPar    =    Math.min(paru,    Math.max(gNorm,    parl));    paru    =    Math.min(paru,    Math.max(gNorm,    parl));    	non-compiled	[CE]  illegal  start  of  type	19	None	replace
132	[BUG]  [BUGGY]  Parser  paru  =  Math.min(paru,  Math.max(gNorm,  parl));  [CE]  illegal  start  of  type  [FE]      AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  Parser  paru  =  Math.min(paru,  Math.max(gNorm,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	Parser  paru  =  Math.min(paru,  Math.max(gNorm,  parl));	          lmPar    =    Math.min(paru,    Math.max(gNorm,    parl));    paru    =    Math.min(paru,    Math.max(gNorm,    parl));    	non-compiled	[CE]  illegal  start  of  type	19	None	replace
133	[BUG]  [BUGGY]  if(sum2)  {  lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  paru  =  Math.min(paru,  Math.max(gNorm,  parl));  }  else  {  throw  new  IllegalArgumentException( " ");  }  [CE]  illegal  start  of  type  [FE]        AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  if(sum2)  {  lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  paru  =  Math.min(paru,  Math.max(gNorm,  parl));  }  else  {  throw  new  IllegalArgumentException( " ");  }  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	if(sum2)  {  lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  paru  =  Math.min(paru,  Math.max(gNorm,  parl));  }  else  {  throw  new  IllegalArgumentException( " ");  }	          lmPar    =    Math.min(paru,    Math.max(gNorm,    parl));    paru    =    Math.min(paru,    Math.max(gNorm,    parl));    	non-compiled	[CE]  illegal  start  of  type	19	None	replace
134	[BUG]  [BUGGY]  lmPar  =  Math.max(2.22e-308,  0.001  *  paru);  [CE]  illegal  start  of  type  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  lmPar  =  Math.max(2.22e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	lmPar  =  Math.max(2.22e-308,  0.001  *  paru);	          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    	non-compiled	[CE]  illegal  start  of  type	67	None	replace
135	[BUG]  [BUGGY]  LmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  [CE]  illegal  start  of  type  [FE]              AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  LmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	LmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));	          lmPar    =    Math.min(delta,    Math.max(dxNorm,    parl));    LmPar    =    Math.min(delta,    Math.max(dxNorm,    parl));    	non-compiled	[CE]  illegal  start  of  type	48	None	replace
136	[BUG]  [BUGGY]  LmPar  =  Math.min(delta,  Math.max(lmPar,  parl));  [CE]  illegal  start  of  type  [FE]                AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  LmPar  =  Math.min(delta,  Math.max(lmPar,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	LmPar  =  Math.min(delta,  Math.max(lmPar,  parl));	          lmPar    =    Math.min(delta,    Math.max(dxNorm,    parl));    LmPar    =    Math.min(delta,    Math.max(dxNorm,    parl));    	non-compiled	[CE]  illegal  start  of  type	48	None	replace
137	[BUG]  [BUGGY]  if(delta  ==  0.0)  {  if(dxNorm  ==  0.0)  {  [CE]  illegal  start  of  expression  [FE]        AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  if(delta  ==  0.0)  {  if(dxNorm  ==  0.0)  {  [BUGGY]      lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	if(delta  ==  0.0)  {  if(dxNorm  ==  0.0)  {	  if(dxNorm    ==    0.0)    {    if(dxNorm    ==    0.0)    {    	non-compiled	[CE]  illegal  start  of  expression	22	None	replace
138	[BUG]  [BUGGY]  lmPar  =  Math.max(0.0,  Math.max(1.0,  paru));  [CE]  illegal  start  of  type  [FE]          AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  lmPar  =  Math.max(0.0,  Math.max(1.0,  paru));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	lmPar  =  Math.max(0.0,  Math.max(1.0,  paru));	  lmPar    =    Math.max(0.0,    Math.max(1.0,    parl));    	non-compiled	[CE]  illegal  start  of  type	27	None	replace
139	[BUG]  [BUGGY]  lmPar  =  Math.max(0.0,  Math.max(2.0,  parl));  [CE]  illegal  start  of  type  [FE]            AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  lmPar  =  Math.max(0.0,  Math.max(2.0,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	lmPar  =  Math.max(0.0,  Math.max(2.0,  parl));	  lmPar    =    Math.max(0.0,    Math.max(1.0,    parl));    	non-compiled	[CE]  illegal  start  of  type	27	None	replace
140	[BUG]  [BUGGY]  lmPar  =  Math.max(0.0,  Math.max(0.5,  parl));  [CE]  illegal  start  of  type  [FE]              AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  lmPar  =  Math.max(0.0,  Math.max(0.5,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	lmPar  =  Math.max(0.0,  Math.max(0.5,  parl));	  lmPar    =    Math.max(0.0,    Math.max(1.0,    parl));    	non-compiled	[CE]  illegal  start  of  type	27	None	replace
141	[BUG]  [BUGGY]  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  LmPar  =  Math.max(2.251e-308,  0.001  *  paru);  [CE]  illegal  start  of  type  [FE]        AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  LmPar  =  Math.max(2.251e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  LmPar  =  Math.max(2.251e-308,  0.001  *  paru);	          lmPar    =    Math.max(2.251e-308,    0.001    *    paru);    LmPar    =    Math.max(2.251e-308,    0.001    *    paru);    	non-compiled	[CE]  illegal  start  of  type	114	None	replace
142	[BUG]  [BUGGY]  LmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [CE]  illegal  start  of  type  [FE]          AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  LmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	LmPar  =  Math.max(2.2251e-308,  0.001  *  paru);	          lmPar    =    Math.max(2.251e-308,    0.001    *    paru);    LmPar    =    Math.max(2.251e-308,    0.001    *    paru);    	non-compiled	[CE]  illegal  start  of  type	114	None	replace
143	[BUG]  [BUGGY]  double  lmPar  =  Math.min(paru,  Math.max(lmPar,  delta));  [CE]  illegal  start  of  type  [FE]              AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  double  lmPar  =  Math.min(paru,  Math.max(lmPar,  delta));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	double  lmPar  =  Math.min(paru,  Math.max(lmPar,  delta));	  double    lmPar    =    Math.min(delta,    Math.max(lmPar,    parl));    	non-compiled	[CE]  illegal  start  of  type	97	None	replace
144	[BUG]  [BUGGY]  lmPar  =  Math.min(paru,  Math.max(lmPar,  delta));  [CE]  illegal  start  of  type  [FE]                AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  lmPar  =  Math.min(paru,  Math.max(lmPar,  delta));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	lmPar  =  Math.min(paru,  Math.max(lmPar,  delta));	  double    lmPar    =    Math.min(delta,    Math.max(lmPar,    parl));    	non-compiled	[CE]  illegal  start  of  type	97	None	replace
145	[BUG]  [BUGGY]  lmPar  =  Math.min(gNorm,  Math.max(lmPar,  parl));  [CE]  illegal  start  of  type  [FE]        AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  lmPar  =  Math.min(gNorm,  Math.max(lmPar,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	lmPar  =  Math.min(gNorm,  Math.max(lmPar,  parl));	  lmPar    =    Math.min(sum2,    Math.max(gNorm,    parl));    	non-compiled	[CE]  illegal  start  of  type	1	None	replace
146	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2251e-308,.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	add	                lmPar        =        Math.max(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.2251e-308,.001    *    paru);    lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	70	5	add
147	[BUG]  [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2251e-308,.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,.001  *  paru);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2251e-308,.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.max(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.2251e-308,.001    *    paru);    lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	70	5	add
148	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2251e-308,.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	add	                lmPar        =        Math.max(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.2251e-308,.001    *    paru);    lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	70	5	add
149	[BUG]  [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2251e-308,.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,.001  *  paru);  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2251e-308,.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.max(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.2251e-308,.001    *    paru);    lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	70	5	add
150	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2251e-308,.001  *  paru);  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	add	                lmPar        =        Math.max(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.2251e-308,.001    *    paru);    lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	70	5	add
151	[BUG]  [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2251e-308,.001  *  paru);  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,.001  *  paru);  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2251e-308,.001  *  paru);  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.max(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.2251e-308,.001    *    paru);    lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	70	5	add
152	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2251e-308,.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	add	                lmPar        =        Math.max(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.2251e-308,.001    *    paru);    lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	70	5	add
153	[BUG]  [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2251e-308,.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,.001  *  paru);  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2251e-308,.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.max(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.2251e-308,.001    *    paru);    lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	70	5	add
154	[BUG]  [BUGGY]  LmPar  =  Math.max(2.0,  Math.max(1.0,  parl));  [CE]  illegal  start  of  type  [FE]            AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  LmPar  =  Math.max(2.0,  Math.max(1.0,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	LmPar  =  Math.max(2.0,  Math.max(1.0,  parl));	          lmPar    =    Math.max(2.0,    Math.max(1.0,    parl));    LmPar    =    Math.max(2.0,    Math.max(1.0,    parl));    	non-compiled	[CE]  illegal  start  of  type	65	None	replace
155	[BUG]  [BUGGY]  lmPar  =  Math.max(2.3251e-308,  0.001  *  paru);  [CE]  illegal  start  of  type  [FE]        AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  lmPar  =  Math.max(2.3251e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	lmPar  =  Math.max(2.3251e-308,  0.001  *  paru);	  lmPar    =    Math.max(2.2251e-308,    0.001    *    dxNorm);    	non-compiled	[CE]  illegal  start  of  type	110	None	replace
156	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.min(delta,    Math.max(dxNorm,    parl));    lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	add	                lmPar        =        Math.min(delta,        Math.max(dxNorm,        parl));        lmPar    =    Math.min(paru,    Math.max(dxNorm,    parl));    lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));	  	compilable	  [FE]  AssertionFailedError  	45	6	add
157	[BUG]  [BUGGY]          lmPar    =    Math.min(delta,    Math.max(dxNorm,    parl));    lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.min(delta,    Math.max(dxNorm,    parl));    lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.min(delta,        Math.max(dxNorm,        parl));        lmPar    =    Math.min(paru,    Math.max(dxNorm,    parl));    lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));	  	compilable	  [FE]  AssertionFailedError  	45	6	add
158	[BUG]  [BUGGY]          lmPar    =    Math.min(delta,    Math.max(dxNorm,    parl));    lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(dyNorm,  parl));  [CE]  cannot  find  symbol  dyNorm  [FE]      AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.min(delta,    Math.max(dxNorm,    parl));    lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(dyNorm,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.min(delta,        Math.max(dxNorm,        parl));        lmPar    =    Math.min(paru,    Math.max(dxNorm,    parl));    lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(dyNorm,  parl));	  	non-compiled	[CE]  cannot  find  symbol  dyNorm	45	None	add
159	[BUG]  [BUGGY]          lmPar    =    Math.min(delta,    Math.max(dxNorm,    parl));    lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(delta,  Math.max(dyNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  [CE]  cannot  find  symbol  dyNorm  [FE]        AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.min(delta,    Math.max(dxNorm,    parl));    lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(delta,  Math.max(dyNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.min(delta,        Math.max(dxNorm,        parl));        lmPar    =    Math.min(paru,    Math.max(dxNorm,    parl));    lmPar  =  Math.min(delta,  Math.max(dyNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));	  	non-compiled	[CE]  cannot  find  symbol  dyNorm	45	None	add
160	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.min(delta,    Math.max(dxNorm,    parl));    lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  paru  =  Math.min(delta,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	add	                lmPar        =        Math.min(delta,        Math.max(dxNorm,        parl));        lmPar    =    Math.min(paru,    Math.max(dxNorm,    parl));    paru  =  Math.min(delta,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));	  	compilable	  [FE]  AssertionFailedError  	45	5	add
161	[BUG]  [BUGGY]          lmPar    =    Math.min(delta,    Math.max(dxNorm,    parl));    lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  paru  =  Math.min(delta,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.min(delta,    Math.max(dxNorm,    parl));    lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  paru  =  Math.min(delta,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.min(delta,        Math.max(dxNorm,        parl));        lmPar    =    Math.min(paru,    Math.max(dxNorm,    parl));    paru  =  Math.min(delta,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));	  	compilable	  [FE]  AssertionFailedError  	45	5	add
162	[BUG]  [BUGGY]  if(dxNorm  <  =  0.0)  {  [CE]  illegal  start  of  expression  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  if(dxNorm  <  =  0.0)  {  [BUGGY]      lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	if(dxNorm  <  =  0.0)  {	  if(dxNorm    <    0.0)    {    	non-compiled	[CE]  illegal  start  of  expression	32	None	replace
163	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  if(dxNorm  <  0.0  ||  dxNorm  >  0.0)  {  [BUGGY]      lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	add	if(dxNorm  <  0.0  ||  dxNorm  >  0.0)  {	  if(dxNorm    <    0.0)    {    	compilable	  [FE]  AssertionFailedError  	32	5	replace
164	[BUG]  [BUGGY]  if(dxNorm  <  0.0  ||  dxNorm  >  0.0)  {  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  if(dxNorm  <  0.0  ||  dxNorm  >  0.0)  {  [BUGGY]      lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	if(dxNorm  <  0.0  ||  dxNorm  >  0.0)  {	  if(dxNorm    <    0.0)    {    	compilable	  [FE]  AssertionFailedError  	32	5	replace
165	[BUG]  [BUGGY]  double  lmPar  =  Math.min(gNorm,  Math.max(delta,  parl));  [CE]  illegal  start  of  type  [FE]              AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  double  lmPar  =  Math.min(gNorm,  Math.max(delta,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	double  lmPar  =  Math.min(gNorm,  Math.max(delta,  parl));	  double    lmPar    =    Math.min(paru,    Math.max(delta,    parl));    	non-compiled	[CE]  illegal  start  of  type	78	None	replace
166	[BUG]  [BUGGY]  if(gNorm!=  null  &&  dxNorm.equals(dxNorm))  {  [CE]  incomparable  types:  double  and  <null>  [FE]                AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  if(gNorm!=  null  &&  dxNorm.equals(dxNorm))  {  [BUGGY]      lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	if(gNorm!=  null  &&  dxNorm.equals(dxNorm))  {	  if(dxNorm!=    null    &&    dxNorm.equals(gNorm))    {    	non-compiled	[CE]  incomparable  types:  double  and  <null>	133	None	replace
167	[BUG]  [BUGGY]  if(dxNorm!=  null  ||  dxNorm.equals(gNorm))  {  [CE]  incomparable  types:  double  and  <null>  [FE]                  AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  if(dxNorm!=  null  ||  dxNorm.equals(gNorm))  {  [BUGGY]      lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	if(dxNorm!=  null  ||  dxNorm.equals(gNorm))  {	  if(dxNorm!=    null    &&    dxNorm.equals(gNorm))    {    	non-compiled	[CE]  incomparable  types:  double  and  <null>	133	None	replace
168	[BUG]  [BUGGY]  lmPar  =  Math.max(paru,  Math.max(lmPar,  gNorm));  [CE]  illegal  start  of  type  [FE]        AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  lmPar  =  Math.max(paru,  Math.max(lmPar,  gNorm));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	lmPar  =  Math.max(paru,  Math.max(lmPar,  gNorm));	  lmPar    =    Math.max(gNorm,    Math.max(lmPar,    parl));    	non-compiled	[CE]  illegal  start  of  type	121	None	replace
169	[BUG]  [BUGGY]          lmPar    =    Math.max(2.0,    Math.max(1.0,    parl));    double  lmPar  =  Math.max(2.0,  Math.max(1.0,  parl));  lmPar  =  Math.max(2.0,  Math.max(1.0,  parl));  double  lmPar  =  Math.max(2.0,  Math.max(1.0,  parl));  [CE]  variable  lmPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.max(2.0,    Math.max(1.0,    parl));    double  lmPar  =  Math.max(2.0,  Math.max(1.0,  parl));  lmPar  =  Math.max(2.0,  Math.max(1.0,  parl));  double  lmPar  =  Math.max(2.0,  Math.max(1.0,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.max(2.0,        Math.max(1.0,        parl));        double    lmPar    =    Math.max(2.0,    Math.max(1.0,    parl));    lmPar  =  Math.max(2.0,  Math.max(1.0,  parl));  double  lmPar  =  Math.max(2.0,  Math.max(1.0,  parl));	  	non-compiled	[CE]  variable  lmPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	63	None	add
170	[BUG]  [BUGGY]          lmPar    =    Math.max(2.0,    Math.max(1.0,    parl));    double  lmPar  =  Math.max(2.0,  Math.max(1.0,  parl));  double  lmPar  =  Math.max(2.0,  Math.max(1.0,  parl));  double  lmPar  =  Math.max(2.0,  Math.max(1.0,  parl));  [CE]  variable  lmPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]      AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.max(2.0,    Math.max(1.0,    parl));    double  lmPar  =  Math.max(2.0,  Math.max(1.0,  parl));  double  lmPar  =  Math.max(2.0,  Math.max(1.0,  parl));  double  lmPar  =  Math.max(2.0,  Math.max(1.0,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.max(2.0,        Math.max(1.0,        parl));        double    lmPar    =    Math.max(2.0,    Math.max(1.0,    parl));    double  lmPar  =  Math.max(2.0,  Math.max(1.0,  parl));  double  lmPar  =  Math.max(2.0,  Math.max(1.0,  parl));	  	non-compiled	[CE]  variable  lmPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	63	None	add
171	[BUG]  [BUGGY]          lmPar    =    Math.max(2.0,    Math.max(1.0,    parl));    double  lmPar  =  Math.max(2.0,  Math.max(1.0,  parl));  lmPar  =  Math.max(1.0,  Math.max(1.0,  parl));  double  lmPar  =  Math.max(2.0,  Math.max(1.0,  parl));  [CE]  variable  lmPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]        AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.max(2.0,    Math.max(1.0,    parl));    double  lmPar  =  Math.max(2.0,  Math.max(1.0,  parl));  lmPar  =  Math.max(1.0,  Math.max(1.0,  parl));  double  lmPar  =  Math.max(2.0,  Math.max(1.0,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.max(2.0,        Math.max(1.0,        parl));        double    lmPar    =    Math.max(2.0,    Math.max(1.0,    parl));    lmPar  =  Math.max(1.0,  Math.max(1.0,  parl));  double  lmPar  =  Math.max(2.0,  Math.max(1.0,  parl));	  	non-compiled	[CE]  variable  lmPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	63	None	add
172	[BUG]  [BUGGY]          lmPar    =    Math.max(2.0,    Math.max(1.0,    parl));    double  lmPar  =  Math.max(2.0,  Math.max(1.0,  parl));  lmPar  =  Math.min(2.0,  Math.max(1.0,  parl));  double  lmPar  =  Math.max(2.0,  Math.max(1.0,  parl));  [CE]  variable  lmPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]          AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.max(2.0,    Math.max(1.0,    parl));    double  lmPar  =  Math.max(2.0,  Math.max(1.0,  parl));  lmPar  =  Math.min(2.0,  Math.max(1.0,  parl));  double  lmPar  =  Math.max(2.0,  Math.max(1.0,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.max(2.0,        Math.max(1.0,        parl));        double    lmPar    =    Math.max(2.0,    Math.max(1.0,    parl));    lmPar  =  Math.min(2.0,  Math.max(1.0,  parl));  double  lmPar  =  Math.max(2.0,  Math.max(1.0,  parl));	  	non-compiled	[CE]  variable  lmPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	63	None	add
173	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.min(paru,    Math.max(lmPar,    parl));    paru  =  Math.min(paru,  Math.max(lmPar,  parl));  lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  paru  =  Math.min(paru,  Math.max(lmPar,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	add	                lmPar        =        Math.min(paru,        Math.max(lmPar,        parl));        paru    =    Math.min(paru,    Math.max(lmPar,    parl));    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  paru  =  Math.min(paru,  Math.max(lmPar,  parl));	  	compilable	  [FE]  AssertionFailedError  	90	2	add
174	[BUG]  [BUGGY]          lmPar    =    Math.min(paru,    Math.max(lmPar,    parl));    paru  =  Math.min(paru,  Math.max(lmPar,  parl));  lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  paru  =  Math.min(paru,  Math.max(lmPar,  parl));  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.min(paru,    Math.max(lmPar,    parl));    paru  =  Math.min(paru,  Math.max(lmPar,  parl));  lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  paru  =  Math.min(paru,  Math.max(lmPar,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.min(paru,        Math.max(lmPar,        parl));        paru    =    Math.min(paru,    Math.max(lmPar,    parl));    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  paru  =  Math.min(paru,  Math.max(lmPar,  parl));	  	compilable	  [FE]  AssertionFailedError  	90	2	add
175	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.min(paru,    Math.max(lmPar,    parl));    paru  =  Math.min(paru,  Math.max(lmPar,  parl));  paru  =  Math.min(paru,  Math.max(lmPar,  parl));  paru  =  Math.min(paru,  Math.max(lmPar,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	add	                lmPar        =        Math.min(paru,        Math.max(lmPar,        parl));        paru    =    Math.min(paru,    Math.max(lmPar,    parl));    paru  =  Math.min(paru,  Math.max(lmPar,  parl));  paru  =  Math.min(paru,  Math.max(lmPar,  parl));	  	compilable	  [FE]  AssertionFailedError  	90	2	add
176	[BUG]  [BUGGY]          lmPar    =    Math.min(paru,    Math.max(lmPar,    parl));    paru  =  Math.min(paru,  Math.max(lmPar,  parl));  paru  =  Math.min(paru,  Math.max(lmPar,  parl));  paru  =  Math.min(paru,  Math.max(lmPar,  parl));  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.min(paru,    Math.max(lmPar,    parl));    paru  =  Math.min(paru,  Math.max(lmPar,  parl));  paru  =  Math.min(paru,  Math.max(lmPar,  parl));  paru  =  Math.min(paru,  Math.max(lmPar,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.min(paru,        Math.max(lmPar,        parl));        paru    =    Math.min(paru,    Math.max(lmPar,    parl));    paru  =  Math.min(paru,  Math.max(lmPar,  parl));  paru  =  Math.min(paru,  Math.max(lmPar,  parl));	  	compilable	  [FE]  AssertionFailedError  	90	2	add
177	[BUG]  [BUGGY]          lmPar    =    Math.min(paru,    Math.max(lmPar,    parl));    paru  =  Math.min(paru,  Math.max(lmPar,  parl));  LmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  paru  =  Math.min(paru,  Math.max(lmPar,  parl));  [CE]  cannot  find  symbol  LmPar  [FE]        AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.min(paru,    Math.max(lmPar,    parl));    paru  =  Math.min(paru,  Math.max(lmPar,  parl));  LmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  paru  =  Math.min(paru,  Math.max(lmPar,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.min(paru,        Math.max(lmPar,        parl));        paru    =    Math.min(paru,    Math.max(lmPar,    parl));    LmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  paru  =  Math.min(paru,  Math.max(lmPar,  parl));	  	non-compiled	[CE]  cannot  find  symbol  LmPar	90	None	add
178	[BUG]  [BUGGY]  lmPar  =  Math.max(1.0,  Math.max(0.0,  paru));  [CE]  illegal  start  of  type  [FE]        AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  lmPar  =  Math.max(1.0,  Math.max(0.0,  paru));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	lmPar  =  Math.max(1.0,  Math.max(0.0,  paru));	  lmPar    =    Math.max(1.0,    Math.max(1.0,    paru));    	non-compiled	[CE]  illegal  start  of  type	124	None	replace
179	[BUG]  [BUGGY]  lmPar  =  Math.max(1.0,  Math.max(2.0,  paru));  [CE]  illegal  start  of  type  [FE]          AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  lmPar  =  Math.max(1.0,  Math.max(2.0,  paru));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	lmPar  =  Math.max(1.0,  Math.max(2.0,  paru));	  lmPar    =    Math.max(1.0,    Math.max(1.0,    paru));    	non-compiled	[CE]  illegal  start  of  type	124	None	replace
180	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.max(2.0,    Math.max(1.0,    parl));    paru  =  Math.max(2.0,  Math.max(1.0,  parl));  lmPar  =  Math.max(2.0,  Math.max(1.0,  parl));  paru  =  Math.max(2.0,  Math.max(1.0,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	add	                lmPar        =        Math.max(2.0,        Math.max(1.0,        parl));        paru    =    Math.max(2.0,    Math.max(1.0,    parl));    lmPar  =  Math.max(2.0,  Math.max(1.0,  parl));  paru  =  Math.max(2.0,  Math.max(1.0,  parl));	  	compilable	  [FE]  AssertionFailedError  	126	5	add
181	[BUG]  [BUGGY]          lmPar    =    Math.max(2.0,    Math.max(1.0,    parl));    paru  =  Math.max(2.0,  Math.max(1.0,  parl));  lmPar  =  Math.max(2.0,  Math.max(1.0,  parl));  paru  =  Math.max(2.0,  Math.max(1.0,  parl));  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.max(2.0,    Math.max(1.0,    parl));    paru  =  Math.max(2.0,  Math.max(1.0,  parl));  lmPar  =  Math.max(2.0,  Math.max(1.0,  parl));  paru  =  Math.max(2.0,  Math.max(1.0,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.max(2.0,        Math.max(1.0,        parl));        paru    =    Math.max(2.0,    Math.max(1.0,    parl));    lmPar  =  Math.max(2.0,  Math.max(1.0,  parl));  paru  =  Math.max(2.0,  Math.max(1.0,  parl));	  	compilable	  [FE]  AssertionFailedError  	126	5	add
182	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.max(2.0,    Math.max(1.0,    parl));    paru  =  Math.max(2.0,  Math.max(1.0,  parl));  lmPar  =  Math.max(1.0,  Math.max(1.0,  parl));  paru  =  Math.max(2.0,  Math.max(1.0,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	add	                lmPar        =        Math.max(2.0,        Math.max(1.0,        parl));        paru    =    Math.max(2.0,    Math.max(1.0,    parl));    lmPar  =  Math.max(1.0,  Math.max(1.0,  parl));  paru  =  Math.max(2.0,  Math.max(1.0,  parl));	  	compilable	  [FE]  AssertionFailedError  	126	5	add
183	[BUG]  [BUGGY]          lmPar    =    Math.max(2.0,    Math.max(1.0,    parl));    paru  =  Math.max(2.0,  Math.max(1.0,  parl));  lmPar  =  Math.max(1.0,  Math.max(1.0,  parl));  paru  =  Math.max(2.0,  Math.max(1.0,  parl));  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.max(2.0,    Math.max(1.0,    parl));    paru  =  Math.max(2.0,  Math.max(1.0,  parl));  lmPar  =  Math.max(1.0,  Math.max(1.0,  parl));  paru  =  Math.max(2.0,  Math.max(1.0,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.max(2.0,        Math.max(1.0,        parl));        paru    =    Math.max(2.0,    Math.max(1.0,    parl));    lmPar  =  Math.max(1.0,  Math.max(1.0,  parl));  paru  =  Math.max(2.0,  Math.max(1.0,  parl));	  	compilable	  [FE]  AssertionFailedError  	126	5	add
184	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.max(2.0,    Math.max(1.0,    parl));    paru  =  Math.max(2.0,  Math.max(1.0,  parl));  paru  =  Math.max(2.0,  Math.max(1.0,  parl));  paru  =  Math.max(2.0,  Math.max(1.0,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	add	                lmPar        =        Math.max(2.0,        Math.max(1.0,        parl));        paru    =    Math.max(2.0,    Math.max(1.0,    parl));    paru  =  Math.max(2.0,  Math.max(1.0,  parl));  paru  =  Math.max(2.0,  Math.max(1.0,  parl));	  	compilable	  [FE]  AssertionFailedError  	126	5	add
185	[BUG]  [BUGGY]          lmPar    =    Math.max(2.0,    Math.max(1.0,    parl));    paru  =  Math.max(2.0,  Math.max(1.0,  parl));  paru  =  Math.max(2.0,  Math.max(1.0,  parl));  paru  =  Math.max(2.0,  Math.max(1.0,  parl));  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.max(2.0,    Math.max(1.0,    parl));    paru  =  Math.max(2.0,  Math.max(1.0,  parl));  paru  =  Math.max(2.0,  Math.max(1.0,  parl));  paru  =  Math.max(2.0,  Math.max(1.0,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.max(2.0,        Math.max(1.0,        parl));        paru    =    Math.max(2.0,    Math.max(1.0,    parl));    paru  =  Math.max(2.0,  Math.max(1.0,  parl));  paru  =  Math.max(2.0,  Math.max(1.0,  parl));	  	compilable	  [FE]  AssertionFailedError  	126	5	add
186	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.max(2.0,    Math.max(1.0,    parl));    paru  =  Math.max(2.0,  Math.max(1.0,  parl));  lmPar  =  Math.min(2.0,  Math.max(1.0,  parl));  paru  =  Math.max(2.0,  Math.max(1.0,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	add	                lmPar        =        Math.max(2.0,        Math.max(1.0,        parl));        paru    =    Math.max(2.0,    Math.max(1.0,    parl));    lmPar  =  Math.min(2.0,  Math.max(1.0,  parl));  paru  =  Math.max(2.0,  Math.max(1.0,  parl));	  	compilable	  [FE]  AssertionFailedError  	126	5	add
187	[BUG]  [BUGGY]          lmPar    =    Math.max(2.0,    Math.max(1.0,    parl));    paru  =  Math.max(2.0,  Math.max(1.0,  parl));  lmPar  =  Math.min(2.0,  Math.max(1.0,  parl));  paru  =  Math.max(2.0,  Math.max(1.0,  parl));  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.max(2.0,    Math.max(1.0,    parl));    paru  =  Math.max(2.0,  Math.max(1.0,  parl));  lmPar  =  Math.min(2.0,  Math.max(1.0,  parl));  paru  =  Math.max(2.0,  Math.max(1.0,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.max(2.0,        Math.max(1.0,        parl));        paru    =    Math.max(2.0,    Math.max(1.0,    parl));    lmPar  =  Math.min(2.0,  Math.max(1.0,  parl));  paru  =  Math.max(2.0,  Math.max(1.0,  parl));	  	compilable	  [FE]  AssertionFailedError  	126	5	add
188	[BUG]  [BUGGY]  double  lmPar  =  Math.min(delta,  Math.max(gNorm,  parl));  [CE]  illegal  start  of  type  [FE]                AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  double  lmPar  =  Math.min(delta,  Math.max(gNorm,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	double  lmPar  =  Math.min(delta,  Math.max(gNorm,  parl));	  double    lmPar    =    Math.min(paru,    Math.max(gNorm,    parl));    	non-compiled	[CE]  illegal  start  of  type	79	None	replace
189	[BUG]  [BUGGY]  double  lmPar  =  Math.min(paru,  Math.max(gNorm,  dxNorm));  [CE]  illegal  start  of  type  [FE]                  AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  double  lmPar  =  Math.min(paru,  Math.max(gNorm,  dxNorm));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	double  lmPar  =  Math.min(paru,  Math.max(gNorm,  dxNorm));	  double    lmPar    =    Math.min(paru,    Math.max(gNorm,    parl));    	non-compiled	[CE]  illegal  start  of  type	79	None	replace
190	[BUG]  [BUGGY]  parl  =  Math.max(2.0,  Math.max(1.0,  parl));  [CE]  illegal  start  of  type  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  parl  =  Math.max(2.0,  Math.max(1.0,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	parl  =  Math.max(2.0,  Math.max(1.0,  parl));	          lmPar    =    Math.max(2.0,    Math.max(1.0,    parl));    parl    =    Math.max(2.0,    Math.max(1.0,    parl));    	non-compiled	[CE]  illegal  start  of  type	109	None	replace
191	[BUG]  [BUGGY]  Parl  parl  =  Math.max(2.0,  Math.max(1.0,  parl));  [CE]  illegal  start  of  type  [FE]      AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  Parl  parl  =  Math.max(2.0,  Math.max(1.0,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	Parl  parl  =  Math.max(2.0,  Math.max(1.0,  parl));	          lmPar    =    Math.max(2.0,    Math.max(1.0,    parl));    parl    =    Math.max(2.0,    Math.max(1.0,    parl));    	non-compiled	[CE]  illegal  start  of  type	109	None	replace
192	[BUG]  [BUGGY]  lmPar  =  Math.max(2.2251e-308,.001  *  paru);  [CE]  illegal  start  of  type  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  lmPar  =  Math.max(2.2251e-308,.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	lmPar  =  Math.max(2.2251e-308,.001  *  paru);	          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar    =    Math.max(2.2251e-308,.001    *    paru);    	non-compiled	[CE]  illegal  start  of  type	71	None	replace
193	[BUG]  [BUGGY]  lmPar  =  Math.max(2.22e-308,.001  *  paru);  [CE]  illegal  start  of  type  [FE]      AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  lmPar  =  Math.max(2.22e-308,.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	lmPar  =  Math.max(2.22e-308,.001  *  paru);	          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar    =    Math.max(2.2251e-308,.001    *    paru);    	non-compiled	[CE]  illegal  start  of  type	71	None	replace
194	[BUG]  [BUGGY]  lmPar  =  Math.max(1.0,  Math.max(1.0,  parl));  [CE]  illegal  start  of  type  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  lmPar  =  Math.max(1.0,  Math.max(1.0,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	lmPar  =  Math.max(1.0,  Math.max(1.0,  parl));	          lmPar    =    Math.max(2.0,    Math.max(1.0,    parl));    lmPar    =    Math.max(2.0,    Math.max(1.0,    parl));    	non-compiled	[CE]  illegal  start  of  type	62	None	replace
195	[BUG]  [BUGGY]          lmPar    =    Math.min(delta,    Math.max(dxNorm,    parl));    double  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  double  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  [CE]  variable  lmPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.min(delta,    Math.max(dxNorm,    parl));    double  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  double  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.min(delta,        Math.max(dxNorm,        parl));        double    lmPar    =    Math.min(delta,    Math.max(dxNorm,    parl));    lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  double  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));	  	non-compiled	[CE]  variable  lmPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	98	None	add
196	[BUG]  [BUGGY]          lmPar    =    Math.min(delta,    Math.max(dxNorm,    parl));    double  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  double  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  [CE]  variable  lmPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]      AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.min(delta,    Math.max(dxNorm,    parl));    double  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  double  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.min(delta,        Math.max(dxNorm,        parl));        double    lmPar    =    Math.min(delta,    Math.max(dxNorm,    parl));    lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  double  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));	  	non-compiled	[CE]  variable  lmPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	98	None	add
197	[BUG]  [BUGGY]          lmPar    =    Math.min(delta,    Math.max(dxNorm,    parl));    double  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  double  lmPar  =  Math.min(delta,  Math.max(dyNorm,  parl));  [CE]  variable  lmPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]        AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.min(delta,    Math.max(dxNorm,    parl));    double  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  double  lmPar  =  Math.min(delta,  Math.max(dyNorm,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.min(delta,        Math.max(dxNorm,        parl));        double    lmPar    =    Math.min(delta,    Math.max(dxNorm,    parl));    lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  double  lmPar  =  Math.min(delta,  Math.max(dyNorm,  parl));	  	non-compiled	[CE]  variable  lmPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	98	None	add
198	[BUG]  [BUGGY]          lmPar    =    Math.min(delta,    Math.max(dxNorm,    parl));    double  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  double  lmPar  =  Math.min(delta,  Math.max(dmPar,  parl));  [CE]  variable  lmPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]          AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.min(delta,    Math.max(dxNorm,    parl));    double  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  double  lmPar  =  Math.min(delta,  Math.max(dmPar,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.min(delta,        Math.max(dxNorm,        parl));        double    lmPar    =    Math.min(delta,    Math.max(dxNorm,    parl));    lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  double  lmPar  =  Math.min(delta,  Math.max(dmPar,  parl));	  	non-compiled	[CE]  variable  lmPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	98	None	add
199	[BUG]  [BUGGY]          lmPar    =    Math.min(delta,    Math.max(dxNorm,    parl));    double  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  double  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  double  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  [CE]  variable  lmPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]            AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.min(delta,    Math.max(dxNorm,    parl));    double  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  double  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  double  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.min(delta,        Math.max(dxNorm,        parl));        double    lmPar    =    Math.min(delta,    Math.max(dxNorm,    parl));    double  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  double  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));	  	non-compiled	[CE]  variable  lmPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	98	None	add
200	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	add	                lmPar        =        Math.max(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	66	5	add
201	[BUG]  [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.max(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	66	5	add
202	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	add	                lmPar        =        Math.max(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	66	5	add
203	[BUG]  [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.max(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	66	5	add
204	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	add	                lmPar        =        Math.max(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	66	5	add
205	[BUG]  [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.max(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	66	5	add
206	[BUG]  [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  Paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [CE]  cannot  find  symbol  Paru  [FE]          AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  Paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.max(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2251e-308,  0.001  *  Paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);	  	non-compiled	[CE]  cannot  find  symbol  Paru	66	None	add
207	[BUG]  [BUGGY]  if(dxNorm  >  0.0)  {  if(dxNorm  >  0.0)  {  [CE]  illegal  start  of  expression  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  if(dxNorm  >  0.0)  {  if(dxNorm  >  0.0)  {  [BUGGY]      lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	if(dxNorm    >    0.0)    {    if(dxNorm  >  0.0)  {	  	non-compiled	[CE]  illegal  start  of  expression	29	None	add
208	[BUG]  [BUGGY]  if(dxNorm  >  0.0)  {  If(dxNorm  >  0.0)  {  [CE]  ';'  expected  [FE]      AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  if(dxNorm  >  0.0)  {  If(dxNorm  >  0.0)  {  [BUGGY]      lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	if(dxNorm    >    0.0)    {    If(dxNorm  >  0.0)  {	  	non-compiled	[CE]  ';'  expected	29	None	add
209	[BUG]  [BUGGY]  if(dxNorm  >  0.0)  {  (dxNorm  >  0.0)  {  [CE]  not  a  statement  [FE]        AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  if(dxNorm  >  0.0)  {  (dxNorm  >  0.0)  {  [BUGGY]      lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	if(dxNorm    >    0.0)    {    (dxNorm  >  0.0)  {	  	non-compiled	[CE]  not  a  statement	29	None	add
210	[BUG]  [BUGGY]  if(sum2)  {  lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  }  [CE]  illegal  start  of  type  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  if(sum2)  {  lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  }  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	if(sum2)  {  lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  }	          lmPar    =    Math.min(paru,    Math.max(gNorm,    parl));    double    lmPar    =    Math.min(paru,    Math.max(gNorm,    parl));    	non-compiled	[CE]  illegal  start  of  type	113	None	replace
211	[BUG]  [BUGGY]  double  lmPar  =  Math.max(2.0,  Math.max(1.0,  parl));  [CE]  illegal  start  of  type  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  double  lmPar  =  Math.max(2.0,  Math.max(1.0,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	double  lmPar  =  Math.max(2.0,  Math.max(1.0,  parl));	          lmPar    =    Math.max(2.0,    Math.max(1.0,    parl));    double    lmPar    =    Math.max(2.0,    Math.max(1.0,    parl));    	non-compiled	[CE]  illegal  start  of  type	64	None	replace
212	[BUG]  [BUGGY]  if(dxNorm!=  null  ||  dxNorm.length  >  0)  {  [CE]  incomparable  types:  double  and  <null>  [FE]            AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  if(dxNorm!=  null  ||  dxNorm.length  >  0)  {  [BUGGY]      lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	if(dxNorm!=  null  ||  dxNorm.length  >  0)  {	  if(dxNorm!=    null    &&    dxNorm.length    >    0)    {    	non-compiled	[CE]  incomparable  types:  double  and  <null>	131	None	replace
213	[BUG]  [BUGGY]  if(dxNorm!=  null  &&  dxNorm.length  >  1)  {  [CE]  incomparable  types:  double  and  <null>  [FE]              AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  if(dxNorm!=  null  &&  dxNorm.length  >  1)  {  [BUGGY]      lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	if(dxNorm!=  null  &&  dxNorm.length  >  1)  {	  if(dxNorm!=    null    &&    dxNorm.length    >    0)    {    	non-compiled	[CE]  incomparable  types:  double  and  <null>	131	None	replace
214	[BUG]  [BUGGY]  if(gNorm!=  null  &&  dxNorm.length  >  0)  {  [CE]  incomparable  types:  double  and  <null>  [FE]                AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  if(gNorm!=  null  &&  dxNorm.length  >  0)  {  [BUGGY]      lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	if(gNorm!=  null  &&  dxNorm.length  >  0)  {	  if(dxNorm!=    null    &&    dxNorm.length    >    0)    {    	non-compiled	[CE]  incomparable  types:  double  and  <null>	131	None	replace
215	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.max(2.0,    Math.max(1.0,    parl));    parl  =  Math.max(2.0,  Math.max(1.0,  parl));  lmPar  =  Math.max(2.0,  Math.max(1.0,  parl));  parl  =  Math.max(2.0,  Math.max(1.0,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	add	                lmPar        =        Math.max(2.0,        Math.max(1.0,        parl));        parl    =    Math.max(2.0,    Math.max(1.0,    parl));    lmPar  =  Math.max(2.0,  Math.max(1.0,  parl));  parl  =  Math.max(2.0,  Math.max(1.0,  parl));	  	compilable	  [FE]  AssertionFailedError  	108	13	add
216	[BUG]  [BUGGY]          lmPar    =    Math.max(2.0,    Math.max(1.0,    parl));    parl  =  Math.max(2.0,  Math.max(1.0,  parl));  lmPar  =  Math.max(2.0,  Math.max(1.0,  parl));  parl  =  Math.max(2.0,  Math.max(1.0,  parl));  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.max(2.0,    Math.max(1.0,    parl));    parl  =  Math.max(2.0,  Math.max(1.0,  parl));  lmPar  =  Math.max(2.0,  Math.max(1.0,  parl));  parl  =  Math.max(2.0,  Math.max(1.0,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.max(2.0,        Math.max(1.0,        parl));        parl    =    Math.max(2.0,    Math.max(1.0,    parl));    lmPar  =  Math.max(2.0,  Math.max(1.0,  parl));  parl  =  Math.max(2.0,  Math.max(1.0,  parl));	  	compilable	  [FE]  AssertionFailedError  	108	13	add
217	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.max(2.0,    Math.max(1.0,    parl));    parl  =  Math.max(2.0,  Math.max(1.0,  parl));  lmPar  =  Math.max(1.0,  Math.max(1.0,  parl));  parl  =  Math.max(2.0,  Math.max(1.0,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	add	                lmPar        =        Math.max(2.0,        Math.max(1.0,        parl));        parl    =    Math.max(2.0,    Math.max(1.0,    parl));    lmPar  =  Math.max(1.0,  Math.max(1.0,  parl));  parl  =  Math.max(2.0,  Math.max(1.0,  parl));	  	compilable	  [FE]  AssertionFailedError  	108	13	add
218	[BUG]  [BUGGY]          lmPar    =    Math.max(2.0,    Math.max(1.0,    parl));    parl  =  Math.max(2.0,  Math.max(1.0,  parl));  lmPar  =  Math.max(1.0,  Math.max(1.0,  parl));  parl  =  Math.max(2.0,  Math.max(1.0,  parl));  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.max(2.0,    Math.max(1.0,    parl));    parl  =  Math.max(2.0,  Math.max(1.0,  parl));  lmPar  =  Math.max(1.0,  Math.max(1.0,  parl));  parl  =  Math.max(2.0,  Math.max(1.0,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.max(2.0,        Math.max(1.0,        parl));        parl    =    Math.max(2.0,    Math.max(1.0,    parl));    lmPar  =  Math.max(1.0,  Math.max(1.0,  parl));  parl  =  Math.max(2.0,  Math.max(1.0,  parl));	  	compilable	  [FE]  AssertionFailedError  	108	13	add
219	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.max(2.0,    Math.max(1.0,    parl));    parl  =  Math.max(2.0,  Math.max(1.0,  parl));  lmPar  =  Math.min(2.0,  Math.max(1.0,  parl));  parl  =  Math.max(2.0,  Math.max(1.0,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	add	                lmPar        =        Math.max(2.0,        Math.max(1.0,        parl));        parl    =    Math.max(2.0,    Math.max(1.0,    parl));    lmPar  =  Math.min(2.0,  Math.max(1.0,  parl));  parl  =  Math.max(2.0,  Math.max(1.0,  parl));	  	compilable	  [FE]  AssertionFailedError  	108	13	add
220	[BUG]  [BUGGY]          lmPar    =    Math.max(2.0,    Math.max(1.0,    parl));    parl  =  Math.max(2.0,  Math.max(1.0,  parl));  lmPar  =  Math.min(2.0,  Math.max(1.0,  parl));  parl  =  Math.max(2.0,  Math.max(1.0,  parl));  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.max(2.0,    Math.max(1.0,    parl));    parl  =  Math.max(2.0,  Math.max(1.0,  parl));  lmPar  =  Math.min(2.0,  Math.max(1.0,  parl));  parl  =  Math.max(2.0,  Math.max(1.0,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.max(2.0,        Math.max(1.0,        parl));        parl    =    Math.max(2.0,    Math.max(1.0,    parl));    lmPar  =  Math.min(2.0,  Math.max(1.0,  parl));  parl  =  Math.max(2.0,  Math.max(1.0,  parl));	  	compilable	  [FE]  AssertionFailedError  	108	13	add
221	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.max(2.0,    Math.max(1.0,    parl));    parl  =  Math.max(2.0,  Math.max(1.0,  parl));  parl  =  Math.max(2.0,  Math.max(1.0,  parl));  parl  =  Math.max(2.0,  Math.max(1.0,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	add	                lmPar        =        Math.max(2.0,        Math.max(1.0,        parl));        parl    =    Math.max(2.0,    Math.max(1.0,    parl));    parl  =  Math.max(2.0,  Math.max(1.0,  parl));  parl  =  Math.max(2.0,  Math.max(1.0,  parl));	  	compilable	  [FE]  AssertionFailedError  	108	13	add
222	[BUG]  [BUGGY]          lmPar    =    Math.max(2.0,    Math.max(1.0,    parl));    parl  =  Math.max(2.0,  Math.max(1.0,  parl));  parl  =  Math.max(2.0,  Math.max(1.0,  parl));  parl  =  Math.max(2.0,  Math.max(1.0,  parl));  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.max(2.0,    Math.max(1.0,    parl));    parl  =  Math.max(2.0,  Math.max(1.0,  parl));  parl  =  Math.max(2.0,  Math.max(1.0,  parl));  parl  =  Math.max(2.0,  Math.max(1.0,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.max(2.0,        Math.max(1.0,        parl));        parl    =    Math.max(2.0,    Math.max(1.0,    parl));    parl  =  Math.max(2.0,  Math.max(1.0,  parl));  parl  =  Math.max(2.0,  Math.max(1.0,  parl));	  	compilable	  [FE]  AssertionFailedError  	108	13	add
223	[BUG]  [BUGGY]  double  dxNorm  =  Math.sqrt(delta);  [CE]  illegal  start  of  type  [FE]                      AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  double  dxNorm  =  Math.sqrt(delta);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	double  dxNorm  =  Math.sqrt(delta);	  double    dxNorm    =    Math.sqrt(sum1);    	non-compiled	[CE]  illegal  start  of  type	77	None	replace
224	[BUG]  [BUGGY]  lmPar  =  Math.max(2.0,  Math.max(0.0,  paru));  [CE]  illegal  start  of  type  [FE]        AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  lmPar  =  Math.max(2.0,  Math.max(0.0,  paru));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	lmPar  =  Math.max(2.0,  Math.max(0.0,  paru));	  lmPar    =    Math.max(2.0,    Math.max(1.0,    paru));    	non-compiled	[CE]  illegal  start  of  type	26	None	replace
225	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.max(2.251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	add	                lmPar        =        Math.max(2.251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	53	5	add
226	[BUG]  [BUGGY]          lmPar    =    Math.max(2.251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.max(2.251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.max(2.251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	53	5	add
227	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.max(2.251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	add	                lmPar        =        Math.max(2.251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	53	5	add
228	[BUG]  [BUGGY]          lmPar    =    Math.max(2.251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.max(2.251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.max(2.251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	53	5	add
229	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.max(2.251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.253e-308,  0.001  *  paru);  lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	add	                lmPar        =        Math.max(2.251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.253e-308,  0.001  *  paru);  lmPar  =  Math.max(2.252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	53	5	add
230	[BUG]  [BUGGY]          lmPar    =    Math.max(2.251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.253e-308,  0.001  *  paru);  lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.max(2.251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.253e-308,  0.001  *  paru);  lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.max(2.251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.253e-308,  0.001  *  paru);  lmPar  =  Math.max(2.252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	53	5	add
231	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.max(2.251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.51e-308,  0.001  *  paru);  lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	add	                lmPar        =        Math.max(2.251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.51e-308,  0.001  *  paru);  lmPar  =  Math.max(2.252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	53	5	add
232	[BUG]  [BUGGY]          lmPar    =    Math.max(2.251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.51e-308,  0.001  *  paru);  lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.max(2.251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.51e-308,  0.001  *  paru);  lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.max(2.251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.51e-308,  0.001  *  paru);  lmPar  =  Math.max(2.252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	53	5	add
233	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.min(paru,    Math.max(lmPar,    parl));    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	add	                lmPar        =        Math.min(paru,        Math.max(lmPar,        parl));        lmPar    =    Math.min(paru,    Math.max(lmPar,    parl));    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));	  	compilable	  [FE]  AssertionFailedError  	86	2	add
234	[BUG]  [BUGGY]          lmPar    =    Math.min(paru,    Math.max(lmPar,    parl));    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.min(paru,    Math.max(lmPar,    parl));    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.min(paru,        Math.max(lmPar,        parl));        lmPar    =    Math.min(paru,    Math.max(lmPar,    parl));    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));	  	compilable	  [FE]  AssertionFailedError  	86	2	add
235	[BUG]  [BUGGY]          lmPar    =    Math.min(paru,    Math.max(lmPar,    parl));    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  LmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  [CE]  cannot  find  symbol  LmPar  [FE]      AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.min(paru,    Math.max(lmPar,    parl));    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  LmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.min(paru,        Math.max(lmPar,        parl));        lmPar    =    Math.min(paru,    Math.max(lmPar,    parl));    LmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));	  	non-compiled	[CE]  cannot  find  symbol  LmPar	86	None	add
236	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.min(paru,    Math.max(lmPar,    parl));    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  paru  =  Math.min(paru,  Math.max(lmPar,  parl));  lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	add	                lmPar        =        Math.min(paru,        Math.max(lmPar,        parl));        lmPar    =    Math.min(paru,    Math.max(lmPar,    parl));    paru  =  Math.min(paru,  Math.max(lmPar,  parl));  lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));	  	compilable	  [FE]  AssertionFailedError  	86	2	add
237	[BUG]  [BUGGY]          lmPar    =    Math.min(paru,    Math.max(lmPar,    parl));    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  paru  =  Math.min(paru,  Math.max(lmPar,  parl));  lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.min(paru,    Math.max(lmPar,    parl));    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  paru  =  Math.min(paru,  Math.max(lmPar,  parl));  lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.min(paru,        Math.max(lmPar,        parl));        lmPar    =    Math.min(paru,    Math.max(lmPar,    parl));    paru  =  Math.min(paru,  Math.max(lmPar,  parl));  lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));	  	compilable	  [FE]  AssertionFailedError  	86	2	add
238	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]              AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  if(gNorm!=  0)  {  [BUGGY]      lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	add	if(gNorm!=  0)  {	  if(dxNorm!=    0)    {    if(dxNorm    ==    0)    {    	compilable	  [FE]  AssertionFailedError  	85	5	replace
239	[BUG]  [BUGGY]  if(gNorm!=  0)  {  [FE]  AssertionFailedError  [FE]              AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  if(gNorm!=  0)  {  [BUGGY]      lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	if(gNorm!=  0)  {	  if(dxNorm!=    0)    {    if(dxNorm    ==    0)    {    	compilable	  [FE]  AssertionFailedError  	85	5	replace
240	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.max(2.251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.251e-308,.001  *  paru);  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	add	                lmPar        =        Math.max(2.251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.251e-308,.001    *    paru);    lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	55	5	add
241	[BUG]  [BUGGY]          lmPar    =    Math.max(2.251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.251e-308,.001  *  paru);  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,.001  *  paru);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.max(2.251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.251e-308,.001  *  paru);  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.max(2.251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.251e-308,.001    *    paru);    lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	55	5	add
242	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.max(2.251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.251e-308,.001  *  paru);  lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	add	                lmPar        =        Math.max(2.251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.251e-308,.001    *    paru);    lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	55	5	add
243	[BUG]  [BUGGY]          lmPar    =    Math.max(2.251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.251e-308,.001  *  paru);  lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,.001  *  paru);  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.max(2.251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.251e-308,.001  *  paru);  lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.max(2.251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.251e-308,.001    *    paru);    lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	55	5	add
244	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.max(2.251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.251e-308,.001  *  paru);  lmPar  =  Math.max(2.051e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	add	                lmPar        =        Math.max(2.251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.251e-308,.001    *    paru);    lmPar  =  Math.max(2.051e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	55	5	add
245	[BUG]  [BUGGY]          lmPar    =    Math.max(2.251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.251e-308,.001  *  paru);  lmPar  =  Math.max(2.051e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,.001  *  paru);  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.max(2.251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.251e-308,.001  *  paru);  lmPar  =  Math.max(2.051e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.max(2.251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.251e-308,.001    *    paru);    lmPar  =  Math.max(2.051e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	55	5	add
246	[BUG]  [BUGGY]  double  lmPar  =  Math.min(delta,  Math.max(sum2,  parl));  [CE]  illegal  start  of  type  [FE]                    AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  double  lmPar  =  Math.min(delta,  Math.max(sum2,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	double  lmPar  =  Math.min(delta,  Math.max(sum2,  parl));	  double    lmPar    =    Math.min(paru,    Math.max(sum2,    parl));    	non-compiled	[CE]  illegal  start  of  type	81	None	replace
247	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  if(dxNorm!=  0.0  ||  dxNorm  ==  0.0)  {  [BUGGY]      lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	add	if(dxNorm!=  0.0  ||  dxNorm  ==  0.0)  {	  if(dxNorm!=    0.0    ||    dxNorm!=    0.0)    {    	compilable	  [FE]  AssertionFailedError  	130	5	replace
248	[BUG]  [BUGGY]  if(dxNorm!=  0.0  ||  dxNorm  ==  0.0)  {  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  if(dxNorm!=  0.0  ||  dxNorm  ==  0.0)  {  [BUGGY]      lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	if(dxNorm!=  0.0  ||  dxNorm  ==  0.0)  {	  if(dxNorm!=    0.0    ||    dxNorm!=    0.0)    {    	compilable	  [FE]  AssertionFailedError  	130	5	replace
249	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  if(dxNorm!=  0.0  &&  dxNorm!=  0.0)  {  [BUGGY]      lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	add	if(dxNorm!=  0.0  &&  dxNorm!=  0.0)  {	  if(dxNorm!=    0.0    ||    dxNorm!=    0.0)    {    	compilable	  [FE]  AssertionFailedError  	130	5	replace
250	[BUG]  [BUGGY]  if(dxNorm!=  0.0  &&  dxNorm!=  0.0)  {  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  if(dxNorm!=  0.0  &&  dxNorm!=  0.0)  {  [BUGGY]      lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	if(dxNorm!=  0.0  &&  dxNorm!=  0.0)  {	  if(dxNorm!=    0.0    ||    dxNorm!=    0.0)    {    	compilable	  [FE]  AssertionFailedError  	130	5	replace
251	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  if(gNorm!=  0.0  ||  dxNorm!=  0.0)  {  [BUGGY]      lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	add	if(gNorm!=  0.0  ||  dxNorm!=  0.0)  {	  if(dxNorm!=    0.0    ||    dxNorm!=    0.0)    {    	compilable	  [FE]  AssertionFailedError  	130	5	replace
252	[BUG]  [BUGGY]  if(gNorm!=  0.0  ||  dxNorm!=  0.0)  {  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  if(gNorm!=  0.0  ||  dxNorm!=  0.0)  {  [BUGGY]      lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	if(gNorm!=  0.0  ||  dxNorm!=  0.0)  {	  if(dxNorm!=    0.0    ||    dxNorm!=    0.0)    {    	compilable	  [FE]  AssertionFailedError  	130	5	replace
253	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  if(dxNorm  ==  0.0  ||  dxNorm!=  0.0)  {  [BUGGY]      lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	add	if(dxNorm  ==  0.0  ||  dxNorm!=  0.0)  {	  if(dxNorm!=    0.0    ||    dxNorm!=    0.0)    {    	compilable	  [FE]  AssertionFailedError  	130	5	replace
254	[BUG]  [BUGGY]  if(dxNorm  ==  0.0  ||  dxNorm!=  0.0)  {  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  if(dxNorm  ==  0.0  ||  dxNorm!=  0.0)  {  [BUGGY]      lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	if(dxNorm  ==  0.0  ||  dxNorm!=  0.0)  {	  if(dxNorm!=    0.0    ||    dxNorm!=    0.0)    {    	compilable	  [FE]  AssertionFailedError  	130	5	replace
255	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.min(delta,    Math.max(dxNorm,    parl));    lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	add	                lmPar        =        Math.min(delta,        Math.max(dxNorm,        parl));        lmPar    =    Math.min(delta,    Math.max(dxNorm,    parl));    lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));	  	compilable	  [FE]  AssertionFailedError  	43	5	add
256	[BUG]  [BUGGY]          lmPar    =    Math.min(delta,    Math.max(dxNorm,    parl));    lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.min(delta,    Math.max(dxNorm,    parl));    lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.min(delta,        Math.max(dxNorm,        parl));        lmPar    =    Math.min(delta,    Math.max(dxNorm,    parl));    lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));	  	compilable	  [FE]  AssertionFailedError  	43	5	add
257	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.min(delta,    Math.max(dxNorm,    parl));    lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	add	                lmPar        =        Math.min(delta,        Math.max(dxNorm,        parl));        lmPar    =    Math.min(delta,    Math.max(dxNorm,    parl));    lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));	  	compilable	  [FE]  AssertionFailedError  	43	5	add
258	[BUG]  [BUGGY]          lmPar    =    Math.min(delta,    Math.max(dxNorm,    parl));    lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.min(delta,    Math.max(dxNorm,    parl));    lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.min(delta,        Math.max(dxNorm,        parl));        lmPar    =    Math.min(delta,    Math.max(dxNorm,    parl));    lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));	  	compilable	  [FE]  AssertionFailedError  	43	5	add
259	[BUG]  [BUGGY]          lmPar    =    Math.min(delta,    Math.max(dxNorm,    parl));    lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(delta,  Math.max(dyNorm,  parl));  [CE]  cannot  find  symbol  dyNorm  [FE]        AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.min(delta,    Math.max(dxNorm,    parl));    lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(delta,  Math.max(dyNorm,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.min(delta,        Math.max(dxNorm,        parl));        lmPar    =    Math.min(delta,    Math.max(dxNorm,    parl));    lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(delta,  Math.max(dyNorm,  parl));	  	non-compiled	[CE]  cannot  find  symbol  dyNorm	43	None	add
260	[BUG]  [BUGGY]          lmPar    =    Math.min(delta,    Math.max(dxNorm,    parl));    lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(delta,  Math.max(doNorm,  parl));  [CE]  cannot  find  symbol  doNorm  [FE]          AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.min(delta,    Math.max(dxNorm,    parl));    lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(delta,  Math.max(doNorm,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.min(delta,        Math.max(dxNorm,        parl));        lmPar    =    Math.min(delta,    Math.max(dxNorm,    parl));    lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(delta,  Math.max(doNorm,  parl));	  	non-compiled	[CE]  cannot  find  symbol  doNorm	43	None	add
261	[BUG]  [BUGGY]  lmPar  =  Math.max(param,  Math.max(gNorm,  parl));  [CE]  illegal  start  of  type  [FE]          AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  lmPar  =  Math.max(param,  Math.max(gNorm,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	lmPar  =  Math.max(param,  Math.max(gNorm,  parl));	  lmPar    =    Math.max(gNorm,    Math.max(paru,    parl));    	non-compiled	[CE]  illegal  start  of  type	119	None	replace
262	[BUG]  [BUGGY]  double  sPar  =  Math.sqrt(dxNorm);  [CE]  illegal  start  of  type  [FE]                AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  double  sPar  =  Math.sqrt(dxNorm);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	double  sPar  =  Math.sqrt(dxNorm);	  double    sPar    =    Math.sqrt(sum2);    	non-compiled	[CE]  illegal  start  of  type	105	None	replace
263	[BUG]  [BUGGY]  double  sPar  =  Math.sqrt(gNorm);  [CE]  illegal  start  of  type  [FE]                  AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  double  sPar  =  Math.sqrt(gNorm);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	double  sPar  =  Math.sqrt(gNorm);	  double    sPar    =    Math.sqrt(sum2);    	non-compiled	[CE]  illegal  start  of  type	105	None	replace
264	[BUG]  [BUGGY]  lmPar  =  Math.max(1.0,  Math.max(0.0,  parl));  [CE]  illegal  start  of  type  [FE]            AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  lmPar  =  Math.max(1.0,  Math.max(0.0,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	lmPar  =  Math.max(1.0,  Math.max(0.0,  parl));	  lmPar    =    Math.max(2.0,    Math.max(0.0,    parl));    	non-compiled	[CE]  illegal  start  of  type	28	None	replace
265	[BUG]  [BUGGY]  double  lmPar  =  Math.sqrt(lmPar);  [CE]  illegal  start  of  type  [FE]                  AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  double  lmPar  =  Math.sqrt(lmPar);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	double  lmPar  =  Math.sqrt(lmPar);	  double    lmPar    =    Math.sqrt(sum2);    	non-compiled	[CE]  illegal  start  of  type	75	None	replace
266	[BUG]  [BUGGY]  double  lmPar  =  Math.sqrt(paru);  [CE]  illegal  start  of  type  [FE]                    AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  double  lmPar  =  Math.sqrt(paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	double  lmPar  =  Math.sqrt(paru);	  double    lmPar    =    Math.sqrt(sum2);    	non-compiled	[CE]  illegal  start  of  type	75	None	replace
267	[BUG]  [BUGGY]  double  lmPar  =  Math.sqrt(gNorm);  [CE]  illegal  start  of  type  [FE]                      AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  double  lmPar  =  Math.sqrt(gNorm);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	double  lmPar  =  Math.sqrt(gNorm);	  double    lmPar    =    Math.sqrt(sum2);    	non-compiled	[CE]  illegal  start  of  type	75	None	replace
268	[BUG]  [BUGGY]  double  lmPar  =  Math.sqrt(dxNorm);  [CE]  illegal  start  of  type  [FE]                        AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  double  lmPar  =  Math.sqrt(dxNorm);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	double  lmPar  =  Math.sqrt(dxNorm);	  double    lmPar    =    Math.sqrt(sum2);    	non-compiled	[CE]  illegal  start  of  type	75	None	replace
269	[BUG]  [BUGGY]  if(lmPar!=  null  &&  dxNorm.equals(dxNorm))  {  [CE]  incomparable  types:  double  and  <null>  [FE]              AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  if(lmPar!=  null  &&  dxNorm.equals(dxNorm))  {  [BUGGY]      lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	if(lmPar!=  null  &&  dxNorm.equals(dxNorm))  {	  if(dxNorm!=    null    &&    dxNorm.equals(lmPar))    {    	non-compiled	[CE]  incomparable  types:  double  and  <null>	132	None	replace
270	[BUG]  [BUGGY]  if(dxNorm!=  null  ||  dxNorm.equals(lmPar))  {  [CE]  incomparable  types:  double  and  <null>  [FE]                AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  if(dxNorm!=  null  ||  dxNorm.equals(lmPar))  {  [BUGGY]      lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	if(dxNorm!=  null  ||  dxNorm.equals(lmPar))  {	  if(dxNorm!=    null    &&    dxNorm.equals(lmPar))    {    	non-compiled	[CE]  incomparable  types:  double  and  <null>	132	None	replace
271	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.min(paru,    Math.max(gNorm,    parl));    lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	add	                lmPar        =        Math.min(paru,        Math.max(gNorm,        parl));        lmPar    =    Math.min(paru,    Math.max(gNorm,    parl));    lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));	  	compilable	  [FE]  AssertionFailedError  	16	5	add
272	[BUG]  [BUGGY]          lmPar    =    Math.min(paru,    Math.max(gNorm,    parl));    lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.min(paru,    Math.max(gNorm,    parl));    lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.min(paru,        Math.max(gNorm,        parl));        lmPar    =    Math.min(paru,    Math.max(gNorm,    parl));    lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));	  	compilable	  [FE]  AssertionFailedError  	16	5	add
273	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.min(paru,    Math.max(gNorm,    parl));    lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	add	                lmPar        =        Math.min(paru,        Math.max(gNorm,        parl));        lmPar    =    Math.min(paru,    Math.max(gNorm,    parl));    lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));	  	compilable	  [FE]  AssertionFailedError  	16	5	add
274	[BUG]  [BUGGY]          lmPar    =    Math.min(paru,    Math.max(gNorm,    parl));    lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.min(paru,    Math.max(gNorm,    parl));    lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.min(paru,        Math.max(gNorm,        parl));        lmPar    =    Math.min(paru,    Math.max(gNorm,    parl));    lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));	  	compilable	  [FE]  AssertionFailedError  	16	5	add
275	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.min(paru,    Math.max(gNorm,    parl));    lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  paru  =  Math.min(paru,  Math.max(gNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	add	                lmPar        =        Math.min(paru,        Math.max(gNorm,        parl));        lmPar    =    Math.min(paru,    Math.max(gNorm,    parl));    paru  =  Math.min(paru,  Math.max(gNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));	  	compilable	  [FE]  AssertionFailedError  	16	5	add
276	[BUG]  [BUGGY]          lmPar    =    Math.min(paru,    Math.max(gNorm,    parl));    lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  paru  =  Math.min(paru,  Math.max(gNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.min(paru,    Math.max(gNorm,    parl));    lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  paru  =  Math.min(paru,  Math.max(gNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.min(paru,        Math.max(gNorm,        parl));        lmPar    =    Math.min(paru,    Math.max(gNorm,    parl));    paru  =  Math.min(paru,  Math.max(gNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));	  	compilable	  [FE]  AssertionFailedError  	16	5	add
277	[BUG]  [BUGGY]          lmPar    =    Math.min(paru,    Math.max(gNorm,    parl));    lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  LmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  [CE]  cannot  find  symbol  LmPar  [FE]          AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.min(paru,    Math.max(gNorm,    parl));    lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  LmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.min(paru,        Math.max(gNorm,        parl));        lmPar    =    Math.min(paru,    Math.max(gNorm,    parl));    LmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));	  	non-compiled	[CE]  cannot  find  symbol  LmPar	16	None	add
278	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.min(paru,    Math.max(dxNorm,    parl));    lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	add	                lmPar        =        Math.min(paru,        Math.max(dxNorm,        parl));        lmPar    =    Math.min(paru,    Math.max(dxNorm,    parl));    lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));	  	compilable	  [FE]  AssertionFailedError  	10	6	add
279	[BUG]  [BUGGY]          lmPar    =    Math.min(paru,    Math.max(dxNorm,    parl));    lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.min(paru,    Math.max(dxNorm,    parl));    lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.min(paru,        Math.max(dxNorm,        parl));        lmPar    =    Math.min(paru,    Math.max(dxNorm,    parl));    lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));	  	compilable	  [FE]  AssertionFailedError  	10	6	add
280	[BUG]  [BUGGY]          lmPar    =    Math.min(paru,    Math.max(dxNorm,    parl));    lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(dyNorm,  parl));  [CE]  cannot  find  symbol  dyNorm  [FE]      AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.min(paru,    Math.max(dxNorm,    parl));    lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(dyNorm,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.min(paru,        Math.max(dxNorm,        parl));        lmPar    =    Math.min(paru,    Math.max(dxNorm,    parl));    lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(dyNorm,  parl));	  	non-compiled	[CE]  cannot  find  symbol  dyNorm	10	None	add
281	[BUG]  [BUGGY]          lmPar    =    Math.min(paru,    Math.max(dxNorm,    parl));    lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(dyNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  [CE]  cannot  find  symbol  dyNorm  [FE]        AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.min(paru,    Math.max(dxNorm,    parl));    lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(dyNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.min(paru,        Math.max(dxNorm,        parl));        lmPar    =    Math.min(paru,    Math.max(dxNorm,    parl));    lmPar  =  Math.min(paru,  Math.max(dyNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));	  	non-compiled	[CE]  cannot  find  symbol  dyNorm	10	None	add
282	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.min(paru,    Math.max(dxNorm,    parl));    lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  paru  =  Math.min(paru,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	add	                lmPar        =        Math.min(paru,        Math.max(dxNorm,        parl));        lmPar    =    Math.min(paru,    Math.max(dxNorm,    parl));    paru  =  Math.min(paru,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));	  	compilable	  [FE]  AssertionFailedError  	10	6	add
283	[BUG]  [BUGGY]          lmPar    =    Math.min(paru,    Math.max(dxNorm,    parl));    lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  paru  =  Math.min(paru,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.min(paru,    Math.max(dxNorm,    parl));    lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  paru  =  Math.min(paru,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.min(paru,        Math.max(dxNorm,        parl));        lmPar    =    Math.min(paru,    Math.max(dxNorm,    parl));    paru  =  Math.min(paru,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));	  	compilable	  [FE]  AssertionFailedError  	10	6	add
284	[BUG]  [BUGGY]  lmPar  =  Math.min(param2,  Math.max(gNorm,  parl));  [CE]  illegal  start  of  type  [FE]        AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  lmPar  =  Math.min(param2,  Math.max(gNorm,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	lmPar  =  Math.min(param2,  Math.max(gNorm,  parl));	  lmPar    =    Math.min(sum2,    Math.max(gNorm,    parl));    	non-compiled	[CE]  illegal  start  of  type	1	None	replace
285	[BUG]  [BUGGY]  lmPar  =  Math.max(2.2251e-38,  0.001  *  paru);  [CE]  illegal  start  of  type  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  lmPar  =  Math.max(2.2251e-38,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	lmPar  =  Math.max(2.2251e-38,  0.001  *  paru);	          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    	non-compiled	[CE]  illegal  start  of  type	67	None	replace
286	[BUG]  [BUGGY]  lmPar  =  Math.min(paru,  Math.max(delta,  gNorm));  [CE]  illegal  start  of  type  [FE]          AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  lmPar  =  Math.min(paru,  Math.max(delta,  gNorm));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	lmPar  =  Math.min(paru,  Math.max(delta,  gNorm));	  lmPar    =    Math.min(delta,    Math.max(gNorm,    parl));    	non-compiled	[CE]  illegal  start  of  type	2	None	replace
287	[BUG]  [BUGGY]  if(dxNorm  >  0.0)  {  if(dxNorm  >=  0.0)  {  [CE]  illegal  start  of  expression  [FE]              AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  if(dxNorm  >  0.0)  {  if(dxNorm  >=  0.0)  {  [BUGGY]      lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	if(dxNorm  >  0.0)  {  if(dxNorm  >=  0.0)  {	  if(dxNorm    ==    0.0)    {    if(dxNorm    >=    0.0)    {    	non-compiled	[CE]  illegal  start  of  expression	25	None	replace
288	[BUG]  [BUGGY]  lmPar  =  Math.max(2.0,  0.001  *  dxNorm);  [CE]  illegal  start  of  type  [FE]        AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  lmPar  =  Math.max(2.0,  0.001  *  dxNorm);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	lmPar  =  Math.max(2.0,  0.001  *  dxNorm);	  lmPar    =    Math.max(2.2251e-308,    0.001    *    dxNorm);    	non-compiled	[CE]  illegal  start  of  type	110	None	replace
289	[BUG]  [BUGGY]  double  sPar  =  Math.sqrt(p);  [CE]  illegal  start  of  type  [FE]                AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  double  sPar  =  Math.sqrt(p);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	double  sPar  =  Math.sqrt(p);	  double    sPar    =    Math.sqrt(sum2);    	non-compiled	[CE]  illegal  start  of  type	105	None	replace
290	[BUG]  [BUGGY]          lmPar    =    Math.min(paru,    Math.max(dxNorm,    parl));    paru  =  Math.min(paru,  Math.max(dxNorm,  parl));  LmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  paru  =  Math.min(paru,  Math.max(dxNorm,  parl));  [CE]  cannot  find  symbol  LmPar  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.min(paru,    Math.max(dxNorm,    parl));    paru  =  Math.min(paru,  Math.max(dxNorm,  parl));  LmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  paru  =  Math.min(paru,  Math.max(dxNorm,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.min(paru,        Math.max(dxNorm,        parl));        paru    =    Math.min(paru,    Math.max(dxNorm,    parl));    LmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  paru  =  Math.min(paru,  Math.max(dxNorm,  parl));	  	non-compiled	[CE]  cannot  find  symbol  LmPar	14	None	add
291	[BUG]  [BUGGY]          lmPar    =    Math.max(2.0,    Math.max(1.0,    parl));    lmPar  =  Math.max(2.0,  Math.max(1.0,  parl));  LmPar  =  Math.max(2.0,  Math.max(1.0,  parl));  lmPar  =  Math.max(2.0,  Math.max(1.0,  parl));  [CE]  cannot  find  symbol  LmPar  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.max(2.0,    Math.max(1.0,    parl));    lmPar  =  Math.max(2.0,  Math.max(1.0,  parl));  LmPar  =  Math.max(2.0,  Math.max(1.0,  parl));  lmPar  =  Math.max(2.0,  Math.max(1.0,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.max(2.0,        Math.max(1.0,        parl));        lmPar    =    Math.max(2.0,    Math.max(1.0,    parl));    LmPar  =  Math.max(2.0,  Math.max(1.0,  parl));  lmPar  =  Math.max(2.0,  Math.max(1.0,  parl));	  	non-compiled	[CE]  cannot  find  symbol  LmPar	61	None	add
292	[BUG]  [BUGGY]  lmPar  =  Math.max(paru,  Math.max(param2,  parl));  [CE]  illegal  start  of  type  [FE]        AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  lmPar  =  Math.max(paru,  Math.max(param2,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	lmPar  =  Math.max(paru,  Math.max(param2,  parl));	  lmPar    =    Math.max(paru,    Math.max(delta,    parl));    	non-compiled	[CE]  illegal  start  of  type	128	None	replace
293	[BUG]  [BUGGY]  lmPar  =  Math.max(paru,  Math.max(delta,  0.5));  [CE]  illegal  start  of  type  [FE]          AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  lmPar  =  Math.max(paru,  Math.max(delta,  0.5));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	lmPar  =  Math.max(paru,  Math.max(delta,  0.5));	  lmPar    =    Math.max(paru,    Math.max(delta,    parl));    	non-compiled	[CE]  illegal  start  of  type	128	None	replace
294	[BUG]  [BUGGY]  lmPar  =  Math.min(paru,  Math.max(param2,  parl));  [CE]  illegal  start  of  type  [FE]        AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  lmPar  =  Math.min(paru,  Math.max(param2,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	lmPar  =  Math.min(paru,  Math.max(param2,  parl));	  lmPar    =    Math.min(paru,    Math.max(delta,    parl));    	non-compiled	[CE]  illegal  start  of  type	8	None	replace
295	[BUG]  [BUGGY]  lmPar  =  Math.min(paru,  Math.max(parl,  parl));  [CE]  illegal  start  of  type  [FE]          AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  lmPar  =  Math.min(paru,  Math.max(parl,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	lmPar  =  Math.min(paru,  Math.max(parl,  parl));	  lmPar    =    Math.min(paru,    Math.max(delta,    parl));    	non-compiled	[CE]  illegal  start  of  type	8	None	replace
296	[BUG]  [BUGGY]  lmPar  =  Math.min(paru,  Math.max(delta,  0.5));  [CE]  illegal  start  of  type  [FE]            AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  lmPar  =  Math.min(paru,  Math.max(delta,  0.5));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	lmPar  =  Math.min(paru,  Math.max(delta,  0.5));	  lmPar    =    Math.min(paru,    Math.max(delta,    parl));    	non-compiled	[CE]  illegal  start  of  type	8	None	replace
297	[BUG]  [BUGGY]  if(lmPar!=  null  &&  dxNorm.equals(lmPar))  {  [CE]  incomparable  types:  double  and  <null>  [FE]              AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  if(lmPar!=  null  &&  dxNorm.equals(lmPar))  {  [BUGGY]      lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	if(lmPar!=  null  &&  dxNorm.equals(lmPar))  {	  if(dxNorm!=    null    &&    dxNorm.equals(lmPar))    {    	non-compiled	[CE]  incomparable  types:  double  and  <null>	132	None	replace
298	[BUG]  [BUGGY]          lmPar    =    Math.min(delta,    Math.max(dxNorm,    parl));    double  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  double  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  double  lmPar  =  Math.min(delta,  Math.max(dyNorm,  parl));  [CE]  variable  lmPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.min(delta,    Math.max(dxNorm,    parl));    double  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  double  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  double  lmPar  =  Math.min(delta,  Math.max(dyNorm,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.min(delta,        Math.max(dxNorm,        parl));        double    lmPar    =    Math.min(delta,    Math.max(dxNorm,    parl));    double  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  double  lmPar  =  Math.min(delta,  Math.max(dyNorm,  parl));	  	non-compiled	[CE]  variable  lmPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	98	None	add
299	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.max(2.0,    Math.max(1.0,    parl));    paru  =  Math.max(2.0,  Math.max(1.0,  parl));  lmPar  =  Math.max(2.0,  Math.max(0.0,  parl));  paru  =  Math.max(2.0,  Math.max(1.0,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	add	                lmPar        =        Math.max(2.0,        Math.max(1.0,        parl));        paru    =    Math.max(2.0,    Math.max(1.0,    parl));    lmPar  =  Math.max(2.0,  Math.max(0.0,  parl));  paru  =  Math.max(2.0,  Math.max(1.0,  parl));	  	compilable	  [FE]  AssertionFailedError  	126	5	add
300	[BUG]  [BUGGY]          lmPar    =    Math.max(2.0,    Math.max(1.0,    parl));    paru  =  Math.max(2.0,  Math.max(1.0,  parl));  lmPar  =  Math.max(2.0,  Math.max(0.0,  parl));  paru  =  Math.max(2.0,  Math.max(1.0,  parl));  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.max(2.0,    Math.max(1.0,    parl));    paru  =  Math.max(2.0,  Math.max(1.0,  parl));  lmPar  =  Math.max(2.0,  Math.max(0.0,  parl));  paru  =  Math.max(2.0,  Math.max(1.0,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.max(2.0,        Math.max(1.0,        parl));        paru    =    Math.max(2.0,    Math.max(1.0,    parl));    lmPar  =  Math.max(2.0,  Math.max(0.0,  parl));  paru  =  Math.max(2.0,  Math.max(1.0,  parl));	  	compilable	  [FE]  AssertionFailedError  	126	5	add
301	[BUG]  [BUGGY]  lmPar  =  Math.max(2.0,  Math.max(1.0,  paru));  LmPar  =  Math.max(2.0,  Math.max(1.0,  parl));  [CE]  illegal  start  of  type  [FE]            AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  lmPar  =  Math.max(2.0,  Math.max(1.0,  paru));  LmPar  =  Math.max(2.0,  Math.max(1.0,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	lmPar  =  Math.max(2.0,  Math.max(1.0,  paru));  LmPar  =  Math.max(2.0,  Math.max(1.0,  parl));	          lmPar    =    Math.max(2.0,    Math.max(1.0,    parl));    LmPar    =    Math.max(2.0,    Math.max(1.0,    parl));    	non-compiled	[CE]  illegal  start  of  type	65	None	replace
302	[BUG]  [BUGGY]  lmPar  =  Math.max(2.0,  Math.max(0.0,  parl));  LmPar  =  Math.max(2.0,  Math.max(1.0,  parl));  [CE]  illegal  start  of  type  [FE]              AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  lmPar  =  Math.max(2.0,  Math.max(0.0,  parl));  LmPar  =  Math.max(2.0,  Math.max(1.0,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	lmPar  =  Math.max(2.0,  Math.max(0.0,  parl));  LmPar  =  Math.max(2.0,  Math.max(1.0,  parl));	          lmPar    =    Math.max(2.0,    Math.max(1.0,    parl));    LmPar    =    Math.max(2.0,    Math.max(1.0,    parl));    	non-compiled	[CE]  illegal  start  of  type	65	None	replace
303	[BUG]  [BUGGY]  lmPar  =  Math.min(paru,  Math.max(rmPar,  dxNorm));  [CE]  illegal  start  of  type  [FE]                AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  lmPar  =  Math.min(paru,  Math.max(rmPar,  dxNorm));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	lmPar  =  Math.min(paru,  Math.max(rmPar,  dxNorm));	  lmPar    =    Math.min(paru,    Math.max(rmPar,    parl));    	non-compiled	[CE]  illegal  start  of  type	123	None	replace
304	[BUG]  [BUGGY]  if(lmPar  ==  null  ||  dxNorm!=  0.0)  {  [CE]  incomparable  types:  double  and  <null>  [FE]            AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  if(lmPar  ==  null  ||  dxNorm!=  0.0)  {  [BUGGY]      lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	if(lmPar  ==  null  ||  dxNorm!=  0.0)  {	  if(lmPar    ==    null)    {    	non-compiled	[CE]  incomparable  types:  double  and  <null>	92	None	replace
305	[BUG]  [BUGGY]  lmPar  =  Math.min(paru,  Math.max(1.0,  parl));  [CE]  illegal  start  of  type  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  lmPar  =  Math.min(paru,  Math.max(1.0,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	lmPar  =  Math.min(paru,  Math.max(1.0,  parl));	          lmPar    =    Math.max(2.0,    Math.max(1.0,    parl));    lmPar    =    Math.max(2.0,    Math.max(1.0,    parl));    	non-compiled	[CE]  illegal  start  of  type	62	None	replace
306	[BUG]  [BUGGY]          lmPar    =    Math.min(paru,    Math.max(dxNorm,    parl));    lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  LmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  [CE]  cannot  find  symbol  LmPar  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.min(paru,    Math.max(dxNorm,    parl));    lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  LmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.min(paru,        Math.max(dxNorm,        parl));        lmPar    =    Math.min(paru,    Math.max(dxNorm,    parl));    LmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));	  	non-compiled	[CE]  cannot  find  symbol  LmPar	10	None	add
307	[BUG]  [BUGGY]          lmPar    =    Math.min(delta,    Math.max(dxNorm,    parl));    lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  LmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  [CE]  cannot  find  symbol  LmPar  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.min(delta,    Math.max(dxNorm,    parl));    lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  LmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.min(delta,        Math.max(dxNorm,        parl));        lmPar    =    Math.min(paru,    Math.max(dxNorm,    parl));    LmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));	  	non-compiled	[CE]  cannot  find  symbol  LmPar	45	None	add
308	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.min(delta,    Math.max(dxNorm,    parl));    lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  double  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	add	                lmPar        =        Math.min(delta,        Math.max(dxNorm,        parl));        lmPar    =    Math.min(paru,    Math.max(dxNorm,    parl));    double  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));	  	compilable	  [FE]  AssertionFailedError  	45	6	add
309	[BUG]  [BUGGY]          lmPar    =    Math.min(delta,    Math.max(dxNorm,    parl));    lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  double  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.min(delta,    Math.max(dxNorm,    parl));    lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  double  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.min(delta,        Math.max(dxNorm,        parl));        lmPar    =    Math.min(paru,    Math.max(dxNorm,    parl));    double  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));	  	compilable	  [FE]  AssertionFailedError  	45	6	add
310	[BUG]  [BUGGY]  lmPar  =  Math.min(paru,  Math.max(lmPar,  lm2));  [CE]  illegal  start  of  type  [FE]          AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  lmPar  =  Math.min(paru,  Math.max(lmPar,  lm2));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	lmPar  =  Math.min(paru,  Math.max(lmPar,  lm2));	  lmPar    =    Math.min(sum2,    Math.max(lmPar,    parl));    	non-compiled	[CE]  illegal  start  of  type	34	None	replace
311	[BUG]  [BUGGY]  lmPar  =  Math.max(gNorm,  Math.max(paru,  dxNorm));  [CE]  illegal  start  of  type  [FE]          AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  lmPar  =  Math.max(gNorm,  Math.max(paru,  dxNorm));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	lmPar  =  Math.max(gNorm,  Math.max(paru,  dxNorm));	  lmPar    =    Math.max(gNorm,    Math.max(paru,    parl));    	non-compiled	[CE]  illegal  start  of  type	119	None	replace
312	[BUG]  [BUGGY]  if(sum2)  {  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  }  [CE]  illegal  start  of  type  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  if(sum2)  {  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  }  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	if(sum2)  {  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  }	          lmPar    =    Math.min(delta,    Math.max(dxNorm,    parl));    lmPar    =    Math.min(paru,    Math.max(dxNorm,    parl));    	non-compiled	[CE]  illegal  start  of  type	46	None	replace
313	[BUG]  [BUGGY]  if(sum2)  {  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  }  else  {  [CE]  incompatible  types  [FE]      AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  if(sum2)  {  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  }  else  {  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	if(sum2)  {  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  }  else  {	          lmPar    =    Math.min(delta,    Math.max(dxNorm,    parl));    lmPar    =    Math.min(paru,    Math.max(dxNorm,    parl));    	non-compiled	[CE]  incompatible  types	46	None	replace
314	[BUG]  [BUGGY]  lmPar  =  Math.max(paru,  Math.min(delta,  0.001));  [CE]  illegal  start  of  type  [FE]        AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  lmPar  =  Math.max(paru,  Math.min(delta,  0.001));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	lmPar  =  Math.max(paru,  Math.min(delta,  0.001));	  lmPar    =    Math.max(paru,    Math.max(dxNorm,    parl));    	non-compiled	[CE]  illegal  start  of  type	125	None	replace
315	[BUG]  [BUGGY]  paru  =  Math.min(paru,  Math.max(delta,  0.0));  [CE]  illegal  start  of  type  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  paru  =  Math.min(paru,  Math.max(delta,  0.0));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	paru  =  Math.min(paru,  Math.max(delta,  0.0));	          lmPar    =    Math.min(paru,    Math.max(lmPar,    parl));    paru    =    Math.min(paru,    Math.max(lmPar,    parl));    	non-compiled	[CE]  illegal  start  of  type	91	None	replace
316	[BUG]  [BUGGY]  paru  =  Math.min(paru,  Math.max(delta,  0.001));  [CE]  illegal  start  of  type  [FE]      AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  paru  =  Math.min(paru,  Math.max(delta,  0.001));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	paru  =  Math.min(paru,  Math.max(delta,  0.001));	          lmPar    =    Math.min(paru,    Math.max(lmPar,    parl));    paru    =    Math.min(paru,    Math.max(lmPar,    parl));    	non-compiled	[CE]  illegal  start  of  type	91	None	replace
317	[BUG]  [BUGGY]  Parser  paru  =  Math.min(paru,  Math.max(delta,  0.0));  [CE]  illegal  start  of  type  [FE]        AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  Parser  paru  =  Math.min(paru,  Math.max(delta,  0.0));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	Parser  paru  =  Math.min(paru,  Math.max(delta,  0.0));	          lmPar    =    Math.min(paru,    Math.max(lmPar,    parl));    paru    =    Math.min(paru,    Math.max(lmPar,    parl));    	non-compiled	[CE]  illegal  start  of  type	91	None	replace
318	[BUG]  [BUGGY]  if(sum2)  {  lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  }  else  {  [CE]  incompatible  types  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  if(sum2)  {  lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  }  else  {  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	if(sum2)  {  lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  }  else  {	          lmPar    =    Math.min(paru,    Math.max(gNorm,    parl));    lmPar    =    Math.min(paru,    Math.max(gNorm,    parl));    	non-compiled	[CE]  incompatible  types	17	None	replace
319	[BUG]  [BUGGY]  lmPar  =  Math.min(paru,  Math.max(delta,  0.0));  [CE]  illegal  start  of  type  [FE]      AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  lmPar  =  Math.min(paru,  Math.max(delta,  0.0));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	lmPar  =  Math.min(paru,  Math.max(delta,  0.0));	          lmPar    =    Math.min(paru,    Math.max(gNorm,    parl));    lmPar    =    Math.min(paru,    Math.max(gNorm,    parl));    	non-compiled	[CE]  illegal  start  of  type	17	None	replace
320	[BUG]  [BUGGY]  double  lmPar  =  Math.min(paru,  Math.max(lmPar,  par2));  [CE]  illegal  start  of  type  [FE]                  AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  double  lmPar  =  Math.min(paru,  Math.max(lmPar,  par2));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	double  lmPar  =  Math.min(paru,  Math.max(lmPar,  par2));	  double    lmPar    =    Math.min(paru,    Math.max(sum2));    	non-compiled	[CE]  illegal  start  of  type	80	None	replace
321	[BUG]  [BUGGY]  double  lmPar  =  Math.min(paru,  Math.max(sPar,  parl));  [CE]  illegal  start  of  type  [FE]                    AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  double  lmPar  =  Math.min(paru,  Math.max(sPar,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	double  lmPar  =  Math.min(paru,  Math.max(sPar,  parl));	  double    lmPar    =    Math.min(paru,    Math.max(sum2));    	non-compiled	[CE]  illegal  start  of  type	80	None	replace
322	[BUG]  [BUGGY]          lmPar    =    Math.max(2.251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.251e-308,.001  *  paru);  LmPar  =  Math.max(2.251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,.001  *  paru);  [CE]  cannot  find  symbol  LmPar  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.max(2.251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.251e-308,.001  *  paru);  LmPar  =  Math.max(2.251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.max(2.251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.251e-308,.001    *    paru);    LmPar  =  Math.max(2.251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,.001  *  paru);	  	non-compiled	[CE]  cannot  find  symbol  LmPar	55	None	add
323	[BUG]  [BUGGY]          lmPar    =    Math.max(2.0,    Math.max(1.0,    parl));    double  lmPar  =  Math.max(2.0,  Math.max(1.0,  parl));  lmPar  =  Math.max(2.0,  Math.max(0.0,  parl));  double  lmPar  =  Math.max(2.0,  Math.max(1.0,  parl));  [CE]  variable  lmPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.max(2.0,    Math.max(1.0,    parl));    double  lmPar  =  Math.max(2.0,  Math.max(1.0,  parl));  lmPar  =  Math.max(2.0,  Math.max(0.0,  parl));  double  lmPar  =  Math.max(2.0,  Math.max(1.0,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.max(2.0,        Math.max(1.0,        parl));        double    lmPar    =    Math.max(2.0,    Math.max(1.0,    parl));    lmPar  =  Math.max(2.0,  Math.max(0.0,  parl));  double  lmPar  =  Math.max(2.0,  Math.max(1.0,  parl));	  	non-compiled	[CE]  variable  lmPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	63	None	add
324	[BUG]  [BUGGY]  if(sum2  >  0.0)  {  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  }  [CE]  illegal  start  of  type  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  if(sum2  >  0.0)  {  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  }  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	if(sum2  >  0.0)  {  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  }	          lmPar    =    Math.min(paru,    Math.max(dxNorm,    parl));    lmPar    =    Math.min(paru,    Math.max(dxNorm,    parl));    	non-compiled	[CE]  illegal  start  of  type	11	None	replace
325	[BUG]  [BUGGY]  if(sum2)  {  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  }  else  {  [CE]  incompatible  types  [FE]      AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  if(sum2)  {  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  }  else  {  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	if(sum2)  {  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  }  else  {	          lmPar    =    Math.min(paru,    Math.max(dxNorm,    parl));    lmPar    =    Math.min(paru,    Math.max(dxNorm,    parl));    	non-compiled	[CE]  incompatible  types	11	None	replace
326	[BUG]  [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  LmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [CE]  cannot  find  symbol  LmPar  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  LmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.max(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    LmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);	  	non-compiled	[CE]  cannot  find  symbol  LmPar	66	None	add
327	[BUG]  [BUGGY]  lmPar  =  Math.max(2.0e-308,  0.001  *  paru);  [CE]  illegal  start  of  type  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  lmPar  =  Math.max(2.0e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	lmPar  =  Math.max(2.0e-308,  0.001  *  paru);	          lmPar    =    Math.max(2.251e-308,    0.001    *    paru);    lmPar    =    Math.max(2.252e-308,    0.001    *    paru);    	non-compiled	[CE]  illegal  start  of  type	54	None	replace
328	[BUG]  [BUGGY]  lmPar  =  Math.min(delta,  Math.max(pr,  parl));  [CE]  illegal  start  of  type  [FE]              AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  lmPar  =  Math.min(delta,  Math.max(pr,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	lmPar  =  Math.min(delta,  Math.max(pr,  parl));	  lmPar    =    Math.min(paru,    Math.max(pr,    parl));    	non-compiled	[CE]  illegal  start  of  type	122	None	replace
329	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.max(2.251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	add	                lmPar        =        Math.max(2.251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	49	5	add
330	[BUG]  [BUGGY]          lmPar    =    Math.max(2.251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.max(2.251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.max(2.251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	49	5	add
331	[BUG]  [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2251e-308,.001  *  paru);  LmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,.001  *  paru);  [CE]  cannot  find  symbol  LmPar  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2251e-308,.001  *  paru);  LmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.max(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.2251e-308,.001    *    paru);    LmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,.001  *  paru);	  	non-compiled	[CE]  cannot  find  symbol  LmPar	70	None	add
332	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2251e-308,.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	add	                lmPar        =        Math.max(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.2251e-308,.001    *    paru);    lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	70	5	add
333	[BUG]  [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2251e-308,.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,.001  *  paru);  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2251e-308,.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.max(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.2251e-308,.001    *    paru);    lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	70	5	add
334	[BUG]  [BUGGY]  double  lmPar  =  Math.min(paru,  Math.max(delta,  0.5));  [CE]  illegal  start  of  type  [FE]              AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  double  lmPar  =  Math.min(paru,  Math.max(delta,  0.5));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	double  lmPar  =  Math.min(paru,  Math.max(delta,  0.5));	  double    lmPar    =    Math.min(paru,    Math.max(delta,    parl));    	non-compiled	[CE]  illegal  start  of  type	78	None	replace
335	[BUG]  [BUGGY]  double  lmPar  =  Math.min(paru,  Math.max(delta,  0.0));  [CE]  illegal  start  of  type  [FE]                AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  double  lmPar  =  Math.min(paru,  Math.max(delta,  0.0));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	double  lmPar  =  Math.min(paru,  Math.max(delta,  0.0));	  double    lmPar    =    Math.min(paru,    Math.max(delta,    parl));    	non-compiled	[CE]  illegal  start  of  type	78	None	replace
336	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.253e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	add	                lmPar        =        Math.max(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.253e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	72	5	add
337	[BUG]  [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.253e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.253e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.max(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.253e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	72	5	add
338	[BUG]  [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  LmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  [CE]  cannot  find  symbol  LmPar  [FE]      AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  LmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.max(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.251e-308,    0.001    *    paru);    LmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);	  	non-compiled	[CE]  cannot  find  symbol  LmPar	72	None	add
339	[BUG]  [BUGGY]  lmPar  =  Math.min(paru,  Math.max(1.0,  parl));  paru  =  Math.max(2.0,  Math.max(1.0,  parl));  [CE]  illegal  start  of  type  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  lmPar  =  Math.min(paru,  Math.max(1.0,  parl));  paru  =  Math.max(2.0,  Math.max(1.0,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	lmPar  =  Math.min(paru,  Math.max(1.0,  parl));  paru  =  Math.max(2.0,  Math.max(1.0,  parl));	          lmPar    =    Math.max(2.0,    Math.max(1.0,    parl));    paru    =    Math.max(2.0,    Math.max(1.0,    parl));    	non-compiled	[CE]  illegal  start  of  type	127	None	replace
340	[BUG]  [BUGGY]  paru  =  Math.min(delta,  Math.max(delta,  0.0));  [CE]  illegal  start  of  type  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  paru  =  Math.min(delta,  Math.max(delta,  0.0));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	paru  =  Math.min(delta,  Math.max(delta,  0.0));	          lmPar    =    Math.min(delta,    Math.max(dxNorm,    parl));    paru    =    Math.min(delta,    Math.max(dxNorm,    parl));    	non-compiled	[CE]  illegal  start  of  type	101	None	replace
341	[BUG]  [BUGGY]  paru  =  Math.min(delta,  Math.max(delta,  parl));  [CE]  illegal  start  of  type  [FE]      AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  paru  =  Math.min(delta,  Math.max(delta,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	paru  =  Math.min(delta,  Math.max(delta,  parl));	          lmPar    =    Math.min(delta,    Math.max(dxNorm,    parl));    paru    =    Math.min(delta,    Math.max(dxNorm,    parl));    	non-compiled	[CE]  illegal  start  of  type	101	None	replace
342	[BUG]  [BUGGY]  lmPar  =  Math.max(2.0,  0.001  *  paru  +  1);  [CE]  illegal  start  of  type  [FE]        AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  lmPar  =  Math.max(2.0,  0.001  *  paru  +  1);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	lmPar  =  Math.max(2.0,  0.001  *  paru  +  1);	  lmPar    =    Math.max(2.0,    0.001    *    paru);    	non-compiled	[CE]  illegal  start  of  type	21	None	replace
343	[BUG]  [BUGGY]  lmPar  =  Math.max(2.2252e-308,  0.001  *  dxNorm);  [CE]  illegal  start  of  type  [FE]        AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  lmPar  =  Math.max(2.2252e-308,  0.001  *  dxNorm);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	lmPar  =  Math.max(2.2252e-308,  0.001  *  dxNorm);	  lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    	non-compiled	[CE]  illegal  start  of  type	9	None	replace
344	[BUG]  [BUGGY]  if(sum2)  {  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  double  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  }  [CE]  illegal  start  of  type  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  if(sum2)  {  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  double  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  }  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	if(sum2)  {  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  double  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  }	          lmPar    =    Math.min(paru,    Math.max(dxNorm,    parl));    double    lmPar    =    Math.min(paru,    Math.max(dxNorm,    parl));    	non-compiled	[CE]  illegal  start  of  type	96	None	replace
345	[BUG]  [BUGGY]  if(sum2)  {  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  double  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  }  else  {  [CE]  incompatible  types  [FE]      AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  if(sum2)  {  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  double  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  }  else  {  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	if(sum2)  {  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  double  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  }  else  {	          lmPar    =    Math.min(paru,    Math.max(dxNorm,    parl));    double    lmPar    =    Math.min(paru,    Math.max(dxNorm,    parl));    	non-compiled	[CE]  incompatible  types	96	None	replace
346	[BUG]  [BUGGY]  if(dxNorm!=  0.0  ||  dxNorm!=  0.0)  {  If(dxNorm!=  0.0  ||  dxNorm!=  0.0)  {  [CE]  ';'  expected  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  if(dxNorm!=  0.0  ||  dxNorm!=  0.0)  {  If(dxNorm!=  0.0  ||  dxNorm!=  0.0)  {  [BUGGY]      lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	if(dxNorm!=    0.0    ||    dxNorm!=    0.0)    {    If(dxNorm!=  0.0  ||  dxNorm!=  0.0)  {	  	non-compiled	[CE]  ';'  expected	129	None	add
347	[BUG]  [BUGGY]          lmPar    =    Math.min(delta,    Math.max(dxNorm,    parl));    lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  LmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  [CE]  cannot  find  symbol  LmPar  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.min(delta,    Math.max(dxNorm,    parl));    lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  LmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.min(delta,        Math.max(dxNorm,        parl));        lmPar    =    Math.min(delta,    Math.max(dxNorm,    parl));    LmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));	  	non-compiled	[CE]  cannot  find  symbol  LmPar	43	None	add
348	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.min(delta,    Math.max(dxNorm,    parl));    lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  double  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	add	                lmPar        =        Math.min(delta,        Math.max(dxNorm,        parl));        lmPar    =    Math.min(delta,    Math.max(dxNorm,    parl));    double  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));	  	compilable	  [FE]  AssertionFailedError  	43	9	add
349	[BUG]  [BUGGY]          lmPar    =    Math.min(delta,    Math.max(dxNorm,    parl));    lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  double  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.min(delta,    Math.max(dxNorm,    parl));    lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  double  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.min(delta,        Math.max(dxNorm,        parl));        lmPar    =    Math.min(delta,    Math.max(dxNorm,    parl));    double  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));	  	compilable	  [FE]  AssertionFailedError  	43	9	add
350	[BUG]  [BUGGY]  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,.001  *  paru);  [CE]  illegal  start  of  type  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,.001  *  paru);	          lmPar    =    Math.max(2.251e-308,    0.001    *    paru);    lmPar    =    Math.max(2.251e-308,.001    *    paru);    	non-compiled	[CE]  illegal  start  of  type	56	None	replace
351	[BUG]  [BUGGY]          lmPar    =    Math.min(paru,    Math.max(gNorm,    parl));    paru  =  Math.min(paru,  Math.max(gNorm,  parl));  LmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  paru  =  Math.min(paru,  Math.max(gNorm,  parl));  [CE]  cannot  find  symbol  LmPar  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.min(paru,    Math.max(gNorm,    parl));    paru  =  Math.min(paru,  Math.max(gNorm,  parl));  LmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  paru  =  Math.min(paru,  Math.max(gNorm,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.min(paru,        Math.max(gNorm,        parl));        paru    =    Math.min(paru,    Math.max(gNorm,    parl));    LmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  paru  =  Math.min(paru,  Math.max(gNorm,  parl));	  	non-compiled	[CE]  cannot  find  symbol  LmPar	18	None	add
352	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.min(paru,    Math.max(gNorm,    parl));    paru  =  Math.min(paru,  Math.max(gNorm,  parl));  double  lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  paru  =  Math.min(paru,  Math.max(gNorm,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	add	                lmPar        =        Math.min(paru,        Math.max(gNorm,        parl));        paru    =    Math.min(paru,    Math.max(gNorm,    parl));    double  lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  paru  =  Math.min(paru,  Math.max(gNorm,  parl));	  	compilable	  [FE]  AssertionFailedError  	18	6	add
353	[BUG]  [BUGGY]          lmPar    =    Math.min(paru,    Math.max(gNorm,    parl));    paru  =  Math.min(paru,  Math.max(gNorm,  parl));  double  lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  paru  =  Math.min(paru,  Math.max(gNorm,  parl));  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.min(paru,    Math.max(gNorm,    parl));    paru  =  Math.min(paru,  Math.max(gNorm,  parl));  double  lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  paru  =  Math.min(paru,  Math.max(gNorm,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.min(paru,        Math.max(gNorm,        parl));        paru    =    Math.min(paru,    Math.max(gNorm,    parl));    double  lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  paru  =  Math.min(paru,  Math.max(gNorm,  parl));	  	compilable	  [FE]  AssertionFailedError  	18	6	add
354	[BUG]  [BUGGY]  if(lmPar!=  null  &&  dxNorm.equals(gNorm))  {  [CE]  incomparable  types:  double  and  <null>  [FE]                AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  if(lmPar!=  null  &&  dxNorm.equals(gNorm))  {  [BUGGY]      lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	if(lmPar!=  null  &&  dxNorm.equals(gNorm))  {	  if(dxNorm!=    null    &&    dxNorm.equals(gNorm))    {    	non-compiled	[CE]  incomparable  types:  double  and  <null>	133	None	replace
355	[BUG]  [BUGGY]  if(dxNorm!=  null  &&  dxNorm.equals(delta))  {  [CE]  incomparable  types:  double  and  <null>  [FE]                  AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  if(dxNorm!=  null  &&  dxNorm.equals(delta))  {  [BUGGY]      lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	if(dxNorm!=  null  &&  dxNorm.equals(delta))  {	  if(dxNorm!=    null    &&    dxNorm.equals(gNorm))    {    	non-compiled	[CE]  incomparable  types:  double  and  <null>	133	None	replace
356	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  if(dxNorm  >=  0.0  ||  dxNorm  ==  0.0)  {  [BUGGY]      lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	add	if(dxNorm  >=  0.0  ||  dxNorm  ==  0.0)  {	  if(dxNorm!=    0.0    ||    dxNorm!=    0.0)    {    	compilable	  [FE]  AssertionFailedError  	130	5	replace
357	[BUG]  [BUGGY]  if(dxNorm  >=  0.0  ||  dxNorm  ==  0.0)  {  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  if(dxNorm  >=  0.0  ||  dxNorm  ==  0.0)  {  [BUGGY]      lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	if(dxNorm  >=  0.0  ||  dxNorm  ==  0.0)  {	  if(dxNorm!=    0.0    ||    dxNorm!=    0.0)    {    	compilable	  [FE]  AssertionFailedError  	130	5	replace
358	[BUG]  [BUGGY]  if(sum2)  {  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  double  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  }  [CE]  illegal  start  of  type  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  if(sum2)  {  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  double  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  }  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	if(sum2)  {  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  double  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  }	          lmPar    =    Math.min(delta,    Math.max(dxNorm,    parl));    double    lmPar    =    Math.min(delta,    Math.max(dxNorm,    parl));    	non-compiled	[CE]  illegal  start  of  type	99	None	replace
359	[BUG]  [BUGGY]  if(sum2)  {  lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  paru  =  Math.min(paru,  Math.max(gNorm,  parl));  }  else  {  [CE]  incompatible  types  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  if(sum2)  {  lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  paru  =  Math.min(paru,  Math.max(gNorm,  parl));  }  else  {  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	if(sum2)  {  lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  paru  =  Math.min(paru,  Math.max(gNorm,  parl));  }  else  {	          lmPar    =    Math.min(paru,    Math.max(gNorm,    parl));    paru    =    Math.min(paru,    Math.max(gNorm,    parl));    	non-compiled	[CE]  incompatible  types	19	None	replace
360	[BUG]  [BUGGY]  double  lmPar  =  Math.min(paru,  Math.max(delta,  lmPar));  [CE]  illegal  start  of  type  [FE]            AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  double  lmPar  =  Math.min(paru,  Math.max(delta,  lmPar));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	double  lmPar  =  Math.min(paru,  Math.max(delta,  lmPar));	          lmPar    =    Math.min(paru,    Math.max(lmPar,    parl));    double    lmPar    =    Math.min(paru,    Math.max(lmPar,    parl));    	non-compiled	[CE]  illegal  start  of  type	89	None	replace
361	[BUG]  [BUGGY]  if(dxNorm  >  0.0)  {  int  dxNorm  >  0.0)  {  [CE]  ';'  expected  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  if(dxNorm  >  0.0)  {  int  dxNorm  >  0.0)  {  [BUGGY]      lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	if(dxNorm    >    0.0)    {    int  dxNorm  >  0.0)  {	  	non-compiled	[CE]  ';'  expected	29	None	add
362	[BUG]  [BUGGY]  lmPar  =  Math.min(paru,  Math.max(delta,  0));  [CE]  illegal  start  of  type  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  lmPar  =  Math.min(paru,  Math.max(delta,  0));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	lmPar  =  Math.min(paru,  Math.max(delta,  0));	          lmPar    =    Math.min(paru,    Math.max(lmPar,    parl));    lmPar    =    Math.min(paru,    Math.max(lmPar,    parl));    	non-compiled	[CE]  illegal  start  of  type	87	None	replace
363	[BUG]  [BUGGY]  lmPar  =  Math.min(paru,  Math.max(delta,  0.1));  [CE]  illegal  start  of  type  [FE]      AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  lmPar  =  Math.min(paru,  Math.max(delta,  0.1));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	lmPar  =  Math.min(paru,  Math.max(delta,  0.1));	          lmPar    =    Math.min(paru,    Math.max(lmPar,    parl));    lmPar    =    Math.min(paru,    Math.max(lmPar,    parl));    	non-compiled	[CE]  illegal  start  of  type	87	None	replace
364	[BUG]  [BUGGY]  lmPar  =  Math.max(2.2251e-38,.001  *  paru);  [CE]  illegal  start  of  type  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  lmPar  =  Math.max(2.2251e-38,.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	lmPar  =  Math.max(2.2251e-38,.001  *  paru);	          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar    =    Math.max(2.2251e-308,.001    *    paru);    	non-compiled	[CE]  illegal  start  of  type	71	None	replace
365	[BUG]  [BUGGY]          lmPar    =    Math.min(paru,    Math.max(dxNorm,    parl));    double  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  Math  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  double  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  [CE]  variable  lmPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.min(paru,    Math.max(dxNorm,    parl));    double  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  Math  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  double  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.min(paru,        Math.max(dxNorm,        parl));        double    lmPar    =    Math.min(paru,    Math.max(dxNorm,    parl));    Math  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  double  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));	  	non-compiled	[CE]  variable  lmPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	95	None	add
366	[BUG]  [BUGGY]  lmPar  =  Math.min(paru,  Math.max(1.0,  parl));  parl  =  Math.max(2.0,  Math.max(1.0,  parl));  [CE]  illegal  start  of  type  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  lmPar  =  Math.min(paru,  Math.max(1.0,  parl));  parl  =  Math.max(2.0,  Math.max(1.0,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	lmPar  =  Math.min(paru,  Math.max(1.0,  parl));  parl  =  Math.max(2.0,  Math.max(1.0,  parl));	          lmPar    =    Math.max(2.0,    Math.max(1.0,    parl));    parl    =    Math.max(2.0,    Math.max(1.0,    parl));    	non-compiled	[CE]  illegal  start  of  type	109	None	replace
367	[BUG]  [BUGGY]  lmPar  =  Math.max(0.0,  Math.max(1.0,  parl));  parl  =  Math.max(0.0,  Math.max(1.0,  parl));  [CE]  illegal  start  of  type  [FE]      AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  lmPar  =  Math.max(0.0,  Math.max(1.0,  parl));  parl  =  Math.max(0.0,  Math.max(1.0,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	lmPar  =  Math.max(0.0,  Math.max(1.0,  parl));  parl  =  Math.max(0.0,  Math.max(1.0,  parl));	          lmPar    =    Math.max(2.0,    Math.max(1.0,    parl));    parl    =    Math.max(2.0,    Math.max(1.0,    parl));    	non-compiled	[CE]  illegal  start  of  type	109	None	replace
368	[BUG]  [BUGGY]  if(dxNorm  >  0.0)  {  if(dxNorm  ==  0.0)  {  [CE]  illegal  start  of  expression  [FE]              AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  if(dxNorm  >  0.0)  {  if(dxNorm  ==  0.0)  {  [BUGGY]      lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	if(dxNorm  >  0.0)  {  if(dxNorm  ==  0.0)  {	  if(dxNorm    >=    0.0)    {    if(dxNorm    ==    0.0)    {    	non-compiled	[CE]  illegal  start  of  expression	42	None	replace
369	[BUG]  [BUGGY]  if(sum2)  {  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  paru  =  Math.min(paru,  Math.max(dxNorm,  parl));  }  else  {  [CE]  incompatible  types  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  if(sum2)  {  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  paru  =  Math.min(paru,  Math.max(dxNorm,  parl));  }  else  {  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	if(sum2)  {  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  paru  =  Math.min(paru,  Math.max(dxNorm,  parl));  }  else  {	          lmPar    =    Math.min(paru,    Math.max(dxNorm,    parl));    paru    =    Math.min(paru,    Math.max(dxNorm,    parl));    	non-compiled	[CE]  incompatible  types	15	None	replace
370	[BUG]  [BUGGY]          lmPar    =    Math.min(paru,    Math.max(lmPar,    parl));    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  Math  lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  [CE]  no  suitable  method  found  for  max(Math,double)  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.min(paru,    Math.max(lmPar,    parl));    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  Math  lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.min(paru,        Math.max(lmPar,        parl));        lmPar    =    Math.min(paru,    Math.max(lmPar,    parl));    Math  lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));	  	non-compiled	[CE]  no  suitable  method  found  for  max(Math,double)	86	None	add
371	[BUG]  [BUGGY]  lmPar  =  Math.max(paru,  Math.max(delta,  0.001));  [CE]  illegal  start  of  type  [FE]        AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  lmPar  =  Math.max(paru,  Math.max(delta,  0.001));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	lmPar  =  Math.max(paru,  Math.max(delta,  0.001));	  lmPar    =    Math.max(paru,    Math.max(delta,    0.0));    	non-compiled	[CE]  illegal  start  of  type	117	None	replace
372	[BUG]  [BUGGY]  lmPar  =  Math.max(paru,  Math.max(delta,  1.0));  [CE]  illegal  start  of  type  [FE]          AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  lmPar  =  Math.max(paru,  Math.max(delta,  1.0));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	lmPar  =  Math.max(paru,  Math.max(delta,  1.0));	  lmPar    =    Math.max(paru,    Math.max(delta,    0.0));    	non-compiled	[CE]  illegal  start  of  type	117	None	replace
373	[BUG]  [BUGGY]  lmPar  =  Math.min(paru,  Math.max(lmPar,  par2));  [CE]  illegal  start  of  type  [FE]            AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  lmPar  =  Math.min(paru,  Math.max(lmPar,  par2));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	lmPar  =  Math.min(paru,  Math.max(lmPar,  par2));	  lmPar    =    Math.min(paru,    Math.max(sum2));    	non-compiled	[CE]  illegal  start  of  type	3	None	replace
374	[BUG]  [BUGGY]  lmPar  =  Math.min(parl,  Math.max(dxNorm,  parl));  [CE]  illegal  start  of  type  [FE]        AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  lmPar  =  Math.min(parl,  Math.max(dxNorm,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	lmPar  =  Math.min(parl,  Math.max(dxNorm,  parl));	  lmPar    =    Math.min(sum2,    Math.max(dxNorm,    parl));    	non-compiled	[CE]  illegal  start  of  type	33	None	replace
375	[BUG]  [BUGGY]  if(lmPar!=  null  &&  dxNorm.length  >  0)  {  [CE]  incomparable  types:  double  and  <null>  [FE]            AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  if(lmPar!=  null  &&  dxNorm.length  >  0)  {  [BUGGY]      lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	if(lmPar!=  null  &&  dxNorm.length  >  0)  {	  if(dxNorm!=    null    &&    dxNorm.length    >    0)    {    	non-compiled	[CE]  incomparable  types:  double  and  <null>	131	None	replace
376	[BUG]  [BUGGY]  if(dxNorm  ==  null  &&  dxNorm.length  >  0)  {  [CE]  incomparable  types:  double  and  <null>  [FE]              AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  if(dxNorm  ==  null  &&  dxNorm.length  >  0)  {  [BUGGY]      lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	if(dxNorm  ==  null  &&  dxNorm.length  >  0)  {	  if(dxNorm!=    null    &&    dxNorm.length    >    0)    {    	non-compiled	[CE]  incomparable  types:  double  and  <null>	131	None	replace
377	[BUG]  [BUGGY]  if(dxNorm  >  0.0)  {  If(dxNorm  <  0.0)  {  [CE]  ';'  expected  [FE]        AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  if(dxNorm  >  0.0)  {  If(dxNorm  <  0.0)  {  [BUGGY]      lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	if(dxNorm  >  0.0)  {  If(dxNorm  <  0.0)  {	  if(dxNorm    >=    0.0)    {    If(dxNorm    >=    0.0)    {    	non-compiled	[CE]  ';'  expected	111	None	replace
378	[BUG]  [BUGGY]  double  lmPar  =  Math.sqrt(param);  [CE]  illegal  start  of  type  [FE]                  AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  double  lmPar  =  Math.sqrt(param);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	double  lmPar  =  Math.sqrt(param);	  double    lmPar    =    Math.sqrt(sum2);    	non-compiled	[CE]  illegal  start  of  type	75	None	replace
379	[BUG]  [BUGGY]  if(sum2)  {  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  }  [CE]  illegal  start  of  type  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  if(sum2)  {  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  }  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	if(sum2)  {  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  }	          lmPar    =    Math.min(delta,    Math.max(dxNorm,    parl));    lmPar    =    Math.min(delta,    Math.max(dxNorm,    parl));    	non-compiled	[CE]  illegal  start  of  type	44	None	replace
380	[BUG]  [BUGGY]  if(sum2)  {  lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  double  lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  }  [CE]  illegal  start  of  type  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  if(sum2)  {  lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  double  lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  }  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	if(sum2)  {  lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  double  lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  }	          lmPar    =    Math.min(paru,    Math.max(gNorm,    parl));    double    lmPar    =    Math.min(paru,    Math.max(gNorm,    parl));    	non-compiled	[CE]  illegal  start  of  type	113	None	replace
381	[BUG]  [BUGGY]  if(sum2)  {  lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  double  lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  }  else  {  [CE]  incompatible  types  [FE]      AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  if(sum2)  {  lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  double  lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  }  else  {  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	if(sum2)  {  lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  double  lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  }  else  {	          lmPar    =    Math.min(paru,    Math.max(gNorm,    parl));    double    lmPar    =    Math.min(paru,    Math.max(gNorm,    parl));    	non-compiled	[CE]  incompatible  types	113	None	replace
382	[BUG]  [BUGGY]  lmPar  =  Math.max(2.0,  Math.max(2.0,  paru));  [CE]  illegal  start  of  type  [FE]        AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  lmPar  =  Math.max(2.0,  Math.max(2.0,  paru));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	lmPar  =  Math.max(2.0,  Math.max(2.0,  paru));	  lmPar    =    Math.max(1.0,    Math.max(1.0,    paru));    	non-compiled	[CE]  illegal  start  of  type	124	None	replace
383	[BUG]  [BUGGY]  double  lmPar  =  Math.min(delta,  Math.max(paru,  lmPar));  [CE]  illegal  start  of  type  [FE]              AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  double  lmPar  =  Math.min(delta,  Math.max(paru,  lmPar));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	double  lmPar  =  Math.min(delta,  Math.max(paru,  lmPar));	  double    lmPar    =    Math.min(delta,    Math.max(lmPar,    parl));    	non-compiled	[CE]  illegal  start  of  type	97	None	replace
384	[BUG]  [BUGGY]  double  lmPar  =  Math.min(paru,  Math.max(lmPar,  alpha));  [CE]  illegal  start  of  type  [FE]                AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  double  lmPar  =  Math.min(paru,  Math.max(lmPar,  alpha));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	double  lmPar  =  Math.min(paru,  Math.max(lmPar,  alpha));	  double    lmPar    =    Math.min(delta,    Math.max(lmPar,    parl));    	non-compiled	[CE]  illegal  start  of  type	97	None	replace
385	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.max(2.0,    Math.max(1.0,    parl));    parl  =  Math.max(2.0,  Math.max(1.0,  parl));  lmPar  =  Math.max(2.0,  Math.max(0.0,  parl));  parl  =  Math.max(2.0,  Math.max(1.0,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	add	                lmPar        =        Math.max(2.0,        Math.max(1.0,        parl));        parl    =    Math.max(2.0,    Math.max(1.0,    parl));    lmPar  =  Math.max(2.0,  Math.max(0.0,  parl));  parl  =  Math.max(2.0,  Math.max(1.0,  parl));	  	compilable	  [FE]  AssertionFailedError  	108	13	add
386	[BUG]  [BUGGY]          lmPar    =    Math.max(2.0,    Math.max(1.0,    parl));    parl  =  Math.max(2.0,  Math.max(1.0,  parl));  lmPar  =  Math.max(2.0,  Math.max(0.0,  parl));  parl  =  Math.max(2.0,  Math.max(1.0,  parl));  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.max(2.0,    Math.max(1.0,    parl));    parl  =  Math.max(2.0,  Math.max(1.0,  parl));  lmPar  =  Math.max(2.0,  Math.max(0.0,  parl));  parl  =  Math.max(2.0,  Math.max(1.0,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.max(2.0,        Math.max(1.0,        parl));        parl    =    Math.max(2.0,    Math.max(1.0,    parl));    lmPar  =  Math.max(2.0,  Math.max(0.0,  parl));  parl  =  Math.max(2.0,  Math.max(1.0,  parl));	  	compilable	  [FE]  AssertionFailedError  	108	13	add
387	[BUG]  [BUGGY]          lmPar    =    Math.max(2.0,    Math.max(1.0,    parl));    parl  =  Math.max(2.0,  Math.max(1.0,  parl));  LmPar  =  Math.max(2.0,  Math.max(1.0,  parl));  parl  =  Math.max(2.0,  Math.max(1.0,  parl));  [CE]  cannot  find  symbol  LmPar  [FE]      AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.max(2.0,    Math.max(1.0,    parl));    parl  =  Math.max(2.0,  Math.max(1.0,  parl));  LmPar  =  Math.max(2.0,  Math.max(1.0,  parl));  parl  =  Math.max(2.0,  Math.max(1.0,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.max(2.0,        Math.max(1.0,        parl));        parl    =    Math.max(2.0,    Math.max(1.0,    parl));    LmPar  =  Math.max(2.0,  Math.max(1.0,  parl));  parl  =  Math.max(2.0,  Math.max(1.0,  parl));	  	non-compiled	[CE]  cannot  find  symbol  LmPar	108	None	add
388	[BUG]  [BUGGY]          lmPar    =    Math.min(delta,    Math.max(dxNorm,    parl));    paru  =  Math.min(delta,  Math.max(dxNorm,  parl));  LmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  paru  =  Math.min(delta,  Math.max(dxNorm,  parl));  [CE]  cannot  find  symbol  LmPar  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.min(delta,    Math.max(dxNorm,    parl));    paru  =  Math.min(delta,  Math.max(dxNorm,  parl));  LmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  paru  =  Math.min(delta,  Math.max(dxNorm,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.min(delta,        Math.max(dxNorm,        parl));        paru    =    Math.min(delta,    Math.max(dxNorm,    parl));    LmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  paru  =  Math.min(delta,  Math.max(dxNorm,  parl));	  	non-compiled	[CE]  cannot  find  symbol  LmPar	100	None	add
389	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.min(delta,    Math.max(dxNorm,    parl));    paru  =  Math.min(delta,  Math.max(dxNorm,  parl));  double  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  paru  =  Math.min(delta,  Math.max(dxNorm,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	add	                lmPar        =        Math.min(delta,        Math.max(dxNorm,        parl));        paru    =    Math.min(delta,    Math.max(dxNorm,    parl));    double  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  paru  =  Math.min(delta,  Math.max(dxNorm,  parl));	  	compilable	  [FE]  AssertionFailedError  	100	9	add
390	[BUG]  [BUGGY]          lmPar    =    Math.min(delta,    Math.max(dxNorm,    parl));    paru  =  Math.min(delta,  Math.max(dxNorm,  parl));  double  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  paru  =  Math.min(delta,  Math.max(dxNorm,  parl));  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.min(delta,    Math.max(dxNorm,    parl));    paru  =  Math.min(delta,  Math.max(dxNorm,  parl));  double  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  paru  =  Math.min(delta,  Math.max(dxNorm,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.min(delta,        Math.max(dxNorm,        parl));        paru    =    Math.min(delta,    Math.max(dxNorm,    parl));    double  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  paru  =  Math.min(delta,  Math.max(dxNorm,  parl));	  	compilable	  [FE]  AssertionFailedError  	100	9	add
391	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.min(paru,    Math.max(gNorm,    parl));    lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  double  lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	add	                lmPar        =        Math.min(paru,        Math.max(gNorm,        parl));        lmPar    =    Math.min(paru,    Math.max(gNorm,    parl));    double  lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));	  	compilable	  [FE]  AssertionFailedError  	16	6	add
392	[BUG]  [BUGGY]          lmPar    =    Math.min(paru,    Math.max(gNorm,    parl));    lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  double  lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.min(paru,    Math.max(gNorm,    parl));    lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  double  lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.min(paru,        Math.max(gNorm,        parl));        lmPar    =    Math.min(paru,    Math.max(gNorm,    parl));    double  lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));	  	compilable	  [FE]  AssertionFailedError  	16	6	add
393	[BUG]  [BUGGY]  LmPar  =  Math.min(paru,  Math.max(delta,  parl));  [CE]  illegal  start  of  type  [FE]          AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  LmPar  =  Math.min(paru,  Math.max(delta,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	LmPar  =  Math.min(paru,  Math.max(delta,  parl));	          lmPar    =    Math.min(paru,    Math.max(lmPar,    parl));    LmPar    =    Math.min(paru,    Math.max(lmPar,    parl));    	non-compiled	[CE]  illegal  start  of  type	88	None	replace
394	[BUG]  [BUGGY]  LmPar  =  Math.min(paru,  Math.max(delta,  0.0));  [CE]  illegal  start  of  type  [FE]            AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  LmPar  =  Math.min(paru,  Math.max(delta,  0.0));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	LmPar  =  Math.min(paru,  Math.max(delta,  0.0));	          lmPar    =    Math.min(paru,    Math.max(lmPar,    parl));    LmPar    =    Math.min(paru,    Math.max(lmPar,    parl));    	non-compiled	[CE]  illegal  start  of  type	88	None	replace
395	[BUG]  [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  LmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  [CE]  cannot  find  symbol  LmPar  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  LmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.max(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    LmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);	  	non-compiled	[CE]  cannot  find  symbol  LmPar	68	None	add
396	[BUG]  [BUGGY]  lmPar  =  Math.min(parl,  Math.max(1.0,  delta));  [CE]  illegal  start  of  type  [FE]            AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  lmPar  =  Math.min(parl,  Math.max(1.0,  delta));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	lmPar  =  Math.min(parl,  Math.max(1.0,  delta));	  lmPar    =    Math.min(delta,    Math.max(1.0,    parl));    	non-compiled	[CE]  illegal  start  of  type	120	None	replace
397	[BUG]  [BUGGY]  LmPar  =  Math.max(2.251e-308,  0.001  *  paru);  [CE]  illegal  start  of  type  [FE]        AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  LmPar  =  Math.max(2.251e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	LmPar  =  Math.max(2.251e-308,  0.001  *  paru);	          lmPar    =    Math.max(2.251e-308,    0.001    *    paru);    LmPar    =    Math.max(2.251e-308,    0.001    *    paru);    	non-compiled	[CE]  illegal  start  of  type	114	None	replace
398	[BUG]  [BUGGY]  LmPar  =  Math.max(2.252e-308,  0.001  *  paru);  [CE]  illegal  start  of  type  [FE]          AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  LmPar  =  Math.max(2.252e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	LmPar  =  Math.max(2.252e-308,  0.001  *  paru);	          lmPar    =    Math.max(2.251e-308,    0.001    *    paru);    LmPar    =    Math.max(2.251e-308,    0.001    *    paru);    	non-compiled	[CE]  illegal  start  of  type	114	None	replace
399	[BUG]  [BUGGY]  LmPar  =  Math.min(paru,  Math.max(lmPar,  lmNorm));  [CE]  illegal  start  of  type  [FE]          AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  LmPar  =  Math.min(paru,  Math.max(lmPar,  lmNorm));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	LmPar  =  Math.min(paru,  Math.max(lmPar,  lmNorm));	          lmPar    =    Math.min(paru,    Math.max(lmPar,    parl));    LmPar    =    Math.min(paru,    Math.max(lmPar,    parl));    	non-compiled	[CE]  illegal  start  of  type	88	None	replace
400	[BUG]  [BUGGY]  double  lmPar  =  Math.min(gNorm,  Math.max(lmPar,  parl));  [CE]  illegal  start  of  type  [FE]                AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  double  lmPar  =  Math.min(gNorm,  Math.max(lmPar,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	double  lmPar  =  Math.min(gNorm,  Math.max(lmPar,  parl));	  double    lmPar    =    Math.min(paru,    Math.max(gNorm,    parl));    	non-compiled	[CE]  illegal  start  of  type	79	None	replace
401	[BUG]  [BUGGY]  if(gNorm!=  null  &&  dxNorm!=  0.0)  {  [CE]  incomparable  types:  double  and  <null>  [FE]              AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  if(gNorm!=  null  &&  dxNorm!=  0.0)  {  [BUGGY]      lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	if(gNorm!=  null  &&  dxNorm!=  0.0)  {	  if(gNorm!=    null)    {    	non-compiled	[CE]  incomparable  types:  double  and  <null>	93	None	replace
402	[BUG]  [BUGGY]  if(gNorm!=  null  &&  dxNorm  >=  0.0)  {  [CE]  incomparable  types:  double  and  <null>  [FE]                AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  if(gNorm!=  null  &&  dxNorm  >=  0.0)  {  [BUGGY]      lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	if(gNorm!=  null  &&  dxNorm  >=  0.0)  {	  if(gNorm!=    null)    {    	non-compiled	[CE]  incomparable  types:  double  and  <null>	93	None	replace
403	[BUG]  [BUGGY]          lmPar    =    Math.min(delta,    Math.max(dxNorm,    parl));    double  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  lmPar  =  Math.max(delta,  Math.max(dxNorm,  parl));  double  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  [CE]  variable  lmPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.min(delta,    Math.max(dxNorm,    parl));    double  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  lmPar  =  Math.max(delta,  Math.max(dxNorm,  parl));  double  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.min(delta,        Math.max(dxNorm,        parl));        double    lmPar    =    Math.min(delta,    Math.max(dxNorm,    parl));    lmPar  =  Math.max(delta,  Math.max(dxNorm,  parl));  double  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));	  	non-compiled	[CE]  variable  lmPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	98	None	add
404	[BUG]  [BUGGY]          lmPar    =    Math.min(delta,    Math.max(dxNorm,    parl));    double  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  double  lmPar  =  Math.max(dxNorm,  parl));  [CE]  ';'  expected  [FE]      AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.min(delta,    Math.max(dxNorm,    parl));    double  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  double  lmPar  =  Math.max(dxNorm,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.min(delta,        Math.max(dxNorm,        parl));        double    lmPar    =    Math.min(delta,    Math.max(dxNorm,    parl));    lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  double  lmPar  =  Math.max(dxNorm,  parl));	  	non-compiled	[CE]  ';'  expected	98	None	add
405	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]            AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  if(dxNorm  >  0)  {  [BUGGY]      lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	add	if(dxNorm  >  0)  {	  if(dxNorm    ==    0)    {    if(dxNorm    >=    0)    {    	compilable	  [FE]  AssertionFailedError  	6	5	replace
406	[BUG]  [BUGGY]  if(dxNorm  >  0)  {  [FE]  AssertionFailedError  [FE]            AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  if(dxNorm  >  0)  {  [BUGGY]      lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	if(dxNorm  >  0)  {	  if(dxNorm    ==    0)    {    if(dxNorm    >=    0)    {    	compilable	  [FE]  AssertionFailedError  	6	5	replace
407	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]              AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  if(dxNorm  >=  0)  {  [BUGGY]      lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	add	if(dxNorm  >=  0)  {	  if(dxNorm    ==    0)    {    if(dxNorm    >=    0)    {    	compilable	  [FE]  AssertionFailedError  	6	5	replace
408	[BUG]  [BUGGY]  if(dxNorm  >=  0)  {  [FE]  AssertionFailedError  [FE]              AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  if(dxNorm  >=  0)  {  [BUGGY]      lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	if(dxNorm  >=  0)  {	  if(dxNorm    ==    0)    {    if(dxNorm    >=    0)    {    	compilable	  [FE]  AssertionFailedError  	6	5	replace
409	[BUG]  [BUGGY]  lmPar  =  Math.max(2.0,  Math.max(0.001,  paru));  [CE]  illegal  start  of  type  [FE]        AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  lmPar  =  Math.max(2.0,  Math.max(0.001,  paru));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	lmPar  =  Math.max(2.0,  Math.max(0.001,  paru));	  lmPar    =    Math.max(2.0,    Math.max(1.0,    paru));    	non-compiled	[CE]  illegal  start  of  type	26	None	replace
410	[BUG]  [BUGGY]  lmPar  =  Math.max(2.0,  Math.max(1.0,  paru  +  1));  [CE]  illegal  start  of  type  [FE]          AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  lmPar  =  Math.max(2.0,  Math.max(1.0,  paru  +  1));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	lmPar  =  Math.max(2.0,  Math.max(1.0,  paru  +  1));	  lmPar    =    Math.max(2.0,    Math.max(1.0,    paru));    	non-compiled	[CE]  illegal  start  of  type	26	None	replace
411	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  if(dxNorm  >  0.0  ||  dxNorm  >  1.0)  {  [BUGGY]      lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	add	if(dxNorm  >  0.0  ||  dxNorm  >  1.0)  {	  if(dxNorm    >    0.0)    {    	compilable	  [FE]  AssertionFailedError  	30	5	replace
412	[BUG]  [BUGGY]  if(dxNorm  >  0.0  ||  dxNorm  >  1.0)  {  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  if(dxNorm  >  0.0  ||  dxNorm  >  1.0)  {  [BUGGY]      lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	if(dxNorm  >  0.0  ||  dxNorm  >  1.0)  {	  if(dxNorm    >    0.0)    {    	compilable	  [FE]  AssertionFailedError  	30	5	replace
413	[BUG]  [BUGGY]  lmPar  =  Math.min(paru,  Math.max(paru,  parl));  [CE]  illegal  start  of  type  [FE]        AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  lmPar  =  Math.min(paru,  Math.max(paru,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	lmPar  =  Math.min(paru,  Math.max(paru,  parl));	  lmPar    =    Math.min(delta,    Math.max(paru,    parl));    	non-compiled	[CE]  illegal  start  of  type	118	None	replace
414	[BUG]  [BUGGY]  if(sum2  >  0.0)  {  lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  paru  =  Math.min(paru,  Math.max(gNorm,  parl));  }  [CE]  illegal  start  of  type  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  if(sum2  >  0.0)  {  lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  paru  =  Math.min(paru,  Math.max(gNorm,  parl));  }  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	if(sum2  >  0.0)  {  lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  paru  =  Math.min(paru,  Math.max(gNorm,  parl));  }	          lmPar    =    Math.min(paru,    Math.max(gNorm,    parl));    paru    =    Math.min(paru,    Math.max(gNorm,    parl));    	non-compiled	[CE]  illegal  start  of  type	19	None	replace
415	[BUG]  [BUGGY]  if(sum2  >  0.0)  {  lmPar  =  Math.max(paru,  Math.max(gNorm,  parl));  paru  =  Math.min(paru,  Math.max(gNorm,  parl));  }  [CE]  illegal  start  of  type  [FE]      AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  if(sum2  >  0.0)  {  lmPar  =  Math.max(paru,  Math.max(gNorm,  parl));  paru  =  Math.min(paru,  Math.max(gNorm,  parl));  }  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	if(sum2  >  0.0)  {  lmPar  =  Math.max(paru,  Math.max(gNorm,  parl));  paru  =  Math.min(paru,  Math.max(gNorm,  parl));  }	          lmPar    =    Math.min(paru,    Math.max(gNorm,    parl));    paru    =    Math.min(paru,    Math.max(gNorm,    parl));    	non-compiled	[CE]  illegal  start  of  type	19	None	replace
416	[BUG]  [BUGGY]  paru  =  Math.min(paru,  Math.max(delta,  lmPar));  [CE]  illegal  start  of  type  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  paru  =  Math.min(paru,  Math.max(delta,  lmPar));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	paru  =  Math.min(paru,  Math.max(delta,  lmPar));	          lmPar    =    Math.min(paru,    Math.max(lmPar,    parl));    paru    =    Math.min(paru,    Math.max(lmPar,    parl));    	non-compiled	[CE]  illegal  start  of  type	91	None	replace
417	[BUG]  [BUGGY]  double  sPar  =  Math.sqrt(parl);  [CE]  illegal  start  of  type  [FE]                    AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  double  sPar  =  Math.sqrt(parl);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	double  sPar  =  Math.sqrt(parl);	  double    sPar    =    Math.sqrt(lmPar);    	non-compiled	[CE]  illegal  start  of  type	76	None	replace
418	[BUG]  [BUGGY]          lmPar    =    Math.min(paru,    Math.max(gNorm,    parl));    double  lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  double  lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  [CE]  variable  lmPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.min(paru,    Math.max(gNorm,    parl));    double  lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  double  lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.min(paru,        Math.max(gNorm,        parl));        double    lmPar    =    Math.min(paru,    Math.max(gNorm,    parl));    lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  double  lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));	  	non-compiled	[CE]  variable  lmPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	112	None	add
419	[BUG]  [BUGGY]          lmPar    =    Math.min(paru,    Math.max(gNorm,    parl));    double  lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  double  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  double  lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  [CE]  variable  lmPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]      AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.min(paru,    Math.max(gNorm,    parl));    double  lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  double  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  double  lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.min(paru,        Math.max(gNorm,        parl));        double    lmPar    =    Math.min(paru,    Math.max(gNorm,    parl));    double  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  double  lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));	  	non-compiled	[CE]  variable  lmPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	112	None	add
420	[BUG]  [BUGGY]  lmPar  =  Math.min(gNorm,  Math.max(delta,  parl));  [CE]  illegal  start  of  type  [FE]          AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  lmPar  =  Math.min(gNorm,  Math.max(delta,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	lmPar  =  Math.min(gNorm,  Math.max(delta,  parl));	  lmPar    =    Math.min(delta,    Math.max(gNorm,    parl));    	non-compiled	[CE]  illegal  start  of  type	2	None	replace
421	[BUG]  [BUGGY]  double  lmPar  =  Math.max(paru,  Math.max(lmPar,  parl));  [CE]  illegal  start  of  type  [FE]                  AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  double  lmPar  =  Math.max(paru,  Math.max(lmPar,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	double  lmPar  =  Math.max(paru,  Math.max(lmPar,  parl));	  double    lmPar    =    Math.min(paru,    Math.max(sum2));    	non-compiled	[CE]  illegal  start  of  type	80	None	replace
422	[BUG]  [BUGGY]  lmPar  =  Math.max(2.0,  Math.max(10.0,  parl));  [CE]  illegal  start  of  type  [FE]            AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  lmPar  =  Math.max(2.0,  Math.max(10.0,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	lmPar  =  Math.max(2.0,  Math.max(10.0,  parl));	          lmPar    =    Math.max(2.0,    Math.max(1.0,    parl));    LmPar    =    Math.max(2.0,    Math.max(1.0,    parl));    	non-compiled	[CE]  illegal  start  of  type	65	None	replace
423	[BUG]  [BUGGY]  if(sum2  >  0.0)  {  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  paru  =  Math.min(paru,  Math.max(dxNorm,  parl));  }  [CE]  illegal  start  of  type  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  if(sum2  >  0.0)  {  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  paru  =  Math.min(paru,  Math.max(dxNorm,  parl));  }  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	if(sum2  >  0.0)  {  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  paru  =  Math.min(paru,  Math.max(dxNorm,  parl));  }	          lmPar    =    Math.min(paru,    Math.max(dxNorm,    parl));    paru    =    Math.min(paru,    Math.max(dxNorm,    parl));    	non-compiled	[CE]  illegal  start  of  type	15	None	replace
424	[BUG]  [BUGGY]  Paru  paru  =  Math.min(paru,  Math.max(dxNorm,  parl));  [CE]  illegal  start  of  type  [FE]      AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  Paru  paru  =  Math.min(paru,  Math.max(dxNorm,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	Paru  paru  =  Math.min(paru,  Math.max(dxNorm,  parl));	          lmPar    =    Math.min(paru,    Math.max(dxNorm,    parl));    paru    =    Math.min(paru,    Math.max(dxNorm,    parl));    	non-compiled	[CE]  illegal  start  of  type	15	None	replace
425	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.min(paru,    Math.max(lmPar,    parl));    paru  =  Math.min(paru,  Math.max(lmPar,  parl));  lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  paru  =  Math.max(paru,  Math.max(lmPar,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	add	                lmPar        =        Math.min(paru,        Math.max(lmPar,        parl));        paru    =    Math.min(paru,    Math.max(lmPar,    parl));    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  paru  =  Math.max(paru,  Math.max(lmPar,  parl));	  	compilable	  [FE]  AssertionFailedError  	90	2	add
426	[BUG]  [BUGGY]          lmPar    =    Math.min(paru,    Math.max(lmPar,    parl));    paru  =  Math.min(paru,  Math.max(lmPar,  parl));  lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  paru  =  Math.max(paru,  Math.max(lmPar,  parl));  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.min(paru,    Math.max(lmPar,    parl));    paru  =  Math.min(paru,  Math.max(lmPar,  parl));  lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  paru  =  Math.max(paru,  Math.max(lmPar,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.min(paru,        Math.max(lmPar,        parl));        paru    =    Math.min(paru,    Math.max(lmPar,    parl));    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  paru  =  Math.max(paru,  Math.max(lmPar,  parl));	  	compilable	  [FE]  AssertionFailedError  	90	2	add
427	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.min(paru,    Math.max(lmPar,    parl));    paru  =  Math.min(paru,  Math.max(lmPar,  parl));  lmPar  =  Math.max(lmPar,  Math.max(lmPar,  parl));  paru  =  Math.min(paru,  Math.max(lmPar,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	add	                lmPar        =        Math.min(paru,        Math.max(lmPar,        parl));        paru    =    Math.min(paru,    Math.max(lmPar,    parl));    lmPar  =  Math.max(lmPar,  Math.max(lmPar,  parl));  paru  =  Math.min(paru,  Math.max(lmPar,  parl));	  	compilable	  [FE]  AssertionFailedError  	90	2	add
428	[BUG]  [BUGGY]          lmPar    =    Math.min(paru,    Math.max(lmPar,    parl));    paru  =  Math.min(paru,  Math.max(lmPar,  parl));  lmPar  =  Math.max(lmPar,  Math.max(lmPar,  parl));  paru  =  Math.min(paru,  Math.max(lmPar,  parl));  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.min(paru,    Math.max(lmPar,    parl));    paru  =  Math.min(paru,  Math.max(lmPar,  parl));  lmPar  =  Math.max(lmPar,  Math.max(lmPar,  parl));  paru  =  Math.min(paru,  Math.max(lmPar,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.min(paru,        Math.max(lmPar,        parl));        paru    =    Math.min(paru,    Math.max(lmPar,    parl));    lmPar  =  Math.max(lmPar,  Math.max(lmPar,  parl));  paru  =  Math.min(paru,  Math.max(lmPar,  parl));	  	compilable	  [FE]  AssertionFailedError  	90	2	add
429	[BUG]  [BUGGY]          lmPar    =    Math.min(paru,    Math.max(lmPar,    parl));    paru  =  Math.min(paru,  Math.max(lmPar,  parl));  lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  paru  =  Math.max(lmPar,  parl));  [CE]  ';'  expected  [FE]        AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.min(paru,    Math.max(lmPar,    parl));    paru  =  Math.min(paru,  Math.max(lmPar,  parl));  lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  paru  =  Math.max(lmPar,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.min(paru,        Math.max(lmPar,        parl));        paru    =    Math.min(paru,    Math.max(lmPar,    parl));    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  paru  =  Math.max(lmPar,  parl));	  	non-compiled	[CE]  ';'  expected	90	None	add
430	[BUG]  [BUGGY]  double  dxNorm  =  Math.sqrt(sum3);  [CE]  illegal  start  of  type  [FE]                      AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  double  dxNorm  =  Math.sqrt(sum3);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	double  dxNorm  =  Math.sqrt(sum3);	  double    dxNorm    =    Math.sqrt(sum1);    	non-compiled	[CE]  illegal  start  of  type	77	None	replace
431	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.min(delta,    Math.max(dxNorm,    parl));    lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  lmPar  =  Math.max(delta,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	add	                lmPar        =        Math.min(delta,        Math.max(dxNorm,        parl));        lmPar    =    Math.min(paru,    Math.max(dxNorm,    parl));    lmPar  =  Math.max(delta,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));	  	compilable	  [FE]  AssertionFailedError  	45	6	add
432	[BUG]  [BUGGY]          lmPar    =    Math.min(delta,    Math.max(dxNorm,    parl));    lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  lmPar  =  Math.max(delta,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.min(delta,    Math.max(dxNorm,    parl));    lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  lmPar  =  Math.max(delta,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.min(delta,        Math.max(dxNorm,        parl));        lmPar    =    Math.min(paru,    Math.max(dxNorm,    parl));    lmPar  =  Math.max(delta,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));	  	compilable	  [FE]  AssertionFailedError  	45	6	add
433	[BUG]  [BUGGY]  if(lmPar!=  null  &&  dxNorm!=  0.0)  {  [CE]  incomparable  types:  double  and  <null>  [FE]            AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  if(lmPar!=  null  &&  dxNorm!=  0.0)  {  [BUGGY]      lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	if(lmPar!=  null  &&  dxNorm!=  0.0)  {	  if(lmPar!=    null)    {    	non-compiled	[CE]  incomparable  types:  double  and  <null>	103	None	replace
434	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.min(paru,    Math.max(dxNorm,    parl));    lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  lmPar  =  Math.max(paru,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	add	                lmPar        =        Math.min(paru,        Math.max(dxNorm,        parl));        lmPar    =    Math.min(paru,    Math.max(dxNorm,    parl));    lmPar  =  Math.max(paru,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));	  	compilable	  [FE]  AssertionFailedError  	10	6	add
435	[BUG]  [BUGGY]          lmPar    =    Math.min(paru,    Math.max(dxNorm,    parl));    lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  lmPar  =  Math.max(paru,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.min(paru,    Math.max(dxNorm,    parl));    lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  lmPar  =  Math.max(paru,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.min(paru,        Math.max(dxNorm,        parl));        lmPar    =    Math.min(paru,    Math.max(dxNorm,    parl));    lmPar  =  Math.max(paru,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));	  	compilable	  [FE]  AssertionFailedError  	10	6	add
436	[BUG]  [BUGGY]  double  lmPar  =  Math.max(paru,  Math.max(delta,  parl));  [CE]  illegal  start  of  type  [FE]              AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  double  lmPar  =  Math.max(paru,  Math.max(delta,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	double  lmPar  =  Math.max(paru,  Math.max(delta,  parl));	  double    lmPar    =    Math.min(delta,    Math.max(lmPar,    parl));    	non-compiled	[CE]  illegal  start  of  type	97	None	replace
437	[BUG]  [BUGGY]          lmPar    =    Math.min(delta,    Math.max(dxNorm,    parl));    lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  lmPar  =  Math.max(dxNorm,  parl));  [CE]  ';'  expected  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.min(delta,    Math.max(dxNorm,    parl));    lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  lmPar  =  Math.max(dxNorm,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.min(delta,        Math.max(dxNorm,        parl));        lmPar    =    Math.min(delta,    Math.max(dxNorm,    parl));    lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  lmPar  =  Math.max(dxNorm,  parl));	  	non-compiled	[CE]  ';'  expected	43	None	add
438	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.min(delta,    Math.max(dxNorm,    parl));    lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  lmPar  =  Math.max(delta,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	add	                lmPar        =        Math.min(delta,        Math.max(dxNorm,        parl));        lmPar    =    Math.min(delta,    Math.max(dxNorm,    parl));    lmPar  =  Math.max(delta,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));	  	compilable	  [FE]  AssertionFailedError  	43	5	add
439	[BUG]  [BUGGY]          lmPar    =    Math.min(delta,    Math.max(dxNorm,    parl));    lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  lmPar  =  Math.max(delta,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.min(delta,    Math.max(dxNorm,    parl));    lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  lmPar  =  Math.max(delta,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.min(delta,        Math.max(dxNorm,        parl));        lmPar    =    Math.min(delta,    Math.max(dxNorm,    parl));    lmPar  =  Math.max(delta,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));	  	compilable	  [FE]  AssertionFailedError  	43	5	add
440	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.min(delta,    Math.max(dxNorm,    parl));    lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  lmPar  =  Math.max(delta,  Math.max(dxNorm,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	add	                lmPar        =        Math.min(delta,        Math.max(dxNorm,        parl));        lmPar    =    Math.min(delta,    Math.max(dxNorm,    parl));    lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  lmPar  =  Math.max(delta,  Math.max(dxNorm,  parl));	  	compilable	  [FE]  AssertionFailedError  	43	5	add
441	[BUG]  [BUGGY]          lmPar    =    Math.min(delta,    Math.max(dxNorm,    parl));    lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  lmPar  =  Math.max(delta,  Math.max(dxNorm,  parl));  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.min(delta,    Math.max(dxNorm,    parl));    lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  lmPar  =  Math.max(delta,  Math.max(dxNorm,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.min(delta,        Math.max(dxNorm,        parl));        lmPar    =    Math.min(delta,    Math.max(dxNorm,    parl));    lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  lmPar  =  Math.max(delta,  Math.max(dxNorm,  parl));	  	compilable	  [FE]  AssertionFailedError  	43	5	add
442	[BUG]  [BUGGY]  lmPar  =  Math.min(paru,  Math.max(paramPar,  parl));  [CE]  illegal  start  of  type  [FE]              AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  lmPar  =  Math.min(paru,  Math.max(paramPar,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	lmPar  =  Math.min(paru,  Math.max(paramPar,  parl));	  lmPar    =    Math.min(paru,    Math.max(pr,    parl));    	non-compiled	[CE]  illegal  start  of  type	122	None	replace
443	[BUG]  [BUGGY]  lmPar  =  Math.min(paru,  Math.max(pr,  dxNorm));  [CE]  illegal  start  of  type  [FE]                  AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  lmPar  =  Math.min(paru,  Math.max(pr,  dxNorm));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	lmPar  =  Math.min(paru,  Math.max(pr,  dxNorm));	  lmPar    =    Math.min(paru,    Math.max(gNorm,    dxNorm));    	non-compiled	[CE]  illegal  start  of  type	107	None	replace
444	[BUG]  [BUGGY]  if(dxNorm  >=  null)  {  [CE]  bad  operand  types  for  binary  operator  '>='  [FE]                AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  if(dxNorm  >=  null)  {  [BUGGY]      lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	if(dxNorm  >=  null)  {	  if(dxNorm    ==    null)    {    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '>='	94	None	replace
445	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  if(dxNorm  <  0.0  ||  dxNorm  >  1.0)  {  [BUGGY]      lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	add	if(dxNorm  <  0.0  ||  dxNorm  >  1.0)  {	  if(dxNorm    <    0.0)    {    	compilable	  [FE]  AssertionFailedError  	32	4	replace
446	[BUG]  [BUGGY]  if(dxNorm  <  0.0  ||  dxNorm  >  1.0)  {  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  if(dxNorm  <  0.0  ||  dxNorm  >  1.0)  {  [BUGGY]      lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	if(dxNorm  <  0.0  ||  dxNorm  >  1.0)  {	  if(dxNorm    <    0.0)    {    	compilable	  [FE]  AssertionFailedError  	32	4	replace
447	[BUG]  [BUGGY]          lmPar    =    Math.min(delta,    Math.max(dxNorm,    parl));    paru  =  Math.min(delta,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  paru  =  Math.max(dxNorm,  parl));  [CE]  ';'  expected  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.min(delta,    Math.max(dxNorm,    parl));    paru  =  Math.min(delta,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  paru  =  Math.max(dxNorm,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.min(delta,        Math.max(dxNorm,        parl));        paru    =    Math.min(delta,    Math.max(dxNorm,    parl));    lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  paru  =  Math.max(dxNorm,  parl));	  	non-compiled	[CE]  ';'  expected	100	None	add
448	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.min(delta,    Math.max(dxNorm,    parl));    paru  =  Math.min(delta,  Math.max(dxNorm,  parl));  lmPar  =  Math.max(delta,  Math.max(dxNorm,  parl));  paru  =  Math.min(delta,  Math.max(dxNorm,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	add	                lmPar        =        Math.min(delta,        Math.max(dxNorm,        parl));        paru    =    Math.min(delta,    Math.max(dxNorm,    parl));    lmPar  =  Math.max(delta,  Math.max(dxNorm,  parl));  paru  =  Math.min(delta,  Math.max(dxNorm,  parl));	  	compilable	  [FE]  AssertionFailedError  	100	5	add
449	[BUG]  [BUGGY]          lmPar    =    Math.min(delta,    Math.max(dxNorm,    parl));    paru  =  Math.min(delta,  Math.max(dxNorm,  parl));  lmPar  =  Math.max(delta,  Math.max(dxNorm,  parl));  paru  =  Math.min(delta,  Math.max(dxNorm,  parl));  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.min(delta,    Math.max(dxNorm,    parl));    paru  =  Math.min(delta,  Math.max(dxNorm,  parl));  lmPar  =  Math.max(delta,  Math.max(dxNorm,  parl));  paru  =  Math.min(delta,  Math.max(dxNorm,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.min(delta,        Math.max(dxNorm,        parl));        paru    =    Math.min(delta,    Math.max(dxNorm,    parl));    lmPar  =  Math.max(delta,  Math.max(dxNorm,  parl));  paru  =  Math.min(delta,  Math.max(dxNorm,  parl));	  	compilable	  [FE]  AssertionFailedError  	100	5	add
450	[BUG]  [BUGGY]          lmPar    =    Math.min(delta,    Math.max(dxNorm,    parl));    paru  =  Math.min(delta,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  paru  =  Math.max(dyNorm,  parl));  [CE]  ';'  expected  [FE]        AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.min(delta,    Math.max(dxNorm,    parl));    paru  =  Math.min(delta,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  paru  =  Math.max(dyNorm,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.min(delta,        Math.max(dxNorm,        parl));        paru    =    Math.min(delta,    Math.max(dxNorm,    parl));    lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  paru  =  Math.max(dyNorm,  parl));	  	non-compiled	[CE]  ';'  expected	100	None	add
451	[BUG]  [BUGGY]  lmPar  =  Math.max(2.2252e-308,.001  *  paru);  [CE]  illegal  start  of  type  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  lmPar  =  Math.max(2.2252e-308,.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	lmPar  =  Math.max(2.2252e-308,.001  *  paru);	          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar    =    Math.max(2.2251e-308,.001    *    paru);    	non-compiled	[CE]  illegal  start  of  type	71	None	replace
452	[BUG]  [BUGGY]  double  lmPar  =  Math.sqrt(p);  [CE]  illegal  start  of  type  [FE]                  AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  double  lmPar  =  Math.sqrt(p);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	double  lmPar  =  Math.sqrt(p);	  double    lmPar    =    Math.sqrt(sum2);    	non-compiled	[CE]  illegal  start  of  type	75	None	replace
453	[BUG]  [BUGGY]  lmPar  =  Math.max(paru,  Math.max(paru,  parl));  [CE]  illegal  start  of  type  [FE]        AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  lmPar  =  Math.max(paru,  Math.max(paru,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	lmPar  =  Math.max(paru,  Math.max(paru,  parl));	  lmPar    =    Math.min(paru,    Math.max(delta,    parl));    	non-compiled	[CE]  illegal  start  of  type	8	None	replace
454	[BUG]  [BUGGY]  if(dxNorm  >  0.0)  {  If(dxNorm  ==  0.0)  {  [CE]  ';'  expected  [FE]            AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  if(dxNorm  >  0.0)  {  If(dxNorm  ==  0.0)  {  [BUGGY]      lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	if(dxNorm  >  0.0)  {  If(dxNorm  ==  0.0)  {	  if(dxNorm    ==    0.0)    {    If(dxNorm    ==    0.0)    {    	non-compiled	[CE]  ';'  expected	24	None	replace
455	[BUG]  [BUGGY]  lmPar  =  Math.max(paru,  Math.max(delta,  2.0));  [CE]  illegal  start  of  type  [FE]        AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  lmPar  =  Math.max(paru,  Math.max(delta,  2.0));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	lmPar  =  Math.max(paru,  Math.max(delta,  2.0));	  lmPar    =    Math.max(paru,    Math.max(delta,    0.0));    	non-compiled	[CE]  illegal  start  of  type	117	None	replace
456	[BUG]  [BUGGY]  if(paru  >  0.0)  {  lmPar  =  Math.max(delta,  Math.max(dxNorm,  parl));  paru  =  Math.min(delta,  Math.max(dxNorm,  parl));  }  [CE]  illegal  start  of  type  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  if(paru  >  0.0)  {  lmPar  =  Math.max(delta,  Math.max(dxNorm,  parl));  paru  =  Math.min(delta,  Math.max(dxNorm,  parl));  }  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	if(paru  >  0.0)  {  lmPar  =  Math.max(delta,  Math.max(dxNorm,  parl));  paru  =  Math.min(delta,  Math.max(dxNorm,  parl));  }	          lmPar    =    Math.min(delta,    Math.max(dxNorm,    parl));    paru    =    Math.min(delta,    Math.max(dxNorm,    parl));    	non-compiled	[CE]  illegal  start  of  type	101	None	replace
457	[BUG]  [BUGGY]  if(paru  >  0.0)  {  lmPar  =  Math.max(delta,  Math.max(parl,  1.0));  paru  =  Math.min(delta,  Math.max(dxNorm,  parl));  }  [CE]  illegal  start  of  type  [FE]      AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  if(paru  >  0.0)  {  lmPar  =  Math.max(delta,  Math.max(parl,  1.0));  paru  =  Math.min(delta,  Math.max(dxNorm,  parl));  }  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	if(paru  >  0.0)  {  lmPar  =  Math.max(delta,  Math.max(parl,  1.0));  paru  =  Math.min(delta,  Math.max(dxNorm,  parl));  }	          lmPar    =    Math.min(delta,    Math.max(dxNorm,    parl));    paru    =    Math.min(delta,    Math.max(dxNorm,    parl));    	non-compiled	[CE]  illegal  start  of  type	101	None	replace
458	[BUG]  [BUGGY]  lmPar  =  Math.max(paru,  Math.min(gNorm,  parl));  [CE]  illegal  start  of  type  [FE]        AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  lmPar  =  Math.max(paru,  Math.min(gNorm,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	lmPar  =  Math.max(paru,  Math.min(gNorm,  parl));	  lmPar    =    Math.max(paru,    Math.max(dxNorm,    parl));    	non-compiled	[CE]  illegal  start  of  type	125	None	replace
459	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.min(paru,    Math.max(dxNorm,    parl));    paru  =  Math.min(paru,  Math.max(dxNorm,  parl));  lmPar  =  Math.max(paru,  Math.max(dxNorm,  parl));  paru  =  Math.min(paru,  Math.max(dxNorm,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	add	                lmPar        =        Math.min(paru,        Math.max(dxNorm,        parl));        paru    =    Math.min(paru,    Math.max(dxNorm,    parl));    lmPar  =  Math.max(paru,  Math.max(dxNorm,  parl));  paru  =  Math.min(paru,  Math.max(dxNorm,  parl));	  	compilable	  [FE]  AssertionFailedError  	14	5	add
460	[BUG]  [BUGGY]          lmPar    =    Math.min(paru,    Math.max(dxNorm,    parl));    paru  =  Math.min(paru,  Math.max(dxNorm,  parl));  lmPar  =  Math.max(paru,  Math.max(dxNorm,  parl));  paru  =  Math.min(paru,  Math.max(dxNorm,  parl));  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.min(paru,    Math.max(dxNorm,    parl));    paru  =  Math.min(paru,  Math.max(dxNorm,  parl));  lmPar  =  Math.max(paru,  Math.max(dxNorm,  parl));  paru  =  Math.min(paru,  Math.max(dxNorm,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.min(paru,        Math.max(dxNorm,        parl));        paru    =    Math.min(paru,    Math.max(dxNorm,    parl));    lmPar  =  Math.max(paru,  Math.max(dxNorm,  parl));  paru  =  Math.min(paru,  Math.max(dxNorm,  parl));	  	compilable	  [FE]  AssertionFailedError  	14	5	add
461	[BUG]  [BUGGY]  if(sum2  >  0.0)  {  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  double  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  }  [CE]  illegal  start  of  type  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  if(sum2  >  0.0)  {  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  double  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  }  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	if(sum2  >  0.0)  {  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  double  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  }	          lmPar    =    Math.min(paru,    Math.max(dxNorm,    parl));    double    lmPar    =    Math.min(paru,    Math.max(dxNorm,    parl));    	non-compiled	[CE]  illegal  start  of  type	96	None	replace
462	[BUG]  [BUGGY]  lmPar  =  Math.max(0.0,  Math.max(0.0,  paru));  [CE]  illegal  start  of  type  [FE]            AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  lmPar  =  Math.max(0.0,  Math.max(0.0,  paru));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	lmPar  =  Math.max(0.0,  Math.max(0.0,  paru));	  lmPar    =    Math.max(2.0,    Math.max(0.0,    parl));    	non-compiled	[CE]  illegal  start  of  type	28	None	replace
463	[BUG]  [BUGGY]  double  lmPar  =  Math.min(paru,  Math.max(paru,  parl));  [CE]  illegal  start  of  type  [FE]              AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  double  lmPar  =  Math.min(paru,  Math.max(paru,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	double  lmPar  =  Math.min(paru,  Math.max(paru,  parl));	  double    lmPar    =    Math.min(paru,    Math.max(delta,    parl));    	non-compiled	[CE]  illegal  start  of  type	78	None	replace
464	[BUG]  [BUGGY]  double  lmPar  =  Math.max(paru,  Math.max(delta,  lmPar));  [CE]  illegal  start  of  type  [FE]                AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  double  lmPar  =  Math.max(paru,  Math.max(delta,  lmPar));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	double  lmPar  =  Math.max(paru,  Math.max(delta,  lmPar));	  double    lmPar    =    Math.min(paru,    Math.max(delta,    parl));    	non-compiled	[CE]  illegal  start  of  type	78	None	replace
465	[BUG]  [BUGGY]  lmPar  =  Math.min(paru,  Math.max(0,  parl));  [CE]  illegal  start  of  type  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  lmPar  =  Math.min(paru,  Math.max(0,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	lmPar  =  Math.min(paru,  Math.max(0,  parl));	          lmPar    =    Math.min(paru,    Math.max(lmPar,    parl));    lmPar    =    Math.min(paru,    Math.max(lmPar,    parl));    	non-compiled	[CE]  illegal  start  of  type	87	None	replace
466	[BUG]  [BUGGY]  if(lmPar  ==  null  ||  dxNorm  >=  0.0)  {  [CE]  incomparable  types:  double  and  <null>  [FE]            AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  if(lmPar  ==  null  ||  dxNorm  >=  0.0)  {  [BUGGY]      lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	if(lmPar  ==  null  ||  dxNorm  >=  0.0)  {	  if(lmPar    ==    null)    {    	non-compiled	[CE]  incomparable  types:  double  and  <null>	92	None	replace
467	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.min(paru,    Math.max(gNorm,    parl));    paru  =  Math.min(paru,  Math.max(gNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  paru  =  Math.max(paru,  Math.max(gNorm,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	add	                lmPar        =        Math.min(paru,        Math.max(gNorm,        parl));        paru    =    Math.min(paru,    Math.max(gNorm,    parl));    lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  paru  =  Math.max(paru,  Math.max(gNorm,  parl));	  	compilable	  [FE]  AssertionFailedError  	18	5	add
468	[BUG]  [BUGGY]          lmPar    =    Math.min(paru,    Math.max(gNorm,    parl));    paru  =  Math.min(paru,  Math.max(gNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  paru  =  Math.max(paru,  Math.max(gNorm,  parl));  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.min(paru,    Math.max(gNorm,    parl));    paru  =  Math.min(paru,  Math.max(gNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  paru  =  Math.max(paru,  Math.max(gNorm,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.min(paru,        Math.max(gNorm,        parl));        paru    =    Math.min(paru,    Math.max(gNorm,    parl));    lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  paru  =  Math.max(paru,  Math.max(gNorm,  parl));	  	compilable	  [FE]  AssertionFailedError  	18	5	add
469	[BUG]  [BUGGY]          lmPar    =    Math.min(paru,    Math.max(gNorm,    parl));    lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(nNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  [CE]  cannot  find  symbol  nNorm  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.min(paru,    Math.max(gNorm,    parl));    lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(nNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.min(paru,        Math.max(gNorm,        parl));        lmPar    =    Math.min(paru,    Math.max(gNorm,    parl));    lmPar  =  Math.min(paru,  Math.max(nNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));	  	non-compiled	[CE]  cannot  find  symbol  nNorm	16	None	add
470	[BUG]  [BUGGY]  if(sum2  >  0.0)  {  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  }  [CE]  illegal  start  of  type  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  if(sum2  >  0.0)  {  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  }  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	if(sum2  >  0.0)  {  lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  }	          lmPar    =    Math.min(delta,    Math.max(dxNorm,    parl));    lmPar    =    Math.min(paru,    Math.max(dxNorm,    parl));    	non-compiled	[CE]  illegal  start  of  type	46	None	replace
471	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	add	                lmPar        =        Math.max(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	68	5	add
472	[BUG]  [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.max(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	68	5	add
473	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.3251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	add	                lmPar        =        Math.max(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.3251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	68	5	add
474	[BUG]  [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.3251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.3251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.max(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.3251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	68	5	add
475	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.max(2.251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.251e-308,.001  *  paru);  lmPar  =  Math.max(2.0e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	add	                lmPar        =        Math.max(2.251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.251e-308,.001    *    paru);    lmPar  =  Math.max(2.0e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	55	5	add
476	[BUG]  [BUGGY]          lmPar    =    Math.max(2.251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.251e-308,.001  *  paru);  lmPar  =  Math.max(2.0e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,.001  *  paru);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.max(2.251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.251e-308,.001  *  paru);  lmPar  =  Math.max(2.0e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.max(2.251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.251e-308,.001    *    paru);    lmPar  =  Math.max(2.0e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	55	5	add
477	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  if(gNorm!=  dxNorm)  {  [BUGGY]      lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	add	if(gNorm!=  dxNorm)  {	  if(dxNorm    ==    0)    {    if(dxNorm!=    0)    {    	compilable	  [FE]  AssertionFailedError  	5	5	replace
478	[BUG]  [BUGGY]  if(gNorm!=  dxNorm)  {  [FE]  AssertionFailedError  [FE]          AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  if(gNorm!=  dxNorm)  {  [BUGGY]      lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	if(gNorm!=  dxNorm)  {	  if(dxNorm    ==    0)    {    if(dxNorm!=    0)    {    	compilable	  [FE]  AssertionFailedError  	5	5	replace
479	[BUG]  [BUGGY]  lmPar  =  Math.max(dxNorm,  Math.max(paru,  parl));  [CE]  illegal  start  of  type  [FE]          AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  lmPar  =  Math.max(dxNorm,  Math.max(paru,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	lmPar  =  Math.max(dxNorm,  Math.max(paru,  parl));	  lmPar    =    Math.max(gNorm,    Math.max(paru,    parl));    	non-compiled	[CE]  illegal  start  of  type	119	None	replace
480	[BUG]  [BUGGY]          lmPar    =    Math.min(paru,    Math.max(lmPar,    parl));    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  lmPar  =  Math.max(lmPar,  parl));  [CE]  ';'  expected  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.min(paru,    Math.max(lmPar,    parl));    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  lmPar  =  Math.max(lmPar,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.min(paru,        Math.max(lmPar,        parl));        lmPar    =    Math.min(paru,    Math.max(lmPar,    parl));    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  lmPar  =  Math.max(lmPar,  parl));	  	non-compiled	[CE]  ';'  expected	86	None	add
481	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.min(paru,    Math.max(lmPar,    parl));    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  lmPar  =  Math.max(lmPar,  Math.max(lmPar,  parl));  lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	add	                lmPar        =        Math.min(paru,        Math.max(lmPar,        parl));        lmPar    =    Math.min(paru,    Math.max(lmPar,    parl));    lmPar  =  Math.max(lmPar,  Math.max(lmPar,  parl));  lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));	  	compilable	  [FE]  AssertionFailedError  	86	2	add
482	[BUG]  [BUGGY]          lmPar    =    Math.min(paru,    Math.max(lmPar,    parl));    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  lmPar  =  Math.max(lmPar,  Math.max(lmPar,  parl));  lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.min(paru,    Math.max(lmPar,    parl));    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  lmPar  =  Math.max(lmPar,  Math.max(lmPar,  parl));  lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.min(paru,        Math.max(lmPar,        parl));        lmPar    =    Math.min(paru,    Math.max(lmPar,    parl));    lmPar  =  Math.max(lmPar,  Math.max(lmPar,  parl));  lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));	  	compilable	  [FE]  AssertionFailedError  	86	2	add
483	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	add	                lmPar        =        Math.max(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	66	5	add
484	[BUG]  [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.max(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	66	5	add
485	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	add	                lmPar        =        Math.max(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	66	5	add
486	[BUG]  [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.max(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	66	5	add
487	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	add	                lmPar        =        Math.max(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	72	5	add
488	[BUG]  [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	                lmPar        =        Math.max(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	72	5	add
489	[BUG]  [BUGGY]  if(dxNorm!=  null  &&  dxNorm.equals(tmp))  {  [CE]  incomparable  types:  double  and  <null>  [FE]                AssertionFailedError      [CONTEXT]      double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));      [BUGGY]  if(dxNorm!=  null  &&  dxNorm.equals(tmp))  {  [BUGGY]      lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	if(dxNorm!=  null  &&  dxNorm.equals(tmp))  {	  if(dxNorm!=    null    &&    dxNorm.equals(gNorm))    {    	non-compiled	[CE]  incomparable  types:  double  and  <null>	133	None	replace
