bugid	buggy	buggy_class	suspiciousness	buggy_line	endbuggycode	original_failing_test_number	action	patch	original_buggy	execution_result	diagnosis	previous_bug_id	new_failing_test_number	this_action
1	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError  [CONTEXT]  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  [BUGGY]    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  [BUGGY]  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	add	    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));		compilable	  [FE]  AssertionFailedError  	72	2	add
2	[BUG]  [BUGGY]    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  [FE]  AssertionFailedError  [FE]    AssertionFailedError  [CONTEXT]  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  [BUGGY]    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  [BUGGY]  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));		compilable	  [FE]  AssertionFailedError  	72	2	add
3	[BUG]  [BUGGY]    double  lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  [CE]  variable  lmPar  might  not  have  been  initialized  [FE]      AssertionFailedError  [CONTEXT]  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  [BUGGY]    double  lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  [BUGGY]  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	    double  lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));		non-compiled	[CE]  variable  lmPar  might  not  have  been  initialized	72	None	add
4	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError  [CONTEXT]  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  [BUGGY]    lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  [BUGGY]  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	add	    lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));		compilable	  [FE]  AssertionFailedError  	72	6	add
5	[BUG]  [BUGGY]    lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  [FE]  AssertionFailedError  [FE]        AssertionFailedError  [CONTEXT]  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  [BUGGY]    lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));  [BUGGY]  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	    lmPar  =  Math.min(paru,  Math.max(dxNorm,  parl));		compilable	  [FE]  AssertionFailedError  	72	6	add
6	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError  [CONTEXT]  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  [BUGGY]    lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  [BUGGY]  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	add	    lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));		compilable	  [FE]  AssertionFailedError  	72	5	add
7	[BUG]  [BUGGY]    lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  [FE]  AssertionFailedError  [FE]          AssertionFailedError  [CONTEXT]  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  [BUGGY]    lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  [BUGGY]  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	    lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));		compilable	  [FE]  AssertionFailedError  	72	5	add
8	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError  [CONTEXT]  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  [BUGGY]  if(dxNorm!=  0.0)  {  [BUGGY]  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	add	if(dxNorm!=  0.0)  {	if  (lmPar  ==  0)  {  	compilable	  [FE]  AssertionFailedError  	71	5	replace
9	[BUG]  [BUGGY]  if(dxNorm!=  0.0)  {  [FE]  AssertionFailedError  [FE]    AssertionFailedError  [CONTEXT]  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  [BUGGY]  if(dxNorm!=  0.0)  {  [BUGGY]  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	if(dxNorm!=  0.0)  {	if  (lmPar  ==  0)  {  	compilable	  [FE]  AssertionFailedError  	71	5	replace
10	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError  [CONTEXT]  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  [BUGGY]  if(dxNorm  ==  0.0)  {  [BUGGY]  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	add	if(dxNorm  ==  0.0)  {	if  (lmPar  ==  0)  {  	compilable	  [FE]  AssertionFailedError  	71	2	replace
11	[BUG]  [BUGGY]  if(dxNorm  ==  0.0)  {  [FE]  AssertionFailedError  [FE]      AssertionFailedError  [CONTEXT]  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  [BUGGY]  if(dxNorm  ==  0.0)  {  [BUGGY]  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	if(dxNorm  ==  0.0)  {	if  (lmPar  ==  0)  {  	compilable	  [FE]  AssertionFailedError  	71	2	replace
12	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError  [CONTEXT]  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  [BUGGY]  if(dxNorm!=  0)  {  [BUGGY]  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	add	if(dxNorm!=  0)  {	if  (lmPar  ==  0)  {  	compilable	  [FE]  AssertionFailedError  	71	5	replace
13	[BUG]  [BUGGY]  if(dxNorm!=  0)  {  [FE]  AssertionFailedError  [FE]        AssertionFailedError  [CONTEXT]  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  [BUGGY]  if(dxNorm!=  0)  {  [BUGGY]  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	if(dxNorm!=  0)  {	if  (lmPar  ==  0)  {  	compilable	  [FE]  AssertionFailedError  	71	5	replace
14	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError  [CONTEXT]  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  [BUGGY]  if(dxNorm  ==  0)  {  [BUGGY]  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	add	if(dxNorm  ==  0)  {	if  (lmPar  ==  0)  {  	compilable	  [FE]  AssertionFailedError  	71	2	replace
15	[BUG]  [BUGGY]  if(dxNorm  ==  0)  {  [FE]  AssertionFailedError  [FE]          AssertionFailedError  [CONTEXT]  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  [BUGGY]  if(dxNorm  ==  0)  {  [BUGGY]  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	if(dxNorm  ==  0)  {	if  (lmPar  ==  0)  {  	compilable	  [FE]  AssertionFailedError  	71	2	replace
16	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError  [CONTEXT]  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  [BUGGY]    lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  [BUGGY]  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	add	    lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));		compilable	  [FE]  AssertionFailedError  	72	5	add
17	[BUG]  [BUGGY]    lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  [FE]  AssertionFailedError  [FE]    AssertionFailedError  [CONTEXT]  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  [BUGGY]    lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));  [BUGGY]  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	    lmPar  =  Math.min(delta,  Math.max(dxNorm,  parl));		compilable	  [FE]  AssertionFailedError  	72	5	add
18	[BUG]  [BUGGY]    lmPar  =  Math.min(paru,  Math.max(sPar,  parl));  [CE]  cannot  find  symbol  sPar  [FE]      AssertionFailedError  [CONTEXT]  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  [BUGGY]    lmPar  =  Math.min(paru,  Math.max(sPar,  parl));  [BUGGY]  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	    lmPar  =  Math.min(paru,  Math.max(sPar,  parl));		non-compiled	[CE]  cannot  find  symbol  sPar	72	None	add
19	[BUG]  [BUGGY]    double  dxNorm  =  Math.sqrt(lmPar);  [CE]  variable  dxNorm  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]        AssertionFailedError  [CONTEXT]  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  [BUGGY]    double  dxNorm  =  Math.sqrt(lmPar);  [BUGGY]  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	    double  dxNorm  =  Math.sqrt(lmPar);		non-compiled	[CE]  variable  dxNorm  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	72	None	add
20	[BUG]  [BUGGY]    lmPar  =  Math.min(paru,  Math.max(sPar,  dxNorm));  [CE]  cannot  find  symbol  sPar  [FE]          AssertionFailedError  [CONTEXT]  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  [BUGGY]    lmPar  =  Math.min(paru,  Math.max(sPar,  dxNorm));  [BUGGY]  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	    lmPar  =  Math.min(paru,  Math.max(sPar,  dxNorm));		non-compiled	[CE]  cannot  find  symbol  sPar	72	None	add
21	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError  [CONTEXT]  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  [BUGGY]  if(dxNorm  >=  0.0)  {  [BUGGY]  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	add	if(dxNorm  >=  0.0)  {	if  (lmPar  ==  0)  {  	compilable	  [FE]  AssertionFailedError  	71	5	replace
22	[BUG]  [BUGGY]  if(dxNorm  >=  0.0)  {  [FE]  AssertionFailedError  [FE]    AssertionFailedError  [CONTEXT]  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  [BUGGY]  if(dxNorm  >=  0.0)  {  [BUGGY]  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	if(dxNorm  >=  0.0)  {	if  (lmPar  ==  0)  {  	compilable	  [FE]  AssertionFailedError  	71	5	replace
23	[BUG]  [BUGGY]  if(dxNorm!=  null)  {  [CE]  incomparable  types:  double  and  <null>  [FE]    AssertionFailedError  [CONTEXT]  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  [BUGGY]  if(dxNorm!=  null)  {  [BUGGY]  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	if(dxNorm!=  null)  {	if  (lmPar  ==  0)  {  	non-compiled	[CE]  incomparable  types:  double  and  <null>	71	None	replace
24	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError  [CONTEXT]  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  [BUGGY]    lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [BUGGY]  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	add	    lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);		compilable	  [FE]  AssertionFailedError  	72	5	add
25	[BUG]  [BUGGY]    lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]    AssertionFailedError  [CONTEXT]  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  [BUGGY]    lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [BUGGY]  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	    lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);		compilable	  [FE]  AssertionFailedError  	72	5	add
26	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError  [CONTEXT]  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  [BUGGY]    lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  [BUGGY]  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	add	    lmPar  =  Math.max(2.251e-308,  0.001  *  paru);		compilable	  [FE]  AssertionFailedError  	72	5	add
27	[BUG]  [BUGGY]    lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]      AssertionFailedError  [CONTEXT]  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  [BUGGY]    lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  [BUGGY]  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	    lmPar  =  Math.max(2.251e-308,  0.001  *  paru);		compilable	  [FE]  AssertionFailedError  	72	5	add
28	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError  [CONTEXT]  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  [BUGGY]    lmPar  =  Math.max(2.0,  Math.max(1.0,  parl));  [BUGGY]  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	add	    lmPar  =  Math.max(2.0,  Math.max(1.0,  parl));		compilable	  [FE]  AssertionFailedError  	72	5	add
29	[BUG]  [BUGGY]    lmPar  =  Math.max(2.0,  Math.max(1.0,  parl));  [FE]  AssertionFailedError  [FE]        AssertionFailedError  [CONTEXT]  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  [BUGGY]    lmPar  =  Math.max(2.0,  Math.max(1.0,  parl));  [BUGGY]  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	    lmPar  =  Math.max(2.0,  Math.max(1.0,  parl));		compilable	  [FE]  AssertionFailedError  	72	5	add
