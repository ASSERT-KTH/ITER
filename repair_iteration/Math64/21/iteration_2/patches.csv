bugid	buggy	buggy_class	suspiciousness	buggy_line	endbuggycode	original_failing_test_number	action	patch	original_buggy	execution_result	diagnosis	previous_bug_id	new_failing_test_number	this_action
1	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(previousCost,  preRed);  [CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double,double)  [FE]                AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  new  VectorialPointValuePair(previousCost,  preRed);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  VectorialPointValuePair(previousCost,  preRed);	  tmpVec    =    new    VectorialPointValuePair(lastX,    previousCost);    	non-compiled	[CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double,double)	54	None	replace
2	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(lastX,  preRed);  [CE]  cannot  find  symbol  lastX  [FE]                  AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  new  VectorialPointValuePair(lastX,  preRed);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  VectorialPointValuePair(lastX,  preRed);	  tmpVec    =    new    VectorialPointValuePair(lastX,    previousCost);    	non-compiled	[CE]  cannot  find  symbol  lastX	54	None	replace
3	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  new  double[oldRes.length];  tmpVec  =  new  double[oldRes.length];  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	add	tmpVec    =    new    double[oldRes.length];    tmpVec  =  new  double[oldRes.length];	  	compilable	  [FE]  AssertionFailedError  	63	2	add
4	[BUG]  [BUGGY]  tmpVec  =  new  double[oldRes.length];  tmpVec  =  new  double[oldRes.length];  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  new  double[oldRes.length];  tmpVec  =  new  double[oldRes.length];  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec    =    new    double[oldRes.length];    tmpVec  =  new  double[oldRes.length];	  	compilable	  [FE]  AssertionFailedError  	63	2	add
5	[BUG]  [BUGGY]  tmpVec  =  new  double[oldRes.length];  int  tmpVec  =  new  double[oldRes.length];  [CE]  variable  tmpVec  is  already  defined  in  method  doOptimize()  [FE]      AssertionFailedError    [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  new  double[oldRes.length];  int  tmpVec  =  new  double[oldRes.length];  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec    =    new    double[oldRes.length];    int  tmpVec  =  new  double[oldRes.length];	  	non-compiled	[CE]  variable  tmpVec  is  already  defined  in  method  doOptimize()	63	None	add
6	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  new  double[oldRes.length];  oldRes  =  new  double[oldRes.length];  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	add	tmpVec    =    new    double[oldRes.length];    oldRes  =  new  double[oldRes.length];	  	compilable	  [FE]  AssertionFailedError  	63	2	add
7	[BUG]  [BUGGY]  tmpVec  =  new  double[oldRes.length];  oldRes  =  new  double[oldRes.length];  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  new  double[oldRes.length];  oldRes  =  new  double[oldRes.length];  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec    =    new    double[oldRes.length];    oldRes  =  new  double[oldRes.length];	  	compilable	  [FE]  AssertionFailedError  	63	2	add
8	[BUG]  [BUGGY]  ((  VectorialPointValuePair)previousCost).setVec(tmpVec,  previousCost);  [CE]  inconvertible  types  [FE]                  AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  ((  VectorialPointValuePair)previousCost).setVec(tmpVec,  previousCost);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	((  VectorialPointValuePair)previousCost).setVec(tmpVec,  previousCost);	  ((    VectorialPointValuePair)previousCost).setVec(oldX,    oldVec);    	non-compiled	[CE]  inconvertible  types	83	None	replace
9	[BUG]  [BUGGY]  ((  VectorialPointValuePair)previousCost).setVec(tmpVec,  oldX);  [CE]  inconvertible  types  [FE]                    AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  ((  VectorialPointValuePair)previousCost).setVec(tmpVec,  oldX);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	((  VectorialPointValuePair)previousCost).setVec(tmpVec,  oldX);	  ((    VectorialPointValuePair)previousCost).setVec(oldX,    oldVec);    	non-compiled	[CE]  inconvertible  types	83	None	replace
10	[BUG]  [BUGGY]  ((  VectorialPointValuePair)previousCost).setVec(tmpVec,  tmpVec);  [CE]  inconvertible  types  [FE]                      AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  ((  VectorialPointValuePair)previousCost).setVec(tmpVec,  tmpVec);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	((  VectorialPointValuePair)previousCost).setVec(tmpVec,  tmpVec);	  ((    VectorialPointValuePair)previousCost).setVec(oldX,    oldVec);    	non-compiled	[CE]  inconvertible  types	83	None	replace
11	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  new  double[oldRes.length  +  1];  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	add	tmpVec  =  new  double[oldRes.length  +  1];	  tmpVec    =    new    double[oldRes.length];    	compilable	  [FE]  AssertionFailedError  	64	10	replace
12	[BUG]  [BUGGY]  tmpVec  =  new  double[oldRes.length  +  1];  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  new  double[oldRes.length  +  1];  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  double[oldRes.length  +  1];	  tmpVec    =    new    double[oldRes.length];    	compilable	  [FE]  AssertionFailedError  	64	10	replace
13	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  new  double[oldRes.length  -  1];  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	add	tmpVec  =  new  double[oldRes.length  -  1];	  tmpVec    =    new    double[oldRes.length];    	compilable	  [FE]  AssertionFailedError  	64	10	replace
14	[BUG]  [BUGGY]  tmpVec  =  new  double[oldRes.length  -  1];  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  new  double[oldRes.length  -  1];  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  double[oldRes.length  -  1];	  tmpVec    =    new    double[oldRes.length];    	compilable	  [FE]  AssertionFailedError  	64	10	replace
15	[BUG]  [BUGGY]  Preconditions.checkNotNull(results,  tmpVec);  [CE]  cannot  find  symbol  results  [FE]                AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  Preconditions.checkNotNull(results,  tmpVec);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	Preconditions.checkNotNull(results,  tmpVec);	  Preconditions.checkNotNull(remainings,    tmpVec);    	non-compiled	[CE]  cannot  find  symbol  results	3	None	replace
16	[BUG]  [BUGGY]  Preconditions.checkNotNull(remainings,  pj);  [CE]  cannot  find  symbol  remainings  [FE]                  AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  Preconditions.checkNotNull(remainings,  pj);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	Preconditions.checkNotNull(remainings,  pj);	  Preconditions.checkNotNull(remainings,    tmpVec);    	non-compiled	[CE]  cannot  find  symbol  remainings	3	None	replace
17	[BUG]  [BUGGY]  Preconditions.checkNotNull(oldRes,  tmpVec);  [CE]  cannot  find  symbol  Preconditions  [FE]                    AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  Preconditions.checkNotNull(oldRes,  tmpVec);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	Preconditions.checkNotNull(oldRes,  tmpVec);	  Preconditions.checkNotNull(remainings,    tmpVec);    	non-compiled	[CE]  cannot  find  symbol  Preconditions	3	None	replace
18	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(previousCost,  oldX,  point,  cost);  [CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double,double[],double[],double)  [FE]                    AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  new  VectorialPointValuePair(previousCost,  oldX,  point,  cost);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  VectorialPointValuePair(previousCost,  oldX,  point,  cost);	  tmpVec    =    new    VectorialPointValuePair(previousCost,    point,    cost);    	non-compiled	[CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double,double[],double[],double)	18	None	replace
19	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(previousCost,  preRed,  point,  cost);  [CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double,double,double[],double)  [FE]                      AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  new  VectorialPointValuePair(previousCost,  preRed,  point,  cost);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  VectorialPointValuePair(previousCost,  preRed,  point,  cost);	  tmpVec    =    new    VectorialPointValuePair(previousCost,    point,    cost);    	non-compiled	[CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double,double,double[],double)	18	None	replace
20	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(previousCost,  cost,  point);  [CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double,double,double[])  [FE]                        AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  new  VectorialPointValuePair(previousCost,  cost,  point);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  VectorialPointValuePair(previousCost,  cost,  point);	  tmpVec    =    new    VectorialPointValuePair(previousCost,    point,    cost);    	non-compiled	[CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double,double,double[])	18	None	replace
21	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(previousCost,  point,  preRed,  cost);  [CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double,double[],double,double)  [FE]                          AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  new  VectorialPointValuePair(previousCost,  point,  preRed,  cost);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  VectorialPointValuePair(previousCost,  point,  preRed,  cost);	  tmpVec    =    new    VectorialPointValuePair(previousCost,    point,    cost);    	non-compiled	[CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double,double[],double,double)	18	None	replace
22	[BUG]  [BUGGY]  tmpVec  =  permutation[pj].remainder;  [CE]  cannot  find  symbol  pj  [FE]            AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  permutation[pj].remainder;  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  permutation[pj].remainder;	  tmpVec    =    permutation[j].remainder;    	non-compiled	[CE]  cannot  find  symbol  pj	88	None	replace
23	[BUG]  [BUGGY]  tmpVec  =  permutation[j].previousCost;  [CE]  cannot  find  symbol  j  [FE]              AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  permutation[j].previousCost;  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  permutation[j].previousCost;	  tmpVec    =    permutation[j].remainder;    	non-compiled	[CE]  cannot  find  symbol  j	88	None	replace
24	[BUG]  [BUGGY]  tmpVec  =  permutation[j].next;  [CE]  cannot  find  symbol  j  [FE]                AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  permutation[j].next;  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  permutation[j].next;	  tmpVec    =    permutation[j].remainder;    	non-compiled	[CE]  cannot  find  symbol  j	88	None	replace
25	[BUG]  [BUGGY]  ((  VectorialPointValuePair)previousCost).setVec(pj);  [CE]  cannot  find  symbol  pj  [FE]                  AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  ((  VectorialPointValuePair)previousCost).setVec(pj);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	((  VectorialPointValuePair)previousCost).setVec(pj);	  ((    VectorialPointValuePair)previousCost).setVec(remainings);    	non-compiled	[CE]  cannot  find  symbol  pj	50	None	replace
26	[BUG]  [BUGGY]  ((  VectorialPointValuePair)previousCost).setVec(oldX);  [CE]  inconvertible  types  [FE]                    AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  ((  VectorialPointValuePair)previousCost).setVec(oldX);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	((  VectorialPointValuePair)previousCost).setVec(oldX);	  ((    VectorialPointValuePair)previousCost).setVec(remainings);    	non-compiled	[CE]  inconvertible  types	50	None	replace
27	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  oldRes=    residuals;    tmpVec=  residuals;  oldRes=  residuals;  tmpVec=  residuals;  [BUGGY]      }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	add	oldRes=        residuals;        tmpVec=    residuals;    oldRes=  residuals;  tmpVec=  residuals;	  	compilable	  [FE]  AssertionFailedError  	27	10	add
28	[BUG]  [BUGGY]  oldRes=    residuals;    tmpVec=  residuals;  oldRes=  residuals;  tmpVec=  residuals;  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  oldRes=    residuals;    tmpVec=  residuals;  oldRes=  residuals;  tmpVec=  residuals;  [BUGGY]      }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	oldRes=        residuals;        tmpVec=    residuals;    oldRes=  residuals;  tmpVec=  residuals;	  	compilable	  [FE]  AssertionFailedError  	27	10	add
29	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  oldRes=    residuals;    tmpVec=  residuals;  tmpVec=  residuals;  tmpVec=  residuals;  [BUGGY]      }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	add	oldRes=        residuals;        tmpVec=    residuals;    tmpVec=  residuals;  tmpVec=  residuals;	  	compilable	  [FE]  AssertionFailedError  	27	10	add
30	[BUG]  [BUGGY]  oldRes=    residuals;    tmpVec=  residuals;  tmpVec=  residuals;  tmpVec=  residuals;  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  oldRes=    residuals;    tmpVec=  residuals;  tmpVec=  residuals;  tmpVec=  residuals;  [BUGGY]      }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	oldRes=        residuals;        tmpVec=    residuals;    tmpVec=  residuals;  tmpVec=  residuals;	  	compilable	  [FE]  AssertionFailedError  	27	10	add
31	[BUG]  [BUGGY]  Preconditions.checkState(remainders!=  0);  [CE]  cannot  find  symbol  remainders  [FE]                    AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  Preconditions.checkState(remainders!=  0);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	Preconditions.checkState(remainders!=  0);	  Preconditions.checkState(remainders    ==    0);    	non-compiled	[CE]  cannot  find  symbol  remainders	78	None	replace
32	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(previousCost,  oldX,  residuals);  [CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double,double[],double[])  [FE]              AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  new  VectorialPointValuePair(previousCost,  oldX,  residuals);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  VectorialPointValuePair(previousCost,  oldX,  residuals);	  tmpVec    =    new    VectorialPointValuePair(previousCost,    oldX,    cost);    	non-compiled	[CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double,double[],double[])	15	None	replace
33	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(previousCost,  oldX,  preRed,  cost);  [CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double,double[],double,double)  [FE]                AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  new  VectorialPointValuePair(previousCost,  oldX,  preRed,  cost);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  VectorialPointValuePair(previousCost,  oldX,  preRed,  cost);	  tmpVec    =    new    VectorialPointValuePair(previousCost,    oldX,    cost);    	non-compiled	[CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double,double[],double,double)	15	None	replace
34	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(previousCost,  oldX,  previousCost,  cost);  [CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double,double[],double,double)  [FE]                  AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  new  VectorialPointValuePair(previousCost,  oldX,  previousCost,  cost);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  VectorialPointValuePair(previousCost,  oldX,  previousCost,  cost);	  tmpVec    =    new    VectorialPointValuePair(previousCost,    oldX,    cost);    	non-compiled	[CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double,double[],double,double)	15	None	replace
35	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(previousCost,  oldX,  preres,  cost);  [CE]  cannot  find  symbol  preres  [FE]                    AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  new  VectorialPointValuePair(previousCost,  oldX,  preres,  cost);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  VectorialPointValuePair(previousCost,  oldX,  preres,  cost);	  tmpVec    =    new    VectorialPointValuePair(previousCost,    oldX,    cost);    	non-compiled	[CE]  cannot  find  symbol  preres	15	None	replace
36	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(pj,  preRed,  cost);  [CE]  cannot  find  symbol  pj  [FE]              AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  new  VectorialPointValuePair(pj,  preRed,  cost);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  VectorialPointValuePair(pj,  preRed,  cost);	  tmpVec    =    new    VectorialPointValuePair(pj,    previousCost,    cost);    	non-compiled	[CE]  cannot  find  symbol  pj	60	None	replace
37	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(permutation,  previousCost,  cost);  [CE]  no  suitable  constructor  found  for  VectorialPointValuePair(int[],double,double)  [FE]                AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  new  VectorialPointValuePair(permutation,  previousCost,  cost);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  VectorialPointValuePair(permutation,  previousCost,  cost);	  tmpVec    =    new    VectorialPointValuePair(pj,    previousCost,    cost);    	non-compiled	[CE]  no  suitable  constructor  found  for  VectorialPointValuePair(int[],double,double)	60	None	replace
38	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(period,  previousCost,  cost);  [CE]  cannot  find  symbol  period  [FE]                  AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  new  VectorialPointValuePair(period,  previousCost,  cost);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  VectorialPointValuePair(period,  previousCost,  cost);	  tmpVec    =    new    VectorialPointValuePair(pj,    previousCost,    cost);    	non-compiled	[CE]  cannot  find  symbol  period	60	None	replace
39	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(previousCost,  preRed,  point,  lastIteration);  [CE]  cannot  find  symbol  lastIteration  [FE]                        AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  new  VectorialPointValuePair(previousCost,  preRed,  point,  lastIteration);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  VectorialPointValuePair(previousCost,  preRed,  point,  lastIteration);	  tmpVec    =    new    VectorialPointValuePair(previousCost,    preRed,    point);    	non-compiled	[CE]  cannot  find  symbol  lastIteration	20	None	replace
40	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(previousCost,  preRed,  points);  [CE]  cannot  find  symbol  points  [FE]                          AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  new  VectorialPointValuePair(previousCost,  preRed,  points);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  VectorialPointValuePair(previousCost,  preRed,  points);	  tmpVec    =    new    VectorialPointValuePair(previousCost,    preRed,    point);    	non-compiled	[CE]  cannot  find  symbol  points	20	None	replace
41	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(oldX,  oldRes);  [CE]  incompatible  types  [FE]                AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  new  VectorialPointValuePair(oldX,  oldRes);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  VectorialPointValuePair(oldX,  oldRes);	  tmpVec    =    new    VectorialPointValuePair(oldX);    	non-compiled	[CE]  incompatible  types	66	None	replace
42	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(previousCost,  oldX);  [CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double,double[])  [FE]                  AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  new  VectorialPointValuePair(previousCost,  oldX);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  VectorialPointValuePair(previousCost,  oldX);	  tmpVec    =    new    VectorialPointValuePair(oldX);    	non-compiled	[CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double,double[])	66	None	replace
43	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(pj,  oldX);  [CE]  cannot  find  symbol  pj  [FE]                    AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  new  VectorialPointValuePair(pj,  oldX);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  VectorialPointValuePair(pj,  oldX);	  tmpVec    =    new    VectorialPointValuePair(oldX);    	non-compiled	[CE]  cannot  find  symbol  pj	66	None	replace
44	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(oldX,  oldCost);  [CE]  cannot  find  symbol  oldCost  [FE]                      AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  new  VectorialPointValuePair(oldX,  oldCost);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  VectorialPointValuePair(oldX,  oldCost);	  tmpVec    =    new    VectorialPointValuePair(oldX);    	non-compiled	[CE]  cannot  find  symbol  oldCost	66	None	replace
45	[BUG]  [BUGGY]  Preconditions.checkState(results!=  oldX);  [CE]  cannot  find  symbol  results  [FE]                      AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  Preconditions.checkState(results!=  oldX);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	Preconditions.checkState(results!=  oldX);	  Preconditions.checkState(remainings    >=    oldX);    	non-compiled	[CE]  cannot  find  symbol  results	35	None	replace
46	[BUG]  [BUGGY]  Preconditions.checkState(remainings  >  oldX);  [CE]  cannot  find  symbol  remainings  [FE]                        AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  Preconditions.checkState(remainings  >  oldX);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	Preconditions.checkState(remainings  >  oldX);	  Preconditions.checkState(remainings    >=    oldX);    	non-compiled	[CE]  cannot  find  symbol  remainings	35	None	replace
47	[BUG]  [BUGGY]  Preconditions.checkState(remainings  >  tmpVec);  [CE]  cannot  find  symbol  remainings  [FE]                  AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  Preconditions.checkState(remainings  >  tmpVec);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	Preconditions.checkState(remainings  >  tmpVec);	  Preconditions.checkState(remainings    >=    tmpVec);    	non-compiled	[CE]  cannot  find  symbol  remainings	33	None	replace
48	[BUG]  [BUGGY]  Preconditions.checkState(results!=  tmpVec);  [CE]  cannot  find  symbol  results  [FE]                    AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  Preconditions.checkState(results!=  tmpVec);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	Preconditions.checkState(results!=  tmpVec);	  Preconditions.checkState(remainings    >=    tmpVec);    	non-compiled	[CE]  cannot  find  symbol  results	33	None	replace
49	[BUG]  [BUGGY]  Preconditions.checkState(oldRes!=  tmpVec);  [CE]  cannot  find  symbol  Preconditions  [FE]            AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  Preconditions.checkState(oldRes!=  tmpVec);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	Preconditions.checkState(oldRes!=  tmpVec);	  Preconditions.checkNotNull(oldRes);    	non-compiled	[CE]  cannot  find  symbol  Preconditions	76	None	replace
50	[BUG]  [BUGGY]  tmpVec  =  new  double[results.length  +  1];  [CE]  cannot  find  symbol  results  [FE]                  AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  new  double[results.length  +  1];  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  double[results.length  +  1];	  tmpVec    =    new    double[results.length];    	non-compiled	[CE]  cannot  find  symbol  results	22	None	replace
51	[BUG]  [BUGGY]  tmpVec  =  new  double[results.length  -  1];  [CE]  cannot  find  symbol  results  [FE]                    AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  new  double[results.length  -  1];  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  double[results.length  -  1];	  tmpVec    =    new    double[results.length];    	non-compiled	[CE]  cannot  find  symbol  results	22	None	replace
52	[BUG]  [BUGGY]  tmpVec  =  new  double[results.length  *  2];  [CE]  cannot  find  symbol  results  [FE]                      AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  new  double[results.length  *  2];  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  double[results.length  *  2];	  tmpVec    =    new    double[results.length];    	non-compiled	[CE]  cannot  find  symbol  results	22	None	replace
53	[BUG]  [BUGGY]  tmpVec  =  permutation[j]  +  2;  [CE]  cannot  find  symbol  j  [FE]                AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  permutation[j]  +  2;  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  permutation[j]  +  2;	  tmpVec    =    permutation[j]    +    1;    	non-compiled	[CE]  cannot  find  symbol  j	45	None	replace
54	[BUG]  [BUGGY]  tmpVec  =  permutation[pj]  +  1;  [CE]  cannot  find  symbol  pj  [FE]                  AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  permutation[pj]  +  1;  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  permutation[pj]  +  1;	  tmpVec    =    permutation[j]    +    1;    	non-compiled	[CE]  cannot  find  symbol  pj	45	None	replace
55	[BUG]  [BUGGY]  tmpVec  =  permutation[j]  +  3;  [CE]  cannot  find  symbol  j  [FE]                    AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  permutation[j]  +  3;  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  permutation[j]  +  3;	  tmpVec    =    permutation[j]    +    1;    	non-compiled	[CE]  cannot  find  symbol  j	45	None	replace
56	[BUG]  [BUGGY]  Preconditions.checkState(oldRes  ==  tmpVec);  [CE]  cannot  find  symbol  Preconditions  [FE]              AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  Preconditions.checkState(oldRes  ==  tmpVec);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	Preconditions.checkState(oldRes  ==  tmpVec);	  Preconditions.checkState(oldRes    ==    residuals);    	non-compiled	[CE]  cannot  find  symbol  Preconditions	67	None	replace
57	[BUG]  [BUGGY]  ((  VectorialPointValuePair)previousCost).setVec(new  VectorialPointValuePair(tmpVec,  cost));  [CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double[],double)  [FE]                AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  ((  VectorialPointValuePair)previousCost).setVec(new  VectorialPointValuePair(tmpVec,  cost));  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	((  VectorialPointValuePair)previousCost).setVec(new  VectorialPointValuePair(tmpVec,  cost));	  ((    VectorialPointValuePair)previousCost).setVec(new    VectorialPointValuePair(tmpVec));    	non-compiled	[CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double[],double)	74	None	replace
58	[BUG]  [BUGGY]  ((  VectorialPointValuePair)previousCost).setVec(new  VectorialPointValuePair(tmpVec),  residuals);  [CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double[])  [FE]                  AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  ((  VectorialPointValuePair)previousCost).setVec(new  VectorialPointValuePair(tmpVec),  residuals);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	((  VectorialPointValuePair)previousCost).setVec(new  VectorialPointValuePair(tmpVec),  residuals);	  ((    VectorialPointValuePair)previousCost).setVec(new    VectorialPointValuePair(tmpVec));    	non-compiled	[CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double[])	74	None	replace
59	[BUG]  [BUGGY]  ((  VectorialPointValuePair)previousCost).setVec(new  VectorialPointValuePair(tmpVec,  pj));  [CE]  cannot  find  symbol  pj  [FE]                    AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  ((  VectorialPointValuePair)previousCost).setVec(new  VectorialPointValuePair(tmpVec,  pj));  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	((  VectorialPointValuePair)previousCost).setVec(new  VectorialPointValuePair(tmpVec,  pj));	  ((    VectorialPointValuePair)previousCost).setVec(new    VectorialPointValuePair(tmpVec));    	non-compiled	[CE]  cannot  find  symbol  pj	74	None	replace
60	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(pj,  preRed);  [CE]  cannot  find  symbol  pj  [FE]                  AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  new  VectorialPointValuePair(pj,  preRed);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  VectorialPointValuePair(pj,  preRed);	  tmpVec    =    new    VectorialPointValuePair(pj,    previousCost);    	non-compiled	[CE]  cannot  find  symbol  pj	55	None	replace
61	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(pj,  cost);  [CE]  cannot  find  symbol  pj  [FE]                    AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  new  VectorialPointValuePair(pj,  cost);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  VectorialPointValuePair(pj,  cost);	  tmpVec    =    new    VectorialPointValuePair(pj,    previousCost);    	non-compiled	[CE]  cannot  find  symbol  pj	55	None	replace
62	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(j,  previousCost);  [CE]  cannot  find  symbol  j  [FE]                      AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  new  VectorialPointValuePair(j,  previousCost);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  VectorialPointValuePair(j,  previousCost);	  tmpVec    =    new    VectorialPointValuePair(pj,    previousCost);    	non-compiled	[CE]  cannot  find  symbol  j	55	None	replace
63	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  new  double[oldX.length  +  1];  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	add	tmpVec  =  new  double[oldX.length  +  1];	  tmpVec    =    new    double[oldX.length];    	compilable	  [FE]  AssertionFailedError  	90	10	replace
64	[BUG]  [BUGGY]  tmpVec  =  new  double[oldX.length  +  1];  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  new  double[oldX.length  +  1];  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  double[oldX.length  +  1];	  tmpVec    =    new    double[oldX.length];    	compilable	  [FE]  AssertionFailedError  	90	10	replace
65	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  new  double[oldX.length  -  1];  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	add	tmpVec  =  new  double[oldX.length  -  1];	  tmpVec    =    new    double[oldX.length];    	compilable	  [FE]  AssertionFailedError  	90	10	replace
66	[BUG]  [BUGGY]  tmpVec  =  new  double[oldX.length  -  1];  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  new  double[oldX.length  -  1];  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  double[oldX.length  -  1];	  tmpVec    =    new    double[oldX.length];    	compilable	  [FE]  AssertionFailedError  	90	10	replace
67	[BUG]  [BUGGY]  oldRes=  0;  [CE]  incompatible  types  [FE]    AssertionFailedError    [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  oldRes=  0;  [BUGGY]      }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	oldRes=  0;	  oldRes=    residuals;    oldRes=    residuals;    	non-compiled	[CE]  incompatible  types	26	None	replace
68	[BUG]  [BUGGY]  Preconditions.checkState(results!=  0);  [CE]  cannot  find  symbol  results  [FE]                    AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  Preconditions.checkState(results!=  0);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	Preconditions.checkState(results!=  0);	  Preconditions.checkState(results    ==    0);    	non-compiled	[CE]  cannot  find  symbol  results	4	None	replace
69	[BUG]  [BUGGY]  ((  VectorialPointValuePair)remaining).add(tmpVec);  [CE]  cannot  find  symbol  remaining  [FE]                AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  ((  VectorialPointValuePair)remaining).add(tmpVec);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	((  VectorialPointValuePair)remaining).add(tmpVec);	  ((    VectorialPointValuePair)res2).add(tmpVec);    	non-compiled	[CE]  cannot  find  symbol  remaining	57	None	replace
70	[BUG]  [BUGGY]  tmpVec  =  new  double[result.length];  [CE]  cannot  find  symbol  result  [FE]                    AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  new  double[result.length];  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  double[result.length];	  tmpVec    =    new    double[resistance.length];    	non-compiled	[CE]  cannot  find  symbol  result	23	None	replace
71	[BUG]  [BUGGY]  tmpVec  =  new  double[resistance.length  +  1];  [CE]  cannot  find  symbol  resistance  [FE]                      AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  new  double[resistance.length  +  1];  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  double[resistance.length  +  1];	  tmpVec    =    new    double[resistance.length];    	non-compiled	[CE]  cannot  find  symbol  resistance	23	None	replace
72	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(previousCost,  cost,  preRed);  [CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double,double,double)  [FE]            AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  new  VectorialPointValuePair(previousCost,  cost,  preRed);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  VectorialPointValuePair(previousCost,  cost,  preRed);	  tmpVec    =    new    VectorialPointValuePair(previousCost,    preRed,    cost);    	non-compiled	[CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double,double,double)	14	None	replace
73	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(previousCost,  preRed,  cost,  solvedCols);  [CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double,double,double,int)  [FE]              AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  new  VectorialPointValuePair(previousCost,  preRed,  cost,  solvedCols);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  VectorialPointValuePair(previousCost,  preRed,  cost,  solvedCols);	  tmpVec    =    new    VectorialPointValuePair(previousCost,    preRed,    cost);    	non-compiled	[CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double,double,double,int)	14	None	replace
74	[BUG]  [BUGGY]  oldRes  =  cost;  [CE]  incompatible  types  [FE]    AssertionFailedError    [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  oldRes  =  cost;  [BUGGY]      }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	oldRes  =  cost;	  oldRes=    oldRes;    	non-compiled	[CE]  incompatible  types	38	None	replace
75	[BUG]  [BUGGY]  [FE]  ArrayIndexOutOfBoundsException  [FE]      AssertionFailedError    [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  oldRes=  oldX;  [BUGGY]      }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	add	oldRes=  oldX;	  oldRes=    oldRes;    	compilable	  [FE]  ArrayIndexOutOfBoundsException  	38	12	replace
76	[BUG]  [BUGGY]  oldRes=  oldX;  [FE]  ArrayIndexOutOfBoundsException  [FE]      AssertionFailedError    [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  oldRes=  oldX;  [BUGGY]      }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	oldRes=  oldX;	  oldRes=    oldRes;    	compilable	  [FE]  ArrayIndexOutOfBoundsException  	38	12	replace
77	[BUG]  [BUGGY]  tmpVec  =  oldRes[permutation];  [CE]  incompatible  types  [FE]            AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  oldRes[permutation];  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  oldRes[permutation];	  tmpVec    =    permutation[oldRes];    	non-compiled	[CE]  incompatible  types	73	None	replace
78	[BUG]  [BUGGY]  tmpVec  =  lastIteration;  [CE]  cannot  find  symbol  lastIteration  [FE]                  AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  lastIteration;  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  lastIteration;	  tmpVec    =    prevCost;    	non-compiled	[CE]  cannot  find  symbol  lastIteration	69	None	replace
79	[BUG]  [BUGGY]  ((  VectorialPointValuePair)remainings).add(tmpVec,  oldX);  [CE]  cannot  find  symbol  remainings  [FE]              AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  ((  VectorialPointValuePair)remainings).add(tmpVec,  oldX);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	((  VectorialPointValuePair)remainings).add(tmpVec,  oldX);	  ((    VectorialPointValuePair)remainings).add(tmpVec,    cost);    	non-compiled	[CE]  cannot  find  symbol  remainings	56	None	replace
80	[BUG]  [BUGGY]  ((  VectorialPointValuePair)results).add(tmpVec,  cost);  [CE]  cannot  find  symbol  results  [FE]                AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  ((  VectorialPointValuePair)results).add(tmpVec,  cost);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	((  VectorialPointValuePair)results).add(tmpVec,  cost);	  ((    VectorialPointValuePair)remainings).add(tmpVec,    cost);    	non-compiled	[CE]  cannot  find  symbol  results	56	None	replace
81	[BUG]  [BUGGY]  Preconditions.checkState(remainings  >=  0);  [CE]  cannot  find  symbol  remainings  [FE]                      AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  Preconditions.checkState(remainings  >=  0);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	Preconditions.checkState(remainings  >=  0);	  Preconditions.checkState(remainings!=    0);    	non-compiled	[CE]  cannot  find  symbol  remainings	5	None	replace
82	[BUG]  [BUGGY]  ((  VectorialPointValuePair)previousCost).setVec(tmpVec,  oldX,  residuals);  [CE]  inconvertible  types  [FE]                AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  ((  VectorialPointValuePair)previousCost).setVec(tmpVec,  oldX,  residuals);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	((  VectorialPointValuePair)previousCost).setVec(tmpVec,  oldX,  residuals);	  ((    VectorialPointValuePair)previousCost).setVec(tmpVec,    residuals);    	non-compiled	[CE]  inconvertible  types	49	None	replace
83	[BUG]  [BUGGY]  ((  VectorialPointValuePair)previousCost).setVec(tmpVec,  pj,  residuals);  [CE]  cannot  find  symbol  pj  [FE]                  AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  ((  VectorialPointValuePair)previousCost).setVec(tmpVec,  pj,  residuals);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	((  VectorialPointValuePair)previousCost).setVec(tmpVec,  pj,  residuals);	  ((    VectorialPointValuePair)previousCost).setVec(tmpVec,    residuals);    	non-compiled	[CE]  cannot  find  symbol  pj	49	None	replace
84	[BUG]  [BUGGY]  ((  VectorialPointValuePair)previousCost).setVec(tmpVec,  cost);  [CE]  inconvertible  types  [FE]                    AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  ((  VectorialPointValuePair)previousCost).setVec(tmpVec,  cost);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	((  VectorialPointValuePair)previousCost).setVec(tmpVec,  cost);	  ((    VectorialPointValuePair)previousCost).setVec(tmpVec,    residuals);    	non-compiled	[CE]  inconvertible  types	49	None	replace
85	[BUG]  [BUGGY]  ((  VectorialPointValuePair)previousCost).setVec(tmpVec,  preRed,  residuals);  [CE]  inconvertible  types  [FE]                      AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  ((  VectorialPointValuePair)previousCost).setVec(tmpVec,  preRed,  residuals);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	((  VectorialPointValuePair)previousCost).setVec(tmpVec,  preRed,  residuals);	  ((    VectorialPointValuePair)previousCost).setVec(tmpVec,    residuals);    	non-compiled	[CE]  inconvertible  types	49	None	replace
86	[BUG]  [BUGGY]  tmpVec  =  permutation[0]  +  1;  [CE]  incompatible  types  [FE]              AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  permutation[0]  +  1;  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  permutation[0]  +  1;	  tmpVec    =    permutation[0];    	non-compiled	[CE]  incompatible  types	44	None	replace
87	[BUG]  [BUGGY]  tmpVec  =  permutation[1];  [CE]  incompatible  types  [FE]                AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  permutation[1];  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  permutation[1];	  tmpVec    =    permutation[0];    	non-compiled	[CE]  incompatible  types	44	None	replace
88	[BUG]  [BUGGY]  oldRes  =  new  RelativeTolerance(tmpVec);  [CE]  cannot  find  symbol  [FE]        AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  oldRes  =  new  RelativeTolerance(tmpVec);  [BUGGY]      }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	oldRes  =  new  RelativeTolerance(tmpVec);	  oldRes    =    new    RelativeTolerance(relativeTolerance);    	non-compiled	[CE]  cannot  find  symbol	85	None	replace
89	[BUG]  [BUGGY]  oldRes  =  new  RelativeTolerance(tmpVec,  relativeTolerance);  [CE]  cannot  find  symbol  [FE]          AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  oldRes  =  new  RelativeTolerance(tmpVec,  relativeTolerance);  [BUGGY]      }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	oldRes  =  new  RelativeTolerance(tmpVec,  relativeTolerance);	  oldRes    =    new    RelativeTolerance(relativeTolerance);    	non-compiled	[CE]  cannot  find  symbol	85	None	replace
90	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  oldRes=  oldRes;  oldRes=  oldRes;  [BUGGY]      }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	add	oldRes=    oldRes;    oldRes=  oldRes;	  	compilable	  [FE]  AssertionFailedError  	37	2	add
91	[BUG]  [BUGGY]  oldRes=  oldRes;  oldRes=  oldRes;  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  oldRes=  oldRes;  oldRes=  oldRes;  [BUGGY]      }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	oldRes=    oldRes;    oldRes=  oldRes;	  	compilable	  [FE]  AssertionFailedError  	37	2	add
92	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  oldRes=  oldRes;  tmpVec=  oldRes;  [BUGGY]      }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	add	oldRes=    oldRes;    tmpVec=  oldRes;	  	compilable	  [FE]  AssertionFailedError  	37	10	add
93	[BUG]  [BUGGY]  oldRes=  oldRes;  tmpVec=  oldRes;  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  oldRes=  oldRes;  tmpVec=  oldRes;  [BUGGY]      }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	oldRes=    oldRes;    tmpVec=  oldRes;	  	compilable	  [FE]  AssertionFailedError  	37	10	add
94	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  oldRes=  oldRes;  oldRes=  tmpVec;  [BUGGY]      }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	add	oldRes=    oldRes;    oldRes=  tmpVec;	  	compilable	  [FE]  AssertionFailedError  	37	2	add
95	[BUG]  [BUGGY]  oldRes=  oldRes;  oldRes=  tmpVec;  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  oldRes=  oldRes;  oldRes=  tmpVec;  [BUGGY]      }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	oldRes=    oldRes;    oldRes=  tmpVec;	  	compilable	  [FE]  AssertionFailedError  	37	2	add
96	[BUG]  [BUGGY]  [FE]  ArrayIndexOutOfBoundsException  [FE]          AssertionFailedError    [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  oldRes=  oldRes;  tmpVec=  oldX;  [BUGGY]      }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	add	oldRes=    oldRes;    tmpVec=  oldX;	  	compilable	  [FE]  ArrayIndexOutOfBoundsException  	37	12	add
97	[BUG]  [BUGGY]  oldRes=  oldRes;  tmpVec=  oldX;  [FE]  ArrayIndexOutOfBoundsException  [FE]          AssertionFailedError    [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  oldRes=  oldRes;  tmpVec=  oldX;  [BUGGY]      }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	oldRes=    oldRes;    tmpVec=  oldX;	  	compilable	  [FE]  ArrayIndexOutOfBoundsException  	37	12	add
98	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(preRed,  point);  [CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double,double[])  [FE]                      AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  new  VectorialPointValuePair(preRed,  point);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  VectorialPointValuePair(preRed,  point);	  tmpVec    =    new    VectorialPointValuePair(point,    preRed);    	non-compiled	[CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double,double[])	71	None	replace
99	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(point,  preRed,  cost);  [CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double[],double,double)  [FE]                        AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  new  VectorialPointValuePair(point,  preRed,  cost);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  VectorialPointValuePair(point,  preRed,  cost);	  tmpVec    =    new    VectorialPointValuePair(point,    preRed);    	non-compiled	[CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double[],double,double)	71	None	replace
100	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(oldX,  preRed);  [CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double[],double)  [FE]                          AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  new  VectorialPointValuePair(oldX,  preRed);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  VectorialPointValuePair(oldX,  preRed);	  tmpVec    =    new    VectorialPointValuePair(point,    preRed);    	non-compiled	[CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double[],double)	71	None	replace
101	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(prered,  point);  [CE]  cannot  find  symbol  prered  [FE]                            AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  new  VectorialPointValuePair(prered,  point);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  VectorialPointValuePair(prered,  point);	  tmpVec    =    new    VectorialPointValuePair(point,    preRed);    	non-compiled	[CE]  cannot  find  symbol  prered	71	None	replace
102	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(permutation);  [CE]  no  suitable  constructor  found  for  VectorialPointValuePair(int[])  [FE]                  AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  new  VectorialPointValuePair(permutation);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  VectorialPointValuePair(permutation);	  tmpVec    =    new    VectorialPointValuePair(pj);    	non-compiled	[CE]  no  suitable  constructor  found  for  VectorialPointValuePair(int[])	32	None	replace
103	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(point);  [CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double[])  [FE]                    AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  new  VectorialPointValuePair(point);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  VectorialPointValuePair(point);	  tmpVec    =    new    VectorialPointValuePair(pj);    	non-compiled	[CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double[])	32	None	replace
104	[BUG]  [BUGGY]  tmpVec  =  preRed  +  3;  [CE]  incompatible  types  [FE]                    AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  preRed  +  3;  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  preRed  +  3;	  tmpVec    =    preRed    +    1;    	non-compiled	[CE]  incompatible  types	7	None	replace
105	[BUG]  [BUGGY]  tmpVec  =  previousCost  +  1;  [CE]  incompatible  types  [FE]                      AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  previousCost  +  1;  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  previousCost  +  1;	  tmpVec    =    preRed    +    1;    	non-compiled	[CE]  incompatible  types	7	None	replace
106	[BUG]  [BUGGY]  tmpVec  =  permutation[j];  oldRes=  residuals;  [CE]  cannot  find  symbol  j  [FE]          AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  permutation[j];  oldRes=  residuals;  [BUGGY]      }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  permutation[j];  oldRes=  residuals;	  oldRes=    residuals;    tmpVec    =    permutation[j];    oldRes=    residuals;    	non-compiled	[CE]  cannot  find  symbol  j	80	None	replace
107	[BUG]  [BUGGY]  tmpVec  =  oldX[j];  oldRes=  residuals;  [CE]  cannot  find  symbol  j  [FE]            AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  oldX[j];  oldRes=  residuals;  [BUGGY]      }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  oldX[j];  oldRes=  residuals;	  oldRes=    residuals;    tmpVec    =    permutation[j];    oldRes=    residuals;    	non-compiled	[CE]  cannot  find  symbol  j	80	None	replace
108	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(previousCost,  oldX,  previousCost);  [CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double,double[],double)  [FE]                AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  new  VectorialPointValuePair(previousCost,  oldX,  previousCost);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  VectorialPointValuePair(previousCost,  oldX,  previousCost);	  tmpVec    =    new    VectorialPointValuePair(last,    previousCost,    cost);    	non-compiled	[CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double,double[],double)	61	None	replace
109	[BUG]  [BUGGY]  ((  VectorialPointValuePair)previousCost).setVec(new  VectorialPointValuePair(tmpVec,  oldX,  residuals));  [CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double[],double[],double[])  [FE]                    AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  ((  VectorialPointValuePair)previousCost).setVec(new  VectorialPointValuePair(tmpVec,  oldX,  residuals));  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	((  VectorialPointValuePair)previousCost).setVec(new  VectorialPointValuePair(tmpVec,  oldX,  residuals));	  ((    VectorialPointValuePair)previousCost).setVec(new    VectorialPointValuePair(tmpVec,    residuals));    	non-compiled	[CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double[],double[],double[])	51	None	replace
110	[BUG]  [BUGGY]  ((  VectorialPointValuePair)previousCost).setVec(new  VectorialPointValuePair(tmpVec,  oldRes));  [CE]  inconvertible  types  [FE]                      AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  ((  VectorialPointValuePair)previousCost).setVec(new  VectorialPointValuePair(tmpVec,  oldRes));  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	((  VectorialPointValuePair)previousCost).setVec(new  VectorialPointValuePair(tmpVec,  oldRes));	  ((    VectorialPointValuePair)previousCost).setVec(new    VectorialPointValuePair(tmpVec,    residuals));    	non-compiled	[CE]  inconvertible  types	51	None	replace
111	[BUG]  [BUGGY]  ((  VectorialPointValuePair)previousCost).setVec(new  VectorialPointValuePair(tmpVec,  pj,  residuals));  [CE]  cannot  find  symbol  pj  [FE]                        AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  ((  VectorialPointValuePair)previousCost).setVec(new  VectorialPointValuePair(tmpVec,  pj,  residuals));  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	((  VectorialPointValuePair)previousCost).setVec(new  VectorialPointValuePair(tmpVec,  pj,  residuals));	  ((    VectorialPointValuePair)previousCost).setVec(new    VectorialPointValuePair(tmpVec,    residuals));    	non-compiled	[CE]  cannot  find  symbol  pj	51	None	replace
112	[BUG]  [BUGGY]  [FE]  ArrayIndexOutOfBoundsException  [FE]    AssertionFailedError    [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  new  double[oldX.length];  tmpVec  =  new  double[oldX.length];  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	add	tmpVec    =    new    double[oldX.length];    tmpVec  =  new  double[oldX.length];	  	compilable	  [FE]  ArrayIndexOutOfBoundsException  	89	8	add
113	[BUG]  [BUGGY]  tmpVec  =  new  double[oldX.length];  tmpVec  =  new  double[oldX.length];  [FE]  ArrayIndexOutOfBoundsException  [FE]    AssertionFailedError    [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  new  double[oldX.length];  tmpVec  =  new  double[oldX.length];  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec    =    new    double[oldX.length];    tmpVec  =  new  double[oldX.length];	  	compilable	  [FE]  ArrayIndexOutOfBoundsException  	89	8	add
114	[BUG]  [BUGGY]  tmpVec  =  new  double[oldX.length];  int  tmpVec  =  new  double[oldX.length];  [CE]  variable  tmpVec  is  already  defined  in  method  doOptimize()  [FE]      AssertionFailedError    [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  new  double[oldX.length];  int  tmpVec  =  new  double[oldX.length];  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec    =    new    double[oldX.length];    int  tmpVec  =  new  double[oldX.length];	  	non-compiled	[CE]  variable  tmpVec  is  already  defined  in  method  doOptimize()	89	None	add
115	[BUG]  [BUGGY]  tmpVec  =  new  double[oldX.length];  tmpVec  =  new  double[oldY.length];  [CE]  cannot  find  symbol  oldY  [FE]        AssertionFailedError    [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  new  double[oldX.length];  tmpVec  =  new  double[oldY.length];  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec    =    new    double[oldX.length];    tmpVec  =  new  double[oldY.length];	  	non-compiled	[CE]  cannot  find  symbol  oldY	89	None	add
116	[BUG]  [BUGGY]  [FE]  ArrayIndexOutOfBoundsException  [FE]          AssertionFailedError    [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  new  double[oldX.length];  oldX  =  new  double[oldX.length];  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	add	tmpVec    =    new    double[oldX.length];    oldX  =  new  double[oldX.length];	  	compilable	  [FE]  ArrayIndexOutOfBoundsException  	89	8	add
117	[BUG]  [BUGGY]  tmpVec  =  new  double[oldX.length];  oldX  =  new  double[oldX.length];  [FE]  ArrayIndexOutOfBoundsException  [FE]          AssertionFailedError    [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  new  double[oldX.length];  oldX  =  new  double[oldX.length];  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec    =    new    double[oldX.length];    oldX  =  new  double[oldX.length];	  	compilable	  [FE]  ArrayIndexOutOfBoundsException  	89	8	add
118	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  oldRes=    residuals;    oldRes=  residuals;  oldRes=  residuals;  oldRes=  residuals;  [BUGGY]      }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	add	oldRes=        residuals;        oldRes=    residuals;    oldRes=  residuals;  oldRes=  residuals;	  	compilable	  [FE]  AssertionFailedError  	25	2	add
119	[BUG]  [BUGGY]  oldRes=    residuals;    oldRes=  residuals;  oldRes=  residuals;  oldRes=  residuals;  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  oldRes=    residuals;    oldRes=  residuals;  oldRes=  residuals;  oldRes=  residuals;  [BUGGY]      }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	oldRes=        residuals;        oldRes=    residuals;    oldRes=  residuals;  oldRes=  residuals;	  	compilable	  [FE]  AssertionFailedError  	25	2	add
120	[BUG]  [BUGGY]  oldRes=    residuals;    oldRes=  residuals;  tmpVec  =  permutation[j];  oldRes=  residuals;  [CE]  cannot  find  symbol  j  [FE]      AssertionFailedError    [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  oldRes=    residuals;    oldRes=  residuals;  tmpVec  =  permutation[j];  oldRes=  residuals;  [BUGGY]      }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	oldRes=        residuals;        oldRes=    residuals;    tmpVec  =  permutation[j];  oldRes=  residuals;	  	non-compiled	[CE]  cannot  find  symbol  j	25	None	add
121	[BUG]  [BUGGY]  ((  VectorialPointValuePair)previousCost).setVec(tmpVec,  preRed);  [CE]  inconvertible  types  [FE]                AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  ((  VectorialPointValuePair)previousCost).setVec(tmpVec,  preRed);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	((  VectorialPointValuePair)previousCost).setVec(tmpVec,  preRed);	  ((    VectorialPointValuePair)previousCost).setVec(tmpVec,    pj);    	non-compiled	[CE]  inconvertible  types	82	None	replace
122	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  oldRes;  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	add	tmpVec  =  oldRes;	  tmpVec    =    oldX;    	compilable	  [FE]  AssertionFailedError  	42	10	replace
123	[BUG]  [BUGGY]  tmpVec  =  oldRes;  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  oldRes;  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  oldRes;	  tmpVec    =    oldX;    	compilable	  [FE]  AssertionFailedError  	42	10	replace
124	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(previousCost,  preRed,  oldX);  [CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double,double,double[])  [FE]            AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  new  VectorialPointValuePair(previousCost,  preRed,  oldX);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  VectorialPointValuePair(previousCost,  preRed,  oldX);	  tmpVec    =    new    VectorialPointValuePair(previousCost,    cost,    oldX);    	non-compiled	[CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double,double,double[])	87	None	replace
125	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(previousCost,  previousCost,  oldX,  residuals);  [CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double,double,double[],double[])  [FE]              AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  new  VectorialPointValuePair(previousCost,  previousCost,  oldX,  residuals);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  VectorialPointValuePair(previousCost,  previousCost,  oldX,  residuals);	  tmpVec    =    new    VectorialPointValuePair(previousCost,    cost,    oldX);    	non-compiled	[CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double,double,double[],double[])	87	None	replace
126	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(oldX,  cost,  previousCost);  [CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double[],double,double)  [FE]                AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  new  VectorialPointValuePair(oldX,  cost,  previousCost);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  VectorialPointValuePair(oldX,  cost,  previousCost);	  tmpVec    =    new    VectorialPointValuePair(previousCost,    cost,    oldX);    	non-compiled	[CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double[],double,double)	87	None	replace
127	[BUG]  [BUGGY]  Preconditions.checkState(results  ==  tmpVec);  [CE]  cannot  find  symbol  results  [FE]              AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  Preconditions.checkState(results  ==  tmpVec);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	Preconditions.checkState(results  ==  tmpVec);	  Preconditions.checkState(remainings    ==    tmpVec);    	non-compiled	[CE]  cannot  find  symbol  results	10	None	replace
128	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]              AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec=  tmpVec;  [BUGGY]      }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	add	tmpVec=  tmpVec;	  oldRes=    residuals;    tmpVec=    preRed;    	compilable	  [FE]  AssertionFailedError  	30	10	replace
129	[BUG]  [BUGGY]  tmpVec=  tmpVec;  [FE]  AssertionFailedError  [FE]              AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec=  tmpVec;  [BUGGY]      }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec=  tmpVec;	  oldRes=    residuals;    tmpVec=    preRed;    	compilable	  [FE]  AssertionFailedError  	30	10	replace
130	[BUG]  [BUGGY]  Preconditions.checkState(results  ==  oldX);  [CE]  cannot  find  symbol  results  [FE]                    AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  Preconditions.checkState(results  ==  oldX);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	Preconditions.checkState(results  ==  oldX);	  Preconditions.checkState(results    ==    oldRes);    	non-compiled	[CE]  cannot  find  symbol  results	13	None	replace
131	[BUG]  [BUGGY]  ((  VectorialPointValuePair)previousCost).setVec(oldX,  residuals,  tmpVec);  [CE]  inconvertible  types  [FE]                      AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  ((  VectorialPointValuePair)previousCost).setVec(oldX,  residuals,  tmpVec);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	((  VectorialPointValuePair)previousCost).setVec(oldX,  residuals,  tmpVec);	  ((    VectorialPointValuePair)previousCost).setVec(oldX,    tmpVec);    	non-compiled	[CE]  inconvertible  types	52	None	replace
132	[BUG]  [BUGGY]  ((  VectorialPointValuePair)previousCost).setVec(oldX,  oldRes,  tmpVec);  [CE]  inconvertible  types  [FE]                        AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  ((  VectorialPointValuePair)previousCost).setVec(oldX,  oldRes,  tmpVec);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	((  VectorialPointValuePair)previousCost).setVec(oldX,  oldRes,  tmpVec);	  ((    VectorialPointValuePair)previousCost).setVec(oldX,    tmpVec);    	non-compiled	[CE]  inconvertible  types	52	None	replace
133	[BUG]  [BUGGY]  ((  VectorialPointValuePair)previousCost).setVec(oldX,  tmpVec,  residuals);  [CE]  inconvertible  types  [FE]                          AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  ((  VectorialPointValuePair)previousCost).setVec(oldX,  tmpVec,  residuals);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	((  VectorialPointValuePair)previousCost).setVec(oldX,  tmpVec,  residuals);	  ((    VectorialPointValuePair)previousCost).setVec(oldX,    tmpVec);    	non-compiled	[CE]  inconvertible  types	52	None	replace
134	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(previousCost,  cost,  previousCost);  [CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double,double,double)  [FE]                  AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  new  VectorialPointValuePair(previousCost,  cost,  previousCost);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  VectorialPointValuePair(previousCost,  cost,  previousCost);	  tmpVec    =    new    VectorialPointValuePair(previousCost,    previousCost,    cost);    	non-compiled	[CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double,double,double)	17	None	replace
135	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(results);  [CE]  cannot  find  symbol  results  [FE]                AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  new  VectorialPointValuePair(results);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  VectorialPointValuePair(results);	  tmpVec    =    new    VectorialPointValuePair(remainings);    	non-compiled	[CE]  cannot  find  symbol  results	31	None	replace
136	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(previous);  [CE]  no  suitable  constructor  found  for  VectorialPointValuePair(VectorialPointValuePair)  [FE]                  AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  new  VectorialPointValuePair(previous);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  VectorialPointValuePair(previous);	  tmpVec    =    new    VectorialPointValuePair(remainings);    	non-compiled	[CE]  no  suitable  constructor  found  for  VectorialPointValuePair(VectorialPointValuePair)	31	None	replace
137	[BUG]  [BUGGY]  tmpVec  =  previousCost  +  2;  [CE]  incompatible  types  [FE]                        AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  previousCost  +  2;  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  previousCost  +  2;	  tmpVec    =    preRed    +    2;    	non-compiled	[CE]  incompatible  types	9	None	replace
138	[BUG]  [BUGGY]  Preconditions.checkState(relatives!=  0);  [CE]  cannot  find  symbol  relatives  [FE]                    AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  Preconditions.checkState(relatives!=  0);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	Preconditions.checkState(relatives!=  0);	  Preconditions.checkState(relatives    ==    0);    	non-compiled	[CE]  cannot  find  symbol  relatives	68	None	replace
139	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(current,  point,  previousCost);  [CE]  no  suitable  constructor  found  for  VectorialPointValuePair(VectorialPointValuePair,double[],double)  [FE]                    AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  new  VectorialPointValuePair(current,  point,  previousCost);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  VectorialPointValuePair(current,  point,  previousCost);	  tmpVec    =    new    VectorialPointValuePair(point,    previousCost);    	non-compiled	[CE]  no  suitable  constructor  found  for  VectorialPointValuePair(VectorialPointValuePair,double[],double)	70	None	replace
140	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(point,  previousCost,  cost);  [CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double[],double,double)  [FE]                      AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  new  VectorialPointValuePair(point,  previousCost,  cost);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  VectorialPointValuePair(point,  previousCost,  cost);	  tmpVec    =    new    VectorialPointValuePair(point,    previousCost);    	non-compiled	[CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double[],double,double)	70	None	replace
141	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(pr,  previousCost);  [CE]  cannot  find  symbol  pr  [FE]                        AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  new  VectorialPointValuePair(pr,  previousCost);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  VectorialPointValuePair(pr,  previousCost);	  tmpVec    =    new    VectorialPointValuePair(point,    previousCost);    	non-compiled	[CE]  cannot  find  symbol  pr	70	None	replace
142	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(lastX,  previousCost,  oldRes);  [CE]  cannot  find  symbol  lastX  [FE]                        AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  new  VectorialPointValuePair(lastX,  previousCost,  oldRes);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  VectorialPointValuePair(lastX,  previousCost,  oldRes);	  tmpVec    =    new    VectorialPointValuePair(lastX,    previousCost,    point);    	non-compiled	[CE]  cannot  find  symbol  lastX	72	None	replace
143	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(period,  cost);  [CE]  cannot  find  symbol  period  [FE]                AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  new  VectorialPointValuePair(period,  cost);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  VectorialPointValuePair(period,  cost);	  tmpVec    =    new    VectorialPointValuePair(currentCost,    cost);    	non-compiled	[CE]  cannot  find  symbol  period	16	None	replace
144	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(previous,  cost);  [CE]  no  suitable  constructor  found  for  VectorialPointValuePair(VectorialPointValuePair,double)  [FE]                  AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  new  VectorialPointValuePair(previous,  cost);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  VectorialPointValuePair(previous,  cost);	  tmpVec    =    new    VectorialPointValuePair(currentCost,    cost);    	non-compiled	[CE]  no  suitable  constructor  found  for  VectorialPointValuePair(VectorialPointValuePair,double)	16	None	replace
145	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(previousCost,  oldRes);  [CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double,double[])  [FE]        AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  new  VectorialPointValuePair(previousCost,  oldRes);  [BUGGY]      }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  VectorialPointValuePair(previousCost,  oldRes);	  oldRes=    residuals;    tmpVec    =    new    VectorialPointValuePair(previousCost);    	non-compiled	[CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double,double[])	79	None	replace
146	[BUG]  [BUGGY]  ((  VectorialPointValuePair)remainings).add(tmpVec,  value);  [CE]  cannot  find  symbol  value  [FE]              AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  ((  VectorialPointValuePair)remainings).add(tmpVec,  value);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	((  VectorialPointValuePair)remainings).add(tmpVec,  value);	  ((    VectorialPointValuePair)remainings).add(tmpVec,    residuals);    	non-compiled	[CE]  cannot  find  symbol  value	84	None	replace
147	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  residuals;  tmpVec  =  residuals;  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	add	tmpVec    =    residuals;    tmpVec  =  residuals;	  	compilable	  [FE]  AssertionFailedError  	39	10	add
148	[BUG]  [BUGGY]  tmpVec  =  residuals;  tmpVec  =  residuals;  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  residuals;  tmpVec  =  residuals;  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec    =    residuals;    tmpVec  =  residuals;	  	compilable	  [FE]  AssertionFailedError  	39	10	add
149	[BUG]  [BUGGY]  tmpVec  =  residuals;  ((  VectorialPointValuePair)previousCost).setVec(tmpVec);  [CE]  inconvertible  types  [FE]      AssertionFailedError    [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  residuals;  ((  VectorialPointValuePair)previousCost).setVec(tmpVec);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec    =    residuals;    ((  VectorialPointValuePair)previousCost).setVec(tmpVec);	  	non-compiled	[CE]  inconvertible  types	39	None	add
150	[BUG]  [BUGGY]  tmpVec  =  residuals;  ((  VectorialPointValuePair)remainings).add(tmpVec);  [CE]  cannot  find  symbol  remainings  [FE]        AssertionFailedError    [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  residuals;  ((  VectorialPointValuePair)remainings).add(tmpVec);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec    =    residuals;    ((  VectorialPointValuePair)remainings).add(tmpVec);	  	non-compiled	[CE]  cannot  find  symbol  remainings	39	None	add
151	[BUG]  [BUGGY]  tmpVec  =  residuals;  ((  VectorialPointValuePair)previousCost).remainings  =  tmpVec;  [CE]  inconvertible  types  [FE]          AssertionFailedError    [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  residuals;  ((  VectorialPointValuePair)previousCost).remainings  =  tmpVec;  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec    =    residuals;    ((  VectorialPointValuePair)previousCost).remainings  =  tmpVec;	  	non-compiled	[CE]  inconvertible  types	39	None	add
152	[BUG]  [BUGGY]  tmpVec  =  residuals;  ((  VectorialPointValuePair)previousCost).add(tmpVec);  [CE]  inconvertible  types  [FE]            AssertionFailedError    [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  residuals;  ((  VectorialPointValuePair)previousCost).add(tmpVec);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec    =    residuals;    ((  VectorialPointValuePair)previousCost).add(tmpVec);	  	non-compiled	[CE]  inconvertible  types	39	None	add
153	[BUG]  [BUGGY]  Preconditions.checkNotNull(results,  firstIteration);  [CE]  cannot  find  symbol  results  [FE]            AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  Preconditions.checkNotNull(results,  firstIteration);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	Preconditions.checkNotNull(results,  firstIteration);	  Preconditions.checkNotNull(results);    	non-compiled	[CE]  cannot  find  symbol  results	1	None	replace
154	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(previousCost,  oldX,  preRed,  point);  [CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double,double[],double,double[])  [FE]                      AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  new  VectorialPointValuePair(previousCost,  oldX,  preRed,  point);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  VectorialPointValuePair(previousCost,  oldX,  preRed,  point);	  tmpVec    =    new    VectorialPointValuePair(previousCost,    oldX,    point);    	non-compiled	[CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double,double[],double,double[])	19	None	replace
155	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(previousCost,  oldX,  previousCost,  point);  [CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double,double[],double,double[])  [FE]                        AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  new  VectorialPointValuePair(previousCost,  oldX,  previousCost,  point);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  VectorialPointValuePair(previousCost,  oldX,  previousCost,  point);	  tmpVec    =    new    VectorialPointValuePair(previousCost,    oldX,    point);    	non-compiled	[CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double,double[],double,double[])	19	None	replace
156	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(previousCost,  oldX,  preRed);  [CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double,double[],double)  [FE]                          AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  new  VectorialPointValuePair(previousCost,  oldX,  preRed);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  VectorialPointValuePair(previousCost,  oldX,  preRed);	  tmpVec    =    new    VectorialPointValuePair(previousCost,    oldX,    point);    	non-compiled	[CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double,double[],double)	19	None	replace
157	[BUG]  [BUGGY]  Preconditions.checkState(tmpVec!=  0);  [CE]  incomparable  types:  double[]  and  int  [FE]                        AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  Preconditions.checkState(tmpVec!=  0);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	Preconditions.checkState(tmpVec!=  0);	  Preconditions.checkState(tmpVec    ==    0);    	non-compiled	[CE]  incomparable  types:  double[]  and  int	6	None	replace
158	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(previousCost,  previousCost,  point,  preRed);  [CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double,double,double[],double)  [FE]                          AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  new  VectorialPointValuePair(previousCost,  previousCost,  point,  preRed);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  VectorialPointValuePair(previousCost,  previousCost,  point,  preRed);	  tmpVec    =    new    VectorialPointValuePair(previousCost,    point,    preRed);    	non-compiled	[CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double,double,double[],double)	21	None	replace
159	[BUG]  [BUGGY]  Preconditions.checkState(oldRes  >=  tmpVec);  [CE]  bad  operand  types  for  binary  operator  '>='  [FE]                    AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  Preconditions.checkState(oldRes  >=  tmpVec);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	Preconditions.checkState(oldRes  >=  tmpVec);	  Preconditions.checkState(oldRes!=    residuals);    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '>='	48	None	replace
160	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(lastIteration);  [CE]  cannot  find  symbol  lastIteration  [FE]              AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  new  VectorialPointValuePair(lastIteration);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  VectorialPointValuePair(lastIteration);	  tmpVec    =    new    VectorialPointValuePair(currentCost);    	non-compiled	[CE]  cannot  find  symbol  lastIteration	53	None	replace
161	[BUG]  [BUGGY]  [FE]  ArrayIndexOutOfBoundsException  [FE]    AssertionFailedError    [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  oldX;  tmpVec  =  oldX;  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	add	tmpVec    =    oldX;    tmpVec  =  oldX;	  	compilable	  [FE]  ArrayIndexOutOfBoundsException  	41	12	add
162	[BUG]  [BUGGY]  tmpVec  =  oldX;  tmpVec  =  oldX;  [FE]  ArrayIndexOutOfBoundsException  [FE]    AssertionFailedError    [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  oldX;  tmpVec  =  oldX;  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec    =    oldX;    tmpVec  =  oldX;	  	compilable	  [FE]  ArrayIndexOutOfBoundsException  	41	12	add
163	[BUG]  [BUGGY]  tmpVec  =  oldX;  ((  VectorialPointValuePair)previousCost).doubleValue();  tmpVec  =  oldX;  [CE]  inconvertible  types  [FE]      AssertionFailedError    [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  oldX;  ((  VectorialPointValuePair)previousCost).doubleValue();  tmpVec  =  oldX;  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec    =    oldX;    ((  VectorialPointValuePair)previousCost).doubleValue();  tmpVec  =  oldX;	  	non-compiled	[CE]  inconvertible  types	41	None	add
164	[BUG]  [BUGGY]  tmpVec  =  oldX;  ((  VectorialPointValuePair)previousCost).setVec(tmpVec);  tmpVec  =  oldX;  [CE]  inconvertible  types  [FE]        AssertionFailedError    [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  oldX;  ((  VectorialPointValuePair)previousCost).setVec(tmpVec);  tmpVec  =  oldX;  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec    =    oldX;    ((  VectorialPointValuePair)previousCost).setVec(tmpVec);  tmpVec  =  oldX;	  	non-compiled	[CE]  inconvertible  types	41	None	add
165	[BUG]  [BUGGY]  tmpVec  =  oldX;  ((  VectorialPointValuePair)previousCost).setVec(tmpVec);  [CE]  inconvertible  types  [FE]          AssertionFailedError    [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  oldX;  ((  VectorialPointValuePair)previousCost).setVec(tmpVec);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec    =    oldX;    ((  VectorialPointValuePair)previousCost).setVec(tmpVec);	  	non-compiled	[CE]  inconvertible  types	41	None	add
166	[BUG]  [BUGGY]  tmpVec  =  oldX;  ((  VectorialPointValuePair)previousCost).setVec(tmpVec,  tmpVec);  [CE]  inconvertible  types  [FE]            AssertionFailedError    [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  oldX;  ((  VectorialPointValuePair)previousCost).setVec(tmpVec,  tmpVec);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec    =    oldX;    ((  VectorialPointValuePair)previousCost).setVec(tmpVec,  tmpVec);	  	non-compiled	[CE]  inconvertible  types	41	None	add
167	[BUG]  [BUGGY]  Preconditions.checkState(results  >=  oldRes);  [CE]  cannot  find  symbol  results  [FE]                  AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  Preconditions.checkState(results  >=  oldRes);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	Preconditions.checkState(results  >=  oldRes);	  Preconditions.checkState(oldRes    >=    residuals);    	non-compiled	[CE]  cannot  find  symbol  results	75	None	replace
168	[BUG]  [BUGGY]  Preconditions.checkState(results  >  oldRes);  [CE]  cannot  find  symbol  results  [FE]                    AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  Preconditions.checkState(results  >  oldRes);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	Preconditions.checkState(results  >  oldRes);	  Preconditions.checkState(remainings    >    oldRes);    	non-compiled	[CE]  cannot  find  symbol  results	34	None	replace
169	[BUG]  [BUGGY]  Preconditions.checkState(oldRes  >  residuals);  [CE]  bad  operand  types  for  binary  operator  '>'  [FE]                      AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  Preconditions.checkState(oldRes  >  residuals);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	Preconditions.checkState(oldRes  >  residuals);	  Preconditions.checkState(remainings    >    oldRes);    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '>'	34	None	replace
170	[BUG]  [BUGGY]  Preconditions.checkState(results  >  oldX);  [CE]  cannot  find  symbol  results  [FE]                        AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  Preconditions.checkState(results  >  oldX);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	Preconditions.checkState(results  >  oldX);	  Preconditions.checkState(remainings    >    oldRes);    	non-compiled	[CE]  cannot  find  symbol  results	34	None	replace
171	[BUG]  [BUGGY]  ((  VectorialPointValuePair)res1).add(tmpVec);  [CE]  cannot  find  symbol  res1  [FE]                AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  ((  VectorialPointValuePair)res1).add(tmpVec);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	((  VectorialPointValuePair)res1).add(tmpVec);	  ((    VectorialPointValuePair)res2).add(tmpVec);    	non-compiled	[CE]  cannot  find  symbol  res1	57	None	replace
172	[BUG]  [BUGGY]  Preconditions.checkState(results  >=  oldX);  [CE]  cannot  find  symbol  results  [FE]                      AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  Preconditions.checkState(results  >=  oldX);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	Preconditions.checkState(results  >=  oldX);	  Preconditions.checkState(remainings    >=    oldX);    	non-compiled	[CE]  cannot  find  symbol  results	35	None	replace
173	[BUG]  [BUGGY]  Preconditions.checkState(oldRes  >=  oldX);  [CE]  bad  operand  types  for  binary  operator  '>='  [FE]                        AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  Preconditions.checkState(oldRes  >=  oldX);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	Preconditions.checkState(oldRes  >=  oldX);	  Preconditions.checkState(remainings    >=    oldX);    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '>='	35	None	replace
174	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(previousCost,  preRed,  cost,  fixedCols);  [CE]  cannot  find  symbol  fixedCols  [FE]            AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  new  VectorialPointValuePair(previousCost,  preRed,  cost,  fixedCols);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  VectorialPointValuePair(previousCost,  preRed,  cost,  fixedCols);	  tmpVec    =    new    VectorialPointValuePair(previousCost,    preRed,    cost);    	non-compiled	[CE]  cannot  find  symbol  fixedCols	14	None	replace
175	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(oldX,  previousCost,  cost);  [CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double[],double,double)  [FE]              AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  new  VectorialPointValuePair(oldX,  previousCost,  cost);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  VectorialPointValuePair(oldX,  previousCost,  cost);	  tmpVec    =    new    VectorialPointValuePair(previousCost,    oldX,    cost);    	non-compiled	[CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double[],double,double)	15	None	replace
176	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(previousCost,  oldX,  oldRes);  [CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double,double[],double[])  [FE]                AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  new  VectorialPointValuePair(previousCost,  oldX,  oldRes);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  VectorialPointValuePair(previousCost,  oldX,  oldRes);	  tmpVec    =    new    VectorialPointValuePair(previousCost,    oldX,    cost);    	non-compiled	[CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double,double[],double[])	15	None	replace
177	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(oldX,  preRed,  cost);  [CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double[],double,double)  [FE]                  AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  new  VectorialPointValuePair(oldX,  preRed,  cost);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  VectorialPointValuePair(oldX,  preRed,  cost);	  tmpVec    =    new    VectorialPointValuePair(previousCost,    oldX,    cost);    	non-compiled	[CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double[],double,double)	15	None	replace
178	[BUG]  [BUGGY]  ((  VectorialPointValuePair)previousCost).setVec(new  VectorialPointValuePair(pj,  previousCost));  [CE]  cannot  find  symbol  pj  [FE]                  AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  ((  VectorialPointValuePair)previousCost).setVec(new  VectorialPointValuePair(pj,  previousCost));  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	((  VectorialPointValuePair)previousCost).setVec(new  VectorialPointValuePair(pj,  previousCost));	  ((    VectorialPointValuePair)previousCost).setVec(remainings);    	non-compiled	[CE]  cannot  find  symbol  pj	50	None	replace
179	[BUG]  [BUGGY]  ((  VectorialPointValuePair)previousCost).setVec(oldX,  residuals);  [CE]  inconvertible  types  [FE]                  AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  ((  VectorialPointValuePair)previousCost).setVec(oldX,  residuals);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	((  VectorialPointValuePair)previousCost).setVec(oldX,  residuals);	  ((    VectorialPointValuePair)previousCost).setVec(oldX,    oldVec);    	non-compiled	[CE]  inconvertible  types	83	None	replace
180	[BUG]  [BUGGY]  oldRes=  0;  tmpVec  =  new  VectorialPointValuePair();  [CE]  incompatible  types  [FE]            AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  oldRes=  0;  tmpVec  =  new  VectorialPointValuePair();  [BUGGY]      }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	oldRes=  0;  tmpVec  =  new  VectorialPointValuePair();	  oldRes=    residuals;    tmpVec    =    new    VectorialPointValuePair();    	non-compiled	[CE]  incompatible  types	81	None	replace
181	[BUG]  [BUGGY]  oldRes=  pj;  tmpVec  =  new  VectorialPointValuePair();  [CE]  cannot  find  symbol  pj  [FE]              AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  oldRes=  pj;  tmpVec  =  new  VectorialPointValuePair();  [BUGGY]      }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	oldRes=  pj;  tmpVec  =  new  VectorialPointValuePair();	  oldRes=    residuals;    tmpVec    =    new    VectorialPointValuePair();    	non-compiled	[CE]  cannot  find  symbol  pj	81	None	replace
182	[BUG]  [BUGGY]  ((  VectorialPointValuePair)previousCost).setVec(new  VectorialPointValuePair(tmpVec,  value));  [CE]  cannot  find  symbol  value  [FE]                    AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  ((  VectorialPointValuePair)previousCost).setVec(new  VectorialPointValuePair(tmpVec,  value));  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	((  VectorialPointValuePair)previousCost).setVec(new  VectorialPointValuePair(tmpVec,  value));	  ((    VectorialPointValuePair)previousCost).setVec(new    VectorialPointValuePair(tmpVec,    residuals));    	non-compiled	[CE]  cannot  find  symbol  value	51	None	replace
183	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(lastX,  oldRes);  [CE]  cannot  find  symbol  lastX  [FE]                AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  new  VectorialPointValuePair(lastX,  oldRes);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  VectorialPointValuePair(lastX,  oldRes);	  tmpVec    =    new    VectorialPointValuePair(lastX,    previousCost);    	non-compiled	[CE]  cannot  find  symbol  lastX	54	None	replace
184	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(previousCost,  pj);  [CE]  cannot  find  symbol  pj  [FE]                  AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  new  VectorialPointValuePair(previousCost,  pj);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  VectorialPointValuePair(previousCost,  pj);	  tmpVec    =    new    VectorialPointValuePair(lastX,    previousCost);    	non-compiled	[CE]  cannot  find  symbol  pj	54	None	replace
185	[BUG]  [BUGGY]  ((  VectorialPointValuePair)remainders).add(tmpVec);  [CE]  cannot  find  symbol  remainders  [FE]                  AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  ((  VectorialPointValuePair)remainders).add(tmpVec);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	((  VectorialPointValuePair)remainders).add(tmpVec);	  ((    VectorialPointValuePair)res).add(tmpVec);    	non-compiled	[CE]  cannot  find  symbol  remainders	58	None	replace
186	[BUG]  [BUGGY]  tmpVec  =  oldRes[oldRes];  [CE]  incompatible  types  [FE]            AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  oldRes[oldRes];  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  oldRes[oldRes];	  tmpVec    =    permutation[oldRes];    	non-compiled	[CE]  incompatible  types	73	None	replace
187	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(j,  previousCost,  cost);  [CE]  cannot  find  symbol  j  [FE]              AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  new  VectorialPointValuePair(j,  previousCost,  cost);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  VectorialPointValuePair(j,  previousCost,  cost);	  tmpVec    =    new    VectorialPointValuePair(pj,    previousCost,    cost);    	non-compiled	[CE]  cannot  find  symbol  j	60	None	replace
188	[BUG]  [BUGGY]  Preconditions.checkState(oldRes!=  oldX);  [CE]  cannot  find  symbol  Preconditions  [FE]                AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  Preconditions.checkState(oldRes!=  oldX);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	Preconditions.checkState(oldRes!=  oldX);	  Preconditions.checkState(remainings!=    oldX);    	non-compiled	[CE]  cannot  find  symbol  Preconditions	46	None	replace
189	[BUG]  [BUGGY]  Preconditions.checkState(tmpVec!=  oldX);  [CE]  cannot  find  symbol  Preconditions  [FE]                  AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  Preconditions.checkState(tmpVec!=  oldX);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	Preconditions.checkState(tmpVec!=  oldX);	  Preconditions.checkState(remainings!=    oldX);    	non-compiled	[CE]  cannot  find  symbol  Preconditions	46	None	replace
190	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(j);  [CE]  cannot  find  symbol  j  [FE]                  AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  new  VectorialPointValuePair(j);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  VectorialPointValuePair(j);	  tmpVec    =    new    VectorialPointValuePair(pj);    	non-compiled	[CE]  cannot  find  symbol  j	32	None	replace
191	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(previousCost,  pj,  cost);  [CE]  cannot  find  symbol  pj  [FE]                AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  new  VectorialPointValuePair(previousCost,  pj,  cost);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  VectorialPointValuePair(previousCost,  pj,  cost);	  tmpVec    =    new    VectorialPointValuePair(last,    previousCost,    cost);    	non-compiled	[CE]  cannot  find  symbol  pj	61	None	replace
192	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(previous,  cost,  previousCost);  [CE]  no  suitable  constructor  found  for  VectorialPointValuePair(VectorialPointValuePair,double,double)  [FE]                  AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  new  VectorialPointValuePair(previous,  cost,  previousCost);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  VectorialPointValuePair(previous,  cost,  previousCost);	  tmpVec    =    new    VectorialPointValuePair(last,    previousCost,    cost);    	non-compiled	[CE]  no  suitable  constructor  found  for  VectorialPointValuePair(VectorialPointValuePair,double,double)	61	None	replace
193	[BUG]  [BUGGY]  oldRes=  preRed;  tmpVec=  residuals;  [CE]  incompatible  types  [FE]              AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  oldRes=  preRed;  tmpVec=  residuals;  [BUGGY]      }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	oldRes=  preRed;  tmpVec=  residuals;	  oldRes=    residuals;    tmpVec=    preRed;    	non-compiled	[CE]  incompatible  types	30	None	replace
194	[BUG]  [BUGGY]  tmpVec  =  permutation[0].remainder;  [CE]  int  cannot  be  dereferenced  [FE]            AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  permutation[0].remainder;  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  permutation[0].remainder;	  tmpVec    =    permutation[j].remainder;    	non-compiled	[CE]  int  cannot  be  dereferenced	88	None	replace
195	[BUG]  [BUGGY]  tmpVec  =  oldX  +  1;  [CE]  bad  operand  types  for  binary  operator  '+'  [FE]                    AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  oldX  +  1;  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  oldX  +  1;	  tmpVec    =    preRed    +    1;    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '+'	7	None	replace
196	[BUG]  [BUGGY]  oldRes=  tmpVec;  tmpVec=  permutation[j];  [CE]  cannot  find  symbol  j  [FE]            AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  oldRes=  tmpVec;  tmpVec=  permutation[j];  [BUGGY]      }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	oldRes=  tmpVec;  tmpVec=  permutation[j];	  oldRes=    residuals;    tmpVec=    permutation[j];    	non-compiled	[CE]  cannot  find  symbol  j	29	None	replace
197	[BUG]  [BUGGY]  oldRes=  pj;  tmpVec=  permutation[pj];  [CE]  cannot  find  symbol  pj  [FE]              AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  oldRes=  pj;  tmpVec=  permutation[pj];  [BUGGY]      }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	oldRes=  pj;  tmpVec=  permutation[pj];	  oldRes=    residuals;    tmpVec=    permutation[j];    	non-compiled	[CE]  cannot  find  symbol  pj	29	None	replace
198	[BUG]  [BUGGY]  oldRes=  tmpVec;  tmpVec=  permutation[pj];  [CE]  cannot  find  symbol  pj  [FE]                AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  oldRes=  tmpVec;  tmpVec=  permutation[pj];  [BUGGY]      }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	oldRes=  tmpVec;  tmpVec=  permutation[pj];	  oldRes=    residuals;    tmpVec=    permutation[j];    	non-compiled	[CE]  cannot  find  symbol  pj	29	None	replace
199	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(currentCost,  oldX,  cost);  [CE]  cannot  find  symbol  currentCost  [FE]            AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  new  VectorialPointValuePair(currentCost,  oldX,  cost);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  VectorialPointValuePair(currentCost,  oldX,  cost);	  tmpVec    =    new    VectorialPointValuePair(previousCost,    cost,    oldX);    	non-compiled	[CE]  cannot  find  symbol  currentCost	87	None	replace
200	[BUG]  [BUGGY]  tmpVec  =  oldX  +  2;  [CE]  bad  operand  types  for  binary  operator  '+'  [FE]                        AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  oldX  +  2;  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  oldX  +  2;	  tmpVec    =    preRed    +    2;    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '+'	9	None	replace
201	[BUG]  [BUGGY]  tmpVec  =  permutation[0]  +  cost;  [CE]  incompatible  types  [FE]              AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  permutation[0]  +  cost;  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  permutation[0]  +  cost;	  tmpVec    =    permutation[0];    	non-compiled	[CE]  incompatible  types	44	None	replace
202	[BUG]  [BUGGY]  ((  VectorialPointValuePair)previousCost).setVec(tmpVec,  oldRes);  [CE]  inconvertible  types  [FE]                AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  ((  VectorialPointValuePair)previousCost).setVec(tmpVec,  oldRes);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	((  VectorialPointValuePair)previousCost).setVec(tmpVec,  oldRes);	  ((    VectorialPointValuePair)previousCost).setVec(tmpVec,    residuals);    	non-compiled	[CE]  inconvertible  types	49	None	replace
203	[BUG]  [BUGGY]  ((  VectorialPointValuePair)previousCost).setVec(pj,  tmpVec,  residuals);  [CE]  cannot  find  symbol  pj  [FE]                  AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  ((  VectorialPointValuePair)previousCost).setVec(pj,  tmpVec,  residuals);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	((  VectorialPointValuePair)previousCost).setVec(pj,  tmpVec,  residuals);	  ((    VectorialPointValuePair)previousCost).setVec(tmpVec,    residuals);    	non-compiled	[CE]  cannot  find  symbol  pj	49	None	replace
204	[BUG]  [BUGGY]  oldRes=    residuals;    oldRes=  residuals;  tmpVec  =  permutation[j];  [CE]  cannot  find  symbol  j  [FE]    AssertionFailedError    [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  oldRes=    residuals;    oldRes=  residuals;  tmpVec  =  permutation[j];  [BUGGY]      }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	oldRes=        residuals;        oldRes=    residuals;    tmpVec  =  permutation[j];	  	non-compiled	[CE]  cannot  find  symbol  j	25	None	add
205	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(point,  previousCost,  preRed);  [CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double[],double,double)  [FE]                          AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  new  VectorialPointValuePair(point,  previousCost,  preRed);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  VectorialPointValuePair(point,  previousCost,  preRed);	  tmpVec    =    new    VectorialPointValuePair(previousCost,    point,    preRed);    	non-compiled	[CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double[],double,double)	21	None	replace
206	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(previousCost,  value,  point,  preRed);  [CE]  cannot  find  symbol  value  [FE]                            AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  new  VectorialPointValuePair(previousCost,  value,  point,  preRed);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  VectorialPointValuePair(previousCost,  value,  point,  preRed);	  tmpVec    =    new    VectorialPointValuePair(previousCost,    point,    preRed);    	non-compiled	[CE]  cannot  find  symbol  value	21	None	replace
207	[BUG]  [BUGGY]  ((  VectorialPointValuePair)remainings).add(tmpVec,  oldRes);  [CE]  cannot  find  symbol  remainings  [FE]              AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  ((  VectorialPointValuePair)remainings).add(tmpVec,  oldRes);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	((  VectorialPointValuePair)remainings).add(tmpVec,  oldRes);	  ((    VectorialPointValuePair)remainings).add(tmpVec,    residuals);    	non-compiled	[CE]  cannot  find  symbol  remainings	84	None	replace
208	[BUG]  [BUGGY]  Preconditions.checkState(oldRes!=  null);  [CE]  cannot  find  symbol  Preconditions  [FE]            AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  Preconditions.checkState(oldRes!=  null);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	Preconditions.checkState(oldRes!=  null);	  Preconditions.checkNotNull(oldRes);    	non-compiled	[CE]  cannot  find  symbol  Preconditions	76	None	replace
209	[BUG]  [BUGGY]  oldRes  =  new  RelativeTolerance(tmpVec,  residualTolerance);  [CE]  cannot  find  symbol  [FE]        AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  oldRes  =  new  RelativeTolerance(tmpVec,  residualTolerance);  [BUGGY]      }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	oldRes  =  new  RelativeTolerance(tmpVec,  residualTolerance);	  oldRes    =    new    RelativeTolerance(relativeTolerance);    	non-compiled	[CE]  cannot  find  symbol	85	None	replace
210	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(point,  oldX,  previousCost);  [CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double[],double[],double)  [FE]                    AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  new  VectorialPointValuePair(point,  oldX,  previousCost);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  VectorialPointValuePair(point,  oldX,  previousCost);	  tmpVec    =    new    VectorialPointValuePair(point,    previousCost);    	non-compiled	[CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double[],double[],double)	70	None	replace
211	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(point,  cost);  [CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double[],double)  [FE]                      AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  new  VectorialPointValuePair(point,  cost);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  VectorialPointValuePair(point,  cost);	  tmpVec    =    new    VectorialPointValuePair(point,    previousCost);    	non-compiled	[CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double[],double)	70	None	replace
212	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(point,  preRed,  previousCost);  [CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double[],double,double)  [FE]                        AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  new  VectorialPointValuePair(point,  preRed,  previousCost);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  VectorialPointValuePair(point,  preRed,  previousCost);	  tmpVec    =    new    VectorialPointValuePair(point,    previousCost);    	non-compiled	[CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double[],double,double)	70	None	replace
213	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(last,  cost);  [CE]  cannot  find  symbol  last  [FE]                AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  new  VectorialPointValuePair(last,  cost);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  VectorialPointValuePair(last,  cost);	  tmpVec    =    new    VectorialPointValuePair(currentCost,    cost);    	non-compiled	[CE]  cannot  find  symbol  last	16	None	replace
214	[BUG]  [BUGGY]  tmpVec  =  residuals;  int  tmpVec  =  residuals;  [CE]  variable  tmpVec  is  already  defined  in  method  doOptimize()  [FE]    AssertionFailedError    [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  residuals;  int  tmpVec  =  residuals;  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec    =    residuals;    int  tmpVec  =  residuals;	  	non-compiled	[CE]  variable  tmpVec  is  already  defined  in  method  doOptimize()	39	None	add
215	[BUG]  [BUGGY]  tmpVec  =  residuals;  ((  VectorialPointValuePair)previousCost).setVec(remainings);  [CE]  cannot  find  symbol  remainings  [FE]      AssertionFailedError    [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  residuals;  ((  VectorialPointValuePair)previousCost).setVec(remainings);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec    =    residuals;    ((  VectorialPointValuePair)previousCost).setVec(remainings);	  	non-compiled	[CE]  cannot  find  symbol  remainings	39	None	add
216	[BUG]  [BUGGY]  ((  VectorialPointValuePair)previousCost).setVec(new  VectorialPointValuePair(pj,  tmpVec));  [CE]  cannot  find  symbol  pj  [FE]                AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  ((  VectorialPointValuePair)previousCost).setVec(new  VectorialPointValuePair(pj,  tmpVec));  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	((  VectorialPointValuePair)previousCost).setVec(new  VectorialPointValuePair(pj,  tmpVec));	  ((    VectorialPointValuePair)previousCost).setVec(new    VectorialPointValuePair(tmpVec));    	non-compiled	[CE]  cannot  find  symbol  pj	74	None	replace
217	[BUG]  [BUGGY]  tmpVec  =  oldX;  ((  VectorialPointValuePair)new  VectorialPointValuePair(previousCost,  oldX,  oldVec)).remainings  =  tmpVec;  [CE]  cannot  find  symbol  oldVec  [FE]    AssertionFailedError    [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  oldX;  ((  VectorialPointValuePair)new  VectorialPointValuePair(previousCost,  oldX,  oldVec)).remainings  =  tmpVec;  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec    =    oldX;    ((  VectorialPointValuePair)new  VectorialPointValuePair(previousCost,  oldX,  oldVec)).remainings  =  tmpVec;	  	non-compiled	[CE]  cannot  find  symbol  oldVec	41	None	add
218	[BUG]  [BUGGY]  tmpVec  =  oldX;  ((  VectorialPointValuePair)new  VectorialPointValuePair(previousCost,  pj,  tmpVec)).remainings  =  oldX;  [CE]  cannot  find  symbol  pj  [FE]      AssertionFailedError    [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  oldX;  ((  VectorialPointValuePair)new  VectorialPointValuePair(previousCost,  pj,  tmpVec)).remainings  =  oldX;  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec    =    oldX;    ((  VectorialPointValuePair)new  VectorialPointValuePair(previousCost,  pj,  tmpVec)).remainings  =  oldX;	  	non-compiled	[CE]  cannot  find  symbol  pj	41	None	add
219	[BUG]  [BUGGY]  tmpVec  =  oldX;  ((  VectorialPointValuePair)new  VectorialPointValuePair(previousCost,  oldX,  oldVec)).add(tmpVec);  [CE]  cannot  find  symbol  oldVec  [FE]        AssertionFailedError    [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  oldX;  ((  VectorialPointValuePair)new  VectorialPointValuePair(previousCost,  oldX,  oldVec)).add(tmpVec);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec    =    oldX;    ((  VectorialPointValuePair)new  VectorialPointValuePair(previousCost,  oldX,  oldVec)).add(tmpVec);	  	non-compiled	[CE]  cannot  find  symbol  oldVec	41	None	add
220	[BUG]  [BUGGY]  tmpVec  =  oldX;  ((  VectorialPointValuePair)new  VectorialPointValuePair(previousCost)).add(tmpVec);  [CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double)  [FE]          AssertionFailedError    [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  oldX;  ((  VectorialPointValuePair)new  VectorialPointValuePair(previousCost)).add(tmpVec);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec    =    oldX;    ((  VectorialPointValuePair)new  VectorialPointValuePair(previousCost)).add(tmpVec);	  	non-compiled	[CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double)	41	None	add
221	[BUG]  [BUGGY]  tmpVec  =  new  double[pj];  [CE]  cannot  find  symbol  pj  [FE]    AssertionFailedError    [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  new  double[pj];  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  double[pj];	  tmpVec    =    oldX;    	non-compiled	[CE]  cannot  find  symbol  pj	42	None	replace
222	[BUG]  [BUGGY]  Preconditions.checkState(tmpVec  >  oldRes);  [CE]  bad  operand  types  for  binary  operator  '>'  [FE]                    AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  Preconditions.checkState(tmpVec  >  oldRes);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	Preconditions.checkState(tmpVec  >  oldRes);	  Preconditions.checkState(remainings    >    oldRes);    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '>'	34	None	replace
223	[BUG]  [BUGGY]  tmpVec  =  new  double[oldRes.length];  ((  VectorialPointValuePair)oldRes).remainings  =  new  double[oldRes.length];  [CE]  inconvertible  types  [FE]    AssertionFailedError    [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  new  double[oldRes.length];  ((  VectorialPointValuePair)oldRes).remainings  =  new  double[oldRes.length];  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec    =    new    double[oldRes.length];    ((  VectorialPointValuePair)oldRes).remainings  =  new  double[oldRes.length];	  	non-compiled	[CE]  inconvertible  types	63	None	add
224	[BUG]  [BUGGY]  tmpVec  =  new  double[oldRes.length];  ((  VectorialPointValuePair)oldRes).add(tmpVec);  [CE]  inconvertible  types  [FE]      AssertionFailedError    [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  new  double[oldRes.length];  ((  VectorialPointValuePair)oldRes).add(tmpVec);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec    =    new    double[oldRes.length];    ((  VectorialPointValuePair)oldRes).add(tmpVec);	  	non-compiled	[CE]  inconvertible  types	63	None	add
225	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(last);  [CE]  cannot  find  symbol  last  [FE]              AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  new  VectorialPointValuePair(last);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  VectorialPointValuePair(last);	  tmpVec    =    new    VectorialPointValuePair(currentCost);    	non-compiled	[CE]  cannot  find  symbol  last	53	None	replace
226	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(oldX,  previousCost,  point);  [CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double[],double,double[])  [FE]                      AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  new  VectorialPointValuePair(oldX,  previousCost,  point);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  VectorialPointValuePair(oldX,  previousCost,  point);	  tmpVec    =    new    VectorialPointValuePair(previousCost,    oldX,    point);    	non-compiled	[CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double[],double,double[])	19	None	replace
227	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(lastX,  previousCost,  oldX);  [CE]  cannot  find  symbol  lastX  [FE]                        AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  new  VectorialPointValuePair(lastX,  previousCost,  oldX);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  VectorialPointValuePair(lastX,  previousCost,  oldX);	  tmpVec    =    new    VectorialPointValuePair(previousCost,    oldX,    point);    	non-compiled	[CE]  cannot  find  symbol  lastX	19	None	replace
228	[BUG]  [BUGGY]  oldRes=  previousCost;  tmpVec  =  new  VectorialPointValuePair(remainings);  [CE]  incompatible  types  [FE]        AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  oldRes=  previousCost;  tmpVec  =  new  VectorialPointValuePair(remainings);  [BUGGY]      }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	oldRes=  previousCost;  tmpVec  =  new  VectorialPointValuePair(remainings);	  oldRes=    residuals;    tmpVec    =    new    VectorialPointValuePair(previousCost);    	non-compiled	[CE]  incompatible  types	79	None	replace
229	[BUG]  [BUGGY]  oldRes=  preRed;  tmpVec  =  new  VectorialPointValuePair(previousCost);  [CE]  incompatible  types  [FE]          AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  oldRes=  preRed;  tmpVec  =  new  VectorialPointValuePair(previousCost);  [BUGGY]      }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	oldRes=  preRed;  tmpVec  =  new  VectorialPointValuePair(previousCost);	  oldRes=    residuals;    tmpVec    =    new    VectorialPointValuePair(previousCost);    	non-compiled	[CE]  incompatible  types	79	None	replace
230	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(previous,  oldX);  [CE]  no  suitable  constructor  found  for  VectorialPointValuePair(VectorialPointValuePair,double[])  [FE]                AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  new  VectorialPointValuePair(previous,  oldX);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  VectorialPointValuePair(previous,  oldX);	  tmpVec    =    new    VectorialPointValuePair(oldX);    	non-compiled	[CE]  no  suitable  constructor  found  for  VectorialPointValuePair(VectorialPointValuePair,double[])	66	None	replace
231	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(oldX,  prev);  [CE]  cannot  find  symbol  prev  [FE]                  AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  new  VectorialPointValuePair(oldX,  prev);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  VectorialPointValuePair(oldX,  prev);	  tmpVec    =    new    VectorialPointValuePair(oldX);    	non-compiled	[CE]  cannot  find  symbol  prev	66	None	replace
232	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(oldX,  value);  [CE]  cannot  find  symbol  value  [FE]                    AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  new  VectorialPointValuePair(oldX,  value);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  VectorialPointValuePair(oldX,  value);	  tmpVec    =    new    VectorialPointValuePair(oldX);    	non-compiled	[CE]  cannot  find  symbol  value	66	None	replace
233	[BUG]  [BUGGY]  Preconditions.checkState(oldRes  ==  0);  [CE]  incomparable  types:  double[]  and  int  [FE]                        AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  Preconditions.checkState(oldRes  ==  0);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	Preconditions.checkState(oldRes  ==  0);	  Preconditions.checkState(tmpVec    ==    0);    	non-compiled	[CE]  incomparable  types:  double[]  and  int	6	None	replace
234	[BUG]  [BUGGY]  tmpVec  =  new  double[oldX.length];  int  oldX  =  new  double[oldX.length];  [CE]  variable  oldX  is  already  defined  in  method  doOptimize()  [FE]    AssertionFailedError    [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  new  double[oldX.length];  int  oldX  =  new  double[oldX.length];  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec    =    new    double[oldX.length];    int  oldX  =  new  double[oldX.length];	  	non-compiled	[CE]  variable  oldX  is  already  defined  in  method  doOptimize()	89	None	add
235	[BUG]  [BUGGY]  tmpVec  =  new  double[oldX.length];  new  double[oldX.length];  [CE]  not  a  statement  [FE]      AssertionFailedError    [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  new  double[oldX.length];  new  double[oldX.length];  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec    =    new    double[oldX.length];    new  double[oldX.length];	  	non-compiled	[CE]  not  a  statement	89	None	add
236	[BUG]  [BUGGY]  ((  VectorialPointValuePair)res).add(tmpVec,  cost);  [CE]  cannot  find  symbol  res  [FE]              AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  ((  VectorialPointValuePair)res).add(tmpVec,  cost);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	((  VectorialPointValuePair)res).add(tmpVec,  cost);	  ((    VectorialPointValuePair)remainings).add(tmpVec,    cost);    	non-compiled	[CE]  cannot  find  symbol  res	56	None	replace
237	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(lastX,  previousCost,  preRed);  [CE]  cannot  find  symbol  lastX  [FE]                AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  new  VectorialPointValuePair(lastX,  previousCost,  preRed);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  VectorialPointValuePair(lastX,  previousCost,  preRed);	  tmpVec    =    new    VectorialPointValuePair(previousCost,    previousCost);    	non-compiled	[CE]  cannot  find  symbol  lastX	77	None	replace
238	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(currentCost,  previousCost);  [CE]  cannot  find  symbol  currentCost  [FE]                  AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  new  VectorialPointValuePair(currentCost,  previousCost);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  VectorialPointValuePair(currentCost,  previousCost);	  tmpVec    =    new    VectorialPointValuePair(previousCost,    previousCost);    	non-compiled	[CE]  cannot  find  symbol  currentCost	77	None	replace
239	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(pj,  previousCost,  point);  [CE]  cannot  find  symbol  pj  [FE]                        AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  new  VectorialPointValuePair(pj,  previousCost,  point);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  VectorialPointValuePair(pj,  previousCost,  point);	  tmpVec    =    new    VectorialPointValuePair(lastX,    previousCost,    point);    	non-compiled	[CE]  cannot  find  symbol  pj	72	None	replace
240	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(lastX,  oldRes,  point);  [CE]  cannot  find  symbol  lastX  [FE]                          AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  new  VectorialPointValuePair(lastX,  oldRes,  point);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  VectorialPointValuePair(lastX,  oldRes,  point);	  tmpVec    =    new    VectorialPointValuePair(lastX,    previousCost,    point);    	non-compiled	[CE]  cannot  find  symbol  lastX	72	None	replace
241	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(previousCost,  pj,  point);  [CE]  cannot  find  symbol  pj  [FE]                            AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  new  VectorialPointValuePair(previousCost,  pj,  point);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  VectorialPointValuePair(previousCost,  pj,  point);	  tmpVec    =    new    VectorialPointValuePair(lastX,    previousCost,    point);    	non-compiled	[CE]  cannot  find  symbol  pj	72	None	replace
242	[BUG]  [BUGGY]  ((  VectorialPointValuePair)previousCost).setVec(oldX,  oldRes);  [CE]  inconvertible  types  [FE]                AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  ((  VectorialPointValuePair)previousCost).setVec(oldX,  oldRes);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	((  VectorialPointValuePair)previousCost).setVec(oldX,  oldRes);	  ((    VectorialPointValuePair)previousCost).setVec(tmpVec,    pj);    	non-compiled	[CE]  inconvertible  types	82	None	replace
243	[BUG]  [BUGGY]  ((  VectorialPointValuePair)previousCost).setVec(tmpVec,  j);  [CE]  cannot  find  symbol  j  [FE]                  AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  ((  VectorialPointValuePair)previousCost).setVec(tmpVec,  j);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	((  VectorialPointValuePair)previousCost).setVec(tmpVec,  j);	  ((    VectorialPointValuePair)previousCost).setVec(tmpVec,    pj);    	non-compiled	[CE]  cannot  find  symbol  j	82	None	replace
244	[BUG]  [BUGGY]  tmpVec  =  permutation[point];  [CE]  incompatible  types  [FE]            AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  permutation[point];  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  permutation[point];	  tmpVec    =    permutation[pj];    	non-compiled	[CE]  incompatible  types	43	None	replace
245	[BUG]  [BUGGY]  tmpVec  =  permutation[j];  oldRes=  repaints;  [CE]  cannot  find  symbol  j  [FE]          AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  permutation[j];  oldRes=  repaints;  [BUGGY]      }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  permutation[j];  oldRes=  repaints;	  oldRes=    residuals;    tmpVec    =    permutation[j];    oldRes=    residuals;    	non-compiled	[CE]  cannot  find  symbol  j	80	None	replace
246	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(previousCost,  cost,  preRed,  point);  [CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double,double,double,double[])  [FE]                        AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  new  VectorialPointValuePair(previousCost,  cost,  preRed,  point);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  VectorialPointValuePair(previousCost,  cost,  preRed,  point);	  tmpVec    =    new    VectorialPointValuePair(previousCost,    preRed,    point);    	non-compiled	[CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double,double,double,double[])	20	None	replace
247	[BUG]  [BUGGY]  ((  VectorialPointValuePair)previousCost).setVec(oldX,  pj,  tmpVec);  [CE]  cannot  find  symbol  pj  [FE]                      AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  ((  VectorialPointValuePair)previousCost).setVec(oldX,  pj,  tmpVec);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	((  VectorialPointValuePair)previousCost).setVec(oldX,  pj,  tmpVec);	  ((    VectorialPointValuePair)previousCost).setVec(oldX,    tmpVec);    	non-compiled	[CE]  cannot  find  symbol  pj	52	None	replace
248	[BUG]  [BUGGY]  ((  VectorialPointValuePair)previousCost).setVec(new  VectorialPointValuePair(tmpVec),  cost);  [CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double[])  [FE]                AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  ((  VectorialPointValuePair)previousCost).setVec(new  VectorialPointValuePair(tmpVec),  cost);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	((  VectorialPointValuePair)previousCost).setVec(new  VectorialPointValuePair(tmpVec),  cost);	  ((    VectorialPointValuePair)previousCost).setVec(new    VectorialPointValuePair(tmpVec));    	non-compiled	[CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double[])	74	None	replace
249	[BUG]  [BUGGY]  tmpVec  =  permutation[0]  +  point[pj];  [CE]  cannot  find  symbol  pj  [FE]              AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  permutation[0]  +  point[pj];  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  permutation[0]  +  point[pj];	  tmpVec    =    permutation[0];    	non-compiled	[CE]  cannot  find  symbol  pj	44	None	replace
250	[BUG]  [BUGGY]  tmpVec  =  residuals;  tmpVec  =  remainings;  [CE]  cannot  find  symbol  remainings  [FE]    AssertionFailedError    [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  residuals;  tmpVec  =  remainings;  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec    =    residuals;    tmpVec  =  remainings;	  	non-compiled	[CE]  cannot  find  symbol  remainings	39	None	add
251	[BUG]  [BUGGY]  tmpVec  =  residuals;  tmpVec  =  residuals.length;  [CE]  incompatible  types  [FE]      AssertionFailedError    [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  residuals;  tmpVec  =  residuals.length;  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec    =    residuals;    tmpVec  =  residuals.length;	  	non-compiled	[CE]  incompatible  types	39	None	add
252	[BUG]  [BUGGY]  ((  VectorialPointValuePair)previousCost).setVec(new  VectorialPointValuePair(tmpVec,  oldX));  [CE]  inconvertible  types  [FE]                    AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  ((  VectorialPointValuePair)previousCost).setVec(new  VectorialPointValuePair(tmpVec,  oldX));  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	((  VectorialPointValuePair)previousCost).setVec(new  VectorialPointValuePair(tmpVec,  oldX));	  ((    VectorialPointValuePair)previousCost).setVec(new    VectorialPointValuePair(tmpVec,    residuals));    	non-compiled	[CE]  inconvertible  types	51	None	replace
253	[BUG]  [BUGGY]  ((  VectorialPointValuePair)remainings).add(tmpVec,  previousCost);  [CE]  cannot  find  symbol  remainings  [FE]              AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  ((  VectorialPointValuePair)remainings).add(tmpVec,  previousCost);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	((  VectorialPointValuePair)remainings).add(tmpVec,  previousCost);	  ((    VectorialPointValuePair)remainings).add(tmpVec,    cost);    	non-compiled	[CE]  cannot  find  symbol  remainings	56	None	replace
254	[BUG]  [BUGGY]  ((  VectorialPointValuePair)remainings).add(tmpVec,  currentCost);  [CE]  cannot  find  symbol  currentCost  [FE]                AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  ((  VectorialPointValuePair)remainings).add(tmpVec,  currentCost);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	((  VectorialPointValuePair)remainings).add(tmpVec,  currentCost);	  ((    VectorialPointValuePair)remainings).add(tmpVec,    cost);    	non-compiled	[CE]  cannot  find  symbol  currentCost	56	None	replace
255	[BUG]  [BUGGY]  tmpVec  =  permutation[i];  [CE]  cannot  find  symbol  i  [FE]            AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  permutation[i];  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  permutation[i];	  tmpVec    =    permutation[pj];    	non-compiled	[CE]  cannot  find  symbol  i	43	None	replace
256	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(new  VectorialPointValuePair(oldX,  oldRes));  [CE]  no  suitable  constructor  found  for  VectorialPointValuePair(VectorialPointValuePair)  [FE]                AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  new  VectorialPointValuePair(new  VectorialPointValuePair(oldX,  oldRes));  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  VectorialPointValuePair(new  VectorialPointValuePair(oldX,  oldRes));	  tmpVec    =    new    VectorialPointValuePair(oldX);    	non-compiled	[CE]  no  suitable  constructor  found  for  VectorialPointValuePair(VectorialPointValuePair)	66	None	replace
257	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(oldX,  oldVec);  [CE]  cannot  find  symbol  oldVec  [FE]                  AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  new  VectorialPointValuePair(oldX,  oldVec);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  VectorialPointValuePair(oldX,  oldVec);	  tmpVec    =    new    VectorialPointValuePair(oldX);    	non-compiled	[CE]  cannot  find  symbol  oldVec	66	None	replace
258	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(lastX);  [CE]  cannot  find  symbol  lastX  [FE]              AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  new  VectorialPointValuePair(lastX);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  VectorialPointValuePair(lastX);	  tmpVec    =    new    VectorialPointValuePair(currentCost);    	non-compiled	[CE]  cannot  find  symbol  lastX	53	None	replace
259	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(lastX,  previousCost,  point,  cost);  [CE]  cannot  find  symbol  lastX  [FE]                    AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  new  VectorialPointValuePair(lastX,  previousCost,  point,  cost);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  VectorialPointValuePair(lastX,  previousCost,  point,  cost);	  tmpVec    =    new    VectorialPointValuePair(previousCost,    point,    cost);    	non-compiled	[CE]  cannot  find  symbol  lastX	18	None	replace
260	[BUG]  [BUGGY]  Preconditions.checkState(results!=  null);  [CE]  cannot  find  symbol  results  [FE]            AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  Preconditions.checkState(results!=  null);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	Preconditions.checkState(results!=  null);	  Preconditions.checkNotNull(results);    	non-compiled	[CE]  cannot  find  symbol  results	1	None	replace
261	[BUG]  [BUGGY]  Preconditions.checkState(remainings  ==  oldX,  residuals);  [CE]  cannot  find  symbol  remainings  [FE]                  AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  Preconditions.checkState(remainings  ==  oldX,  residuals);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	Preconditions.checkState(remainings  ==  oldX,  residuals);	  Preconditions.checkState(remainings    ==    oldX);    	non-compiled	[CE]  cannot  find  symbol  remainings	12	None	replace
262	[BUG]  [BUGGY]  Preconditions.checkNotNull(remainders);  [CE]  cannot  find  symbol  remainders  [FE]              AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  Preconditions.checkNotNull(remainders);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	Preconditions.checkNotNull(remainders);	  Preconditions.checkNotNull(tmpVec);    	non-compiled	[CE]  cannot  find  symbol  remainders	2	None	replace
263	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(previousCost,  oldX,  oldRes,  point);  [CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double,double[],double[],double[])  [FE]                      AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  new  VectorialPointValuePair(previousCost,  oldX,  oldRes,  point);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  VectorialPointValuePair(previousCost,  oldX,  oldRes,  point);	  tmpVec    =    new    VectorialPointValuePair(previousCost,    oldX,    point);    	non-compiled	[CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double,double[],double[],double[])	19	None	replace
264	[BUG]  [BUGGY]  oldRes  =  tmpVec;  tmpVec  =  new  VectorialPointValuePair();  [CE]  no  suitable  constructor  found  for  VectorialPointValuePair()  [FE]            AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  oldRes  =  tmpVec;  tmpVec  =  new  VectorialPointValuePair();  [BUGGY]      }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	oldRes  =  tmpVec;  tmpVec  =  new  VectorialPointValuePair();	  oldRes=    residuals;    tmpVec    =    new    VectorialPointValuePair();    	non-compiled	[CE]  no  suitable  constructor  found  for  VectorialPointValuePair()	81	None	replace
265	[BUG]  [BUGGY]  Preconditions.checkState(remainders!=  oldRes);  [CE]  cannot  find  symbol  remainders  [FE]                    AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  Preconditions.checkState(remainders!=  oldRes);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	Preconditions.checkState(remainders!=  oldRes);	  Preconditions.checkState(oldRes!=    residuals);    	non-compiled	[CE]  cannot  find  symbol  remainders	48	None	replace
266	[BUG]  [BUGGY]  ((  VectorialPointValuePair)remainder).add(tmpVec);  [CE]  cannot  find  symbol  remainder  [FE]                  AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  ((  VectorialPointValuePair)remainder).add(tmpVec);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	((  VectorialPointValuePair)remainder).add(tmpVec);	  ((    VectorialPointValuePair)res).add(tmpVec);    	non-compiled	[CE]  cannot  find  symbol  remainder	58	None	replace
267	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(period,  preRed);  [CE]  cannot  find  symbol  period  [FE]                      AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  new  VectorialPointValuePair(period,  preRed);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  VectorialPointValuePair(period,  preRed);	  tmpVec    =    new    VectorialPointValuePair(point,    preRed);    	non-compiled	[CE]  cannot  find  symbol  period	71	None	replace
268	[BUG]  [BUGGY]  tmpVec  =  new  double[remaining.length];  [CE]  cannot  find  symbol  remaining  [FE]                      AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  new  double[remaining.length];  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  double[remaining.length];	  tmpVec    =    new    double[resitive.length];    	non-compiled	[CE]  cannot  find  symbol  remaining	24	None	replace
269	[BUG]  [BUGGY]  oldRes=  previousCost;  tmpVec  =  new  VectorialPointValuePair(remainders);  [CE]  incompatible  types  [FE]        AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  oldRes=  previousCost;  tmpVec  =  new  VectorialPointValuePair(remainders);  [BUGGY]      }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	oldRes=  previousCost;  tmpVec  =  new  VectorialPointValuePair(remainders);	  oldRes=    residuals;    tmpVec    =    new    VectorialPointValuePair(previousCost);    	non-compiled	[CE]  incompatible  types	79	None	replace
270	[BUG]  [BUGGY]  oldRes  =  previousCost;  tmpVec  =  new  VectorialPointValuePair(remainder);  [CE]  incompatible  types  [FE]          AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  oldRes  =  previousCost;  tmpVec  =  new  VectorialPointValuePair(remainder);  [BUGGY]      }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	oldRes  =  previousCost;  tmpVec  =  new  VectorialPointValuePair(remainder);	  oldRes=    residuals;    tmpVec    =    new    VectorialPointValuePair(previousCost);    	non-compiled	[CE]  incompatible  types	79	None	replace
271	[BUG]  [BUGGY]  oldRes=  new  RelativeRelativeTolerance(relativeTolerance);  [CE]  cannot  find  symbol  [FE]    AssertionFailedError    [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  oldRes=  new  RelativeRelativeTolerance(relativeTolerance);  [BUGGY]      }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	oldRes=  new  RelativeRelativeTolerance(relativeTolerance);	  oldRes=    residuals;    oldRes=    residuals;    	non-compiled	[CE]  cannot  find  symbol	26	None	replace
272	[BUG]  [BUGGY]  oldRes=    residuals;    tmpVec=  residuals;  tmpVec  =  new  VectorialPointValuePair();  [CE]  no  suitable  constructor  found  for  VectorialPointValuePair()  [FE]    AssertionFailedError    [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  oldRes=    residuals;    tmpVec=  residuals;  tmpVec  =  new  VectorialPointValuePair();  [BUGGY]      }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	oldRes=        residuals;        tmpVec=    residuals;    tmpVec  =  new  VectorialPointValuePair();	  	non-compiled	[CE]  no  suitable  constructor  found  for  VectorialPointValuePair()	27	None	add
273	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  oldRes=    residuals;    oldRes=  residuals;  oldRes=  tmpVec;  oldRes=  residuals;  [BUGGY]      }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	add	oldRes=        residuals;        oldRes=    residuals;    oldRes=  tmpVec;  oldRes=  residuals;	  	compilable	  [FE]  AssertionFailedError  	25	2	add
274	[BUG]  [BUGGY]  oldRes=    residuals;    oldRes=  residuals;  oldRes=  tmpVec;  oldRes=  residuals;  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  oldRes=    residuals;    oldRes=  residuals;  oldRes=  tmpVec;  oldRes=  residuals;  [BUGGY]      }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	oldRes=        residuals;        oldRes=    residuals;    oldRes=  tmpVec;  oldRes=  residuals;	  	compilable	  [FE]  AssertionFailedError  	25	2	add
275	[BUG]  [BUGGY]  ((  VectorialPointValuePair)previousCost).setVec(null);  [CE]  inconvertible  types  [FE]                  AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  ((  VectorialPointValuePair)previousCost).setVec(null);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	((  VectorialPointValuePair)previousCost).setVec(null);	  ((    VectorialPointValuePair)previousCost).setVec(remainings);    	non-compiled	[CE]  inconvertible  types	50	None	replace
276	[BUG]  [BUGGY]  ((  VectorialPointValuePair)previousCost).setVec(vec);  [CE]  cannot  find  symbol  vec  [FE]                    AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  ((  VectorialPointValuePair)previousCost).setVec(vec);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	((  VectorialPointValuePair)previousCost).setVec(vec);	  ((    VectorialPointValuePair)previousCost).setVec(remainings);    	non-compiled	[CE]  cannot  find  symbol  vec	50	None	replace
277	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(pj,  cost,  previousCost);  [CE]  cannot  find  symbol  pj  [FE]              AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  new  VectorialPointValuePair(pj,  cost,  previousCost);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  VectorialPointValuePair(pj,  cost,  previousCost);	  tmpVec    =    new    VectorialPointValuePair(pj,    previousCost,    cost);    	non-compiled	[CE]  cannot  find  symbol  pj	60	None	replace
278	[BUG]  [BUGGY]  Preconditions.checkState(remainders  ==  oldRes);  [CE]  cannot  find  symbol  remainders  [FE]              AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  Preconditions.checkState(remainders  ==  oldRes);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	Preconditions.checkState(remainders  ==  oldRes);	  Preconditions.checkState(oldRes    ==    residuals);    	non-compiled	[CE]  cannot  find  symbol  remainders	67	None	replace
279	[BUG]  [BUGGY]  tmpVec  =  oldX[oldRes];  [CE]  incompatible  types  [FE]            AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  oldX[oldRes];  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  oldX[oldRes];	  tmpVec    =    permutation[oldRes];    	non-compiled	[CE]  incompatible  types	73	None	replace
280	[BUG]  [BUGGY]  Preconditions.checkNotNull(oldX,  tmpVec);  [CE]  cannot  find  symbol  Preconditions  [FE]                AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  Preconditions.checkNotNull(oldX,  tmpVec);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	Preconditions.checkNotNull(oldX,  tmpVec);	  Preconditions.checkNotNull(remainings,    tmpVec);    	non-compiled	[CE]  cannot  find  symbol  Preconditions	3	None	replace
281	[BUG]  [BUGGY]  tmpVec  =  oldX;  ((  VectorialPointValuePair)point[pj]).setValue(value);  tmpVec  =  oldX;  [CE]  cannot  find  symbol  value  [FE]    AssertionFailedError    [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  oldX;  ((  VectorialPointValuePair)point[pj]).setValue(value);  tmpVec  =  oldX;  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec    =    oldX;    ((  VectorialPointValuePair)point[pj]).setValue(value);  tmpVec  =  oldX;	  	non-compiled	[CE]  cannot  find  symbol  value	41	None	add
282	[BUG]  [BUGGY]  Preconditions.checkState(remainders  >=  oldRes);  [CE]  cannot  find  symbol  remainders  [FE]                  AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  Preconditions.checkState(remainders  >=  oldRes);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	Preconditions.checkState(remainders  >=  oldRes);	  Preconditions.checkState(oldRes    >=    residuals);    	non-compiled	[CE]  cannot  find  symbol  remainders	75	None	replace
283	[BUG]  [BUGGY]  oldRes  =  new  RelativeTolerance(relativeTolerance,  cost);  [CE]  cannot  find  symbol  [FE]        AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  oldRes  =  new  RelativeTolerance(relativeTolerance,  cost);  [BUGGY]      }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	oldRes  =  new  RelativeTolerance(relativeTolerance,  cost);	  oldRes    =    new    RelativeTolerance(relativeTolerance);    	non-compiled	[CE]  cannot  find  symbol	85	None	replace
284	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(lastX,  lastCost,  point);  [CE]  cannot  find  symbol  lastX  [FE]                        AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  new  VectorialPointValuePair(lastX,  lastCost,  point);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  VectorialPointValuePair(lastX,  lastCost,  point);	  tmpVec    =    new    VectorialPointValuePair(lastX,    previousCost,    point);    	non-compiled	[CE]  cannot  find  symbol  lastX	72	None	replace
285	[BUG]  [BUGGY]  Preconditions.checkState(oldRes  ==  result);  [CE]  cannot  find  symbol  result  [FE]                    AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  Preconditions.checkState(oldRes  ==  result);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	Preconditions.checkState(oldRes  ==  result);	  Preconditions.checkState(results    ==    oldRes);    	non-compiled	[CE]  cannot  find  symbol  result	13	None	replace
286	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(lastX,  previousCost,  prered);  [CE]  cannot  find  symbol  lastX  [FE]                AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  new  VectorialPointValuePair(lastX,  previousCost,  prered);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  VectorialPointValuePair(lastX,  previousCost,  prered);	  tmpVec    =    new    VectorialPointValuePair(previousCost,    previousCost);    	non-compiled	[CE]  cannot  find  symbol  lastX	77	None	replace
287	[BUG]  [BUGGY]  Preconditions.checkState(remainders  >=  0);  [CE]  cannot  find  symbol  remainders  [FE]                    AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  Preconditions.checkState(remainders  >=  0);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	Preconditions.checkState(remainders  >=  0);	  Preconditions.checkState(remainders    ==    0);    	non-compiled	[CE]  cannot  find  symbol  remainders	78	None	replace
288	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(lastX,  previousCost,  preRed,  cost);  [CE]  cannot  find  symbol  lastX  [FE]            AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  new  VectorialPointValuePair(lastX,  previousCost,  preRed,  cost);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  VectorialPointValuePair(lastX,  previousCost,  preRed,  cost);	  tmpVec    =    new    VectorialPointValuePair(previousCost,    preRed,    cost);    	non-compiled	[CE]  cannot  find  symbol  lastX	14	None	replace
289	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(currentCost,  preRed,  cost);  [CE]  cannot  find  symbol  currentCost  [FE]              AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  new  VectorialPointValuePair(currentCost,  preRed,  cost);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  VectorialPointValuePair(currentCost,  preRed,  cost);	  tmpVec    =    new    VectorialPointValuePair(previousCost,    preRed,    cost);    	non-compiled	[CE]  cannot  find  symbol  currentCost	14	None	replace
290	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(lastX,  lastIteration);  [CE]  cannot  find  symbol  lastX  [FE]                AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  new  VectorialPointValuePair(lastX,  lastIteration);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  VectorialPointValuePair(lastX,  lastIteration);	  tmpVec    =    new    VectorialPointValuePair(lastX,    previousCost);    	non-compiled	[CE]  cannot  find  symbol  lastX	54	None	replace
291	[BUG]  [BUGGY]  Preconditions.checkState(remainings  ==  tmpVec,  residuals);  [CE]  cannot  find  symbol  remainings  [FE]              AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  Preconditions.checkState(remainings  ==  tmpVec,  residuals);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	Preconditions.checkState(remainings  ==  tmpVec,  residuals);	  Preconditions.checkState(remainings    ==    tmpVec);    	non-compiled	[CE]  cannot  find  symbol  remainings	10	None	replace
292	[BUG]  [BUGGY]  oldRes=  oldRes;  tmpVec  =  oldX[pj];  [CE]  cannot  find  symbol  pj  [FE]    AssertionFailedError    [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  oldRes=  oldRes;  tmpVec  =  oldX[pj];  [BUGGY]      }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	oldRes=    oldRes;    tmpVec  =  oldX[pj];	  	non-compiled	[CE]  cannot  find  symbol  pj	37	None	add
293	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(previousCost,  oldX,  oldRes,  cost);  [CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double,double[],double[],double)  [FE]              AssertionFailedError      [CONTEXT]        }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;      [BUGGY]  tmpVec  =  new  VectorialPointValuePair(previousCost,  oldX,  oldRes,  cost);  [BUGGY]      oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  VectorialPointValuePair(previousCost,  oldX,  oldRes,  cost);	  tmpVec    =    new    VectorialPointValuePair(previousCost,    oldX,    cost);    	non-compiled	[CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double,double[],double[],double)	15	None	replace
