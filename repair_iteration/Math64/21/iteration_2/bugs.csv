bugid	buggy	buggy_class	suspiciousness	buggy_line	endbuggycode	original_failing_test_number	action	patch	original_buggy	execution_result	diagnosis	previous_bug_id	new_failing_test_number	this_action
1	[BUG]  [BUGGY]  Preconditions.checkNotNull(results);  [CE]  cannot  find  symbol  results  [FE]        AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;    [BUGGY]  Preconditions.checkNotNull(results);  [BUGGY]    oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	Preconditions.checkNotNull(results);	      Preconditions.checkNotNull(remainings);    	non-compiled	[CE]  cannot  find  symbol  results	8	None	replace
2	[BUG]  [BUGGY]  Preconditions.checkNotNull(tmpVec);  [CE]  cannot  find  symbol  Preconditions  [FE]          AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;    [BUGGY]  Preconditions.checkNotNull(tmpVec);  [BUGGY]    oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	Preconditions.checkNotNull(tmpVec);	      Preconditions.checkNotNull(remainings);    	non-compiled	[CE]  cannot  find  symbol  Preconditions	8	None	replace
3	[BUG]  [BUGGY]  Preconditions.checkNotNull(remainings,  tmpVec);  [CE]  cannot  find  symbol  remainings  [FE]            AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;    [BUGGY]  Preconditions.checkNotNull(remainings,  tmpVec);  [BUGGY]    oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	Preconditions.checkNotNull(remainings,  tmpVec);	      Preconditions.checkNotNull(remainings);    	non-compiled	[CE]  cannot  find  symbol  remainings	8	None	replace
4	[BUG]  [BUGGY]  Preconditions.checkState(results  ==  0);  [CE]  cannot  find  symbol  results  [FE]                AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;    [BUGGY]  Preconditions.checkState(results  ==  0);  [BUGGY]    oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	Preconditions.checkState(results  ==  0);	      Preconditions.checkState(remainings    ==    0);    	non-compiled	[CE]  cannot  find  symbol  results	12	None	replace
5	[BUG]  [BUGGY]  Preconditions.checkState(remainings!=  0);  [CE]  cannot  find  symbol  remainings  [FE]                  AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;    [BUGGY]  Preconditions.checkState(remainings!=  0);  [BUGGY]    oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	Preconditions.checkState(remainings!=  0);	      Preconditions.checkState(remainings    ==    0);    	non-compiled	[CE]  cannot  find  symbol  remainings	12	None	replace
6	[BUG]  [BUGGY]  Preconditions.checkState(tmpVec  ==  0);  [CE]  incomparable  types:  double[]  and  int  [FE]                    AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;    [BUGGY]  Preconditions.checkState(tmpVec  ==  0);  [BUGGY]    oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	Preconditions.checkState(tmpVec  ==  0);	      Preconditions.checkState(remainings    ==    0);    	non-compiled	[CE]  incomparable  types:  double[]  and  int	12	None	replace
7	[BUG]  [BUGGY]  tmpVec  =  preRed  +  1;  [CE]  incompatible  types  [FE]                AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;    [BUGGY]  tmpVec  =  preRed  +  1;  [BUGGY]    oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  preRed  +  1;	      tmpVec    =    preRed;    	non-compiled	[CE]  incompatible  types	5	None	replace
8	[BUG]  [BUGGY]  tmpVec  =  previousCost;  [CE]  incompatible  types  [FE]                  AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;    [BUGGY]  tmpVec  =  previousCost;  [BUGGY]    oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  previousCost;	      tmpVec    =    preRed;    	non-compiled	[CE]  incompatible  types	5	None	replace
9	[BUG]  [BUGGY]  tmpVec  =  preRed  +  2;  [CE]  incompatible  types  [FE]                    AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;    [BUGGY]  tmpVec  =  preRed  +  2;  [BUGGY]    oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  preRed  +  2;	      tmpVec    =    preRed;    	non-compiled	[CE]  incompatible  types	5	None	replace
10	[BUG]  [BUGGY]  Preconditions.checkState(remainings  ==  tmpVec);  [CE]  cannot  find  symbol  remainings  [FE]          AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;    [BUGGY]  Preconditions.checkState(remainings  ==  tmpVec);  [BUGGY]    oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	Preconditions.checkState(remainings  ==  tmpVec);	      Preconditions.checkState(remainings    ==    oldRes);    	non-compiled	[CE]  cannot  find  symbol  remainings	9	None	replace
11	[BUG]  [BUGGY]  Preconditions.checkState(remainings!=  tmpVec);  [CE]  cannot  find  symbol  remainings  [FE]            AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;    [BUGGY]  Preconditions.checkState(remainings!=  tmpVec);  [BUGGY]    oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	Preconditions.checkState(remainings!=  tmpVec);	      Preconditions.checkState(remainings    ==    oldRes);    	non-compiled	[CE]  cannot  find  symbol  remainings	9	None	replace
12	[BUG]  [BUGGY]  Preconditions.checkState(remainings  ==  oldX);  [CE]  cannot  find  symbol  remainings  [FE]              AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;    [BUGGY]  Preconditions.checkState(remainings  ==  oldX);  [BUGGY]    oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	Preconditions.checkState(remainings  ==  oldX);	      Preconditions.checkState(remainings    ==    oldRes);    	non-compiled	[CE]  cannot  find  symbol  remainings	9	None	replace
13	[BUG]  [BUGGY]  Preconditions.checkState(results  ==  oldRes);  [CE]  cannot  find  symbol  results  [FE]                AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;    [BUGGY]  Preconditions.checkState(results  ==  oldRes);  [BUGGY]    oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	Preconditions.checkState(results  ==  oldRes);	      Preconditions.checkState(remainings    ==    oldRes);    	non-compiled	[CE]  cannot  find  symbol  results	9	None	replace
14	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(previousCost,  preRed,  cost);  [CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double,double,double)  [FE]        AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;    [BUGGY]  tmpVec  =  new  VectorialPointValuePair(previousCost,  preRed,  cost);  [BUGGY]    oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  VectorialPointValuePair(previousCost,  preRed,  cost);	      tmpVec    =    new    VectorialPointValuePair(previousCost,    cost);    	non-compiled	[CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double,double,double)	14	None	replace
15	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(previousCost,  oldX,  cost);  [CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double,double[],double)  [FE]          AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;    [BUGGY]  tmpVec  =  new  VectorialPointValuePair(previousCost,  oldX,  cost);  [BUGGY]    oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  VectorialPointValuePair(previousCost,  oldX,  cost);	      tmpVec    =    new    VectorialPointValuePair(previousCost,    cost);    	non-compiled	[CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double,double[],double)	14	None	replace
16	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(currentCost,  cost);  [CE]  cannot  find  symbol  currentCost  [FE]            AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;    [BUGGY]  tmpVec  =  new  VectorialPointValuePair(currentCost,  cost);  [BUGGY]    oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  VectorialPointValuePair(currentCost,  cost);	      tmpVec    =    new    VectorialPointValuePair(previousCost,    cost);    	non-compiled	[CE]  cannot  find  symbol  currentCost	14	None	replace
17	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(previousCost,  previousCost,  cost);  [CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double,double,double)  [FE]              AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;    [BUGGY]  tmpVec  =  new  VectorialPointValuePair(previousCost,  previousCost,  cost);  [BUGGY]    oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  VectorialPointValuePair(previousCost,  previousCost,  cost);	      tmpVec    =    new    VectorialPointValuePair(previousCost,    cost);    	non-compiled	[CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double,double,double)	14	None	replace
18	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(previousCost,  point,  cost);  [CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double,double[],double)  [FE]                AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;    [BUGGY]  tmpVec  =  new  VectorialPointValuePair(previousCost,  point,  cost);  [BUGGY]    oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  VectorialPointValuePair(previousCost,  point,  cost);	      tmpVec    =    new    VectorialPointValuePair(previousCost,    point);    	non-compiled	[CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double,double[],double)	18	None	replace
19	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(previousCost,  oldX,  point);  [CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double,double[],double[])  [FE]                  AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;    [BUGGY]  tmpVec  =  new  VectorialPointValuePair(previousCost,  oldX,  point);  [BUGGY]    oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  VectorialPointValuePair(previousCost,  oldX,  point);	      tmpVec    =    new    VectorialPointValuePair(previousCost,    point);    	non-compiled	[CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double,double[],double[])	18	None	replace
20	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(previousCost,  preRed,  point);  [CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double,double,double[])  [FE]                    AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;    [BUGGY]  tmpVec  =  new  VectorialPointValuePair(previousCost,  preRed,  point);  [BUGGY]    oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  VectorialPointValuePair(previousCost,  preRed,  point);	      tmpVec    =    new    VectorialPointValuePair(previousCost,    point);    	non-compiled	[CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double,double,double[])	18	None	replace
21	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(previousCost,  point,  preRed);  [CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double,double[],double)  [FE]                      AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;    [BUGGY]  tmpVec  =  new  VectorialPointValuePair(previousCost,  point,  preRed);  [BUGGY]    oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  VectorialPointValuePair(previousCost,  point,  preRed);	      tmpVec    =    new    VectorialPointValuePair(previousCost,    point);    	non-compiled	[CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double,double[],double)	18	None	replace
22	[BUG]  [BUGGY]  tmpVec  =  new  double[results.length];  [CE]  cannot  find  symbol  results  [FE]              AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;    [BUGGY]  tmpVec  =  new  double[results.length];  [BUGGY]    oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  double[results.length];	      tmpVec    =    new    double[remainings.length];    	non-compiled	[CE]  cannot  find  symbol  results	4	None	replace
23	[BUG]  [BUGGY]  tmpVec  =  new  double[resistance.length];  [CE]  cannot  find  symbol  resistance  [FE]                AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;    [BUGGY]  tmpVec  =  new  double[resistance.length];  [BUGGY]    oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  double[resistance.length];	      tmpVec    =    new    double[remainings.length];    	non-compiled	[CE]  cannot  find  symbol  resistance	4	None	replace
24	[BUG]  [BUGGY]  tmpVec  =  new  double[resitive.length];  [CE]  cannot  find  symbol  resitive  [FE]                  AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;    [BUGGY]  tmpVec  =  new  double[resitive.length];  [BUGGY]    oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  double[resitive.length];	      tmpVec    =    new    double[remainings.length];    	non-compiled	[CE]  cannot  find  symbol  resitive	4	None	replace
25	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;    [BUGGY]  oldRes=  residuals;  oldRes=  residuals;  [BUGGY]    }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	add	oldRes=    residuals;    oldRes=  residuals;	  	compilable	  [FE]  AssertionFailedError  	6	2	add
26	[BUG]  [BUGGY]  oldRes=  residuals;  oldRes=  residuals;  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;    [BUGGY]  oldRes=  residuals;  oldRes=  residuals;  [BUGGY]    }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	oldRes=    residuals;    oldRes=  residuals;	  	compilable	  [FE]  AssertionFailedError  	6	2	add
27	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;    [BUGGY]  oldRes=  residuals;  tmpVec=  residuals;  [BUGGY]    }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	add	oldRes=    residuals;    tmpVec=  residuals;	  	compilable	  [FE]  AssertionFailedError  	6	10	add
28	[BUG]  [BUGGY]  oldRes=  residuals;  tmpVec=  residuals;  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;    [BUGGY]  oldRes=  residuals;  tmpVec=  residuals;  [BUGGY]    }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	oldRes=    residuals;    tmpVec=  residuals;	  	compilable	  [FE]  AssertionFailedError  	6	10	add
29	[BUG]  [BUGGY]  oldRes=  residuals;  tmpVec=  permutation[j];  [CE]  cannot  find  symbol  j  [FE]        AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;    [BUGGY]  oldRes=  residuals;  tmpVec=  permutation[j];  [BUGGY]    }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	oldRes=    residuals;    tmpVec=  permutation[j];	  	non-compiled	[CE]  cannot  find  symbol  j	6	None	add
30	[BUG]  [BUGGY]  oldRes=  residuals;  tmpVec=  preRed;  [CE]  incompatible  types  [FE]          AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;    [BUGGY]  oldRes=  residuals;  tmpVec=  preRed;  [BUGGY]    }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	oldRes=    residuals;    tmpVec=  preRed;	  	non-compiled	[CE]  incompatible  types	6	None	add
31	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(remainings);  [CE]  cannot  find  symbol  remainings  [FE]            AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;    [BUGGY]  tmpVec  =  new  VectorialPointValuePair(remainings);  [BUGGY]    oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  VectorialPointValuePair(remainings);	      tmpVec    =    new    VectorialPointValuePair();    	non-compiled	[CE]  cannot  find  symbol  remainings	16	None	replace
32	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(pj);  [CE]  cannot  find  symbol  pj  [FE]              AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;    [BUGGY]  tmpVec  =  new  VectorialPointValuePair(pj);  [BUGGY]    oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  VectorialPointValuePair(pj);	      tmpVec    =    new    VectorialPointValuePair();    	non-compiled	[CE]  cannot  find  symbol  pj	16	None	replace
33	[BUG]  [BUGGY]  Preconditions.checkState(remainings  >=  tmpVec);  [CE]  cannot  find  symbol  remainings  [FE]              AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;    [BUGGY]  Preconditions.checkState(remainings  >=  tmpVec);  [BUGGY]    oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	Preconditions.checkState(remainings  >=  tmpVec);	      Preconditions.checkState(remainings    >=    oldRes);    	non-compiled	[CE]  cannot  find  symbol  remainings	11	None	replace
34	[BUG]  [BUGGY]  Preconditions.checkState(remainings  >  oldRes);  [CE]  cannot  find  symbol  remainings  [FE]                AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;    [BUGGY]  Preconditions.checkState(remainings  >  oldRes);  [BUGGY]    oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	Preconditions.checkState(remainings  >  oldRes);	      Preconditions.checkState(remainings    >=    oldRes);    	non-compiled	[CE]  cannot  find  symbol  remainings	11	None	replace
35	[BUG]  [BUGGY]  Preconditions.checkState(remainings  >=  oldX);  [CE]  cannot  find  symbol  remainings  [FE]                  AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;    [BUGGY]  Preconditions.checkState(remainings  >=  oldX);  [BUGGY]    oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	Preconditions.checkState(remainings  >=  oldX);	      Preconditions.checkState(remainings    >=    oldRes);    	non-compiled	[CE]  cannot  find  symbol  remainings	11	None	replace
36	[BUG]  [BUGGY]  oldRes=  tmpVec  +  2;  [CE]  bad  operand  types  for  binary  operator  '+'  [FE]        AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;    [BUGGY]  oldRes=  tmpVec  +  2;  [BUGGY]    }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	oldRes=  tmpVec  +  2;	  oldRes=    tmpVec    +    1;    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '+'	13	None	replace
37	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;    [BUGGY]  oldRes=  oldRes;  [BUGGY]    }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	add	oldRes=  oldRes;	  oldRes=    residuals;    	compilable	  [FE]  AssertionFailedError  	7	10	replace
38	[BUG]  [BUGGY]  oldRes=  oldRes;  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;    [BUGGY]  oldRes=  oldRes;  [BUGGY]    }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	oldRes=  oldRes;	  oldRes=    residuals;    	compilable	  [FE]  AssertionFailedError  	7	10	replace
39	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]              AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;    [BUGGY]  tmpVec  =  residuals;  [BUGGY]    oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	add	tmpVec  =  residuals;	      tmpVec    =    cost;    	compilable	  [FE]  AssertionFailedError  	17	10	replace
40	[BUG]  [BUGGY]  tmpVec  =  residuals;  [FE]  AssertionFailedError  [FE]              AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;    [BUGGY]  tmpVec  =  residuals;  [BUGGY]    oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  residuals;	      tmpVec    =    cost;    	compilable	  [FE]  AssertionFailedError  	17	10	replace
41	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]                AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;    [BUGGY]  tmpVec  =  oldX;  [BUGGY]    oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	add	tmpVec  =  oldX;	      tmpVec    =    cost;    	compilable	  [FE]  AssertionFailedError  	17	10	replace
42	[BUG]  [BUGGY]  tmpVec  =  oldX;  [FE]  AssertionFailedError  [FE]                AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;    [BUGGY]  tmpVec  =  oldX;  [BUGGY]    oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  oldX;	      tmpVec    =    cost;    	compilable	  [FE]  AssertionFailedError  	17	10	replace
43	[BUG]  [BUGGY]  tmpVec  =  permutation[pj];  [CE]  cannot  find  symbol  pj  [FE]        AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;    [BUGGY]  tmpVec  =  permutation[pj];  [BUGGY]    oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  permutation[pj];	      tmpVec    =    permutation[j];    	non-compiled	[CE]  cannot  find  symbol  pj	1	None	replace
44	[BUG]  [BUGGY]  tmpVec  =  permutation[0];  [CE]  incompatible  types  [FE]          AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;    [BUGGY]  tmpVec  =  permutation[0];  [BUGGY]    oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  permutation[0];	      tmpVec    =    permutation[j];    	non-compiled	[CE]  incompatible  types	1	None	replace
45	[BUG]  [BUGGY]  tmpVec  =  permutation[j]  +  1;  [CE]  cannot  find  symbol  j  [FE]            AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;    [BUGGY]  tmpVec  =  permutation[j]  +  1;  [BUGGY]    oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  permutation[j]  +  1;	      tmpVec    =    permutation[j];    	non-compiled	[CE]  cannot  find  symbol  j	1	None	replace
46	[BUG]  [BUGGY]  Preconditions.checkState(remainings!=  oldX);  [CE]  cannot  find  symbol  remainings  [FE]            AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;    [BUGGY]  Preconditions.checkState(remainings!=  oldX);  [BUGGY]    oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	Preconditions.checkState(remainings!=  oldX);	      Preconditions.checkState(remainings!=    oldRes);    	non-compiled	[CE]  cannot  find  symbol  remainings	10	None	replace
47	[BUG]  [BUGGY]  Preconditions.checkState(results!=  oldRes);  [CE]  cannot  find  symbol  results  [FE]              AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;    [BUGGY]  Preconditions.checkState(results!=  oldRes);  [BUGGY]    oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	Preconditions.checkState(results!=  oldRes);	      Preconditions.checkState(remainings!=    oldRes);    	non-compiled	[CE]  cannot  find  symbol  results	10	None	replace
48	[BUG]  [BUGGY]  Preconditions.checkState(oldRes!=  residuals);  [CE]  cannot  find  symbol  Preconditions  [FE]                AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;    [BUGGY]  Preconditions.checkState(oldRes!=  residuals);  [BUGGY]    oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	Preconditions.checkState(oldRes!=  residuals);	      Preconditions.checkState(remainings!=    oldRes);    	non-compiled	[CE]  cannot  find  symbol  Preconditions	10	None	replace
49	[BUG]  [BUGGY]  ((  VectorialPointValuePair)previousCost).setVec(tmpVec,  residuals);  [CE]  inconvertible  types  [FE]            AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;    [BUGGY]  ((  VectorialPointValuePair)previousCost).setVec(tmpVec,  residuals);  [BUGGY]    oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	((  VectorialPointValuePair)previousCost).setVec(tmpVec,  residuals);	      ((    VectorialPointValuePair)previousCost).setVec(tmpVec);    	non-compiled	[CE]  inconvertible  types	3	None	replace
50	[BUG]  [BUGGY]  ((  VectorialPointValuePair)previousCost).setVec(remainings);  [CE]  cannot  find  symbol  remainings  [FE]              AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;    [BUGGY]  ((  VectorialPointValuePair)previousCost).setVec(remainings);  [BUGGY]    oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	((  VectorialPointValuePair)previousCost).setVec(remainings);	      ((    VectorialPointValuePair)previousCost).setVec(tmpVec);    	non-compiled	[CE]  cannot  find  symbol  remainings	3	None	replace
51	[BUG]  [BUGGY]  ((  VectorialPointValuePair)previousCost).setVec(new  VectorialPointValuePair(tmpVec,  residuals));  [CE]  inconvertible  types  [FE]                AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;    [BUGGY]  ((  VectorialPointValuePair)previousCost).setVec(new  VectorialPointValuePair(tmpVec,  residuals));  [BUGGY]    oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	((  VectorialPointValuePair)previousCost).setVec(new  VectorialPointValuePair(tmpVec,  residuals));	      ((    VectorialPointValuePair)previousCost).setVec(tmpVec);    	non-compiled	[CE]  inconvertible  types	3	None	replace
52	[BUG]  [BUGGY]  ((  VectorialPointValuePair)previousCost).setVec(oldX,  tmpVec);  [CE]  inconvertible  types  [FE]                  AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;    [BUGGY]  ((  VectorialPointValuePair)previousCost).setVec(oldX,  tmpVec);  [BUGGY]    oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	((  VectorialPointValuePair)previousCost).setVec(oldX,  tmpVec);	      ((    VectorialPointValuePair)previousCost).setVec(tmpVec);    	non-compiled	[CE]  inconvertible  types	3	None	replace
53	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(currentCost);  [CE]  cannot  find  symbol  currentCost  [FE]          AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;    [BUGGY]  tmpVec  =  new  VectorialPointValuePair(currentCost);  [BUGGY]    oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  VectorialPointValuePair(currentCost);	      tmpVec    =    new    VectorialPointValuePair(previousCost);    	non-compiled	[CE]  cannot  find  symbol  currentCost	15	None	replace
54	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(lastX,  previousCost);  [CE]  cannot  find  symbol  lastX  [FE]            AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;    [BUGGY]  tmpVec  =  new  VectorialPointValuePair(lastX,  previousCost);  [BUGGY]    oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  VectorialPointValuePair(lastX,  previousCost);	      tmpVec    =    new    VectorialPointValuePair(previousCost);    	non-compiled	[CE]  cannot  find  symbol  lastX	15	None	replace
55	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(pj,  previousCost);  [CE]  cannot  find  symbol  pj  [FE]              AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;    [BUGGY]  tmpVec  =  new  VectorialPointValuePair(pj,  previousCost);  [BUGGY]    oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  VectorialPointValuePair(pj,  previousCost);	      tmpVec    =    new    VectorialPointValuePair(previousCost);    	non-compiled	[CE]  cannot  find  symbol  pj	15	None	replace
56	[BUG]  [BUGGY]  ((  VectorialPointValuePair)remainings).add(tmpVec,  cost);  [CE]  cannot  find  symbol  remainings  [FE]          AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;    [BUGGY]  ((  VectorialPointValuePair)remainings).add(tmpVec,  cost);  [BUGGY]    oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	((  VectorialPointValuePair)remainings).add(tmpVec,  cost);	      ((    VectorialPointValuePair)remainings).add(tmpVec);    	non-compiled	[CE]  cannot  find  symbol  remainings	2	None	replace
57	[BUG]  [BUGGY]  ((  VectorialPointValuePair)res2).add(tmpVec);  [CE]  cannot  find  symbol  res2  [FE]            AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;    [BUGGY]  ((  VectorialPointValuePair)res2).add(tmpVec);  [BUGGY]    oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	((  VectorialPointValuePair)res2).add(tmpVec);	      ((    VectorialPointValuePair)remainings).add(tmpVec);    	non-compiled	[CE]  cannot  find  symbol  res2	2	None	replace
58	[BUG]  [BUGGY]  ((  VectorialPointValuePair)res).add(tmpVec);  [CE]  cannot  find  symbol  res  [FE]              AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;    [BUGGY]  ((  VectorialPointValuePair)res).add(tmpVec);  [BUGGY]    oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	((  VectorialPointValuePair)res).add(tmpVec);	      ((    VectorialPointValuePair)remainings).add(tmpVec);    	non-compiled	[CE]  cannot  find  symbol  res	2	None	replace
59	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(lastX,  previousCost,  cost);  [CE]  cannot  find  symbol  lastX  [FE]        AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;    [BUGGY]  tmpVec  =  new  VectorialPointValuePair(lastX,  previousCost,  cost);  [BUGGY]    oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  VectorialPointValuePair(lastX,  previousCost,  cost);	      tmpVec    =    new    VectorialPointValuePair(previousCost,    cost);    	non-compiled	[CE]  cannot  find  symbol  lastX	14	None	replace
60	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(pj,  previousCost,  cost);  [CE]  cannot  find  symbol  pj  [FE]          AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;    [BUGGY]  tmpVec  =  new  VectorialPointValuePair(pj,  previousCost,  cost);  [BUGGY]    oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  VectorialPointValuePair(pj,  previousCost,  cost);	      tmpVec    =    new    VectorialPointValuePair(previousCost,    cost);    	non-compiled	[CE]  cannot  find  symbol  pj	14	None	replace
61	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(last,  previousCost,  cost);  [CE]  cannot  find  symbol  last  [FE]            AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;    [BUGGY]  tmpVec  =  new  VectorialPointValuePair(last,  previousCost,  cost);  [BUGGY]    oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  VectorialPointValuePair(last,  previousCost,  cost);	      tmpVec    =    new    VectorialPointValuePair(previousCost,    cost);    	non-compiled	[CE]  cannot  find  symbol  last	14	None	replace
62	[BUG]  [BUGGY]  tmpVec  =  new  double[res.length];  [CE]  cannot  find  symbol  res  [FE]              AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;    [BUGGY]  tmpVec  =  new  double[res.length];  [BUGGY]    oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  double[res.length];	      tmpVec    =    new    double[remainings.length];    	non-compiled	[CE]  cannot  find  symbol  res	4	None	replace
63	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]                AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;    [BUGGY]  tmpVec  =  new  double[oldRes.length];  [BUGGY]    oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	add	tmpVec  =  new  double[oldRes.length];	      tmpVec    =    new    double[remainings.length];    	compilable	  [FE]  AssertionFailedError  	4	10	replace
64	[BUG]  [BUGGY]  tmpVec  =  new  double[oldRes.length];  [FE]  AssertionFailedError  [FE]                AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;    [BUGGY]  tmpVec  =  new  double[oldRes.length];  [BUGGY]    oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  double[oldRes.length];	      tmpVec    =    new    double[remainings.length];    	compilable	  [FE]  AssertionFailedError  	4	10	replace
65	[BUG]  [BUGGY]  ((  VectorialPointValuePair)remainings).add(tmpVec,  pj);  [CE]  cannot  find  symbol  pj  [FE]          AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;    [BUGGY]  ((  VectorialPointValuePair)remainings).add(tmpVec,  pj);  [BUGGY]    oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	((  VectorialPointValuePair)remainings).add(tmpVec,  pj);	      ((    VectorialPointValuePair)remainings).add(tmpVec);    	non-compiled	[CE]  cannot  find  symbol  pj	2	None	replace
66	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(oldX);  [CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double[])  [FE]            AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;    [BUGGY]  tmpVec  =  new  VectorialPointValuePair(oldX);  [BUGGY]    oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  VectorialPointValuePair(oldX);	      tmpVec    =    new    VectorialPointValuePair();    	non-compiled	[CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double[])	16	None	replace
67	[BUG]  [BUGGY]  Preconditions.checkState(oldRes  ==  residuals);  [CE]  cannot  find  symbol  Preconditions  [FE]          AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;    [BUGGY]  Preconditions.checkState(oldRes  ==  residuals);  [BUGGY]    oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	Preconditions.checkState(oldRes  ==  residuals);	      Preconditions.checkState(remainings    ==    oldRes);    	non-compiled	[CE]  cannot  find  symbol  Preconditions	9	None	replace
68	[BUG]  [BUGGY]  Preconditions.checkState(relatives  ==  0);  [CE]  cannot  find  symbol  relatives  [FE]                AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;    [BUGGY]  Preconditions.checkState(relatives  ==  0);  [BUGGY]    oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	Preconditions.checkState(relatives  ==  0);	      Preconditions.checkState(remainings    ==    0);    	non-compiled	[CE]  cannot  find  symbol  relatives	12	None	replace
69	[BUG]  [BUGGY]  tmpVec  =  prevCost;  [CE]  cannot  find  symbol  prevCost  [FE]              AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;    [BUGGY]  tmpVec  =  prevCost;  [BUGGY]    oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  prevCost;	      tmpVec    =    cost;    	non-compiled	[CE]  cannot  find  symbol  prevCost	17	None	replace
70	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(point,  previousCost);  [CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double[],double)  [FE]                AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;    [BUGGY]  tmpVec  =  new  VectorialPointValuePair(point,  previousCost);  [BUGGY]    oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  VectorialPointValuePair(point,  previousCost);	      tmpVec    =    new    VectorialPointValuePair(previousCost,    point);    	non-compiled	[CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double[],double)	18	None	replace
71	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(point,  preRed);  [CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double[],double)  [FE]                  AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;    [BUGGY]  tmpVec  =  new  VectorialPointValuePair(point,  preRed);  [BUGGY]    oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  VectorialPointValuePair(point,  preRed);	      tmpVec    =    new    VectorialPointValuePair(previousCost,    point);    	non-compiled	[CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double[],double)	18	None	replace
72	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(lastX,  previousCost,  point);  [CE]  cannot  find  symbol  lastX  [FE]                    AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;    [BUGGY]  tmpVec  =  new  VectorialPointValuePair(lastX,  previousCost,  point);  [BUGGY]    oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  VectorialPointValuePair(lastX,  previousCost,  point);	      tmpVec    =    new    VectorialPointValuePair(previousCost,    point);    	non-compiled	[CE]  cannot  find  symbol  lastX	18	None	replace
73	[BUG]  [BUGGY]  tmpVec  =  permutation[oldRes];  [CE]  incompatible  types  [FE]        AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;    [BUGGY]  tmpVec  =  permutation[oldRes];  [BUGGY]    oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  permutation[oldRes];	      tmpVec    =    permutation[j];    	non-compiled	[CE]  incompatible  types	1	None	replace
74	[BUG]  [BUGGY]  ((  VectorialPointValuePair)previousCost).setVec(new  VectorialPointValuePair(tmpVec));  [CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double[])  [FE]            AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;    [BUGGY]  ((  VectorialPointValuePair)previousCost).setVec(new  VectorialPointValuePair(tmpVec));  [BUGGY]    oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	((  VectorialPointValuePair)previousCost).setVec(new  VectorialPointValuePair(tmpVec));	      ((    VectorialPointValuePair)previousCost).setVec(tmpVec);    	non-compiled	[CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double[])	3	None	replace
75	[BUG]  [BUGGY]  Preconditions.checkState(oldRes  >=  residuals);  [CE]  bad  operand  types  for  binary  operator  '>='  [FE]              AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;    [BUGGY]  Preconditions.checkState(oldRes  >=  residuals);  [BUGGY]    oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	Preconditions.checkState(oldRes  >=  residuals);	      Preconditions.checkState(remainings    >=    oldRes);    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '>='	11	None	replace
76	[BUG]  [BUGGY]  Preconditions.checkNotNull(oldRes);  [CE]  cannot  find  symbol  Preconditions  [FE]        AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;    [BUGGY]  Preconditions.checkNotNull(oldRes);  [BUGGY]    oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	Preconditions.checkNotNull(oldRes);	      Preconditions.checkNotNull(remainings);    	non-compiled	[CE]  cannot  find  symbol  Preconditions	8	None	replace
77	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(previousCost,  previousCost);  [CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double,double)  [FE]            AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;    [BUGGY]  tmpVec  =  new  VectorialPointValuePair(previousCost,  previousCost);  [BUGGY]    oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  VectorialPointValuePair(previousCost,  previousCost);	      tmpVec    =    new    VectorialPointValuePair();    	non-compiled	[CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double,double)	16	None	replace
78	[BUG]  [BUGGY]  Preconditions.checkState(remainders  ==  0);  [CE]  cannot  find  symbol  remainders  [FE]                AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;    [BUGGY]  Preconditions.checkState(remainders  ==  0);  [BUGGY]    oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	Preconditions.checkState(remainders  ==  0);	      Preconditions.checkState(remainings    ==    0);    	non-compiled	[CE]  cannot  find  symbol  remainders	12	None	replace
79	[BUG]  [BUGGY]  oldRes=  residuals;  tmpVec  =  new  VectorialPointValuePair(previousCost);  [CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double)  [FE]    AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;    [BUGGY]  oldRes=  residuals;  tmpVec  =  new  VectorialPointValuePair(previousCost);  [BUGGY]    }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	oldRes=    residuals;    tmpVec  =  new  VectorialPointValuePair(previousCost);	  	non-compiled	[CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double)	6	None	add
80	[BUG]  [BUGGY]  oldRes=  residuals;  tmpVec  =  permutation[j];  oldRes=  residuals;  [CE]  cannot  find  symbol  j  [FE]      AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;    [BUGGY]  oldRes=  residuals;  tmpVec  =  permutation[j];  oldRes=  residuals;  [BUGGY]    }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	oldRes=    residuals;    tmpVec  =  permutation[j];  oldRes=  residuals;	  	non-compiled	[CE]  cannot  find  symbol  j	6	None	add
81	[BUG]  [BUGGY]  oldRes=  residuals;  tmpVec  =  new  VectorialPointValuePair();  [CE]  no  suitable  constructor  found  for  VectorialPointValuePair()  [FE]        AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;    [BUGGY]  oldRes=  residuals;  tmpVec  =  new  VectorialPointValuePair();  [BUGGY]    }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	oldRes=    residuals;    tmpVec  =  new  VectorialPointValuePair();	  	non-compiled	[CE]  no  suitable  constructor  found  for  VectorialPointValuePair()	6	None	add
82	[BUG]  [BUGGY]  ((  VectorialPointValuePair)previousCost).setVec(tmpVec,  pj);  [CE]  cannot  find  symbol  pj  [FE]            AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;    [BUGGY]  ((  VectorialPointValuePair)previousCost).setVec(tmpVec,  pj);  [BUGGY]    oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	((  VectorialPointValuePair)previousCost).setVec(tmpVec,  pj);	      ((    VectorialPointValuePair)previousCost).setVec(tmpVec);    	non-compiled	[CE]  cannot  find  symbol  pj	3	None	replace
83	[BUG]  [BUGGY]  ((  VectorialPointValuePair)previousCost).setVec(oldX,  oldVec);  [CE]  cannot  find  symbol  oldVec  [FE]              AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;    [BUGGY]  ((  VectorialPointValuePair)previousCost).setVec(oldX,  oldVec);  [BUGGY]    oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	((  VectorialPointValuePair)previousCost).setVec(oldX,  oldVec);	      ((    VectorialPointValuePair)previousCost).setVec(tmpVec);    	non-compiled	[CE]  cannot  find  symbol  oldVec	3	None	replace
84	[BUG]  [BUGGY]  ((  VectorialPointValuePair)remainings).add(tmpVec,  residuals);  [CE]  cannot  find  symbol  remainings  [FE]          AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;    [BUGGY]  ((  VectorialPointValuePair)remainings).add(tmpVec,  residuals);  [BUGGY]    oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	((  VectorialPointValuePair)remainings).add(tmpVec,  residuals);	      ((    VectorialPointValuePair)remainings).add(tmpVec);    	non-compiled	[CE]  cannot  find  symbol  remainings	2	None	replace
85	[BUG]  [BUGGY]  oldRes  =  new  RelativeTolerance(relativeTolerance);  [CE]  cannot  find  symbol  [FE]    AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;    [BUGGY]  oldRes  =  new  RelativeTolerance(relativeTolerance);  [BUGGY]    }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	oldRes  =  new  RelativeTolerance(relativeTolerance);	  oldRes=    residuals;    	non-compiled	[CE]  cannot  find  symbol	7	None	replace
86	[BUG]  [BUGGY]  Preconditions.checkState(tmpVec!=  oldRes);  [CE]  cannot  find  symbol  Preconditions  [FE]            AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;    [BUGGY]  Preconditions.checkState(tmpVec!=  oldRes);  [BUGGY]    oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	Preconditions.checkState(tmpVec!=  oldRes);	      Preconditions.checkState(remainings!=    oldRes);    	non-compiled	[CE]  cannot  find  symbol  Preconditions	10	None	replace
87	[BUG]  [BUGGY]  tmpVec  =  new  VectorialPointValuePair(previousCost,  cost,  oldX);  [CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double,double,double[])  [FE]        AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;    [BUGGY]  tmpVec  =  new  VectorialPointValuePair(previousCost,  cost,  oldX);  [BUGGY]    oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  VectorialPointValuePair(previousCost,  cost,  oldX);	      tmpVec    =    new    VectorialPointValuePair(previousCost,    cost);    	non-compiled	[CE]  no  suitable  constructor  found  for  VectorialPointValuePair(double,double,double[])	14	None	replace
88	[BUG]  [BUGGY]  tmpVec  =  permutation[j].remainder;  [CE]  cannot  find  symbol  j  [FE]        AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;    [BUGGY]  tmpVec  =  permutation[j].remainder;  [BUGGY]    oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  permutation[j].remainder;	      tmpVec    =    permutation[j];    	non-compiled	[CE]  cannot  find  symbol  j	1	None	replace
89	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]              AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;    [BUGGY]  tmpVec  =  new  double[oldX.length];  [BUGGY]    oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	add	tmpVec  =  new  double[oldX.length];	      tmpVec    =    new    double[remainings.length];    	compilable	  [FE]  AssertionFailedError  	4	10	replace
90	[BUG]  [BUGGY]  tmpVec  =  new  double[oldX.length];  [FE]  AssertionFailedError  [FE]              AssertionFailedError    [CONTEXT]      }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;    [BUGGY]  tmpVec  =  new  double[oldX.length];  [BUGGY]    oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	433	433	2	replace	tmpVec  =  new  double[oldX.length];	      tmpVec    =    new    double[remainings.length];    	compilable	  [FE]  AssertionFailedError  	4	10	replace
