bugid	buggy	buggy_class	suspiciousness	buggy_line	endbuggycode	original_failing_test_number	action	patch	original_buggy	execution_result	diagnosis	previous_bug_id	new_failing_test_number	this_action
1	[BUG]  [BUGGY]  double  sPar  =  Math.sqrt(lmPar,  beta,  diagR,  gNorm);  [CE]  method  sqrt  in  class  Math  cannot  be  applied  to  given  types;  [FE]            AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  sPar  =  Math.sqrt(lmPar,  beta,  diagR,  gNorm);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double  sPar  =  Math.sqrt(lmPar,  beta,  diagR,  gNorm);	  double    sPar    =    Math.sqrt(lmPar,    diagR,    gNorm);    	non-compiled	[CE]  method  sqrt  in  class  Math  cannot  be  applied  to  given  types;	120	None	replace
2	[BUG]  [BUGGY]  double  sPar  =  Math.sqrt(gNorm,  diagR,  lmPar);  [CE]  method  sqrt  in  class  Math  cannot  be  applied  to  given  types;  [FE]              AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  sPar  =  Math.sqrt(gNorm,  diagR,  lmPar);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double  sPar  =  Math.sqrt(gNorm,  diagR,  lmPar);	  double    sPar    =    Math.sqrt(lmPar,    diagR,    gNorm);    	non-compiled	[CE]  method  sqrt  in  class  Math  cannot  be  applied  to  given  types;	120	None	replace
3	[BUG]  [BUGGY]  double  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [CE]  cannot  find  symbol  sPar  [FE]    AssertionFailedError    [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);	          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    double    lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    	non-compiled	[CE]  cannot  find  symbol  sPar	137	None	replace
4	[BUG]  [BUGGY]  double  sPar  =  Math.max(2.2251e-3,  0.001  *  paru);  double  sPar  =  Math.max(2.2251e-3,  0.001  *  paru);  [CE]  variable  sPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]    AssertionFailedError    [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  sPar  =  Math.max(2.2251e-3,  0.001  *  paru);  double  sPar  =  Math.max(2.2251e-3,  0.001  *  paru);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double    sPar    =    Math.max(2.2251e-3,    0.001    *    paru);    double  sPar  =  Math.max(2.2251e-3,  0.001  *  paru);	  	non-compiled	[CE]  variable  sPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	97	None	add
5	[BUG]  [BUGGY]  double  sPar  =  Math.max(2.2251e-3,  0.001  *  paru);  double  sPar  =  Math.max(2.2252e-3,  0.001  *  paru);  [CE]  variable  sPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]      AssertionFailedError    [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  sPar  =  Math.max(2.2251e-3,  0.001  *  paru);  double  sPar  =  Math.max(2.2252e-3,  0.001  *  paru);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double    sPar    =    Math.max(2.2251e-3,    0.001    *    paru);    double  sPar  =  Math.max(2.2252e-3,  0.001  *  paru);	  	non-compiled	[CE]  variable  sPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	97	None	add
6	[BUG]  [BUGGY]  double  sPar  =  Math.max(2.2251e-3,  0.001  *  paru);  Double  sPar  =  Math.max(2.2251e-3,  0.001  *  paru);  [CE]  variable  sPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]        AssertionFailedError    [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  sPar  =  Math.max(2.2251e-3,  0.001  *  paru);  Double  sPar  =  Math.max(2.2251e-3,  0.001  *  paru);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double    sPar    =    Math.max(2.2251e-3,    0.001    *    paru);    Double  sPar  =  Math.max(2.2251e-3,  0.001  *  paru);	  	non-compiled	[CE]  variable  sPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	97	None	add
7	[BUG]  [BUGGY]  double  sPar  =  Math.max(2.2251e-3,  0.001  *  paru);  double  sPar  =  Math.max(2.251e-3,  0.001  *  paru);  [CE]  variable  sPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]          AssertionFailedError    [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  sPar  =  Math.max(2.2251e-3,  0.001  *  paru);  double  sPar  =  Math.max(2.251e-3,  0.001  *  paru);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double    sPar    =    Math.max(2.2251e-3,    0.001    *    paru);    double  sPar  =  Math.max(2.251e-3,  0.001  *  paru);	  	non-compiled	[CE]  variable  sPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	97	None	add
8	[BUG]  [BUGGY]  double  sPar  =  Math.max(2.2251e-3,  0.001  *  paru);  double  sPar  =  Math.max(2.2251e-3,.001  *  paru);  [CE]  variable  sPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]            AssertionFailedError    [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  sPar  =  Math.max(2.2251e-3,  0.001  *  paru);  double  sPar  =  Math.max(2.2251e-3,.001  *  paru);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double    sPar    =    Math.max(2.2251e-3,    0.001    *    paru);    double  sPar  =  Math.max(2.2251e-3,.001  *  paru);	  	non-compiled	[CE]  variable  sPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	97	None	add
9	[BUG]  [BUGGY]  Double  solveCols  =  Math.max(2.2251e-308,  0.001  *  lmPar);  [CE]  cannot  find  symbol  sPar  [FE]              AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  Double  solveCols  =  Math.max(2.2251e-308,  0.001  *  lmPar);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	Double  solveCols  =  Math.max(2.2251e-308,  0.001  *  lmPar);	  Double    solveCols    =    Math.max(2.2251e-308,    0.001    *    paru);    	non-compiled	[CE]  cannot  find  symbol  sPar	125	None	replace
10	[BUG]  [BUGGY]  Double  solveCols  =  Math.max(2.2251e-308,  0.001  *  solvedCols);  [CE]  cannot  find  symbol  sPar  [FE]                AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  Double  solveCols  =  Math.max(2.2251e-308,  0.001  *  solvedCols);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	Double  solveCols  =  Math.max(2.2251e-308,  0.001  *  solvedCols);	  Double    solveCols    =    Math.max(2.2251e-308,    0.001    *    paru);    	non-compiled	[CE]  cannot  find  symbol  sPar	125	None	replace
11	[BUG]  [BUGGY]  Double  solveCols  =  Math.max(2.2251e-308,  0.001  *  parm);  [CE]  cannot  find  symbol  parm  [FE]                  AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  Double  solveCols  =  Math.max(2.2251e-308,  0.001  *  parm);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	Double  solveCols  =  Math.max(2.2251e-308,  0.001  *  parm);	  Double    solveCols    =    Math.max(2.2251e-308,    0.001    *    paru);    	non-compiled	[CE]  cannot  find  symbol  parm	125	None	replace
12	[BUG]  [BUGGY]  double  diag  =  Math.sqrt(log1(lmPar));  [CE]  variable  diag  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]                  AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  diag  =  Math.sqrt(log1(lmPar));  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double  diag  =  Math.sqrt(log1(lmPar));	  double    diag    =    Math.sqrt(log2(lmPar));    	non-compiled	[CE]  variable  diag  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	160	None	replace
13	[BUG]  [BUGGY]  double  diag  =  Math.sqrt(log2(lmPar)+  1);  [CE]  variable  diag  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]                    AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  diag  =  Math.sqrt(log2(lmPar)+  1);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double  diag  =  Math.sqrt(log2(lmPar)+  1);	  double    diag    =    Math.sqrt(log2(lmPar));    	non-compiled	[CE]  variable  diag  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	160	None	replace
14	[BUG]  [BUGGY]  double  diag  =  Math.sqrt(log2(lmPar)/  2);  [CE]  variable  diag  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]                      AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  diag  =  Math.sqrt(log2(lmPar)/  2);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double  diag  =  Math.sqrt(log2(lmPar)/  2);	  double    diag    =    Math.sqrt(log2(lmPar));    	non-compiled	[CE]  variable  diag  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	160	None	replace
15	[BUG]  [BUGGY]  double  sPar  =  Math.log(lmPar)/  gNorm;  double  sPar  =  Math.log(lmPar)/  gNorm;  [CE]  variable  sPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]    AssertionFailedError    [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  sPar  =  Math.log(lmPar)/  gNorm;  double  sPar  =  Math.log(lmPar)/  gNorm;  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double    sPar    =    Math.log(lmPar)/    gNorm;    double  sPar  =  Math.log(lmPar)/  gNorm;	  	non-compiled	[CE]  variable  sPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	87	None	add
16	[BUG]  [BUGGY]  double  sPar  =  Math.log(lmPar)/  gNorm;  Double  sPar  =  Math.log(lmPar)/  gNorm;  [CE]  variable  sPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]      AssertionFailedError    [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  sPar  =  Math.log(lmPar)/  gNorm;  Double  sPar  =  Math.log(lmPar)/  gNorm;  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double    sPar    =    Math.log(lmPar)/    gNorm;    Double  sPar  =  Math.log(lmPar)/  gNorm;	  	non-compiled	[CE]  variable  sPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	87	None	add
17	[BUG]  [BUGGY]  double  sPar  =  Math.log(lmPar)/  gNorm;  int  sPar  =  Math.log(lmPar)/  gNorm;  [CE]  variable  sPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]        AssertionFailedError    [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  sPar  =  Math.log(lmPar)/  gNorm;  int  sPar  =  Math.log(lmPar)/  gNorm;  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double    sPar    =    Math.log(lmPar)/    gNorm;    int  sPar  =  Math.log(lmPar)/  gNorm;	  	non-compiled	[CE]  variable  sPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	87	None	add
18	[BUG]  [BUGGY]  double  sPar  =  Math.log(lmPar)/  gNorm;  double  sPar  =  Math.log(lmPar)/  gNorm);  [CE]  ';'  expected  [FE]          AssertionFailedError    [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  sPar  =  Math.log(lmPar)/  gNorm;  double  sPar  =  Math.log(lmPar)/  gNorm);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double    sPar    =    Math.log(lmPar)/    gNorm;    double  sPar  =  Math.log(lmPar)/  gNorm);	  	non-compiled	[CE]  ';'  expected	87	None	add
19	[BUG]  [BUGGY]  double  permutation  =  Math.sqrt(lmPar,  gNorm,  diag);  [CE]  method  sqrt  in  class  Math  cannot  be  applied  to  given  types;  [FE]                AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  permutation  =  Math.sqrt(lmPar,  gNorm,  diag);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double  permutation  =  Math.sqrt(lmPar,  gNorm,  diag);	  double    permutation    =    Math.sqrt(lmPar,    diag);    	non-compiled	[CE]  method  sqrt  in  class  Math  cannot  be  applied  to  given  types;	157	None	replace
20	[BUG]  [BUGGY]  double  permutation  =  Math.sqrt(diag,  lmPar);  [CE]  method  sqrt  in  class  Math  cannot  be  applied  to  given  types;  [FE]                  AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  permutation  =  Math.sqrt(diag,  lmPar);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double  permutation  =  Math.sqrt(diag,  lmPar);	  double    permutation    =    Math.sqrt(lmPar,    diag);    	non-compiled	[CE]  method  sqrt  in  class  Math  cannot  be  applied  to  given  types;	157	None	replace
21	[BUG]  [BUGGY]  double  permutation  =  Math.sqrt(lmPar,  diag,  gNorm);  [CE]  method  sqrt  in  class  Math  cannot  be  applied  to  given  types;  [FE]                    AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  permutation  =  Math.sqrt(lmPar,  diag,  gNorm);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double  permutation  =  Math.sqrt(lmPar,  diag,  gNorm);	  double    permutation    =    Math.sqrt(lmPar,    diag);    	non-compiled	[CE]  method  sqrt  in  class  Math  cannot  be  applied  to  given  types;	157	None	replace
22	[BUG]  [BUGGY]  double  permutation  =  Math.sqrt(lmPar,  dxNorm,  diag);  [CE]  method  sqrt  in  class  Math  cannot  be  applied  to  given  types;  [FE]                      AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  permutation  =  Math.sqrt(lmPar,  dxNorm,  diag);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double  permutation  =  Math.sqrt(lmPar,  dxNorm,  diag);	  double    permutation    =    Math.sqrt(lmPar,    diag);    	non-compiled	[CE]  method  sqrt  in  class  Math  cannot  be  applied  to  given  types;	157	None	replace
23	[BUG]  [BUGGY]  double  solvedCols  =  Math.sqrt(dxNorm);  [CE]  cannot  find  symbol  sPar  [FE]          AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  solvedCols  =  Math.sqrt(dxNorm);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double  solvedCols  =  Math.sqrt(dxNorm);	  double    solvedCols    =    Math.sqrt(column);    	non-compiled	[CE]  cannot  find  symbol  sPar	159	None	replace
24	[BUG]  [BUGGY]  double  solves  =  Math.max(2.2252e-308,  0.001  *  paru);  [CE]  cannot  find  symbol  sPar  [FE]          AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  solves  =  Math.max(2.2252e-308,  0.001  *  paru);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double  solves  =  Math.max(2.2252e-308,  0.001  *  paru);	  double    solves    =    Math.max(2.2251e-308,    0.001    *    lmPar);    	non-compiled	[CE]  cannot  find  symbol  sPar	80	None	replace
25	[BUG]  [BUGGY]  double  solves  =  Math.max(2.2251e-408,  0.001  *  paru);  [CE]  floating  point  number  too  small  [FE]            AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  solves  =  Math.max(2.2251e-408,  0.001  *  paru);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double  solves  =  Math.max(2.2251e-408,  0.001  *  paru);	  double    solves    =    Math.max(2.2251e-308,    0.001    *    lmPar);    	non-compiled	[CE]  floating  point  number  too  small	80	None	replace
26	[BUG]  [BUGGY]  Double  solvedCols  =  Math.max(2.2251e-308,  0.001  *  paru);  [CE]  cannot  find  symbol  sPar  [FE]            AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  Double  solvedCols  =  Math.max(2.2251e-308,  0.001  *  paru);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	Double  solvedCols  =  Math.max(2.2251e-308,  0.001  *  paru);	          double    solvedCols    =    Math.max(2.2251e-308,    0.001    *    paru);    Double    solvedCols    =    Math.max(2.2251e-308,    0.001    *    paru);    	non-compiled	[CE]  cannot  find  symbol  sPar	67	None	replace
27	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  sPar  =  Math.sqrt(lmPar)/  2.0;  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	add	double  sPar  =  Math.sqrt(lmPar)/  2.0;	  double    sPar    =    Math.sqrt(lmPar)/    2;    	compilable	  [FE]  AssertionFailedError  	170	9	replace
28	[BUG]  [BUGGY]  double  sPar  =  Math.sqrt(lmPar)/  2.0;  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  sPar  =  Math.sqrt(lmPar)/  2.0;  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double  sPar  =  Math.sqrt(lmPar)/  2.0;	  double    sPar    =    Math.sqrt(lmPar)/    2;    	compilable	  [FE]  AssertionFailedError  	170	9	replace
29	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  sPar  =  Math.sqrt(lmPar)/  2  +  1;  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	add	double  sPar  =  Math.sqrt(lmPar)/  2  +  1;	  double    sPar    =    Math.sqrt(lmPar)/    2;    	compilable	  [FE]  AssertionFailedError  	170	13	replace
30	[BUG]  [BUGGY]  double  sPar  =  Math.sqrt(lmPar)/  2  +  1;  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  sPar  =  Math.sqrt(lmPar)/  2  +  1;  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double  sPar  =  Math.sqrt(lmPar)/  2  +  1;	  double    sPar    =    Math.sqrt(lmPar)/    2;    	compilable	  [FE]  AssertionFailedError  	170	13	replace
31	[BUG]  [BUGGY]  double  sPar  =  Math.sqrt(lmPar  *  3);  double  sPar  =  Math.sqrt(lmPar  *  3);  [CE]  variable  sPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]    AssertionFailedError    [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  sPar  =  Math.sqrt(lmPar  *  3);  double  sPar  =  Math.sqrt(lmPar  *  3);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double    sPar    =    Math.sqrt(lmPar    *    3);    double  sPar  =  Math.sqrt(lmPar  *  3);	  	non-compiled	[CE]  variable  sPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	5	None	add
32	[BUG]  [BUGGY]  double  sPar  =  Math.sqrt(lmPar  *  3);  Double  sPar  =  Math.sqrt(lmPar  *  3);  [CE]  variable  sPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]      AssertionFailedError    [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  sPar  =  Math.sqrt(lmPar  *  3);  Double  sPar  =  Math.sqrt(lmPar  *  3);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double    sPar    =    Math.sqrt(lmPar    *    3);    Double  sPar  =  Math.sqrt(lmPar  *  3);	  	non-compiled	[CE]  variable  sPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	5	None	add
33	[BUG]  [BUGGY]  double  sPar  =  Math.sqrt(lmPar  *  3);  int  sPar  =  Math.sqrt(lmPar  *  3);  [CE]  variable  sPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]        AssertionFailedError    [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  sPar  =  Math.sqrt(lmPar  *  3);  int  sPar  =  Math.sqrt(lmPar  *  3);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double    sPar    =    Math.sqrt(lmPar    *    3);    int  sPar  =  Math.sqrt(lmPar  *  3);	  	non-compiled	[CE]  variable  sPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	5	None	add
34	[BUG]  [BUGGY]  double  sPar  =  Math.sqrt(lmPar  *  3);  sPar  =  Math.sqrt(lmPar  *  3);  [CE]  variable  sPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]          AssertionFailedError    [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  sPar  =  Math.sqrt(lmPar  *  3);  sPar  =  Math.sqrt(lmPar  *  3);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double    sPar    =    Math.sqrt(lmPar    *    3);    sPar  =  Math.sqrt(lmPar  *  3);	  	non-compiled	[CE]  variable  sPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	5	None	add
35	[BUG]  [BUGGY]  lmPar  =  Math.sqrt(lmPar  +  1);  [CE]  cannot  find  symbol  sPar  [FE]                AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  lmPar  =  Math.sqrt(lmPar  +  1);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	lmPar  =  Math.sqrt(lmPar  +  1);	  double    sPar    =    Math.sqrt(lmPar    +    1);    sPar    =    Math.sqrt(lmPar    +    1);    	non-compiled	[CE]  cannot  find  symbol  sPar	33	None	replace
36	[BUG]  [BUGGY]  sPar  =  Math.sqrt(lmPar  +  1);  [CE]  cannot  find  symbol  sPar  [FE]                  AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  sPar  =  Math.sqrt(lmPar  +  1);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	sPar  =  Math.sqrt(lmPar  +  1);	  double    sPar    =    Math.sqrt(lmPar    +    1);    sPar    =    Math.sqrt(lmPar    +    1);    	non-compiled	[CE]  cannot  find  symbol  sPar	33	None	replace
37	[BUG]  [BUGGY]  double  sPar  =  Math.sqrt(lmPar,  gNorm  +  1);  [CE]  method  sqrt  in  class  Math  cannot  be  applied  to  given  types;  [FE]                    AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  sPar  =  Math.sqrt(lmPar,  gNorm  +  1);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double  sPar  =  Math.sqrt(lmPar,  gNorm  +  1);	  double    sPar    =    Math.sqrt(lmPar    +    1);    sPar    =    Math.sqrt(lmPar    +    1);    	non-compiled	[CE]  method  sqrt  in  class  Math  cannot  be  applied  to  given  types;	33	None	replace
38	[BUG]  [BUGGY]  int  sPar  =  Math.sqrt(lmPar  +  2);  [CE]  possible  loss  of  precision  [FE]            AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  int  sPar  =  Math.sqrt(lmPar  +  2);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	int  sPar  =  Math.sqrt(lmPar  +  2);	  double    sPar    =    Math.sqrt(lmPar    +    2);    int    sPar    =    Math.sqrt(lmPar    +    2);    	non-compiled	[CE]  possible  loss  of  precision	26	None	replace
39	[BUG]  [BUGGY]  int  sPar  =  Math.sqrt(lmPar);  [CE]  possible  loss  of  precision  [FE]              AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  int  sPar  =  Math.sqrt(lmPar);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	int  sPar  =  Math.sqrt(lmPar);	  double    sPar    =    Math.sqrt(lmPar    +    2);    int    sPar    =    Math.sqrt(lmPar    +    2);    	non-compiled	[CE]  possible  loss  of  precision	26	None	replace
40	[BUG]  [BUGGY]  int  sPar  =  Math.sqrt(lmPar  +  1);  [CE]  possible  loss  of  precision  [FE]                AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  int  sPar  =  Math.sqrt(lmPar  +  1);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	int  sPar  =  Math.sqrt(lmPar  +  1);	  double    sPar    =    Math.sqrt(lmPar    +    2);    int    sPar    =    Math.sqrt(lmPar    +    2);    	non-compiled	[CE]  possible  loss  of  precision	26	None	replace
41	[BUG]  [BUGGY]  double  sPar  =  Math.sqrt(lmPar,  paru);  [CE]  method  sqrt  in  class  Math  cannot  be  applied  to  given  types;  [FE]            AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  sPar  =  Math.sqrt(lmPar,  paru);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double  sPar  =  Math.sqrt(lmPar,  paru);	  double    sPar    =    Math.sqrt(lmPar,    diagnosis);    	non-compiled	[CE]  method  sqrt  in  class  Math  cannot  be  applied  to  given  types;	168	None	replace
42	[BUG]  [BUGGY]  double  sPar  =  Math.sqrt(lmPar,  dxNorm);  [CE]  method  sqrt  in  class  Math  cannot  be  applied  to  given  types;  [FE]              AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  sPar  =  Math.sqrt(lmPar,  dxNorm);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double  sPar  =  Math.sqrt(lmPar,  dxNorm);	  double    sPar    =    Math.sqrt(lmPar,    diagnosis);    	non-compiled	[CE]  method  sqrt  in  class  Math  cannot  be  applied  to  given  types;	168	None	replace
43	[BUG]  [BUGGY]  double  sPar  =  Math.sqrt(lmPar,  paren);  [CE]  cannot  find  symbol  paren  [FE]                AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  sPar  =  Math.sqrt(lmPar,  paren);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double  sPar  =  Math.sqrt(lmPar,  paren);	  double    sPar    =    Math.sqrt(lmPar,    diagnosis);    	non-compiled	[CE]  cannot  find  symbol  paren	168	None	replace
44	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  sPar  =  Math.sqrt(lmPar  /  1);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	add	double  sPar  =  Math.sqrt(lmPar  /  1);	  double    sPar    =    Math.sqrt(lmPar    *    1);    	compilable	  [FE]  AssertionFailedError  	59	2	replace
45	[BUG]  [BUGGY]  double  sPar  =  Math.sqrt(lmPar  /  1);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  sPar  =  Math.sqrt(lmPar  /  1);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double  sPar  =  Math.sqrt(lmPar  /  1);	  double    sPar    =    Math.sqrt(lmPar    *    1);    	compilable	  [FE]  AssertionFailedError  	59	2	replace
46	[BUG]  [BUGGY]  double  solves  =  Math.max(2.2252e-408,  0.001  *  paru);  [CE]  floating  point  number  too  small  [FE]        AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  solves  =  Math.max(2.2252e-408,  0.001  *  paru);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double  solves  =  Math.max(2.2252e-408,  0.001  *  paru);	          double    solves    =    Math.max(2.2251e-308,    0.001    *    paru);    double    solves    =    Math.max(2.2251e-408,    0.001    *    paru);    	non-compiled	[CE]  floating  point  number  too  small	147	None	replace
47	[BUG]  [BUGGY]  double  solves  =  Math.max(2.0,  0.001,  0.001  *  paru);  [CE]  no  suitable  method  found  for  max(double,double,double)  [FE]          AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  solves  =  Math.max(2.0,  0.001,  0.001  *  paru);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double  solves  =  Math.max(2.0,  0.001,  0.001  *  paru);	          double    solves    =    Math.max(2.2251e-308,    0.001    *    paru);    double    solves    =    Math.max(2.2251e-408,    0.001    *    paru);    	non-compiled	[CE]  no  suitable  method  found  for  max(double,double,double)	147	None	replace
48	[BUG]  [BUGGY]  double  diag  =  Math.sqrt(gNorm,  lmPar);  [CE]  variable  diag  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]                  AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  diag  =  Math.sqrt(gNorm,  lmPar);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double  diag  =  Math.sqrt(gNorm,  lmPar);	  double    diag    =    Math.sqrt(lmPar,    gNorm);    	non-compiled	[CE]  variable  diag  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	89	None	replace
49	[BUG]  [BUGGY]  double  diag  =  Math.sqrt(lmPar,  gNorm,  dxNorm);  [CE]  variable  diag  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]                    AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  diag  =  Math.sqrt(lmPar,  gNorm,  dxNorm);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double  diag  =  Math.sqrt(lmPar,  gNorm,  dxNorm);	  double    diag    =    Math.sqrt(lmPar,    gNorm);    	non-compiled	[CE]  variable  diag  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	89	None	replace
50	[BUG]  [BUGGY]  double  diag  =  Math.sqrt(lmPar,  delta);  [CE]  variable  diag  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]                      AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  diag  =  Math.sqrt(lmPar,  delta);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double  diag  =  Math.sqrt(lmPar,  delta);	  double    diag    =    Math.sqrt(lmPar,    gNorm);    	non-compiled	[CE]  variable  diag  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	89	None	replace
51	[BUG]  [BUGGY]  double  permutation  =  Math.sqrt(lmPar,  beta,  diagR);  [CE]  method  sqrt  in  class  Math  cannot  be  applied  to  given  types;  [FE]                  AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  permutation  =  Math.sqrt(lmPar,  beta,  diagR);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double  permutation  =  Math.sqrt(lmPar,  beta,  diagR);	  double    permutation    =    Math.sqrt(lmPar,    diagR);    	non-compiled	[CE]  method  sqrt  in  class  Math  cannot  be  applied  to  given  types;	131	None	replace
52	[BUG]  [BUGGY]  double  permutation  =  Math.sqrt(lmPar,  gNorm,  diagR);  [CE]  method  sqrt  in  class  Math  cannot  be  applied  to  given  types;  [FE]                    AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  permutation  =  Math.sqrt(lmPar,  gNorm,  diagR);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double  permutation  =  Math.sqrt(lmPar,  gNorm,  diagR);	  double    permutation    =    Math.sqrt(lmPar,    diagR);    	non-compiled	[CE]  method  sqrt  in  class  Math  cannot  be  applied  to  given  types;	131	None	replace
53	[BUG]  [BUGGY]  double  permutation  =  Math.sqrt(lmPar,  beta);  [CE]  method  sqrt  in  class  Math  cannot  be  applied  to  given  types;  [FE]                      AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  permutation  =  Math.sqrt(lmPar,  beta);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double  permutation  =  Math.sqrt(lmPar,  beta);	  double    permutation    =    Math.sqrt(lmPar,    diagR);    	non-compiled	[CE]  method  sqrt  in  class  Math  cannot  be  applied  to  given  types;	131	None	replace
54	[BUG]  [BUGGY]  double  permutation  =  Math.sqrt(lmPar,  diagR,  beta);  [CE]  method  sqrt  in  class  Math  cannot  be  applied  to  given  types;  [FE]                        AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  permutation  =  Math.sqrt(lmPar,  diagR,  beta);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double  permutation  =  Math.sqrt(lmPar,  diagR,  beta);	  double    permutation    =    Math.sqrt(lmPar,    diagR);    	non-compiled	[CE]  method  sqrt  in  class  Math  cannot  be  applied  to  given  types;	131	None	replace
55	[BUG]  [BUGGY]  double  permutation  =  Math.sqrt(permutation,  lmPar);  [CE]  method  sqrt  in  class  Math  cannot  be  applied  to  given  types;  [FE]                AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  permutation  =  Math.sqrt(permutation,  lmPar);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double  permutation  =  Math.sqrt(permutation,  lmPar);	  double    permutation    =    Math.sqrt(permutation);    	non-compiled	[CE]  method  sqrt  in  class  Math  cannot  be  applied  to  given  types;	130	None	replace
56	[BUG]  [BUGGY]  double  permutation  =  Math.sqrt(permutation,  gNorm);  [CE]  method  sqrt  in  class  Math  cannot  be  applied  to  given  types;  [FE]                  AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  permutation  =  Math.sqrt(permutation,  gNorm);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double  permutation  =  Math.sqrt(permutation,  gNorm);	  double    permutation    =    Math.sqrt(permutation);    	non-compiled	[CE]  method  sqrt  in  class  Math  cannot  be  applied  to  given  types;	130	None	replace
57	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  Double  sPar  =  Math.sqrt(lmPar);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	add	Double  sPar  =  Math.sqrt(lmPar);	  double    sPar    =    Math.sqrt(lmPar    +    2);    Double    sPar    =    Math.sqrt(lmPar    +    2);    	compilable	  [FE]  AssertionFailedError  	25	2	replace
58	[BUG]  [BUGGY]  Double  sPar  =  Math.sqrt(lmPar);  [FE]  AssertionFailedError  [FE]          AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  Double  sPar  =  Math.sqrt(lmPar);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	Double  sPar  =  Math.sqrt(lmPar);	  double    sPar    =    Math.sqrt(lmPar    +    2);    Double    sPar    =    Math.sqrt(lmPar    +    2);    	compilable	  [FE]  AssertionFailedError  	25	2	replace
59	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]            AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  Double  sPar  =  Math.sqrt(lmPar  +  2);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	add	Double  sPar  =  Math.sqrt(lmPar  +  2);	  double    sPar    =    Math.sqrt(lmPar    +    2);    Double    sPar    =    Math.sqrt(lmPar    +    2);    	compilable	  [FE]  AssertionFailedError  	25	13	replace
60	[BUG]  [BUGGY]  Double  sPar  =  Math.sqrt(lmPar  +  2);  [FE]  AssertionFailedError  [FE]            AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  Double  sPar  =  Math.sqrt(lmPar  +  2);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	Double  sPar  =  Math.sqrt(lmPar  +  2);	  double    sPar    =    Math.sqrt(lmPar    +    2);    Double    sPar    =    Math.sqrt(lmPar    +    2);    	compilable	  [FE]  AssertionFailedError  	25	13	replace
61	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]              AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  Double  sPar  =  Math.sqrt(lmPar  +  1);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	add	Double  sPar  =  Math.sqrt(lmPar  +  1);	  double    sPar    =    Math.sqrt(lmPar    +    2);    Double    sPar    =    Math.sqrt(lmPar    +    2);    	compilable	  [FE]  AssertionFailedError  	25	13	replace
62	[BUG]  [BUGGY]  Double  sPar  =  Math.sqrt(lmPar  +  1);  [FE]  AssertionFailedError  [FE]              AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  Double  sPar  =  Math.sqrt(lmPar  +  1);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	Double  sPar  =  Math.sqrt(lmPar  +  1);	  double    sPar    =    Math.sqrt(lmPar    +    2);    Double    sPar    =    Math.sqrt(lmPar    +    2);    	compilable	  [FE]  AssertionFailedError  	25	13	replace
63	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]          lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	add	                lmPar        =        Math.max(2.2252e-308,        0.001        *        paru);        lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	44	12	add
64	[BUG]  [BUGGY]          lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]          lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	                lmPar        =        Math.max(2.2252e-308,        0.001        *        paru);        lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	44	12	add
65	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]          lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	add	                lmPar        =        Math.max(2.2252e-308,        0.001        *        paru);        lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	44	12	add
66	[BUG]  [BUGGY]          lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]          lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	                lmPar        =        Math.max(2.2252e-308,        0.001        *        paru);        lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	44	12	add
67	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]          lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	add	                lmPar        =        Math.max(2.2252e-308,        0.001        *        paru);        lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	44	12	add
68	[BUG]  [BUGGY]          lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]          lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	                lmPar        =        Math.max(2.2252e-308,        0.001        *        paru);        lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	44	12	add
69	[BUG]  [BUGGY]          lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  Paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  [CE]  cannot  find  symbol  Paru  [FE]          AssertionFailedError    [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]          lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  Paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	                lmPar        =        Math.max(2.2252e-308,        0.001        *        paru);        lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,  0.001  *  Paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);	  	non-compiled	[CE]  cannot  find  symbol  Paru	44	None	add
70	[BUG]  [BUGGY]  lmPar  =  Math.max(2.2252e-408,  0.001  *  paru);  [CE]  floating  point  number  too  small  [FE]          AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  lmPar  =  Math.max(2.2252e-408,  0.001  *  paru);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	lmPar  =  Math.max(2.2252e-408,  0.001  *  paru);	          lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar    =    Math.max(2.2252e-408,    0.001    *    paru);    	non-compiled	[CE]  floating  point  number  too  small	145	None	replace
71	[BUG]  [BUGGY]  lmPar  =  Math.max(2.2251e-408,  0.001  *  paru);  [CE]  floating  point  number  too  small  [FE]            AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  lmPar  =  Math.max(2.2251e-408,  0.001  *  paru);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	lmPar  =  Math.max(2.2251e-408,  0.001  *  paru);	          lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar    =    Math.max(2.2252e-408,    0.001    *    paru);    	non-compiled	[CE]  floating  point  number  too  small	145	None	replace
72	[BUG]  [BUGGY]  double  sPar  =  Math.sqrt(lmPar,  diag,  gNorm);  [CE]  method  sqrt  in  class  Math  cannot  be  applied  to  given  types;  [FE]              AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  sPar  =  Math.sqrt(lmPar,  diag,  gNorm);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double  sPar  =  Math.sqrt(lmPar,  diag,  gNorm);	  double    sPar    =    Math.sqrt(lmPar,    diag);    	non-compiled	[CE]  method  sqrt  in  class  Math  cannot  be  applied  to  given  types;	100	None	replace
73	[BUG]  [BUGGY]  double  sPar  =  Math.sqrt(lmPar,  dxNorm,  diag);  [CE]  method  sqrt  in  class  Math  cannot  be  applied  to  given  types;  [FE]                AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  sPar  =  Math.sqrt(lmPar,  dxNorm,  diag);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double  sPar  =  Math.sqrt(lmPar,  dxNorm,  diag);	  double    sPar    =    Math.sqrt(lmPar,    diag);    	non-compiled	[CE]  method  sqrt  in  class  Math  cannot  be  applied  to  given  types;	100	None	replace
74	[BUG]  [BUGGY]  lmPar  =  Math.max(2.2252e-308,  0.001  *  lmPar  +  1);  [CE]  cannot  find  symbol  sPar  [FE]          AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  lmPar  =  Math.max(2.2252e-308,  0.001  *  lmPar  +  1);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	lmPar  =  Math.max(2.2252e-308,  0.001  *  lmPar  +  1);	  lmPar    =    Math.max(2.2252e-308,    0.001    *    paru    +    1);    	non-compiled	[CE]  cannot  find  symbol  sPar	71	None	replace
75	[BUG]  [BUGGY]  lmPar  =  Math.max(2.2252e-308,  0.001  *  param  +  1);  [CE]  cannot  find  symbol  param  [FE]            AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  lmPar  =  Math.max(2.2252e-308,  0.001  *  param  +  1);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	lmPar  =  Math.max(2.2252e-308,  0.001  *  param  +  1);	  lmPar    =    Math.max(2.2252e-308,    0.001    *    paru    +    1);    	non-compiled	[CE]  cannot  find  symbol  param	71	None	replace
76	[BUG]  [BUGGY]  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru  +  2);  [CE]  cannot  find  symbol  sPar  [FE]              AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru  +  2);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	lmPar  =  Math.max(2.2252e-308,  0.001  *  paru  +  2);	  lmPar    =    Math.max(2.2252e-308,    0.001    *    paru    +    1);    	non-compiled	[CE]  cannot  find  symbol  sPar	71	None	replace
77	[BUG]  [BUGGY]  Double  sPar  =  Math.sqrt(lmPar,  gNorm);  [CE]  method  sqrt  in  class  Math  cannot  be  applied  to  given  types;  [FE]          AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  Double  sPar  =  Math.sqrt(lmPar,  gNorm);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	Double  sPar  =  Math.sqrt(lmPar,  gNorm);	  double    sPar    =    Math.sqrt(gNorm);    Double    sPar    =    Math.sqrt(gNorm);    	non-compiled	[CE]  method  sqrt  in  class  Math  cannot  be  applied  to  given  types;	2	None	replace
78	[BUG]  [BUGGY]  double  sPar  =  Math.sqrt(lmPar,  partialStepBoundFactor);  [CE]  cannot  find  symbol  partialStepBoundFactor  [FE]            AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  sPar  =  Math.sqrt(lmPar,  partialStepBoundFactor);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double  sPar  =  Math.sqrt(lmPar,  partialStepBoundFactor);	  double    sPar    =    Math.sqrt(lmPar,    diagnostic);    	non-compiled	[CE]  cannot  find  symbol  partialStepBoundFactor	99	None	replace
79	[BUG]  [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    double  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  double  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [CE]  variable  lmPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]    AssertionFailedError    [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    double  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  double  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	                lmPar        =        Math.max(2.2251e-308,        0.001        *        paru);        double    lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  double  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);	  	non-compiled	[CE]  variable  lmPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	136	None	add
80	[BUG]  [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    double  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  double  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  double  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [CE]  variable  lmPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]      AssertionFailedError    [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    double  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  double  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  double  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	                lmPar        =        Math.max(2.2251e-308,        0.001        *        paru);        double    lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    double  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  double  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);	  	non-compiled	[CE]  variable  lmPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	136	None	add
81	[BUG]  [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    double  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  double  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [CE]  variable  lmPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]        AssertionFailedError    [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    double  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  double  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	                lmPar        =        Math.max(2.2251e-308,        0.001        *        paru);        double    lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  double  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);	  	non-compiled	[CE]  variable  lmPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	136	None	add
82	[BUG]  [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    double  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  double  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [CE]  variable  lmPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]          AssertionFailedError    [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    double  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  double  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	                lmPar        =        Math.max(2.2251e-308,        0.001        *        paru);        double    lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  double  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);	  	non-compiled	[CE]  variable  lmPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	136	None	add
83	[BUG]  [BUGGY]  double  solvedCols  =  Math.max(2.2251e-308,.001  *  paru);  [CE]  cannot  find  symbol  sPar  [FE]                AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  solvedCols  =  Math.max(2.2251e-308,.001  *  paru);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double  solvedCols  =  Math.max(2.2251e-308,.001  *  paru);	          double    solvedCols    =    Math.max(2.2251e-308,    0.001    *    paru);    double    solvedCols    =    Math.max(2.2251e-308,.001    *    paru);    	non-compiled	[CE]  cannot  find  symbol  sPar	69	None	replace
84	[BUG]  [BUGGY]  double  solvedCols  =  Math.max(2.2251e-3,.001  *  paru);  [CE]  cannot  find  symbol  sPar  [FE]                  AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  solvedCols  =  Math.max(2.2251e-3,.001  *  paru);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double  solvedCols  =  Math.max(2.2251e-3,.001  *  paru);	          double    solvedCols    =    Math.max(2.2251e-308,    0.001    *    paru);    double    solvedCols    =    Math.max(2.2251e-308,.001    *    paru);    	non-compiled	[CE]  cannot  find  symbol  sPar	69	None	replace
85	[BUG]  [BUGGY]  double  solvedCols  =  Math.max(2.2252e-308,.001  *  paru);  [CE]  cannot  find  symbol  sPar  [FE]                    AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  solvedCols  =  Math.max(2.2252e-308,.001  *  paru);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double  solvedCols  =  Math.max(2.2252e-308,.001  *  paru);	          double    solvedCols    =    Math.max(2.2251e-308,    0.001    *    paru);    double    solvedCols    =    Math.max(2.2251e-308,.001    *    paru);    	non-compiled	[CE]  cannot  find  symbol  sPar	69	None	replace
86	[BUG]  [BUGGY]  double  solvedCols  =  Math.max(2.0,.001  *  paru);  [CE]  cannot  find  symbol  sPar  [FE]                      AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  solvedCols  =  Math.max(2.0,.001  *  paru);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double  solvedCols  =  Math.max(2.0,.001  *  paru);	          double    solvedCols    =    Math.max(2.2251e-308,    0.001    *    paru);    double    solvedCols    =    Math.max(2.2251e-308,.001    *    paru);    	non-compiled	[CE]  cannot  find  symbol  sPar	69	None	replace
87	[BUG]  [BUGGY]  Double  solvedCols  =  Math.sqrt(lmPar);  [CE]  cannot  find  symbol  sPar  [FE]          AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  Double  solvedCols  =  Math.sqrt(lmPar);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	Double  solvedCols  =  Math.sqrt(lmPar);	          double    solvedCols    =    Math.sqrt(lmPar);    Double    solvedCols    =    Math.sqrt(lmPar);    	non-compiled	[CE]  cannot  find  symbol  sPar	103	None	replace
88	[BUG]  [BUGGY]  Double  solvedCols  =  Math.sqrt(lmPar,  gNorm);  [CE]  method  sqrt  in  class  Math  cannot  be  applied  to  given  types;  [FE]            AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  Double  solvedCols  =  Math.sqrt(lmPar,  gNorm);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	Double  solvedCols  =  Math.sqrt(lmPar,  gNorm);	          double    solvedCols    =    Math.sqrt(lmPar);    Double    solvedCols    =    Math.sqrt(lmPar);    	non-compiled	[CE]  method  sqrt  in  class  Math  cannot  be  applied  to  given  types;	103	None	replace
89	[BUG]  [BUGGY]  int  solvedCols  =  Math.sqrt(lmPar);  [CE]  possible  loss  of  precision  [FE]                AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  int  solvedCols  =  Math.sqrt(lmPar);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	int  solvedCols  =  Math.sqrt(lmPar);	          double    solvedCols    =    Math.sqrt(lmPar);    int    solvedCols    =    Math.sqrt(lmPar);    	non-compiled	[CE]  possible  loss  of  precision	108	None	replace
90	[BUG]  [BUGGY]  int  solvedCols  =  Math.sqrt(lmPar,  gNorm);  [CE]  method  sqrt  in  class  Math  cannot  be  applied  to  given  types;  [FE]                  AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  int  solvedCols  =  Math.sqrt(lmPar,  gNorm);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	int  solvedCols  =  Math.sqrt(lmPar,  gNorm);	          double    solvedCols    =    Math.sqrt(lmPar);    int    solvedCols    =    Math.sqrt(lmPar);    	non-compiled	[CE]  method  sqrt  in  class  Math  cannot  be  applied  to  given  types;	108	None	replace
91	[BUG]  [BUGGY]  double  permutation  =  Math.max(2.2251e-308,  0.001  *  paru,  countdown  +  1);  [CE]  no  suitable  method  found  for  max(double,double,int)  [FE]              AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  permutation  =  Math.max(2.2251e-308,  0.001  *  paru,  countdown  +  1);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double  permutation  =  Math.max(2.2251e-308,  0.001  *  paru,  countdown  +  1);	  double    permutation    =    Math.max(2.2251e-308,    0.001    *    paru    +    1);    	non-compiled	[CE]  no  suitable  method  found  for  max(double,double,int)	63	None	replace
92	[BUG]  [BUGGY]  double  permutation  =  Math.max(2.2251e-308,  0.001  *  paru  +  1,  lmPar);  [CE]  no  suitable  method  found  for  max(double,double,double)  [FE]                AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  permutation  =  Math.max(2.2251e-308,  0.001  *  paru  +  1,  lmPar);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double  permutation  =  Math.max(2.2251e-308,  0.001  *  paru  +  1,  lmPar);	  double    permutation    =    Math.max(2.2251e-308,    0.001    *    paru    +    1);    	non-compiled	[CE]  no  suitable  method  found  for  max(double,double,double)	63	None	replace
93	[BUG]  [BUGGY]  double  permutation  =  Math.max(2.2251e-308,  0.001  *  paru  +  2);  [CE]  array  required,  but  double  found  [FE]                  AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  permutation  =  Math.max(2.2251e-308,  0.001  *  paru  +  2);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double  permutation  =  Math.max(2.2251e-308,  0.001  *  paru  +  2);	  double    permutation    =    Math.max(2.2251e-308,    0.001    *    paru    +    1);    	non-compiled	[CE]  array  required,  but  double  found	63	None	replace
94	[BUG]  [BUGGY]  double  solvedCols  =  Math.max(2.0,  0.001  *  lmPar);  [CE]  cannot  find  symbol  sPar  [FE]            AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  solvedCols  =  Math.max(2.0,  0.001  *  lmPar);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double  solvedCols  =  Math.max(2.0,  0.001  *  lmPar);	  double    solvedCols    =    Math.max(2.0,    0.001    *    paru);    	non-compiled	[CE]  cannot  find  symbol  sPar	9	None	replace
95	[BUG]  [BUGGY]  double  solvedCols  =  Math.max(2.0,  0.001  *  parl);  [CE]  cannot  find  symbol  sPar  [FE]              AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  solvedCols  =  Math.max(2.0,  0.001  *  parl);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double  solvedCols  =  Math.max(2.0,  0.001  *  parl);	  double    solvedCols    =    Math.max(2.0,    0.001    *    paru);    	non-compiled	[CE]  cannot  find  symbol  sPar	9	None	replace
96	[BUG]  [BUGGY]  double  solvedCols  =  Math.max(2.0,  0.001  *  parm);  [CE]  cannot  find  symbol  parm  [FE]                AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  solvedCols  =  Math.max(2.0,  0.001  *  parm);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double  solvedCols  =  Math.max(2.0,  0.001  *  parm);	  double    solvedCols    =    Math.max(2.0,    0.001    *    paru);    	non-compiled	[CE]  cannot  find  symbol  parm	9	None	replace
97	[BUG]  [BUGGY]  Double  solvedCols  =  Math.max(2.0251e-308,  0.001  *  paru);  [CE]  cannot  find  symbol  sPar  [FE]            AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  Double  solvedCols  =  Math.max(2.0251e-308,  0.001  *  paru);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	Double  solvedCols  =  Math.max(2.0251e-308,  0.001  *  paru);	          double    solvedCols    =    Math.max(2.0251e-308,    0.001    *    paru);    Double    solvedCols    =    Math.max(2.0251e-308,    0.001    *    paru);    	non-compiled	[CE]  cannot  find  symbol  sPar	41	None	replace
98	[BUG]  [BUGGY]  double  solvedCols  =  Math.max(2.0251e-3,  0.001  *  paru);  [CE]  cannot  find  symbol  sPar  [FE]              AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  solvedCols  =  Math.max(2.0251e-3,  0.001  *  paru);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double  solvedCols  =  Math.max(2.0251e-3,  0.001  *  paru);	          double    solvedCols    =    Math.max(2.0251e-308,    0.001    *    paru);    Double    solvedCols    =    Math.max(2.0251e-308,    0.001    *    paru);    	non-compiled	[CE]  cannot  find  symbol  sPar	41	None	replace
99	[BUG]  [BUGGY]          lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    double  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  double  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  [CE]  variable  lmPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]    AssertionFailedError    [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]          lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    double  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  double  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	                lmPar        =        Math.max(2.0251e-308,        0.001        *        paru);        double    lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  double  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);	  	non-compiled	[CE]  variable  lmPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	138	None	add
100	[BUG]  [BUGGY]          lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    double  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  double  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  double  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  [CE]  variable  lmPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]      AssertionFailedError    [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]          lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    double  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  double  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  double  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	                lmPar        =        Math.max(2.0251e-308,        0.001        *        paru);        double    lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    double  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  double  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);	  	non-compiled	[CE]  variable  lmPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	138	None	add
101	[BUG]  [BUGGY]          lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    double  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  double  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  [CE]  variable  lmPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]        AssertionFailedError    [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]          lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    double  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  double  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	                lmPar        =        Math.max(2.0251e-308,        0.001        *        paru);        double    lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  double  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);	  	non-compiled	[CE]  variable  lmPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	138	None	add
102	[BUG]  [BUGGY]          lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    double  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  double  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  [CE]  variable  lmPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]          AssertionFailedError    [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]          lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    double  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  double  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	                lmPar        =        Math.max(2.0251e-308,        0.001        *        paru);        double    lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  double  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);	  	non-compiled	[CE]  variable  lmPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	138	None	add
103	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]          lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	add	                lmPar        =        Math.max(2.0251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	51	12	add
104	[BUG]  [BUGGY]          lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]          lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	                lmPar        =        Math.max(2.0251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	51	12	add
105	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]          lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	add	                lmPar        =        Math.max(2.0251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	51	12	add
106	[BUG]  [BUGGY]          lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]          lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	                lmPar        =        Math.max(2.0251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	51	12	add
107	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]          lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	add	                lmPar        =        Math.max(2.0251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	51	12	add
108	[BUG]  [BUGGY]          lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]          lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	                lmPar        =        Math.max(2.0251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	51	12	add
109	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]          lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	add	                lmPar        =        Math.max(2.0251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	51	12	add
110	[BUG]  [BUGGY]          lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]          lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	                lmPar        =        Math.max(2.0251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	51	12	add
111	[BUG]  [BUGGY]  double  solvedCols  =  Math.log(lmPar);  [CE]  cannot  find  symbol  sPar  [FE]    AssertionFailedError    [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  solvedCols  =  Math.log(lmPar);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double  solvedCols  =  Math.log(lmPar);	          double    solvedCols    =    Math.sqrt(lmPar);    double    solveCols    =    Math.sqrt(lmPar);    	non-compiled	[CE]  cannot  find  symbol  sPar	118	None	replace
112	[BUG]  [BUGGY]  double  solvedCols  =  Math.abs(lmPar);  [CE]  cannot  find  symbol  sPar  [FE]      AssertionFailedError    [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  solvedCols  =  Math.abs(lmPar);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double  solvedCols  =  Math.abs(lmPar);	          double    solvedCols    =    Math.sqrt(lmPar);    double    solveCols    =    Math.sqrt(lmPar);    	non-compiled	[CE]  cannot  find  symbol  sPar	118	None	replace
113	[BUG]  [BUGGY]  double  solvedCols  =  Math.max(2.2251e-408,  0.001  *  paru);  [CE]  floating  point  number  too  small  [FE]        AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  solvedCols  =  Math.max(2.2251e-408,  0.001  *  paru);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double  solvedCols  =  Math.max(2.2251e-408,  0.001  *  paru);	  double    solvedCols    =    Math.max(2.2251e-308,    0.001    *    lmPar);    	non-compiled	[CE]  floating  point  number  too  small	7	None	replace
114	[BUG]  [BUGGY]  double  diag  =  Math.max(2.2251e-308,  0.001  *  lmPar  +  1);  [CE]  variable  diag  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]              AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  diag  =  Math.max(2.2251e-308,  0.001  *  lmPar  +  1);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double  diag  =  Math.max(2.2251e-308,  0.001  *  lmPar  +  1);	  double    diag    =    Math.max(2.2251e-308,    0.001    *    paru    +    1);    	non-compiled	[CE]  variable  diag  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	135	None	replace
115	[BUG]  [BUGGY]  double  diag  =  Math.max(2.2251e-308,  0.001  *  parmPar  +  1);  [CE]  variable  diag  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]                AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  diag  =  Math.max(2.2251e-308,  0.001  *  parmPar  +  1);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double  diag  =  Math.max(2.2251e-308,  0.001  *  parmPar  +  1);	  double    diag    =    Math.max(2.2251e-308,    0.001    *    paru    +    1);    	non-compiled	[CE]  variable  diag  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	135	None	replace
116	[BUG]  [BUGGY]  double  diag  =  Math.max(2.2251e-308,  0.001  *  paru  +  2);  [CE]  variable  diag  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]                  AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  diag  =  Math.max(2.2251e-308,  0.001  *  paru  +  2);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double  diag  =  Math.max(2.2251e-308,  0.001  *  paru  +  2);	  double    diag    =    Math.max(2.2251e-308,    0.001    *    paru    +    1);    	non-compiled	[CE]  variable  diag  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	135	None	replace
117	[BUG]  [BUGGY]  double  sPar  =  Math.sqrt(gNorm,  diag);  [CE]  method  sqrt  in  class  Math  cannot  be  applied  to  given  types;  [FE]            AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  sPar  =  Math.sqrt(gNorm,  diag);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double  sPar  =  Math.sqrt(gNorm,  diag);	  double    sPar    =    Math.sqrt(diag,    gNorm);    	non-compiled	[CE]  method  sqrt  in  class  Math  cannot  be  applied  to  given  types;	132	None	replace
118	[BUG]  [BUGGY]  double  sPar  =  Math.sqrt(diag,  lmPar,  gNorm);  [CE]  method  sqrt  in  class  Math  cannot  be  applied  to  given  types;  [FE]              AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  sPar  =  Math.sqrt(diag,  lmPar,  gNorm);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double  sPar  =  Math.sqrt(diag,  lmPar,  gNorm);	  double    sPar    =    Math.sqrt(diag,    gNorm);    	non-compiled	[CE]  method  sqrt  in  class  Math  cannot  be  applied  to  given  types;	132	None	replace
119	[BUG]  [BUGGY]  double  sPar  =  Math.sqrt(gNorm,  diagnostic);  [CE]  cannot  find  symbol  diagnostic  [FE]                AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  sPar  =  Math.sqrt(gNorm,  diagnostic);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double  sPar  =  Math.sqrt(gNorm,  diagnostic);	  double    sPar    =    Math.sqrt(diag,    gNorm);    	non-compiled	[CE]  cannot  find  symbol  diagnostic	132	None	replace
120	[BUG]  [BUGGY]  double  sPar  =  Math.sqrt(dxNorm);  double  sPar  =  Math.sqrt(dxNorm);  [CE]  variable  sPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]    AssertionFailedError    [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  sPar  =  Math.sqrt(dxNorm);  double  sPar  =  Math.sqrt(dxNorm);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double    sPar    =    Math.sqrt(dxNorm);    double  sPar  =  Math.sqrt(dxNorm);	  	non-compiled	[CE]  variable  sPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	85	None	add
121	[BUG]  [BUGGY]  double  sPar  =  Math.sqrt(dxNorm);  Double  sPar  =  Math.sqrt(dxNorm);  [CE]  variable  sPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]      AssertionFailedError    [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  sPar  =  Math.sqrt(dxNorm);  Double  sPar  =  Math.sqrt(dxNorm);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double    sPar    =    Math.sqrt(dxNorm);    Double  sPar  =  Math.sqrt(dxNorm);	  	non-compiled	[CE]  variable  sPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	85	None	add
122	[BUG]  [BUGGY]  double  sPar  =  Math.sqrt(dxNorm);  int  sPar  =  Math.sqrt(dxNorm);  [CE]  variable  sPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]        AssertionFailedError    [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  sPar  =  Math.sqrt(dxNorm);  int  sPar  =  Math.sqrt(dxNorm);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double    sPar    =    Math.sqrt(dxNorm);    int  sPar  =  Math.sqrt(dxNorm);	  	non-compiled	[CE]  variable  sPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	85	None	add
123	[BUG]  [BUGGY]  double  sPar  =  Math.sqrt(dxNorm);  sPar  =  Math.sqrt(dxNorm);  [CE]  variable  sPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]          AssertionFailedError    [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  sPar  =  Math.sqrt(dxNorm);  sPar  =  Math.sqrt(dxNorm);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double    sPar    =    Math.sqrt(dxNorm);    sPar  =  Math.sqrt(dxNorm);	  	non-compiled	[CE]  variable  sPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	85	None	add
124	[BUG]  [BUGGY]  double  permutation  =  Math.sqrt(lmPar,  gNorm,  1);  [CE]  method  sqrt  in  class  Math  cannot  be  applied  to  given  types;  [FE]                    AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  permutation  =  Math.sqrt(lmPar,  gNorm,  1);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double  permutation  =  Math.sqrt(lmPar,  gNorm,  1);	  double    permutation    =    Math.sqrt(lmPar,    1);    	non-compiled	[CE]  method  sqrt  in  class  Math  cannot  be  applied  to  given  types;	78	None	replace
125	[BUG]  [BUGGY]  double  permutation  =  Math.sqrt(lmPar,  0);  [CE]  method  sqrt  in  class  Math  cannot  be  applied  to  given  types;  [FE]                      AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  permutation  =  Math.sqrt(lmPar,  0);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double  permutation  =  Math.sqrt(lmPar,  0);	  double    permutation    =    Math.sqrt(lmPar,    1);    	non-compiled	[CE]  method  sqrt  in  class  Math  cannot  be  applied  to  given  types;	78	None	replace
126	[BUG]  [BUGGY]  double  permutation  =  Math.sqrt(lmPar,  2);  [CE]  method  sqrt  in  class  Math  cannot  be  applied  to  given  types;  [FE]                        AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  permutation  =  Math.sqrt(lmPar,  2);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double  permutation  =  Math.sqrt(lmPar,  2);	  double    permutation    =    Math.sqrt(lmPar,    1);    	non-compiled	[CE]  method  sqrt  in  class  Math  cannot  be  applied  to  given  types;	78	None	replace
127	[BUG]  [BUGGY]  double  permutation  =  Math.sqrt(lmPar,  2,  1);  [CE]  method  sqrt  in  class  Math  cannot  be  applied  to  given  types;  [FE]                          AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  permutation  =  Math.sqrt(lmPar,  2,  1);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double  permutation  =  Math.sqrt(lmPar,  2,  1);	  double    permutation    =    Math.sqrt(lmPar,    1);    	non-compiled	[CE]  method  sqrt  in  class  Math  cannot  be  applied  to  given  types;	78	None	replace
128	[BUG]  [BUGGY]  double  solvedCols  =  Math.max(2.0251e-308,.001  *  paru);  [CE]  cannot  find  symbol  sPar  [FE]                AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  solvedCols  =  Math.max(2.0251e-308,.001  *  paru);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double  solvedCols  =  Math.max(2.0251e-308,.001  *  paru);	          double    solvedCols    =    Math.max(2.0251e-308,    0.001    *    paru);    double    solvedCols    =    Math.max(2.0251e-308,.001    *    paru);    	non-compiled	[CE]  cannot  find  symbol  sPar	43	None	replace
129	[BUG]  [BUGGY]  double  solvedCols  =  Math.max(2.0251e-3,.001  *  paru);  [CE]  cannot  find  symbol  sPar  [FE]                  AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  solvedCols  =  Math.max(2.0251e-3,.001  *  paru);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double  solvedCols  =  Math.max(2.0251e-3,.001  *  paru);	          double    solvedCols    =    Math.max(2.0251e-308,    0.001    *    paru);    double    solvedCols    =    Math.max(2.0251e-308,.001    *    paru);    	non-compiled	[CE]  cannot  find  symbol  sPar	43	None	replace
130	[BUG]  [BUGGY]  double  solvedCols  =  Math.max(2.0252e-308,.001  *  paru);  [CE]  cannot  find  symbol  sPar  [FE]                    AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  solvedCols  =  Math.max(2.0252e-308,.001  *  paru);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double  solvedCols  =  Math.max(2.0252e-308,.001  *  paru);	          double    solvedCols    =    Math.max(2.0251e-308,    0.001    *    paru);    double    solvedCols    =    Math.max(2.0251e-308,.001    *    paru);    	non-compiled	[CE]  cannot  find  symbol  sPar	43	None	replace
131	[BUG]  [BUGGY]  lmPar  =  Math.max(2.2251e-308,.001  *  paru);  [CE]  cannot  find  symbol  sPar  [FE]    AssertionFailedError    [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  lmPar  =  Math.max(2.2251e-308,.001  *  paru);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	lmPar  =  Math.max(2.2251e-308,.001  *  paru);	          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar    =    Math.max(2.2251e-308,.001    *    paru);    	non-compiled	[CE]  cannot  find  symbol  sPar	116	None	replace
132	[BUG]  [BUGGY]  double  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  [CE]  cannot  find  symbol  sPar  [FE]    AssertionFailedError    [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);	          lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    double    lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    	non-compiled	[CE]  cannot  find  symbol  sPar	139	None	replace
133	[BUG]  [BUGGY]  double  solvedCols  =  Math.sqrt(lmPar,  dxNorm);  [CE]  method  sqrt  in  class  Math  cannot  be  applied  to  given  types;  [FE]        AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  solvedCols  =  Math.sqrt(lmPar,  dxNorm);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double  solvedCols  =  Math.sqrt(lmPar,  dxNorm);	          double    solvedCols    =    Math.sqrt(lmPar);    double    solvedCols    =    Math.sqrt(lmPar);    	non-compiled	[CE]  method  sqrt  in  class  Math  cannot  be  applied  to  given  types;	102	None	replace
134	[BUG]  [BUGGY]  lmPar  =  Math.max(2.0251e-308,.001  *  paru);  [CE]  cannot  find  symbol  sPar  [FE]    AssertionFailedError    [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  lmPar  =  Math.max(2.0251e-308,.001  *  paru);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	lmPar  =  Math.max(2.0251e-308,.001  *  paru);	          lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    lmPar    =    Math.max(2.0251e-308,.001    *    paru);    	non-compiled	[CE]  cannot  find  symbol  sPar	57	None	replace
135	[BUG]  [BUGGY]  double  solvedCols  =  Math.min(solvedCols,  lmPar);  [CE]  cannot  find  symbol  sPar  [FE]                    AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  solvedCols  =  Math.min(solvedCols,  lmPar);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double  solvedCols  =  Math.min(solvedCols,  lmPar);	  int    solvedCols    =    Math.min(solvedCols,    lmPar);    	non-compiled	[CE]  cannot  find  symbol  sPar	141	None	replace
136	[BUG]  [BUGGY]  long  solvedCols  =  Math.min(solvedCols,  lmPar);  [CE]  possible  loss  of  precision  [FE]                      AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  long  solvedCols  =  Math.min(solvedCols,  lmPar);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	long  solvedCols  =  Math.min(solvedCols,  lmPar);	  int    solvedCols    =    Math.min(solvedCols,    lmPar);    	non-compiled	[CE]  possible  loss  of  precision	141	None	replace
137	[BUG]  [BUGGY]  Double  solvedCols  =  Math.min(solvedCols,  lmPar);  [CE]  cannot  find  symbol  sPar  [FE]                        AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  Double  solvedCols  =  Math.min(solvedCols,  lmPar);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	Double  solvedCols  =  Math.min(solvedCols,  lmPar);	  int    solvedCols    =    Math.min(solvedCols,    lmPar);    	non-compiled	[CE]  cannot  find  symbol  sPar	141	None	replace
138	[BUG]  [BUGGY]  double  mPar  =  Math.sqrt(lmPar);  [CE]  cannot  find  symbol  sPar  [FE]        AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  mPar  =  Math.sqrt(lmPar);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double  mPar  =  Math.sqrt(lmPar);	  double    sPar    =    Math.sqrt(mPar);    	non-compiled	[CE]  cannot  find  symbol  sPar	161	None	replace
139	[BUG]  [BUGGY]  double  solvedCols  =  Math.sqrt(diag,  lmPar);  [CE]  method  sqrt  in  class  Math  cannot  be  applied  to  given  types;  [FE]        AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  solvedCols  =  Math.sqrt(diag,  lmPar);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double  solvedCols  =  Math.sqrt(diag,  lmPar);	  double    solvedCols    =    Math.sqrt(diag);    	non-compiled	[CE]  method  sqrt  in  class  Math  cannot  be  applied  to  given  types;	122	None	replace
140	[BUG]  [BUGGY]  double  solvedCols  =  Math.sqrt(lmPar,  diag);  [CE]  method  sqrt  in  class  Math  cannot  be  applied  to  given  types;  [FE]          AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  solvedCols  =  Math.sqrt(lmPar,  diag);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double  solvedCols  =  Math.sqrt(lmPar,  diag);	  double    solvedCols    =    Math.sqrt(diag);    	non-compiled	[CE]  method  sqrt  in  class  Math  cannot  be  applied  to  given  types;	122	None	replace
141	[BUG]  [BUGGY]  double  solvedCols  =  Math.sqrt(lmPar,  diagnostic);  [CE]  cannot  find  symbol  diagnostic  [FE]            AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  solvedCols  =  Math.sqrt(lmPar,  diagnostic);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double  solvedCols  =  Math.sqrt(lmPar,  diagnostic);	  double    solvedCols    =    Math.sqrt(diag);    	non-compiled	[CE]  cannot  find  symbol  diagnostic	122	None	replace
142	[BUG]  [BUGGY]  double  solvedCols  =  Math.sqrt(solvedCols,  lmPar);  [CE]  method  sqrt  in  class  Math  cannot  be  applied  to  given  types;  [FE]              AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  solvedCols  =  Math.sqrt(solvedCols,  lmPar);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double  solvedCols  =  Math.sqrt(solvedCols,  lmPar);	  double    solvedCols    =    Math.sqrt(diag);    	non-compiled	[CE]  method  sqrt  in  class  Math  cannot  be  applied  to  given  types;	122	None	replace
143	[BUG]  [BUGGY]  long  solveCols  =  Math.max(2.251e-308,  0.001  *  paru);  [CE]  possible  loss  of  precision  [FE]                  AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  long  solveCols  =  Math.max(2.251e-308,  0.001  *  paru);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	long  solveCols  =  Math.max(2.251e-308,  0.001  *  paru);	  int    solveCols    =    Math.max(2.251e-308,    0.001    *    paru);    	non-compiled	[CE]  possible  loss  of  precision	152	None	replace
144	[BUG]  [BUGGY]  double  solveCols  =  Math.max(2.51e-308,  0.001  *  paru);  [CE]  cannot  find  symbol  sPar  [FE]                    AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  solveCols  =  Math.max(2.51e-308,  0.001  *  paru);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double  solveCols  =  Math.max(2.51e-308,  0.001  *  paru);	  int    solveCols    =    Math.max(2.251e-308,    0.001    *    paru);    	non-compiled	[CE]  cannot  find  symbol  sPar	152	None	replace
145	[BUG]  [BUGGY]  double  diag  =  Math.max(2.2252e-308,  0.001  *  lmPar);  [CE]  variable  diag  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]            AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  diag  =  Math.max(2.2252e-308,  0.001  *  lmPar);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double  diag  =  Math.max(2.2252e-308,  0.001  *  lmPar);	  double    diag    =    Math.max(2.2252e-308,    0.001    *    paru);    	non-compiled	[CE]  variable  diag  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	134	None	replace
146	[BUG]  [BUGGY]  double  diag  =  Math.max(2.2252e-308,  0.001  *  paru,  countdown);  [CE]  variable  diag  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]              AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  diag  =  Math.max(2.2252e-308,  0.001  *  paru,  countdown);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double  diag  =  Math.max(2.2252e-308,  0.001  *  paru,  countdown);	  double    diag    =    Math.max(2.2252e-308,    0.001    *    paru);    	non-compiled	[CE]  variable  diag  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	134	None	replace
147	[BUG]  [BUGGY]  double  diag  =  Math.max(2.2252e-308,  0.001  *  parm);  [CE]  variable  diag  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]                AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  diag  =  Math.max(2.2252e-308,  0.001  *  parm);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double  diag  =  Math.max(2.2252e-308,  0.001  *  parm);	  double    diag    =    Math.max(2.2252e-308,    0.001    *    paru);    	non-compiled	[CE]  variable  diag  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	134	None	replace
148	[BUG]  [BUGGY]  int  sPar  =  Math.sqrt(lmPar,  gNorm);  [CE]  method  sqrt  in  class  Math  cannot  be  applied  to  given  types;  [FE]            AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  int  sPar  =  Math.sqrt(lmPar,  gNorm);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	int  sPar  =  Math.sqrt(lmPar,  gNorm);	  double    sPar    =    Math.sqrt(gNorm);    int    sPar    =    Math.sqrt(gNorm);    	non-compiled	[CE]  method  sqrt  in  class  Math  cannot  be  applied  to  given  types;	3	None	replace
149	[BUG]  [BUGGY]  double  sPar  =  Math.sqrt(lmPar,  gNorm  +  3);  [CE]  method  sqrt  in  class  Math  cannot  be  applied  to  given  types;  [FE]        AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  sPar  =  Math.sqrt(lmPar,  gNorm  +  3);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double  sPar  =  Math.sqrt(lmPar,  gNorm  +  3);	  double    sPar    =    Math.sqrt(lmPar    +    3);    double    sPar    =    Math.sqrt(lmPar    +    3);    	non-compiled	[CE]  method  sqrt  in  class  Math  cannot  be  applied  to  given  types;	34	None	replace
150	[BUG]  [BUGGY]  lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  [CE]  cannot  find  symbol  sPar  [FE]    AssertionFailedError    [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	lmPar  =  Math.max(2.252e-308,  0.001  *  paru);	          lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar    =    Math.max(2.252e-308,    0.001    *    paru);    	non-compiled	[CE]  cannot  find  symbol  sPar	50	None	replace
151	[BUG]  [BUGGY]  double  sPar  =  Math.sqrt(gNorm,  lmPar,  dxNorm);  [CE]  method  sqrt  in  class  Math  cannot  be  applied  to  given  types;  [FE]              AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  sPar  =  Math.sqrt(gNorm,  lmPar,  dxNorm);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double  sPar  =  Math.sqrt(gNorm,  lmPar,  dxNorm);	  double    sPar    =    Math.sqrt(gNorm,    lmPar);    	non-compiled	[CE]  method  sqrt  in  class  Math  cannot  be  applied  to  given  types;	73	None	replace
152	[BUG]  [BUGGY]  double  sPar  =  Math.sqrt(dxNorm,  lmPar);  [CE]  method  sqrt  in  class  Math  cannot  be  applied  to  given  types;  [FE]                AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  sPar  =  Math.sqrt(dxNorm,  lmPar);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double  sPar  =  Math.sqrt(dxNorm,  lmPar);	  double    sPar    =    Math.sqrt(gNorm,    lmPar);    	non-compiled	[CE]  method  sqrt  in  class  Math  cannot  be  applied  to  given  types;	73	None	replace
153	[BUG]  [BUGGY]  double  sPar  =  Math.sqrt(gNorm,  lmPar,  lmPar);  [CE]  method  sqrt  in  class  Math  cannot  be  applied  to  given  types;  [FE]                  AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  sPar  =  Math.sqrt(gNorm,  lmPar,  lmPar);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double  sPar  =  Math.sqrt(gNorm,  lmPar,  lmPar);	  double    sPar    =    Math.sqrt(gNorm,    lmPar);    	non-compiled	[CE]  method  sqrt  in  class  Math  cannot  be  applied  to  given  types;	73	None	replace
154	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]          lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	add	                lmPar        =        Math.max(2.0251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.0252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	53	12	add
155	[BUG]  [BUGGY]          lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]          lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	                lmPar        =        Math.max(2.0251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.0252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	53	12	add
156	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]          lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	add	                lmPar        =        Math.max(2.0251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.0252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	53	12	add
157	[BUG]  [BUGGY]          lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]          lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	                lmPar        =        Math.max(2.0251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.0252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	53	12	add
158	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]          lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	add	                lmPar        =        Math.max(2.0251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.0252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	53	12	add
159	[BUG]  [BUGGY]          lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]          lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	                lmPar        =        Math.max(2.0251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.0252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	53	12	add
160	[BUG]  [BUGGY]          lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  Paru);  lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  [CE]  cannot  find  symbol  Paru  [FE]          AssertionFailedError    [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]          lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  Paru);  lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	                lmPar        =        Math.max(2.0251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.0252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0251e-308,  0.001  *  Paru);  lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);	  	non-compiled	[CE]  cannot  find  symbol  Paru	53	None	add
161	[BUG]  [BUGGY]  double  permutation  =  Math.sqrt(lmPar,  dxNorm,  gNorm);  [CE]  method  sqrt  in  class  Math  cannot  be  applied  to  given  types;  [FE]                AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  permutation  =  Math.sqrt(lmPar,  dxNorm,  gNorm);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double  permutation  =  Math.sqrt(lmPar,  dxNorm,  gNorm);	  double    permutation    =    Math.sqrt(lmPar,    gNorm);    	non-compiled	[CE]  method  sqrt  in  class  Math  cannot  be  applied  to  given  types;	76	None	replace
162	[BUG]  [BUGGY]  double  permutation  =  Math.sqrt(lmPar,  gNorm,  dxNorm);  [CE]  method  sqrt  in  class  Math  cannot  be  applied  to  given  types;  [FE]                  AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  permutation  =  Math.sqrt(lmPar,  gNorm,  dxNorm);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double  permutation  =  Math.sqrt(lmPar,  gNorm,  dxNorm);	  double    permutation    =    Math.sqrt(lmPar,    gNorm);    	non-compiled	[CE]  method  sqrt  in  class  Math  cannot  be  applied  to  given  types;	76	None	replace
163	[BUG]  [BUGGY]  double  permutation  =  Math.sqrt(gNorm,  lmPar);  [CE]  method  sqrt  in  class  Math  cannot  be  applied  to  given  types;  [FE]                    AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  permutation  =  Math.sqrt(gNorm,  lmPar);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double  permutation  =  Math.sqrt(gNorm,  lmPar);	  double    permutation    =    Math.sqrt(lmPar,    gNorm);    	non-compiled	[CE]  method  sqrt  in  class  Math  cannot  be  applied  to  given  types;	76	None	replace
164	[BUG]  [BUGGY]  double  permutation  =  Math.sqrt(lmPar,  lmPar,  gNorm);  [CE]  method  sqrt  in  class  Math  cannot  be  applied  to  given  types;  [FE]                      AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  permutation  =  Math.sqrt(lmPar,  lmPar,  gNorm);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double  permutation  =  Math.sqrt(lmPar,  lmPar,  gNorm);	  double    permutation    =    Math.sqrt(lmPar,    gNorm);    	non-compiled	[CE]  method  sqrt  in  class  Math  cannot  be  applied  to  given  types;	76	None	replace
165	[BUG]  [BUGGY]  double  solveCols  =  Math.max(2.2252e-308,  0.001  *  lmPar);  [CE]  cannot  find  symbol  sPar  [FE]                AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  solveCols  =  Math.max(2.2252e-308,  0.001  *  lmPar);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double  solveCols  =  Math.max(2.2252e-308,  0.001  *  lmPar);	  double    solveCols    =    Math.max(2.2252e-308,    0.001    *    paru);    	non-compiled	[CE]  cannot  find  symbol  sPar	16	None	replace
166	[BUG]  [BUGGY]  double  solveCols  =  Math.max(2.2252e-308,  0.001  *  solvedCols);  [CE]  cannot  find  symbol  sPar  [FE]                  AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  solveCols  =  Math.max(2.2252e-308,  0.001  *  solvedCols);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double  solveCols  =  Math.max(2.2252e-308,  0.001  *  solvedCols);	  double    solveCols    =    Math.max(2.2252e-308,    0.001    *    paru);    	non-compiled	[CE]  cannot  find  symbol  sPar	16	None	replace
167	[BUG]  [BUGGY]  double  solveCols  =  Math.max(2.2252e-308,  0.001  *  parm);  [CE]  cannot  find  symbol  parm  [FE]                    AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  solveCols  =  Math.max(2.2252e-308,  0.001  *  parm);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double  solveCols  =  Math.max(2.2252e-308,  0.001  *  parm);	  double    solveCols    =    Math.max(2.2252e-308,    0.001    *    paru);    	non-compiled	[CE]  cannot  find  symbol  parm	16	None	replace
168	[BUG]  [BUGGY]  double  sPar  =  Math.sqrt(lmPar  +  1,  lmPar);  [CE]  method  sqrt  in  class  Math  cannot  be  applied  to  given  types;  [FE]        AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  sPar  =  Math.sqrt(lmPar  +  1,  lmPar);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double  sPar  =  Math.sqrt(lmPar  +  1,  lmPar);	  double    sPar    =    Math.sqrt(lmPar    +    1);    double    sPar    =    Math.sqrt(lmPar    +    1);    	non-compiled	[CE]  method  sqrt  in  class  Math  cannot  be  applied  to  given  types;	29	None	replace
169	[BUG]  [BUGGY]  double  permutation  =  Math.max(2.2251e-308,  0.001  *  paru,  countdown,  lmPar);  [CE]  no  suitable  method  found  for  max(double,double,int,double)  [FE]            AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  permutation  =  Math.max(2.2251e-308,  0.001  *  paru,  countdown,  lmPar);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double  permutation  =  Math.max(2.2251e-308,  0.001  *  paru,  countdown,  lmPar);	  double    permutation    =    Math.max(2.2251e-308,    0.001    *    paru,    countdown);    	non-compiled	[CE]  no  suitable  method  found  for  max(double,double,int,double)	62	None	replace
170	[BUG]  [BUGGY]  double  permutation  =  Math.max(2.2251e-308,  0.001  *  paru,  countdown,  1);  [CE]  no  suitable  method  found  for  max(double,double,int,int)  [FE]              AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  permutation  =  Math.max(2.2251e-308,  0.001  *  paru,  countdown,  1);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double  permutation  =  Math.max(2.2251e-308,  0.001  *  paru,  countdown,  1);	  double    permutation    =    Math.max(2.2251e-308,    0.001    *    paru,    countdown);    	non-compiled	[CE]  no  suitable  method  found  for  max(double,double,int,int)	62	None	replace
171	[BUG]  [BUGGY]          double    solvedCols    =    Math.sqrt(lmPar);    double  solveCols  =  Math.sqrt(lmPar);  double  solvedCols  =  Math.sqrt(lmPar);  double  solveCols  =  Math.sqrt(lmPar);  [CE]  variable  solvedCols  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]    AssertionFailedError    [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]          double    solvedCols    =    Math.sqrt(lmPar);    double  solveCols  =  Math.sqrt(lmPar);  double  solvedCols  =  Math.sqrt(lmPar);  double  solveCols  =  Math.sqrt(lmPar);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	                double        solvedCols        =        Math.sqrt(lmPar);        double    solveCols    =    Math.sqrt(lmPar);    double  solvedCols  =  Math.sqrt(lmPar);  double  solveCols  =  Math.sqrt(lmPar);	  	non-compiled	[CE]  variable  solvedCols  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	117	None	add
172	[BUG]  [BUGGY]          double    solvedCols    =    Math.sqrt(lmPar);    double  solveCols  =  Math.sqrt(lmPar);  Double  solvedCols  =  Math.sqrt(lmPar);  double  solveCols  =  Math.sqrt(lmPar);  [CE]  variable  solvedCols  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]      AssertionFailedError    [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]          double    solvedCols    =    Math.sqrt(lmPar);    double  solveCols  =  Math.sqrt(lmPar);  Double  solvedCols  =  Math.sqrt(lmPar);  double  solveCols  =  Math.sqrt(lmPar);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	                double        solvedCols        =        Math.sqrt(lmPar);        double    solveCols    =    Math.sqrt(lmPar);    Double  solvedCols  =  Math.sqrt(lmPar);  double  solveCols  =  Math.sqrt(lmPar);	  	non-compiled	[CE]  variable  solvedCols  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	117	None	add
173	[BUG]  [BUGGY]          double    solvedCols    =    Math.sqrt(lmPar);    double  solveCols  =  Math.sqrt(lmPar);  double  solveCols  =  Math.sqrt(lmPar);  double  solveCols  =  Math.sqrt(lmPar);  [CE]  variable  solveCols  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]        AssertionFailedError    [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]          double    solvedCols    =    Math.sqrt(lmPar);    double  solveCols  =  Math.sqrt(lmPar);  double  solveCols  =  Math.sqrt(lmPar);  double  solveCols  =  Math.sqrt(lmPar);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	                double        solvedCols        =        Math.sqrt(lmPar);        double    solveCols    =    Math.sqrt(lmPar);    double  solveCols  =  Math.sqrt(lmPar);  double  solveCols  =  Math.sqrt(lmPar);	  	non-compiled	[CE]  variable  solveCols  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	117	None	add
174	[BUG]  [BUGGY]          double    solvedCols    =    Math.sqrt(lmPar);    double  solveCols  =  Math.sqrt(lmPar);  double  resolvedCols  =  Math.sqrt(lmPar);  double  solveCols  =  Math.sqrt(lmPar);  [CE]  variable  solveCols  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]          AssertionFailedError    [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]          double    solvedCols    =    Math.sqrt(lmPar);    double  solveCols  =  Math.sqrt(lmPar);  double  resolvedCols  =  Math.sqrt(lmPar);  double  solveCols  =  Math.sqrt(lmPar);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	                double        solvedCols        =        Math.sqrt(lmPar);        double    solveCols    =    Math.sqrt(lmPar);    double  resolvedCols  =  Math.sqrt(lmPar);  double  solveCols  =  Math.sqrt(lmPar);	  	non-compiled	[CE]  variable  solveCols  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	117	None	add
175	[BUG]  [BUGGY]  double  sPar  =  Math.sqrt(dxNorm,  diag);  [CE]  method  sqrt  in  class  Math  cannot  be  applied  to  given  types;  [FE]              AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  sPar  =  Math.sqrt(dxNorm,  diag);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double  sPar  =  Math.sqrt(dxNorm,  diag);	  double    sPar    =    Math.sqrt(diag,    dxNorm);    	non-compiled	[CE]  method  sqrt  in  class  Math  cannot  be  applied  to  given  types;	133	None	replace
176	[BUG]  [BUGGY]  double  sPar  =  Math.sqrt(gNorm,  dxNorm);  [CE]  method  sqrt  in  class  Math  cannot  be  applied  to  given  types;  [FE]                AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  sPar  =  Math.sqrt(gNorm,  dxNorm);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double  sPar  =  Math.sqrt(gNorm,  dxNorm);	  double    sPar    =    Math.sqrt(diag,    dxNorm);    	non-compiled	[CE]  method  sqrt  in  class  Math  cannot  be  applied  to  given  types;	133	None	replace
177	[BUG]  [BUGGY]  double  sPar  =  Math.sqrt(diag,  lmPar,  dxNorm);  [CE]  method  sqrt  in  class  Math  cannot  be  applied  to  given  types;  [FE]                  AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  sPar  =  Math.sqrt(diag,  lmPar,  dxNorm);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double  sPar  =  Math.sqrt(diag,  lmPar,  dxNorm);	  double    sPar    =    Math.sqrt(diag,    dxNorm);    	non-compiled	[CE]  method  sqrt  in  class  Math  cannot  be  applied  to  given  types;	133	None	replace
178	[BUG]  [BUGGY]  double  solves  =  Math.max(2.0,  0.001  *  solvedCols);  [CE]  cannot  find  symbol  sPar  [FE]            AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  solves  =  Math.max(2.0,  0.001  *  solvedCols);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double  solves  =  Math.max(2.0,  0.001  *  solvedCols);	  double    solves    =    Math.max(2.0,    0.001    *    paru);    	non-compiled	[CE]  cannot  find  symbol  sPar	81	None	replace
179	[BUG]  [BUGGY]  double  solves  =  Math.max(2.0,  0.001  *  lmPar);  [CE]  cannot  find  symbol  sPar  [FE]              AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  solves  =  Math.max(2.0,  0.001  *  lmPar);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double  solves  =  Math.max(2.0,  0.001  *  lmPar);	  double    solves    =    Math.max(2.0,    0.001    *    paru);    	non-compiled	[CE]  cannot  find  symbol  sPar	81	None	replace
180	[BUG]  [BUGGY]  double  solves  =  Math.max(2.0,  0.001  *  parl);  [CE]  cannot  find  symbol  sPar  [FE]                AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  solves  =  Math.max(2.0,  0.001  *  parl);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double  solves  =  Math.max(2.0,  0.001  *  parl);	  double    solves    =    Math.max(2.0,    0.001    *    paru);    	non-compiled	[CE]  cannot  find  symbol  sPar	81	None	replace
181	[BUG]  [BUGGY]  int  sPar  =  Math.sqrt(lmPar  +  3);  [CE]  possible  loss  of  precision  [FE]            AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  int  sPar  =  Math.sqrt(lmPar  +  3);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	int  sPar  =  Math.sqrt(lmPar  +  3);	  double    sPar    =    Math.sqrt(lmPar    +    3);    int    sPar    =    Math.sqrt(lmPar    +    3);    	non-compiled	[CE]  possible  loss  of  precision	36	None	replace
182	[BUG]  [BUGGY]  lmPar  =  Math.sqrt(lmPar  +  3);  [CE]  cannot  find  symbol  sPar  [FE]              AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  lmPar  =  Math.sqrt(lmPar  +  3);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	lmPar  =  Math.sqrt(lmPar  +  3);	  double    sPar    =    Math.sqrt(lmPar    +    3);    sPar    =    Math.sqrt(lmPar    +    3);    	non-compiled	[CE]  cannot  find  symbol  sPar	37	None	replace
183	[BUG]  [BUGGY]  lmPar  =  Math.sqrt(lmPar);  [CE]  cannot  find  symbol  sPar  [FE]                AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  lmPar  =  Math.sqrt(lmPar);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	lmPar  =  Math.sqrt(lmPar);	  double    sPar    =    Math.sqrt(lmPar    +    3);    sPar    =    Math.sqrt(lmPar    +    3);    	non-compiled	[CE]  cannot  find  symbol  sPar	37	None	replace
184	[BUG]  [BUGGY]  sPar  =  Math.sqrt(lmPar);  [CE]  cannot  find  symbol  sPar  [FE]                  AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  sPar  =  Math.sqrt(lmPar);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	sPar  =  Math.sqrt(lmPar);	  double    sPar    =    Math.sqrt(lmPar    +    3);    sPar    =    Math.sqrt(lmPar    +    3);    	non-compiled	[CE]  cannot  find  symbol  sPar	37	None	replace
185	[BUG]  [BUGGY]  double  sPar  =  Math.sqrt(lmPar)/  2;  double  sPar  =  Math.sqrt(lmPar)/  2;  [CE]  variable  sPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]    AssertionFailedError    [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  sPar  =  Math.sqrt(lmPar)/  2;  double  sPar  =  Math.sqrt(lmPar)/  2;  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double    sPar    =    Math.sqrt(lmPar)/    2;    double  sPar  =  Math.sqrt(lmPar)/  2;	  	non-compiled	[CE]  variable  sPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	169	None	add
186	[BUG]  [BUGGY]  double  sPar  =  Math.sqrt(lmPar)/  2;  Double  sPar  =  Math.sqrt(lmPar)/  2;  [CE]  variable  sPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]      AssertionFailedError    [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  sPar  =  Math.sqrt(lmPar)/  2;  Double  sPar  =  Math.sqrt(lmPar)/  2;  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double    sPar    =    Math.sqrt(lmPar)/    2;    Double  sPar  =  Math.sqrt(lmPar)/  2;	  	non-compiled	[CE]  variable  sPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	169	None	add
187	[BUG]  [BUGGY]  double  sPar  =  Math.sqrt(lmPar)/  2;  int  sPar  =  Math.sqrt(lmPar)/  2;  [CE]  variable  sPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]        AssertionFailedError    [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  sPar  =  Math.sqrt(lmPar)/  2;  int  sPar  =  Math.sqrt(lmPar)/  2;  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double    sPar    =    Math.sqrt(lmPar)/    2;    int  sPar  =  Math.sqrt(lmPar)/  2;	  	non-compiled	[CE]  variable  sPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	169	None	add
188	[BUG]  [BUGGY]  double  sPar  =  Math.sqrt(lmPar)/  2;  sPar  =  Math.sqrt(lmPar)/  2;  [CE]  variable  sPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]          AssertionFailedError    [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  sPar  =  Math.sqrt(lmPar)/  2;  sPar  =  Math.sqrt(lmPar)/  2;  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double    sPar    =    Math.sqrt(lmPar)/    2;    sPar  =  Math.sqrt(lmPar)/  2;	  	non-compiled	[CE]  variable  sPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	169	None	add
189	[BUG]  [BUGGY]  double  sPar  =  Math.sqrt(lmPar)/  2;  double  sPar  =  Math.sqrt(lmPar)/  3;  [CE]  variable  sPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]            AssertionFailedError    [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  sPar  =  Math.sqrt(lmPar)/  2;  double  sPar  =  Math.sqrt(lmPar)/  3;  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double    sPar    =    Math.sqrt(lmPar)/    2;    double  sPar  =  Math.sqrt(lmPar)/  3;	  	non-compiled	[CE]  variable  sPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	169	None	add
190	[BUG]  [BUGGY]  solveCols  =  Math.max(2.2251e-308,  0.001  *  lmPar);  [CE]  cannot  find  symbol  solveCols  [FE]                    AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  solveCols  =  Math.max(2.2251e-308,  0.001  *  lmPar);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	solveCols  =  Math.max(2.2251e-308,  0.001  *  lmPar);	  solveCols    =    Math.max(2.2251e-308,    0.001    *    paru);    	non-compiled	[CE]  cannot  find  symbol  solveCols	83	None	replace
191	[BUG]  [BUGGY]  solveCols  =  Math.max(2.2252e-308,  0.001  *  paru);  [CE]  cannot  find  symbol  solveCols  [FE]                      AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  solveCols  =  Math.max(2.2252e-308,  0.001  *  paru);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	solveCols  =  Math.max(2.2252e-308,  0.001  *  paru);	  solveCols    =    Math.max(2.2251e-308,    0.001    *    paru);    	non-compiled	[CE]  cannot  find  symbol  solveCols	83	None	replace
192	[BUG]  [BUGGY]  solveCols  =  Math.max(2.2251e-308,  0.001  *  parm);  [CE]  cannot  find  symbol  solveCols  [FE]                        AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  solveCols  =  Math.max(2.2251e-308,  0.001  *  parm);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	solveCols  =  Math.max(2.2251e-308,  0.001  *  parm);	  solveCols    =    Math.max(2.2251e-308,    0.001    *    paru);    	non-compiled	[CE]  cannot  find  symbol  solveCols	83	None	replace
193	[BUG]  [BUGGY]  double  sPar  =  Math.sqrt(lmPar,  beta,  gNorm,  diagR);  [CE]  method  sqrt  in  class  Math  cannot  be  applied  to  given  types;  [FE]            AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  sPar  =  Math.sqrt(lmPar,  beta,  gNorm,  diagR);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double  sPar  =  Math.sqrt(lmPar,  beta,  gNorm,  diagR);	  double    sPar    =    Math.sqrt(lmPar,    gNorm,    diagR);    	non-compiled	[CE]  method  sqrt  in  class  Math  cannot  be  applied  to  given  types;	156	None	replace
194	[BUG]  [BUGGY]  double  sPar  =  Math.sqrt(lmPar,  dxNorm,  gNorm,  diagR);  [CE]  method  sqrt  in  class  Math  cannot  be  applied  to  given  types;  [FE]              AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  sPar  =  Math.sqrt(lmPar,  dxNorm,  gNorm,  diagR);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double  sPar  =  Math.sqrt(lmPar,  dxNorm,  gNorm,  diagR);	  double    sPar    =    Math.sqrt(lmPar,    gNorm,    diagR);    	non-compiled	[CE]  method  sqrt  in  class  Math  cannot  be  applied  to  given  types;	156	None	replace
195	[BUG]  [BUGGY]  double  sPar  =  Math.sqrt(diagR,  gNorm,  lmPar);  [CE]  method  sqrt  in  class  Math  cannot  be  applied  to  given  types;  [FE]                AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  sPar  =  Math.sqrt(diagR,  gNorm,  lmPar);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double  sPar  =  Math.sqrt(diagR,  gNorm,  lmPar);	  double    sPar    =    Math.sqrt(lmPar,    gNorm,    diagR);    	non-compiled	[CE]  method  sqrt  in  class  Math  cannot  be  applied  to  given  types;	156	None	replace
196	[BUG]  [BUGGY]  double  sPar  =  Math.max(2.2251e-308,  0.001  *  paru,  countdown,  lmPar);  [CE]  no  suitable  method  found  for  max(double,double,int,double)  [FE]                AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  sPar  =  Math.max(2.2251e-308,  0.001  *  paru,  countdown,  lmPar);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double  sPar  =  Math.max(2.2251e-308,  0.001  *  paru,  countdown,  lmPar);	  double    sPar    =    Math.max(2.2251e-308,    0.001    *    paru,    countdown);    	non-compiled	[CE]  no  suitable  method  found  for  max(double,double,int,double)	96	None	replace
197	[BUG]  [BUGGY]  double  sPar  =  Math.max(2.2251e-308,  0.001  *  paru,  countdown  +  1);  [CE]  no  suitable  method  found  for  max(double,double,int)  [FE]                  AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  sPar  =  Math.max(2.2251e-308,  0.001  *  paru,  countdown  +  1);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double  sPar  =  Math.max(2.2251e-308,  0.001  *  paru,  countdown  +  1);	  double    sPar    =    Math.max(2.2251e-308,    0.001    *    paru,    countdown);    	non-compiled	[CE]  no  suitable  method  found  for  max(double,double,int)	96	None	replace
198	[BUG]  [BUGGY]  double  sPar  =  Math.max(2.2251e-308,  0.001  *  paru,  countdown,  1);  [CE]  no  suitable  method  found  for  max(double,double,int,int)  [FE]                    AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  sPar  =  Math.max(2.2251e-308,  0.001  *  paru,  countdown,  1);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double  sPar  =  Math.max(2.2251e-308,  0.001  *  paru,  countdown,  1);	  double    sPar    =    Math.max(2.2251e-308,    0.001    *    paru,    countdown);    	non-compiled	[CE]  no  suitable  method  found  for  max(double,double,int,int)	96	None	replace
199	[BUG]  [BUGGY]  double  diag  =  Math.max(2.2251e-3,  0.001  *  lmPar);  [CE]  variable  diag  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]                AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  diag  =  Math.max(2.2251e-3,  0.001  *  lmPar);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double  diag  =  Math.max(2.2251e-3,  0.001  *  lmPar);	  double    diag    =    Math.max(2.2251e-3,    0.001    *    paru);    	non-compiled	[CE]  variable  diag  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	93	None	replace
200	[BUG]  [BUGGY]  double  diag  =  Math.max(2.2251e-3,  0.001  *  parm);  [CE]  variable  diag  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]                  AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  diag  =  Math.max(2.2251e-3,  0.001  *  parm);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double  diag  =  Math.max(2.2251e-3,  0.001  *  parm);	  double    diag    =    Math.max(2.2251e-3,    0.001    *    paru);    	non-compiled	[CE]  variable  diag  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	93	None	replace
201	[BUG]  [BUGGY]  long  solvedCols  =  Math.max(2.2251e-308,  0.001  *  paru);  [CE]  possible  loss  of  precision  [FE]                      AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  long  solvedCols  =  Math.max(2.2251e-308,  0.001  *  paru);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	long  solvedCols  =  Math.max(2.2251e-308,  0.001  *  paru);	  int    solvedCols    =    Math.max(2.2251e-308,    0.001    *    paru);    	non-compiled	[CE]  possible  loss  of  precision	84	None	replace
202	[BUG]  [BUGGY]  double  solvedCols  =  Math.max(2.251e-308,  0.001  *  paru);  [CE]  cannot  find  symbol  sPar  [FE]                        AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  solvedCols  =  Math.max(2.251e-308,  0.001  *  paru);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double  solvedCols  =  Math.max(2.251e-308,  0.001  *  paru);	  int    solvedCols    =    Math.max(2.2251e-308,    0.001    *    paru);    	non-compiled	[CE]  cannot  find  symbol  sPar	84	None	replace
203	[BUG]  [BUGGY]  int  solvedCols  =  Math.min(resolvedCols,  solveCols);  [CE]  cannot  find  symbol  resolvedCols  [FE]                  AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  int  solvedCols  =  Math.min(resolvedCols,  solveCols);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	int  solvedCols  =  Math.min(resolvedCols,  solveCols);	  int    solvedCols    =    Math.min(solvedCols,    solveCols);    	non-compiled	[CE]  cannot  find  symbol  resolvedCols	140	None	replace
204	[BUG]  [BUGGY]  int  solvedCols  =  Math.min(solvedCols,  resolvedCols);  [CE]  cannot  find  symbol  resolvedCols  [FE]                    AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  int  solvedCols  =  Math.min(solvedCols,  resolvedCols);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	int  solvedCols  =  Math.min(solvedCols,  resolvedCols);	  int    solvedCols    =    Math.min(solvedCols,    solveCols);    	non-compiled	[CE]  cannot  find  symbol  resolvedCols	140	None	replace
205	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  sPar  =  Math.sqrt(lmPar)/  4;  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	add	double  sPar  =  Math.sqrt(lmPar)/  4;	  double    sPar    =    Math.sqrt(lmPar)/    3;    	compilable	  [FE]  AssertionFailedError  	155	13	replace
206	[BUG]  [BUGGY]  double  sPar  =  Math.sqrt(lmPar)/  4;  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  sPar  =  Math.sqrt(lmPar)/  4;  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double  sPar  =  Math.sqrt(lmPar)/  4;	  double    sPar    =    Math.sqrt(lmPar)/    3;    	compilable	  [FE]  AssertionFailedError  	155	13	replace
207	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  sPar  =  Math.max(2.3251e-308,  0.001  *  paru);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	add	double  sPar  =  Math.max(2.3251e-308,  0.001  *  paru);	  double    sPar    =    Math.max(2.2251e-308,    0.001    *    dxNorm);    	compilable	  [FE]  AssertionFailedError  	127	13	replace
208	[BUG]  [BUGGY]  double  sPar  =  Math.max(2.3251e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  sPar  =  Math.max(2.3251e-308,  0.001  *  paru);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double  sPar  =  Math.max(2.3251e-308,  0.001  *  paru);	  double    sPar    =    Math.max(2.2251e-308,    0.001    *    dxNorm);    	compilable	  [FE]  AssertionFailedError  	127	13	replace
209	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]          lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,.001  *  paru);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	add	                lmPar        =        Math.max(2.2252e-308,        0.001        *        paru);        lmPar    =    Math.max(2.2252e-308,.001    *    paru);    lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	47	12	add
210	[BUG]  [BUGGY]          lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,.001  *  paru);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]          lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,.001  *  paru);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	                lmPar        =        Math.max(2.2252e-308,        0.001        *        paru);        lmPar    =    Math.max(2.2252e-308,.001    *    paru);    lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	47	12	add
211	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]          lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,.001  *  paru);  lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,.001  *  paru);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	add	                lmPar        =        Math.max(2.2252e-308,        0.001        *        paru);        lmPar    =    Math.max(2.2252e-308,.001    *    paru);    lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	47	12	add
212	[BUG]  [BUGGY]          lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,.001  *  paru);  lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,.001  *  paru);  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]          lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,.001  *  paru);  lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,.001  *  paru);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	                lmPar        =        Math.max(2.2252e-308,        0.001        *        paru);        lmPar    =    Math.max(2.2252e-308,.001    *    paru);    lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	47	12	add
213	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]          lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,.001  *  paru);  lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,.001  *  paru);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	add	                lmPar        =        Math.max(2.2252e-308,        0.001        *        paru);        lmPar    =    Math.max(2.2252e-308,.001    *    paru);    lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	47	12	add
214	[BUG]  [BUGGY]          lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,.001  *  paru);  lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,.001  *  paru);  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]          lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,.001  *  paru);  lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,.001  *  paru);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	                lmPar        =        Math.max(2.2252e-308,        0.001        *        paru);        lmPar    =    Math.max(2.2252e-308,.001    *    paru);    lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	47	12	add
215	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]          lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,.001  *  paru);  lmPar  =  Math.max(2.3252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,.001  *  paru);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	add	                lmPar        =        Math.max(2.2252e-308,        0.001        *        paru);        lmPar    =    Math.max(2.2252e-308,.001    *    paru);    lmPar  =  Math.max(2.3252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	47	12	add
216	[BUG]  [BUGGY]          lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,.001  *  paru);  lmPar  =  Math.max(2.3252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,.001  *  paru);  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]          lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,.001  *  paru);  lmPar  =  Math.max(2.3252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,.001  *  paru);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	                lmPar        =        Math.max(2.2252e-308,        0.001        *        paru);        lmPar    =    Math.max(2.2252e-308,.001    *    paru);    lmPar  =  Math.max(2.3252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	47	12	add
217	[BUG]  [BUGGY]  double  sPar  =  Math.abs(lmPar);  double  sPar  =  Math.abs(lmPar);  [CE]  variable  sPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]    AssertionFailedError    [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  sPar  =  Math.abs(lmPar);  double  sPar  =  Math.abs(lmPar);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double    sPar    =    Math.abs(lmPar);    double  sPar  =  Math.abs(lmPar);	  	non-compiled	[CE]  variable  sPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	162	None	add
218	[BUG]  [BUGGY]  double  sPar  =  Math.abs(lmPar);  Double  sPar  =  Math.abs(lmPar);  [CE]  variable  sPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]      AssertionFailedError    [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  sPar  =  Math.abs(lmPar);  Double  sPar  =  Math.abs(lmPar);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double    sPar    =    Math.abs(lmPar);    Double  sPar  =  Math.abs(lmPar);	  	non-compiled	[CE]  variable  sPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	162	None	add
219	[BUG]  [BUGGY]  double  sPar  =  Math.abs(lmPar);  int  sPar  =  Math.abs(lmPar);  [CE]  variable  sPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]        AssertionFailedError    [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  sPar  =  Math.abs(lmPar);  int  sPar  =  Math.abs(lmPar);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double    sPar    =    Math.abs(lmPar);    int  sPar  =  Math.abs(lmPar);	  	non-compiled	[CE]  variable  sPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	162	None	add
220	[BUG]  [BUGGY]  double  sPar  =  Math.abs(lmPar);  double  lmPar  =  Math.abs(lmPar);  [CE]  variable  sPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]          AssertionFailedError    [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  sPar  =  Math.abs(lmPar);  double  lmPar  =  Math.abs(lmPar);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double    sPar    =    Math.abs(lmPar);    double  lmPar  =  Math.abs(lmPar);	  	non-compiled	[CE]  variable  sPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	162	None	add
221	[BUG]  [BUGGY]  double  sPar  =  Math.sqrt(gNorm,  dxNorm,  lmPar);  [CE]  method  sqrt  in  class  Math  cannot  be  applied  to  given  types;  [FE]            AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  sPar  =  Math.sqrt(gNorm,  dxNorm,  lmPar);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double  sPar  =  Math.sqrt(gNorm,  dxNorm,  lmPar);	  double    sPar    =    Math.sqrt(lmPar,    dxNorm,    gNorm);    	non-compiled	[CE]  method  sqrt  in  class  Math  cannot  be  applied  to  given  types;	72	None	replace
222	[BUG]  [BUGGY]  double  sPar  =  Math.sqrt(dxNorm,  lmPar,  gNorm);  [CE]  method  sqrt  in  class  Math  cannot  be  applied  to  given  types;  [FE]              AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  sPar  =  Math.sqrt(dxNorm,  lmPar,  gNorm);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double  sPar  =  Math.sqrt(dxNorm,  lmPar,  gNorm);	  double    sPar    =    Math.sqrt(lmPar,    dxNorm,    gNorm);    	non-compiled	[CE]  method  sqrt  in  class  Math  cannot  be  applied  to  given  types;	72	None	replace
223	[BUG]  [BUGGY]  double  sPar  =  Math.sqrt(lmPar,  dxNorm,  gNorm,  1);  [CE]  method  sqrt  in  class  Math  cannot  be  applied  to  given  types;  [FE]                AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  sPar  =  Math.sqrt(lmPar,  dxNorm,  gNorm,  1);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double  sPar  =  Math.sqrt(lmPar,  dxNorm,  gNorm,  1);	  double    sPar    =    Math.sqrt(lmPar,    dxNorm,    gNorm);    	non-compiled	[CE]  method  sqrt  in  class  Math  cannot  be  applied  to  given  types;	72	None	replace
224	[BUG]  [BUGGY]  double  solvedCols  =  Math.max(2.2253e-308,  0.001  *  paru);  [CE]  cannot  find  symbol  sPar  [FE]        AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  solvedCols  =  Math.max(2.2253e-308,  0.001  *  paru);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double  solvedCols  =  Math.max(2.2253e-308,  0.001  *  paru);	          double    solvedCols    =    Math.max(2.2251e-308,    0.001    *    paru);    double    solvedCols    =    Math.max(2.2253e-308,    0.001    *    paru);    	non-compiled	[CE]  cannot  find  symbol  sPar	151	None	replace
225	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  sPar  =  Math.abs(lmPar  +  1);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	add	double  sPar  =  Math.abs(lmPar  +  1);	  double    sPar    =    Math.abs(lmPar);    	compilable	  [FE]  AssertionFailedError  	163	13	replace
226	[BUG]  [BUGGY]  double  sPar  =  Math.abs(lmPar  +  1);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  sPar  =  Math.abs(lmPar  +  1);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double  sPar  =  Math.abs(lmPar  +  1);	  double    sPar    =    Math.abs(lmPar);    	compilable	  [FE]  AssertionFailedError  	163	13	replace
227	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  sPar  =  Math.abs(lmPar  +  2);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	add	double  sPar  =  Math.abs(lmPar  +  2);	  double    sPar    =    Math.abs(lmPar);    	compilable	  [FE]  AssertionFailedError  	163	13	replace
228	[BUG]  [BUGGY]  double  sPar  =  Math.abs(lmPar  +  2);  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  sPar  =  Math.abs(lmPar  +  2);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double  sPar  =  Math.abs(lmPar  +  2);	  double    sPar    =    Math.abs(lmPar);    	compilable	  [FE]  AssertionFailedError  	163	13	replace
229	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  sPar  =  Math.abs(lmPar  *  paru);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	add	double  sPar  =  Math.abs(lmPar  *  paru);	  double    sPar    =    Math.abs(lmPar);    	compilable	  [FE]  AssertionFailedError  	163	13	replace
230	[BUG]  [BUGGY]  double  sPar  =  Math.abs(lmPar  *  paru);  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  sPar  =  Math.abs(lmPar  *  paru);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double  sPar  =  Math.abs(lmPar  *  paru);	  double    sPar    =    Math.abs(lmPar);    	compilable	  [FE]  AssertionFailedError  	163	13	replace
231	[BUG]  [BUGGY]          double    solvedCols    =    Math.sqrt(lmPar);    double  solves  =  Math.sqrt(lmPar);  double  solvedCols  =  Math.sqrt(lmPar);  double  solves  =  Math.sqrt(lmPar);  [CE]  variable  solvedCols  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]    AssertionFailedError    [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]          double    solvedCols    =    Math.sqrt(lmPar);    double  solves  =  Math.sqrt(lmPar);  double  solvedCols  =  Math.sqrt(lmPar);  double  solves  =  Math.sqrt(lmPar);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	                double        solvedCols        =        Math.sqrt(lmPar);        double    solves    =    Math.sqrt(lmPar);    double  solvedCols  =  Math.sqrt(lmPar);  double  solves  =  Math.sqrt(lmPar);	  	non-compiled	[CE]  variable  solvedCols  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	104	None	add
232	[BUG]  [BUGGY]          double    solvedCols    =    Math.sqrt(lmPar);    double  solves  =  Math.sqrt(lmPar);  Double  solvedCols  =  Math.sqrt(lmPar);  double  solves  =  Math.sqrt(lmPar);  [CE]  variable  solvedCols  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]      AssertionFailedError    [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]          double    solvedCols    =    Math.sqrt(lmPar);    double  solves  =  Math.sqrt(lmPar);  Double  solvedCols  =  Math.sqrt(lmPar);  double  solves  =  Math.sqrt(lmPar);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	                double        solvedCols        =        Math.sqrt(lmPar);        double    solves    =    Math.sqrt(lmPar);    Double  solvedCols  =  Math.sqrt(lmPar);  double  solves  =  Math.sqrt(lmPar);	  	non-compiled	[CE]  variable  solvedCols  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	104	None	add
233	[BUG]  [BUGGY]          double    solvedCols    =    Math.sqrt(lmPar);    double  solves  =  Math.sqrt(lmPar);  double  resolvedCols  =  Math.sqrt(lmPar);  double  solves  =  Math.sqrt(lmPar);  [CE]  variable  solves  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]        AssertionFailedError    [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]          double    solvedCols    =    Math.sqrt(lmPar);    double  solves  =  Math.sqrt(lmPar);  double  resolvedCols  =  Math.sqrt(lmPar);  double  solves  =  Math.sqrt(lmPar);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	                double        solvedCols        =        Math.sqrt(lmPar);        double    solves    =    Math.sqrt(lmPar);    double  resolvedCols  =  Math.sqrt(lmPar);  double  solves  =  Math.sqrt(lmPar);	  	non-compiled	[CE]  variable  solves  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	104	None	add
234	[BUG]  [BUGGY]          double    solvedCols    =    Math.sqrt(lmPar);    double  solves  =  Math.sqrt(lmPar);  double  solvedCols  =  Math.sqrt(lmPar);  Double  solves  =  Math.sqrt(lmPar);  [CE]  variable  solvedCols  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]          AssertionFailedError    [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]          double    solvedCols    =    Math.sqrt(lmPar);    double  solves  =  Math.sqrt(lmPar);  double  solvedCols  =  Math.sqrt(lmPar);  Double  solves  =  Math.sqrt(lmPar);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	                double        solvedCols        =        Math.sqrt(lmPar);        double    solves    =    Math.sqrt(lmPar);    double  solvedCols  =  Math.sqrt(lmPar);  Double  solves  =  Math.sqrt(lmPar);	  	non-compiled	[CE]  variable  solvedCols  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	104	None	add
235	[BUG]  [BUGGY]  double  solvedCols  =  Math.max(2.0253e-308,  0.001  *  paru);  [CE]  cannot  find  symbol  sPar  [FE]        AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  solvedCols  =  Math.max(2.0253e-308,  0.001  *  paru);  [BUGGY]      double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double  solvedCols  =  Math.max(2.0253e-308,  0.001  *  paru);	          double    solvedCols    =    Math.max(2.0251e-308,    0.001    *    paru);    double    solvedCols    =    Math.max(2.0253e-308,    0.001    *    paru);    	non-compiled	[CE]  cannot  find  symbol  sPar	172	None	replace
236	[BUG]  [BUGGY]  double  sPar  =  Math.sqrt(dxNorm,  gNorm,  lmPar);  [CE]  method  sqrt  in  class  Math  cannot  be  applied  to  given  types;  [FE]                AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  sPar  =  Math.sqrt(dxNorm,  gNorm,  lmPar);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double  sPar  =  Math.sqrt(dxNorm,  gNorm,  lmPar);	  double    sPar    =    Math.sqrt(lmPar,    gNorm,    dxNorm);    	non-compiled	[CE]  method  sqrt  in  class  Math  cannot  be  applied  to  given  types;	74	None	replace
237	[BUG]  [BUGGY]  double  sPar  =  Math.sqrt(lmPar,  gNorm,  diagR,  dxNorm);  [CE]  cannot  find  symbol  [FE]                  AssertionFailedError      [CONTEXT]      if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }      [BUGGY]  double  sPar  =  Math.sqrt(lmPar,  gNorm,  diagR,  dxNorm);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  s  =  diag[pj]  *  lmDir[pj];  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	579	579	2	replace	double  sPar  =  Math.sqrt(lmPar,  gNorm,  diagR,  dxNorm);	  double    sPar    =    Math.sqrt(lmPar,    gNorm,    dxNorm);    	non-compiled	[CE]  cannot  find  symbol	74	None	replace
