bugid	buggy	buggy_class	suspiciousness	buggy_line	endbuggycode	original_failing_test_number	action	patch	original_buggy	execution_result	diagnosis	previous_bug_id	new_failing_test_number	this_action
1	[BUG]  [BUGGY]  int  pj  =  cost[j];  point[pj]  =  oldX[pj];  [CE]  array  required,  but  double  found  [FE]          AssertionFailedError    [CONTEXT]    xNorm+=  xK  *  xK;  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {    [BUGGY]  int  pj  =  cost[j];  point[pj]  =  oldX[pj];  [BUGGY]    int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	428	428	2	replace	int  pj  =  cost[j];  point[pj]  =  oldX[pj];	      int    pj    =    permutation[j];    point[pj]    =    oldX[pj];    	non-compiled	[CE]  array  required,  but  double  found	15	None	replace
2	[BUG]  [BUGGY]  double  pj  =  permutation[j];  point[pj]  =  oldX[pj];  [CE]  possible  loss  of  precision  [FE]            AssertionFailedError    [CONTEXT]    xNorm+=  xK  *  xK;  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {    [BUGGY]  double  pj  =  permutation[j];  point[pj]  =  oldX[pj];  [BUGGY]    int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	428	428	2	replace	double  pj  =  permutation[j];  point[pj]  =  oldX[pj];	      int    pj    =    permutation[j];    point[pj]    =    oldX[pj];    	non-compiled	[CE]  possible  loss  of  precision	15	None	replace
3	[BUG]  [BUGGY]  int  pj  =  permutation[j];  point[pj]  =  oldY[pj];  [CE]  cannot  find  symbol  oldY  [FE]              AssertionFailedError    [CONTEXT]    xNorm+=  xK  *  xK;  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {    [BUGGY]  int  pj  =  permutation[j];  point[pj]  =  oldY[pj];  [BUGGY]    int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	428	428	2	replace	int  pj  =  permutation[j];  point[pj]  =  oldY[pj];	      int    pj    =    permutation[j];    point[pj]    =    oldX[pj];    	non-compiled	[CE]  cannot  find  symbol  oldY	15	None	replace
4	[BUG]  [BUGGY]  int  pj  =  permutation[j  +  1];  int  pj  =  permutation[j  +  1];  [CE]  variable  pj  is  already  defined  in  method  doOptimize()  [FE]    ArrayIndexOutOfBoundsException    [CONTEXT]    xNorm+=  xK  *  xK;  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {    [BUGGY]  int  pj  =  permutation[j  +  1];  int  pj  =  permutation[j  +  1];  [BUGGY]    point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	428	428	2	replace	int    pj    =    permutation[j    +    1];    int  pj  =  permutation[j  +  1];	  	non-compiled	[CE]  variable  pj  is  already  defined  in  method  doOptimize()	6	None	add
5	[BUG]  [BUGGY]  int  pj  =  permutation[j  +  1];  Int  pj  =  permutation[j  +  1];  [CE]  cannot  find  symbol  [FE]      ArrayIndexOutOfBoundsException    [CONTEXT]    xNorm+=  xK  *  xK;  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {    [BUGGY]  int  pj  =  permutation[j  +  1];  Int  pj  =  permutation[j  +  1];  [BUGGY]    point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	428	428	2	replace	int    pj    =    permutation[j    +    1];    Int  pj  =  permutation[j  +  1];	  	non-compiled	[CE]  cannot  find  symbol	6	None	add
6	[BUG]  [BUGGY]  int  pj  =  permutation[j  +  1];  int  pj  =  permutation[j  +  1)];  [CE]  ']'  expected  [FE]        ArrayIndexOutOfBoundsException    [CONTEXT]    xNorm+=  xK  *  xK;  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {    [BUGGY]  int  pj  =  permutation[j  +  1];  int  pj  =  permutation[j  +  1)];  [BUGGY]    point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	428	428	2	replace	int    pj    =    permutation[j    +    1];    int  pj  =  permutation[j  +  1)];	  	non-compiled	[CE]  ']'  expected	6	None	add
7	[BUG]  [BUGGY]  int  point[j]  =  cost;  [CE]  ']'  expected  [FE]            AssertionFailedError    [CONTEXT]    xNorm+=  xK  *  xK;  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {    [BUGGY]  int  point[j]  =  cost;  [BUGGY]    int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	428	428	2	replace	int  point[j]  =  cost;	      int    point[j]    =    oldX[j];    	non-compiled	[CE]  ']'  expected	11	None	replace
8	[BUG]  [BUGGY]  int  point[j]  =  xNorm;  [CE]  ']'  expected  [FE]              AssertionFailedError    [CONTEXT]    xNorm+=  xK  *  xK;  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {    [BUGGY]  int  point[j]  =  xNorm;  [BUGGY]    int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	428	428	2	replace	int  point[j]  =  xNorm;	      int    point[j]    =    oldX[j];    	non-compiled	[CE]  ']'  expected	11	None	replace
9	[BUG]  [BUGGY]  int  pj  =  permutation[j]  -  1;  int  pj  =  permutation[j]  -  1;  [CE]  variable  pj  is  already  defined  in  method  doOptimize()  [FE]    ArrayIndexOutOfBoundsException    [CONTEXT]    xNorm+=  xK  *  xK;  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {    [BUGGY]  int  pj  =  permutation[j]  -  1;  int  pj  =  permutation[j]  -  1;  [BUGGY]    point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	428	428	2	replace	int    pj    =    permutation[j]    -    1;    int  pj  =  permutation[j]  -  1;	  	non-compiled	[CE]  variable  pj  is  already  defined  in  method  doOptimize()	4	None	add
10	[BUG]  [BUGGY]  int  pj  =  permutation[j]  -  1;  Int  pj  =  permutation[j]  -  1;  [CE]  cannot  find  symbol  [FE]      ArrayIndexOutOfBoundsException    [CONTEXT]    xNorm+=  xK  *  xK;  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {    [BUGGY]  int  pj  =  permutation[j]  -  1;  Int  pj  =  permutation[j]  -  1;  [BUGGY]    point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	428	428	2	replace	int    pj    =    permutation[j]    -    1;    Int  pj  =  permutation[j]  -  1;	  	non-compiled	[CE]  cannot  find  symbol	4	None	add
11	[BUG]  [BUGGY]  int  pj  =  permutation[j]  -  1;  int  j  =  permutation[j]  -  1;  [CE]  variable  j  is  already  defined  in  method  doOptimize()  [FE]        ArrayIndexOutOfBoundsException    [CONTEXT]    xNorm+=  xK  *  xK;  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {    [BUGGY]  int  pj  =  permutation[j]  -  1;  int  j  =  permutation[j]  -  1;  [BUGGY]    point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	428	428	2	replace	int    pj    =    permutation[j]    -    1;    int  j  =  permutation[j]  -  1;	  	non-compiled	[CE]  variable  j  is  already  defined  in  method  doOptimize()	4	None	add
12	[BUG]  [BUGGY]  int  pj  =  permutation[j]  -  1;  pj  =  permutation[j]  -  1;  [CE]  variable  pj  is  already  defined  in  method  doOptimize()  [FE]          ArrayIndexOutOfBoundsException    [CONTEXT]    xNorm+=  xK  *  xK;  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {    [BUGGY]  int  pj  =  permutation[j]  -  1;  pj  =  permutation[j]  -  1;  [BUGGY]    point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	428	428	2	replace	int    pj    =    permutation[j]    -    1;    pj  =  permutation[j]  -  1;	  	non-compiled	[CE]  variable  pj  is  already  defined  in  method  doOptimize()	4	None	add
13	[BUG]  [BUGGY]  int  pj  =  permutation[j  -  1]  +  cost;  [CE]  possible  loss  of  precision  [FE]    ArrayIndexOutOfBoundsException    [CONTEXT]    xNorm+=  xK  *  xK;  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {    [BUGGY]  int  pj  =  permutation[j  -  1]  +  cost;  [BUGGY]    point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	428	428	2	replace	int  pj  =  permutation[j  -  1]  +  cost;	  int    pj    =    permutation[j    -    1];    	non-compiled	[CE]  possible  loss  of  precision	20	None	replace
14	[BUG]  [BUGGY]  [FE]  ArrayIndexOutOfBoundsException  [FE]      ArrayIndexOutOfBoundsException    [CONTEXT]    xNorm+=  xK  *  xK;  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {    [BUGGY]  int  pj  =  permutation[j  -  2];  [BUGGY]    point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	428	428	2	add	int  pj  =  permutation[j  -  2];	  int    pj    =    permutation[j    -    1];    	compilable	  [FE]  ArrayIndexOutOfBoundsException  	20	15	replace
15	[BUG]  [BUGGY]  int  pj  =  permutation[j  -  2];  [FE]  ArrayIndexOutOfBoundsException  [FE]      ArrayIndexOutOfBoundsException    [CONTEXT]    xNorm+=  xK  *  xK;  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {    [BUGGY]  int  pj  =  permutation[j  -  2];  [BUGGY]    point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	428	428	2	replace	int  pj  =  permutation[j  -  2];	  int    pj    =    permutation[j    -    1];    	compilable	  [FE]  ArrayIndexOutOfBoundsException  	20	15	replace
16	[BUG]  [BUGGY]  [FE]  ArrayIndexOutOfBoundsException  [FE]        ArrayIndexOutOfBoundsException    [CONTEXT]    xNorm+=  xK  *  xK;  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {    [BUGGY]  int  pj  =  permutation[j  -  1]  +  1;  [BUGGY]    point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	428	428	2	add	int  pj  =  permutation[j  -  1]  +  1;	  int    pj    =    permutation[j    -    1];    	compilable	  [FE]  ArrayIndexOutOfBoundsException  	20	15	replace
17	[BUG]  [BUGGY]  int  pj  =  permutation[j  -  1]  +  1;  [FE]  ArrayIndexOutOfBoundsException  [FE]        ArrayIndexOutOfBoundsException    [CONTEXT]    xNorm+=  xK  *  xK;  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {    [BUGGY]  int  pj  =  permutation[j  -  1]  +  1;  [BUGGY]    point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	428	428	2	replace	int  pj  =  permutation[j  -  1]  +  1;	  int    pj    =    permutation[j    -    1];    	compilable	  [FE]  ArrayIndexOutOfBoundsException  	20	15	replace
18	[BUG]  [BUGGY]  int  pj  =  permutation[j  -  1];  int  pj  =  permutation[j  -  1];  [CE]  variable  pj  is  already  defined  in  method  doOptimize()  [FE]    ArrayIndexOutOfBoundsException    [CONTEXT]    xNorm+=  xK  *  xK;  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {    [BUGGY]  int  pj  =  permutation[j  -  1];  int  pj  =  permutation[j  -  1];  [BUGGY]    point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	428	428	2	replace	int    pj    =    permutation[j    -    1];    int  pj  =  permutation[j  -  1];	  	non-compiled	[CE]  variable  pj  is  already  defined  in  method  doOptimize()	19	None	add
19	[BUG]  [BUGGY]  int  pj  =  permutation[j  -  1];  Int  pj  =  permutation[j  -  1];  [CE]  cannot  find  symbol  [FE]      ArrayIndexOutOfBoundsException    [CONTEXT]    xNorm+=  xK  *  xK;  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {    [BUGGY]  int  pj  =  permutation[j  -  1];  Int  pj  =  permutation[j  -  1];  [BUGGY]    point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	428	428	2	replace	int    pj    =    permutation[j    -    1];    Int  pj  =  permutation[j  -  1];	  	non-compiled	[CE]  cannot  find  symbol	19	None	add
20	[BUG]  [BUGGY]  int  pj  =  permutation[j  -  1];  int  pj  =  permutation[j  -  1]);  [CE]  ';'  expected  [FE]        ArrayIndexOutOfBoundsException    [CONTEXT]    xNorm+=  xK  *  xK;  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {    [BUGGY]  int  pj  =  permutation[j  -  1];  int  pj  =  permutation[j  -  1]);  [BUGGY]    point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	428	428	2	replace	int    pj    =    permutation[j    -    1];    int  pj  =  permutation[j  -  1]);	  	non-compiled	[CE]  ';'  expected	19	None	add
21	[BUG]  [BUGGY]  int  permutation[j]  =  xNorm;  [CE]  ']'  expected  [FE]          AssertionFailedError    [CONTEXT]    xNorm+=  xK  *  xK;  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {    [BUGGY]  int  permutation[j]  =  xNorm;  [BUGGY]    int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	428	428	2	replace	int  permutation[j]  =  xNorm;	      int    permutation[j]    =    permutation[j];    	non-compiled	[CE]  ']'  expected	10	None	replace
22	[BUG]  [BUGGY]  int  permutation[j]  =  cost;  [CE]  ']'  expected  [FE]            AssertionFailedError    [CONTEXT]    xNorm+=  xK  *  xK;  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {    [BUGGY]  int  permutation[j]  =  cost;  [BUGGY]    int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	428	428	2	replace	int  permutation[j]  =  cost;	      int    permutation[j]    =    permutation[j];    	non-compiled	[CE]  ']'  expected	10	None	replace
23	[BUG]  [BUGGY]  int  permutation[j]  =  oldX[j];  [CE]  ']'  expected  [FE]              AssertionFailedError    [CONTEXT]    xNorm+=  xK  *  xK;  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {    [BUGGY]  int  permutation[j]  =  oldX[j];  [BUGGY]    int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	428	428	2	replace	int  permutation[j]  =  oldX[j];	      int    permutation[j]    =    permutation[j];    	non-compiled	[CE]  ']'  expected	10	None	replace
24	[BUG]  [BUGGY]  int  permutation[j]  =  permutation[0];  [CE]  ']'  expected  [FE]                AssertionFailedError    [CONTEXT]    xNorm+=  xK  *  xK;  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {    [BUGGY]  int  permutation[j]  =  permutation[0];  [BUGGY]    int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	428	428	2	replace	int  permutation[j]  =  permutation[0];	      int    permutation[j]    =    permutation[j];    	non-compiled	[CE]  ']'  expected	10	None	replace
25	[BUG]  [BUGGY]  int  point[j]  =  permutation[j]  +  1;  [CE]  ']'  expected  [FE]        AssertionFailedError    [CONTEXT]    xNorm+=  xK  *  xK;  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {    [BUGGY]  int  point[j]  =  permutation[j]  +  1;  [BUGGY]    int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	428	428	2	replace	int  point[j]  =  permutation[j]  +  1;	      int    point[j]    =    permutation[j];    	non-compiled	[CE]  ']'  expected	9	None	replace
26	[BUG]  [BUGGY]  int  point[j]  =  permutation[j]  -  1;  [CE]  ']'  expected  [FE]          AssertionFailedError    [CONTEXT]    xNorm+=  xK  *  xK;  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {    [BUGGY]  int  point[j]  =  permutation[j]  -  1;  [BUGGY]    int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	428	428	2	replace	int  point[j]  =  permutation[j]  -  1;	      int    point[j]    =    permutation[j];    	non-compiled	[CE]  ']'  expected	9	None	replace
27	[BUG]  [BUGGY]  int  pj  =  permutation[j]  +  1;  int  pj  =  permutation[j]  +  1;  [CE]  variable  pj  is  already  defined  in  method  doOptimize()  [FE]    ArrayIndexOutOfBoundsException    [CONTEXT]    xNorm+=  xK  *  xK;  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {    [BUGGY]  int  pj  =  permutation[j]  +  1;  int  pj  =  permutation[j]  +  1;  [BUGGY]    point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	428	428	2	replace	int    pj    =    permutation[j]    +    1;    int  pj  =  permutation[j]  +  1;	  	non-compiled	[CE]  variable  pj  is  already  defined  in  method  doOptimize()	2	None	add
28	[BUG]  [BUGGY]  int  pj  =  permutation[j]  +  1;  Int  pj  =  permutation[j]  +  1;  [CE]  cannot  find  symbol  [FE]      ArrayIndexOutOfBoundsException    [CONTEXT]    xNorm+=  xK  *  xK;  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {    [BUGGY]  int  pj  =  permutation[j]  +  1;  Int  pj  =  permutation[j]  +  1;  [BUGGY]    point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	428	428	2	replace	int    pj    =    permutation[j]    +    1;    Int  pj  =  permutation[j]  +  1;	  	non-compiled	[CE]  cannot  find  symbol	2	None	add
29	[BUG]  [BUGGY]  int  pj  =  permutation[j]  +  1;  int  j  =  permutation[j]  +  1;  [CE]  variable  j  is  already  defined  in  method  doOptimize()  [FE]        ArrayIndexOutOfBoundsException    [CONTEXT]    xNorm+=  xK  *  xK;  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {    [BUGGY]  int  pj  =  permutation[j]  +  1;  int  j  =  permutation[j]  +  1;  [BUGGY]    point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	428	428	2	replace	int    pj    =    permutation[j]    +    1;    int  j  =  permutation[j]  +  1;	  	non-compiled	[CE]  variable  j  is  already  defined  in  method  doOptimize()	2	None	add
30	[BUG]  [BUGGY]  int  pj  =  permutation[j]  +  1;  int  pj  =  permutation[j]  +  2;  [CE]  variable  pj  is  already  defined  in  method  doOptimize()  [FE]          ArrayIndexOutOfBoundsException    [CONTEXT]    xNorm+=  xK  *  xK;  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {    [BUGGY]  int  pj  =  permutation[j]  +  1;  int  pj  =  permutation[j]  +  2;  [BUGGY]    point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	428	428	2	replace	int    pj    =    permutation[j]    +    1;    int  pj  =  permutation[j]  +  2;	  	non-compiled	[CE]  variable  pj  is  already  defined  in  method  doOptimize()	2	None	add
31	[BUG]  [BUGGY]  int  point[j]  =  oldX;  [CE]  ']'  expected  [FE]                AssertionFailedError    [CONTEXT]    xNorm+=  xK  *  xK;  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {    [BUGGY]  int  point[j]  =  oldX;  [BUGGY]    int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	428	428	2	replace	int  point[j]  =  oldX;	      int    point[j]    =    previousCost;    	non-compiled	[CE]  ']'  expected	13	None	replace
32	[BUG]  [BUGGY]  double  pj  =  oldX[j];  [CE]  possible  loss  of  precision  [FE]        AssertionFailedError    [CONTEXT]    xNorm+=  xK  *  xK;  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {    [BUGGY]  double  pj  =  oldX[j];  [BUGGY]    point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	428	428	2	replace	double  pj  =  oldX[j];	  int    pj    =    oldX[j];    	non-compiled	[CE]  possible  loss  of  precision	1	None	replace
33	[BUG]  [BUGGY]  float  pj  =  oldX[j];  [CE]  possible  loss  of  precision  [FE]          AssertionFailedError    [CONTEXT]    xNorm+=  xK  *  xK;  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {    [BUGGY]  float  pj  =  oldX[j];  [BUGGY]    point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	428	428	2	replace	float  pj  =  oldX[j];	  int    pj    =    oldX[j];    	non-compiled	[CE]  possible  loss  of  precision	1	None	replace
34	[BUG]  [BUGGY]  long  pj  =  oldX[j];  [CE]  possible  loss  of  precision  [FE]            AssertionFailedError    [CONTEXT]    xNorm+=  xK  *  xK;  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {    [BUGGY]  long  pj  =  oldX[j];  [BUGGY]    point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	428	428	2	replace	long  pj  =  oldX[j];	  int    pj    =    oldX[j];    	non-compiled	[CE]  possible  loss  of  precision	1	None	replace
35	[BUG]  [BUGGY]  int  oldX  =  permutation[j]  -  1;  [CE]  variable  oldX  is  already  defined  in  method  doOptimize()  [FE]        AssertionFailedError    [CONTEXT]    xNorm+=  xK  *  xK;  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {    [BUGGY]  int  oldX  =  permutation[j]  -  1;  [BUGGY]    int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	428	428	2	replace	int  oldX  =  permutation[j]  -  1;	      int    oldX    =    permutation[j];    	non-compiled	[CE]  variable  oldX  is  already  defined  in  method  doOptimize()	18	None	replace
36	[BUG]  [BUGGY]  int  oldX  =  permutation[j]  +  1;  [CE]  variable  oldX  is  already  defined  in  method  doOptimize()  [FE]          AssertionFailedError    [CONTEXT]    xNorm+=  xK  *  xK;  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {    [BUGGY]  int  oldX  =  permutation[j]  +  1;  [BUGGY]    int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	428	428	2	replace	int  oldX  =  permutation[j]  +  1;	      int    oldX    =    permutation[j];    	non-compiled	[CE]  variable  oldX  is  already  defined  in  method  doOptimize()	18	None	replace
37	[BUG]  [BUGGY]  int  oldX  =  permutation[j]  +  cost;  [CE]  variable  oldX  is  already  defined  in  method  doOptimize()  [FE]            AssertionFailedError    [CONTEXT]    xNorm+=  xK  *  xK;  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {    [BUGGY]  int  oldX  =  permutation[j]  +  cost;  [BUGGY]    int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	428	428	2	replace	int  oldX  =  permutation[j]  +  cost;	      int    oldX    =    permutation[j];    	non-compiled	[CE]  variable  oldX  is  already  defined  in  method  doOptimize()	18	None	replace
38	[BUG]  [BUGGY]  double  pj  =  previousCost.doubleValue();  [CE]  double  cannot  be  dereferenced  [FE]                AssertionFailedError    [CONTEXT]    xNorm+=  xK  *  xK;  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {    [BUGGY]  double  pj  =  previousCost.doubleValue();  [BUGGY]    point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	428	428	2	replace	double  pj  =  previousCost.doubleValue();	      	non-compiled	[CE]  double  cannot  be  dereferenced	8	None	replace
39	[BUG]  [BUGGY]  tmpVec  =  Math.sqrt(previousCost);  [CE]  incompatible  types  [FE]                  AssertionFailedError    [CONTEXT]    xNorm+=  xK  *  xK;  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {    [BUGGY]  tmpVec  =  Math.sqrt(previousCost);  [BUGGY]    point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	428	428	2	replace	tmpVec  =  Math.sqrt(previousCost);	      	non-compiled	[CE]  incompatible  types	8	None	replace
40	[BUG]  [BUGGY]  int  pj  =  previousCost.getPosition();  [CE]  double  cannot  be  dereferenced  [FE]                    AssertionFailedError    [CONTEXT]    xNorm+=  xK  *  xK;  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {    [BUGGY]  int  pj  =  previousCost.getPosition();  [BUGGY]    point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	428	428	2	replace	int  pj  =  previousCost.getPosition();	      	non-compiled	[CE]  double  cannot  be  dereferenced	8	None	replace
41	[BUG]  [BUGGY]  tmpVec  =  cost;  [CE]  incompatible  types  [FE]                      AssertionFailedError    [CONTEXT]    xNorm+=  xK  *  xK;  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {    [BUGGY]  tmpVec  =  cost;  [BUGGY]    point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	428	428	2	replace	tmpVec  =  cost;	      	non-compiled	[CE]  incompatible  types	8	None	replace
42	[BUG]  [BUGGY]  int  point  =  permutation[j]  -  1;  [CE]  cannot  find  symbol  pj  [FE]        AssertionFailedError    [CONTEXT]    xNorm+=  xK  *  xK;  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {    [BUGGY]  int  point  =  permutation[j]  -  1;  [BUGGY]    int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	428	428	2	replace	int  point  =  permutation[j]  -  1;	      int    point    =    permutation[j];    	non-compiled	[CE]  cannot  find  symbol  pj	14	None	replace
43	[BUG]  [BUGGY]  int  point  =  permutation[j]  +  1;  [CE]  cannot  find  symbol  pj  [FE]          AssertionFailedError    [CONTEXT]    xNorm+=  xK  *  xK;  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {    [BUGGY]  int  point  =  permutation[j]  +  1;  [BUGGY]    int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	428	428	2	replace	int  point  =  permutation[j]  +  1;	      int    point    =    permutation[j];    	non-compiled	[CE]  cannot  find  symbol  pj	14	None	replace
44	[BUG]  [BUGGY]  int  point  =  permutation[j]  &  0xff;  [CE]  cannot  find  symbol  pj  [FE]            AssertionFailedError    [CONTEXT]    xNorm+=  xK  *  xK;  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {    [BUGGY]  int  point  =  permutation[j]  &  0xff;  [BUGGY]    int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	428	428	2	replace	int  point  =  permutation[j]  &  0xff;	      int    point    =    permutation[j];    	non-compiled	[CE]  cannot  find  symbol  pj	14	None	replace
45	[BUG]  [BUGGY]  int  point[j]  =  permutation[j].doubleValue()  +  1;  [CE]  ']'  expected  [FE]              AssertionFailedError    [CONTEXT]    xNorm+=  xK  *  xK;  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {    [BUGGY]  int  point[j]  =  permutation[j].doubleValue()  +  1;  [BUGGY]    int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	428	428	2	replace	int  point[j]  =  permutation[j].doubleValue()  +  1;	      int    point[j]    =    permutation[j].doubleValue();    	non-compiled	[CE]  ']'  expected	12	None	replace
46	[BUG]  [BUGGY]  int  point[j]  =  permutation[j].doubleValue()  -  1;  [CE]  ']'  expected  [FE]                AssertionFailedError    [CONTEXT]    xNorm+=  xK  *  xK;  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {    [BUGGY]  int  point[j]  =  permutation[j].doubleValue()  -  1;  [BUGGY]    int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	428	428	2	replace	int  point[j]  =  permutation[j].doubleValue()  -  1;	      int    point[j]    =    permutation[j].doubleValue();    	non-compiled	[CE]  ']'  expected	12	None	replace
47	[BUG]  [BUGGY]  int  point[j]  =  permutation[j].doubleValue()  +  2;  [CE]  ']'  expected  [FE]                  AssertionFailedError    [CONTEXT]    xNorm+=  xK  *  xK;  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {    [BUGGY]  int  point[j]  =  permutation[j].doubleValue()  +  2;  [BUGGY]    int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	428	428	2	replace	int  point[j]  =  permutation[j].doubleValue()  +  2;	      int    point[j]    =    permutation[j].doubleValue();    	non-compiled	[CE]  ']'  expected	12	None	replace
48	[BUG]  [BUGGY]  double  pj  =  point[j];  [CE]  possible  loss  of  precision  [FE]        AssertionFailedError    [CONTEXT]    xNorm+=  xK  *  xK;  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {    [BUGGY]  double  pj  =  point[j];  [BUGGY]    point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	428	428	2	replace	double  pj  =  point[j];	  int    pj    =    point[j];    	non-compiled	[CE]  possible  loss  of  precision	17	None	replace
49	[BUG]  [BUGGY]  float  pj  =  point[j];  [CE]  possible  loss  of  precision  [FE]          AssertionFailedError    [CONTEXT]    xNorm+=  xK  *  xK;  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {    [BUGGY]  float  pj  =  point[j];  [BUGGY]    point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	428	428	2	replace	float  pj  =  point[j];	  int    pj    =    point[j];    	non-compiled	[CE]  possible  loss  of  precision	17	None	replace
50	[BUG]  [BUGGY]  long  pj  =  point[j];  [CE]  possible  loss  of  precision  [FE]            AssertionFailedError    [CONTEXT]    xNorm+=  xK  *  xK;  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {    [BUGGY]  long  pj  =  point[j];  [BUGGY]    point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	428	428	2	replace	long  pj  =  point[j];	  int    pj    =    point[j];    	non-compiled	[CE]  possible  loss  of  precision	17	None	replace
51	[BUG]  [BUGGY]  double  point  =  oldX[j];  [CE]  cannot  find  symbol  pj  [FE]            AssertionFailedError    [CONTEXT]    xNorm+=  xK  *  xK;  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {    [BUGGY]  double  point  =  oldX[j];  [BUGGY]    int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	428	428	2	replace	double  point  =  oldX[j];	      int    point    =    oldX[j];    	non-compiled	[CE]  cannot  find  symbol  pj	16	None	replace
52	[BUG]  [BUGGY]  float  point  =  oldX[j];  [CE]  possible  loss  of  precision  [FE]              AssertionFailedError    [CONTEXT]    xNorm+=  xK  *  xK;  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {    [BUGGY]  float  point  =  oldX[j];  [BUGGY]    int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	428	428	2	replace	float  point  =  oldX[j];	      int    point    =    oldX[j];    	non-compiled	[CE]  possible  loss  of  precision	16	None	replace
53	[BUG]  [BUGGY]  long  point  =  oldX[j];  [CE]  possible  loss  of  precision  [FE]                AssertionFailedError    [CONTEXT]    xNorm+=  xK  *  xK;  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {    [BUGGY]  long  point  =  oldX[j];  [BUGGY]    int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	428	428	2	replace	long  point  =  oldX[j];	      int    point    =    oldX[j];    	non-compiled	[CE]  possible  loss  of  precision	16	None	replace
54	[BUG]  [BUGGY]  [FE]  ArrayIndexOutOfBoundsException  [FE]    ArrayIndexOutOfBoundsException    [CONTEXT]    xNorm+=  xK  *  xK;  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {    [BUGGY]  int  pj  =  permutation[j]  -  2;  [BUGGY]    point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	428	428	2	add	int  pj  =  permutation[j]  -  2;	  int    pj    =    permutation[j]    -    1;    	compilable	  [FE]  ArrayIndexOutOfBoundsException  	5	15	replace
55	[BUG]  [BUGGY]  int  pj  =  permutation[j]  -  2;  [FE]  ArrayIndexOutOfBoundsException  [FE]    ArrayIndexOutOfBoundsException    [CONTEXT]    xNorm+=  xK  *  xK;  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {    [BUGGY]  int  pj  =  permutation[j]  -  2;  [BUGGY]    point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	428	428	2	replace	int  pj  =  permutation[j]  -  2;	  int    pj    =    permutation[j]    -    1;    	compilable	  [FE]  ArrayIndexOutOfBoundsException  	5	15	replace
56	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      ArrayIndexOutOfBoundsException    [CONTEXT]    xNorm+=  xK  *  xK;  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {    [BUGGY]  int  pj  =  permutation[j]  /  1;  [BUGGY]    point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	428	428	2	add	int  pj  =  permutation[j]  /  1;	  int    pj    =    permutation[j]    -    1;    	compilable	  [FE]  AssertionFailedError  	5	2	replace
57	[BUG]  [BUGGY]  int  pj  =  permutation[j]  /  1;  [FE]  AssertionFailedError  [FE]      ArrayIndexOutOfBoundsException    [CONTEXT]    xNorm+=  xK  *  xK;  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {    [BUGGY]  int  pj  =  permutation[j]  /  1;  [BUGGY]    point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	428	428	2	replace	int  pj  =  permutation[j]  /  1;	  int    pj    =    permutation[j]    -    1;    	compilable	  [FE]  AssertionFailedError  	5	2	replace
58	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        ArrayIndexOutOfBoundsException    [CONTEXT]    xNorm+=  xK  *  xK;  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {    [BUGGY]  int  pj  =  permutation[j]  -  1  +  1;  [BUGGY]    point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	428	428	2	add	int  pj  =  permutation[j]  -  1  +  1;	  int    pj    =    permutation[j]    -    1;    	compilable	  [FE]  AssertionFailedError  	5	2	replace
59	[BUG]  [BUGGY]  int  pj  =  permutation[j]  -  1  +  1;  [FE]  AssertionFailedError  [FE]        ArrayIndexOutOfBoundsException    [CONTEXT]    xNorm+=  xK  *  xK;  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {    [BUGGY]  int  pj  =  permutation[j]  -  1  +  1;  [BUGGY]    point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	428	428	2	replace	int  pj  =  permutation[j]  -  1  +  1;	  int    pj    =    permutation[j]    -    1;    	compilable	  [FE]  AssertionFailedError  	5	2	replace
60	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    ArrayIndexOutOfBoundsException    [CONTEXT]    xNorm+=  xK  *  xK;  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {    [BUGGY]  int  pj  =  permutation[j]  *  1;  [BUGGY]    point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	428	428	2	add	int  pj  =  permutation[j]  *  1;	  int    pj    =    permutation[j]    +    1;    	compilable	  [FE]  AssertionFailedError  	3	2	replace
61	[BUG]  [BUGGY]  int  pj  =  permutation[j]  *  1;  [FE]  AssertionFailedError  [FE]    ArrayIndexOutOfBoundsException    [CONTEXT]    xNorm+=  xK  *  xK;  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {    [BUGGY]  int  pj  =  permutation[j]  *  1;  [BUGGY]    point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	428	428	2	replace	int  pj  =  permutation[j]  *  1;	  int    pj    =    permutation[j]    +    1;    	compilable	  [FE]  AssertionFailedError  	3	2	replace
62	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    ArrayIndexOutOfBoundsException    [CONTEXT]    xNorm+=  xK  *  xK;  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {    [BUGGY]  int  pj  =  permutation[j  *  1];  [BUGGY]    point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	428	428	2	add	int  pj  =  permutation[j  *  1];	  int    pj    =    permutation[j    +    1];    	compilable	  [FE]  AssertionFailedError  	7	2	replace
63	[BUG]  [BUGGY]  int  pj  =  permutation[j  *  1];  [FE]  AssertionFailedError  [FE]    ArrayIndexOutOfBoundsException    [CONTEXT]    xNorm+=  xK  *  xK;  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {    [BUGGY]  int  pj  =  permutation[j  *  1];  [BUGGY]    point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	428	428	2	replace	int  pj  =  permutation[j  *  1];	  int    pj    =    permutation[j    +    1];    	compilable	  [FE]  AssertionFailedError  	7	2	replace
64	[BUG]  [BUGGY]  [FE]  ArrayIndexOutOfBoundsException  [FE]      ArrayIndexOutOfBoundsException    [CONTEXT]    xNorm+=  xK  *  xK;  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {    [BUGGY]  int  pj  =  permutation[j  +  2];  [BUGGY]    point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	428	428	2	add	int  pj  =  permutation[j  +  2];	  int    pj    =    permutation[j    +    1];    	compilable	  [FE]  ArrayIndexOutOfBoundsException  	7	15	replace
65	[BUG]  [BUGGY]  int  pj  =  permutation[j  +  2];  [FE]  ArrayIndexOutOfBoundsException  [FE]      ArrayIndexOutOfBoundsException    [CONTEXT]    xNorm+=  xK  *  xK;  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {    [BUGGY]  int  pj  =  permutation[j  +  2];  [BUGGY]    point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	428	428	2	replace	int  pj  =  permutation[j  +  2];	  int    pj    =    permutation[j    +    1];    	compilable	  [FE]  ArrayIndexOutOfBoundsException  	7	15	replace
66	[BUG]  [BUGGY]  int  pj  =  permutation[j  -  1];  int  pj  =  permutation[j  +  1];  [CE]  variable  pj  is  already  defined  in  method  doOptimize()  [FE]    ArrayIndexOutOfBoundsException    [CONTEXT]    xNorm+=  xK  *  xK;  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {    [BUGGY]  int  pj  =  permutation[j  -  1];  int  pj  =  permutation[j  +  1];  [BUGGY]    point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	428	428	2	replace	int    pj    =    permutation[j    -    1];    int  pj  =  permutation[j  +  1];	  	non-compiled	[CE]  variable  pj  is  already  defined  in  method  doOptimize()	19	None	add
67	[BUG]  [BUGGY]  int  point[j]  =  oldX[j].doubleValue();  [CE]  ']'  expected  [FE]              AssertionFailedError    [CONTEXT]    xNorm+=  xK  *  xK;  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {    [BUGGY]  int  point[j]  =  oldX[j].doubleValue();  [BUGGY]    int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	428	428	2	replace	int  point[j]  =  oldX[j].doubleValue();	      int    point[j]    =    permutation[j].doubleValue();    	non-compiled	[CE]  ']'  expected	12	None	replace
68	[BUG]  [BUGGY]  int  point[j]  =  oldRes[j];  [CE]  ']'  expected  [FE]            AssertionFailedError    [CONTEXT]    xNorm+=  xK  *  xK;  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {    [BUGGY]  int  point[j]  =  oldRes[j];  [BUGGY]    int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	428	428	2	replace	int  point[j]  =  oldRes[j];	      int    point[j]    =    oldX[j];    	non-compiled	[CE]  ']'  expected	11	None	replace
69	[BUG]  [BUGGY]  int  point[j]  =  oldX[j]  +  1;  [CE]  ']'  expected  [FE]              AssertionFailedError    [CONTEXT]    xNorm+=  xK  *  xK;  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {    [BUGGY]  int  point[j]  =  oldX[j]  +  1;  [BUGGY]    int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	428	428	2	replace	int  point[j]  =  oldX[j]  +  1;	      int    point[j]    =    oldX[j];    	non-compiled	[CE]  ']'  expected	11	None	replace
70	[BUG]  [BUGGY]  [FE]  ArrayIndexOutOfBoundsException  [FE]    ArrayIndexOutOfBoundsException    [CONTEXT]    xNorm+=  xK  *  xK;  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {    [BUGGY]  int  pj  =  permutation[j  -  1]  &  0x7F;  [BUGGY]    point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	428	428	2	add	int  pj  =  permutation[j  -  1]  &  0x7F;	  int    pj    =    permutation[j    -    1];    	compilable	  [FE]  ArrayIndexOutOfBoundsException  	20	15	replace
71	[BUG]  [BUGGY]  int  pj  =  permutation[j  -  1]  &  0x7F;  [FE]  ArrayIndexOutOfBoundsException  [FE]    ArrayIndexOutOfBoundsException    [CONTEXT]    xNorm+=  xK  *  xK;  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {    [BUGGY]  int  pj  =  permutation[j  -  1]  &  0x7F;  [BUGGY]    point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	428	428	2	replace	int  pj  =  permutation[j  -  1]  &  0x7F;	  int    pj    =    permutation[j    -    1];    	compilable	  [FE]  ArrayIndexOutOfBoundsException  	20	15	replace
72	[BUG]  [BUGGY]  int  pj  =  oldX[j];  point[pj]  =  permutation[j];  [CE]  possible  loss  of  precision  [FE]          AssertionFailedError    [CONTEXT]    xNorm+=  xK  *  xK;  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {    [BUGGY]  int  pj  =  oldX[j];  point[pj]  =  permutation[j];  [BUGGY]    int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	428	428	2	replace	int  pj  =  oldX[j];  point[pj]  =  permutation[j];	      int    pj    =    permutation[j];    point[pj]    =    oldX[pj];    	non-compiled	[CE]  possible  loss  of  precision	15	None	replace
73	[BUG]  [BUGGY]  float  pj  =  permutation[j];  point[pj]  =  oldX[pj];  [CE]  possible  loss  of  precision  [FE]            AssertionFailedError    [CONTEXT]    xNorm+=  xK  *  xK;  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {    [BUGGY]  float  pj  =  permutation[j];  point[pj]  =  oldX[pj];  [BUGGY]    int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	428	428	2	replace	float  pj  =  permutation[j];  point[pj]  =  oldX[pj];	      int    pj    =    permutation[j];    point[pj]    =    oldX[pj];    	non-compiled	[CE]  possible  loss  of  precision	15	None	replace
74	[BUG]  [BUGGY]  double  pj  =  Math.sqrt(previousCost);  [CE]  possible  loss  of  precision  [FE]                AssertionFailedError    [CONTEXT]    xNorm+=  xK  *  xK;  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {    [BUGGY]  double  pj  =  Math.sqrt(previousCost);  [BUGGY]    point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	428	428	2	replace	double  pj  =  Math.sqrt(previousCost);	      	non-compiled	[CE]  possible  loss  of  precision	8	None	replace
75	[BUG]  [BUGGY]  [FE]  ArrayIndexOutOfBoundsException  [FE]                  AssertionFailedError    [CONTEXT]    xNorm+=  xK  *  xK;  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {    [BUGGY]  int  pj  =  oldX.length;  [BUGGY]    point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	428	428	2	add	int  pj  =  oldX.length;	      	compilable	  [FE]  ArrayIndexOutOfBoundsException  	8	15	replace
76	[BUG]  [BUGGY]  int  pj  =  oldX.length;  [FE]  ArrayIndexOutOfBoundsException  [FE]                  AssertionFailedError    [CONTEXT]    xNorm+=  xK  *  xK;  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {    [BUGGY]  int  pj  =  oldX.length;  [BUGGY]    point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	428	428	2	replace	int  pj  =  oldX.length;	      	compilable	  [FE]  ArrayIndexOutOfBoundsException  	8	15	replace
77	[BUG]  [BUGGY]  int  pj  =  permutation[j]  +  1;  tmpVec  =  permutation[j]  +  1;  [CE]  incompatible  types  [FE]    ArrayIndexOutOfBoundsException    [CONTEXT]    xNorm+=  xK  *  xK;  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {    [BUGGY]  int  pj  =  permutation[j]  +  1;  tmpVec  =  permutation[j]  +  1;  [BUGGY]    point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	428	428	2	replace	int    pj    =    permutation[j]    +    1;    tmpVec  =  permutation[j]  +  1;	  	non-compiled	[CE]  incompatible  types	2	None	add
78	[BUG]  [BUGGY]  [FE]  ArrayIndexOutOfBoundsException  [FE]    ArrayIndexOutOfBoundsException    [CONTEXT]    xNorm+=  xK  *  xK;  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {    [BUGGY]  int  pj  =  permutation[j  +  1]  -  1;  [BUGGY]    point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	428	428	2	add	int  pj  =  permutation[j  +  1]  -  1;	  int    pj    =    permutation[j    +    1];    	compilable	  [FE]  ArrayIndexOutOfBoundsException  	7	15	replace
79	[BUG]  [BUGGY]  int  pj  =  permutation[j  +  1]  -  1;  [FE]  ArrayIndexOutOfBoundsException  [FE]    ArrayIndexOutOfBoundsException    [CONTEXT]    xNorm+=  xK  *  xK;  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {    [BUGGY]  int  pj  =  permutation[j  +  1]  -  1;  [BUGGY]    point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	428	428	2	replace	int  pj  =  permutation[j  +  1]  -  1;	  int    pj    =    permutation[j    +    1];    	compilable	  [FE]  ArrayIndexOutOfBoundsException  	7	15	replace
80	[BUG]  [BUGGY]  int  point[j]  =  preRed;  [CE]  ']'  expected  [FE]                AssertionFailedError    [CONTEXT]    xNorm+=  xK  *  xK;  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {    [BUGGY]  int  point[j]  =  preRed;  [BUGGY]    int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	428	428	2	replace	int  point[j]  =  preRed;	      int    point[j]    =    previousCost;    	non-compiled	[CE]  ']'  expected	13	None	replace
81	[BUG]  [BUGGY]  int  permutation[j]  =  0;  [CE]  ']'  expected  [FE]          AssertionFailedError    [CONTEXT]    xNorm+=  xK  *  xK;  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {    [BUGGY]  int  permutation[j]  =  0;  [BUGGY]    int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	428	428	2	replace	int  permutation[j]  =  0;	      int    permutation[j]    =    permutation[j];    	non-compiled	[CE]  ']'  expected	10	None	replace
82	[BUG]  [BUGGY]  int  oldX  =  permutation[j]  &  0xF;  [CE]  variable  oldX  is  already  defined  in  method  doOptimize()  [FE]        AssertionFailedError    [CONTEXT]    xNorm+=  xK  *  xK;  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {    [BUGGY]  int  oldX  =  permutation[j]  &  0xF;  [BUGGY]    int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	428	428	2	replace	int  oldX  =  permutation[j]  &  0xF;	      int    oldX    =    permutation[j];    	non-compiled	[CE]  variable  oldX  is  already  defined  in  method  doOptimize()	18	None	replace
83	[BUG]  [BUGGY]  int  point[j]  =  value;  [CE]  ']'  expected  [FE]                AssertionFailedError    [CONTEXT]    xNorm+=  xK  *  xK;  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {    [BUGGY]  int  point[j]  =  value;  [BUGGY]    int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	428	428	2	replace	int  point[j]  =  value;	      int    point[j]    =    previousCost;    	non-compiled	[CE]  ']'  expected	13	None	replace
84	[BUG]  [BUGGY]  [FE]  ArrayIndexOutOfBoundsException  [FE]    ArrayIndexOutOfBoundsException    [CONTEXT]    xNorm+=  xK  *  xK;  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {    [BUGGY]  int  pj  =  permutation[j  -  1]  &  0xFFFF;  [BUGGY]    point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	428	428	2	add	int  pj  =  permutation[j  -  1]  &  0xFFFF;	  int    pj    =    permutation[j    -    1];    	compilable	  [FE]  ArrayIndexOutOfBoundsException  	20	15	replace
85	[BUG]  [BUGGY]  int  pj  =  permutation[j  -  1]  &  0xFFFF;  [FE]  ArrayIndexOutOfBoundsException  [FE]    ArrayIndexOutOfBoundsException    [CONTEXT]    xNorm+=  xK  *  xK;  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {    [BUGGY]  int  pj  =  permutation[j  -  1]  &  0xFFFF;  [BUGGY]    point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	428	428	2	replace	int  pj  =  permutation[j  -  1]  &  0xFFFF;	  int    pj    =    permutation[j    -    1];    	compilable	  [FE]  ArrayIndexOutOfBoundsException  	20	15	replace
86	[BUG]  [BUGGY]  int  point[j]  =  cost.doubleValue();  [CE]  ']'  expected  [FE]              AssertionFailedError    [CONTEXT]    xNorm+=  xK  *  xK;  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {    [BUGGY]  int  point[j]  =  cost.doubleValue();  [BUGGY]    int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	428	428	2	replace	int  point[j]  =  cost.doubleValue();	      int    point[j]    =    permutation[j].doubleValue();    	non-compiled	[CE]  ']'  expected	12	None	replace
87	[BUG]  [BUGGY]  int  oldX  =  xK[j];  [CE]  variable  oldX  is  already  defined  in  method  doOptimize()  [FE]        AssertionFailedError    [CONTEXT]    xNorm+=  xK  *  xK;  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {    [BUGGY]  int  oldX  =  xK[j];  [BUGGY]    int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	428	428	2	replace	int  oldX  =  xK[j];	      int    oldX    =    permutation[j];    	non-compiled	[CE]  variable  oldX  is  already  defined  in  method  doOptimize()	18	None	replace
88	[BUG]  [BUGGY]  int  pj  =  permutation[j]  -  1;  tmpVec  =  permutation[j]  -  1;  [CE]  incompatible  types  [FE]    ArrayIndexOutOfBoundsException    [CONTEXT]    xNorm+=  xK  *  xK;  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {    [BUGGY]  int  pj  =  permutation[j]  -  1;  tmpVec  =  permutation[j]  -  1;  [BUGGY]    point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	428	428	2	replace	int    pj    =    permutation[j]    -    1;    tmpVec  =  permutation[j]  -  1;	  	non-compiled	[CE]  incompatible  types	4	None	add
89	[BUG]  [BUGGY]  Double  pj  =  oldX[j];  [CE]  incompatible  types  [FE]        AssertionFailedError    [CONTEXT]    xNorm+=  xK  *  xK;  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {    [BUGGY]  Double  pj  =  oldX[j];  [BUGGY]    point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	428	428	2	replace	Double  pj  =  oldX[j];	  int    pj    =    oldX[j];    	non-compiled	[CE]  incompatible  types	1	None	replace
90	[BUG]  [BUGGY]  int  pj  =  previousCost[j];  point[pj]  =  oldX[pj];  [CE]  array  required,  but  double  found  [FE]          AssertionFailedError    [CONTEXT]    xNorm+=  xK  *  xK;  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {    [BUGGY]  int  pj  =  previousCost[j];  point[pj]  =  oldX[pj];  [BUGGY]    int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	428	428	2	replace	int  pj  =  previousCost[j];  point[pj]  =  oldX[pj];	      int    pj    =    permutation[j];    point[pj]    =    oldX[pj];    	non-compiled	[CE]  array  required,  but  double  found	15	None	replace
91	[BUG]  [BUGGY]  int  point[j]  =  oldX[j]  +  cost;  [CE]  ']'  expected  [FE]            AssertionFailedError    [CONTEXT]    xNorm+=  xK  *  xK;  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {    [BUGGY]  int  point[j]  =  oldX[j]  +  cost;  [BUGGY]    int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	428	428	2	replace	int  point[j]  =  oldX[j]  +  cost;	      int    point[j]    =    oldX[j];    	non-compiled	[CE]  ']'  expected	11	None	replace
92	[BUG]  [BUGGY]  double  pj  =  Math.sqrt(coeff1);  [CE]  possible  loss  of  precision  [FE]                AssertionFailedError    [CONTEXT]    xNorm+=  xK  *  xK;  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {    [BUGGY]  double  pj  =  Math.sqrt(coeff1);  [BUGGY]    point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	428	428	2	replace	double  pj  =  Math.sqrt(coeff1);	      	non-compiled	[CE]  possible  loss  of  precision	8	None	replace
93	[BUG]  [BUGGY]  [FE]  ArrayIndexOutOfBoundsException  [FE]    ArrayIndexOutOfBoundsException    [CONTEXT]    xNorm+=  xK  *  xK;  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {    [BUGGY]  int  pj  =  permutation[j  +  1]  &  0xff;  [BUGGY]    point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	428	428	2	add	int  pj  =  permutation[j  +  1]  &  0xff;	  int    pj    =    permutation[j    +    1];    	compilable	  [FE]  ArrayIndexOutOfBoundsException  	7	15	replace
94	[BUG]  [BUGGY]  int  pj  =  permutation[j  +  1]  &  0xff;  [FE]  ArrayIndexOutOfBoundsException  [FE]    ArrayIndexOutOfBoundsException    [CONTEXT]    xNorm+=  xK  *  xK;  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {    [BUGGY]  int  pj  =  permutation[j  +  1]  &  0xff;  [BUGGY]    point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	428	428	2	replace	int  pj  =  permutation[j  +  1]  &  0xff;	  int    pj    =    permutation[j    +    1];    	compilable	  [FE]  ArrayIndexOutOfBoundsException  	7	15	replace
