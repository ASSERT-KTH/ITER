bugid	buggy	buggy_class	suspiciousness	buggy_line	endbuggycode	failing_test_number	action	patch
1	[BUG] [BUGGY] formatLongBinary(value, buf, offset, length, negative); [FE] IllegalArgumentException [CONTEXT]  final long maxAsOctalChar = length == TarConstants.UIDLEN ? TarConstants.MAXID : TarConstants.MAXSIZE; final boolean negative = value < 0; if (!negative && value <= maxAsOctalChar) { // OK to store as octal chars return formatLongOctalBytes(value, buf, offset, length); } if (length < 9) { [BUGGY] formatLongBinary(value, buf, offset, length, negative); [BUGGY] } formatBigIntegerBinary(value, buf, offset, length, negative); buf[offset] = (byte) (negative ? 0xff : 0x80); return offset + length; } [CLASS] TarUtils 1 [METHOD] formatLongOctalOrBinaryBytes [RETURN_TYPE] int  final long value final byte[] buf final int offset final int length [VARIABLES] byte[] buf boolean negative ZipEncoding DEFAULT_ENCODING FALLBACK_ENCODING encoding int BYTE_MASK current end i idx len length limit offset remaining start long maxAsOctalChar value  	projects/Compress45/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java	1.0	486	486	1	replace	
2	[BUG] [BUGGY] [FE] IllegalArgumentException [CONTEXT]  final long maxAsOctalChar = length == TarConstants.UIDLEN ? TarConstants.MAXID : TarConstants.MAXSIZE; final boolean negative = value < 0; if (!negative && value <= maxAsOctalChar) { // OK to store as octal chars return formatLongOctalBytes(value, buf, offset, length); } if (length < 9) { [BUGGY] [BUGGY] formatLongBinary(value, buf, offset, length, negative); } formatBigIntegerBinary(value, buf, offset, length, negative); buf[offset] = (byte) (negative ? 0xff : 0x80); return offset + length; } [CLASS] TarUtils 1 [METHOD] formatLongOctalOrBinaryBytes [RETURN_TYPE] int  final long value final byte[] buf final int offset final int length [VARIABLES] byte[] buf boolean negative ZipEncoding DEFAULT_ENCODING FALLBACK_ENCODING encoding int BYTE_MASK current end i idx len length limit offset remaining start long maxAsOctalChar value  	projects/Compress45/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java	1.0	486	486	1	add	
3	[BUG] [BUGGY] final int bits = (length - 1) * 8; [FE] IllegalArgumentException [CONTEXT] private static void formatLongBinary(final long value, final byte[] buf, final int offset, final int length, final boolean negative) { [BUGGY] final int bits = (length - 1) * 8; [BUGGY] final long max = 1l << bits; long val = Math.abs(value); // Long.MIN_VALUE stays Long.MIN_VALUE if (val < 0 || val >= max) { throw new IllegalArgumentException("Value " + value + " is too large for " + length + " byte field."); } if (negative) { val ^= max - 1; val++; val |= 0xffl << bits; [CLASS] TarUtils 1 [METHOD] formatLongBinary [RETURN_TYPE] void  final long value final byte[] buf final int offset final int length final boolean negative [VARIABLES] byte[] buf boolean negative ZipEncoding DEFAULT_ENCODING FALLBACK_ENCODING encoding int BYTE_MASK bits current end i idx len length limit offset remaining start long max val value  	projects/Compress45/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java	1.0	497	497	1	replace	
4	[BUG] [BUGGY] [FE] IllegalArgumentException [CONTEXT] private static void formatLongBinary(final long value, final byte[] buf, final int offset, final int length, final boolean negative) { [BUGGY] [BUGGY] final int bits = (length - 1) * 8; final long max = 1l << bits; long val = Math.abs(value); // Long.MIN_VALUE stays Long.MIN_VALUE if (val < 0 || val >= max) { throw new IllegalArgumentException("Value " + value + " is too large for " + length + " byte field."); } if (negative) { val ^= max - 1; val++; val |= 0xffl << bits; [CLASS] TarUtils 1 [METHOD] formatLongBinary [RETURN_TYPE] void  final long value final byte[] buf final int offset final int length final boolean negative [VARIABLES] byte[] buf boolean negative ZipEncoding DEFAULT_ENCODING FALLBACK_ENCODING encoding int BYTE_MASK bits current end i idx len length limit offset remaining start long max val value  	projects/Compress45/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java	1.0	497	497	1	add	
5	[BUG] [BUGGY] final long max = 1l << bits; [FE] IllegalArgumentException [CONTEXT] private static void formatLongBinary(final long value, final byte[] buf, final int offset, final int length, final boolean negative) { final int bits = (length - 1) * 8; [BUGGY] final long max = 1l << bits; [BUGGY] long val = Math.abs(value); // Long.MIN_VALUE stays Long.MIN_VALUE if (val < 0 || val >= max) { throw new IllegalArgumentException("Value " + value + " is too large for " + length + " byte field."); } if (negative) { val ^= max - 1; val++; val |= 0xffl << bits; } [CLASS] TarUtils 1 [METHOD] formatLongBinary [RETURN_TYPE] void  final long value final byte[] buf final int offset final int length final boolean negative [VARIABLES] byte[] buf boolean negative ZipEncoding DEFAULT_ENCODING FALLBACK_ENCODING encoding int BYTE_MASK bits current end i idx len length limit offset remaining start long max val value  	projects/Compress45/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java	1.0	498	498	1	replace	
6	[BUG] [BUGGY] [FE] IllegalArgumentException [CONTEXT] private static void formatLongBinary(final long value, final byte[] buf, final int offset, final int length, final boolean negative) { final int bits = (length - 1) * 8; [BUGGY] [BUGGY] final long max = 1l << bits; long val = Math.abs(value); // Long.MIN_VALUE stays Long.MIN_VALUE if (val < 0 || val >= max) { throw new IllegalArgumentException("Value " + value + " is too large for " + length + " byte field."); } if (negative) { val ^= max - 1; val++; val |= 0xffl << bits; } [CLASS] TarUtils 1 [METHOD] formatLongBinary [RETURN_TYPE] void  final long value final byte[] buf final int offset final int length final boolean negative [VARIABLES] byte[] buf boolean negative ZipEncoding DEFAULT_ENCODING FALLBACK_ENCODING encoding int BYTE_MASK bits current end i idx len length limit offset remaining start long max val value  	projects/Compress45/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java	1.0	498	498	1	add	
7	[BUG] [BUGGY] long val = Math.abs(value); // Long.MIN_VALUE stays Long.MIN_VALUE if (val < 0 || val >= max) { [FE] IllegalArgumentException [CONTEXT] private static void formatLongBinary(final long value, final byte[] buf, final int offset, final int length, final boolean negative) { final int bits = (length - 1) * 8; final long max = 1l << bits; [BUGGY] long val = Math.abs(value); // Long.MIN_VALUE stays Long.MIN_VALUE  if (val < 0 || val >= max) { [BUGGY] if (val < 0 || val >= max) { throw new IllegalArgumentException("Value " + value + " is too large for " + length + " byte field."); } if (negative) { val ^= max - 1; val++; val |= 0xffl << bits; } for (int i = offset + length - 1; i >= offset; i--) { [CLASS] TarUtils 1 [METHOD] formatLongBinary [RETURN_TYPE] void  final long value final byte[] buf final int offset final int length final boolean negative [VARIABLES] byte[] buf boolean negative ZipEncoding DEFAULT_ENCODING FALLBACK_ENCODING encoding int BYTE_MASK bits current end i idx len length limit offset remaining start long max val value  	projects/Compress45/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java	1.0	499	500	1	replace	
8	[BUG] [BUGGY] [FE] IllegalArgumentException [CONTEXT] private static void formatLongBinary(final long value, final byte[] buf, final int offset, final int length, final boolean negative) { final int bits = (length - 1) * 8; final long max = 1l << bits; [BUGGY] [BUGGY] long val = Math.abs(value); // Long.MIN_VALUE stays Long.MIN_VALUE  if (val < 0 || val >= max) { if (val < 0 || val >= max) { throw new IllegalArgumentException("Value " + value + " is too large for " + length + " byte field."); } if (negative) { val ^= max - 1; val++; val |= 0xffl << bits; } for (int i = offset + length - 1; i >= offset; i--) { [CLASS] TarUtils 1 [METHOD] formatLongBinary [RETURN_TYPE] void  final long value final byte[] buf final int offset final int length final boolean negative [VARIABLES] byte[] buf boolean negative ZipEncoding DEFAULT_ENCODING FALLBACK_ENCODING encoding int BYTE_MASK bits current end i idx len length limit offset remaining start long max val value  	projects/Compress45/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java	1.0	499	500	1	add	
9	[BUG] [BUGGY] if (val < 0 || val >= max) { [FE] IllegalArgumentException [CONTEXT] private static void formatLongBinary(final long value, final byte[] buf, final int offset, final int length, final boolean negative) { final int bits = (length - 1) * 8; final long max = 1l << bits; long val = Math.abs(value); // Long.MIN_VALUE stays Long.MIN_VALUE [BUGGY] if (val < 0 || val >= max) { [BUGGY] throw new IllegalArgumentException("Value " + value + " is too large for " + length + " byte field."); } if (negative) { val ^= max - 1; val++; val |= 0xffl << bits; } for (int i = offset + length - 1; i >= offset; i--) { buf[i] = (byte) val; [CLASS] TarUtils 1 [METHOD] formatLongBinary [RETURN_TYPE] void  final long value final byte[] buf final int offset final int length final boolean negative [VARIABLES] byte[] buf boolean negative ZipEncoding DEFAULT_ENCODING FALLBACK_ENCODING encoding int BYTE_MASK bits current end i idx len length limit offset remaining start long max val value  	projects/Compress45/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java	1.0	500	500	1	replace	
10	[BUG] [BUGGY] [FE] IllegalArgumentException [CONTEXT] private static void formatLongBinary(final long value, final byte[] buf, final int offset, final int length, final boolean negative) { final int bits = (length - 1) * 8; final long max = 1l << bits; long val = Math.abs(value); // Long.MIN_VALUE stays Long.MIN_VALUE [BUGGY] [BUGGY] if (val < 0 || val >= max) { throw new IllegalArgumentException("Value " + value + " is too large for " + length + " byte field."); } if (negative) { val ^= max - 1; val++; val |= 0xffl << bits; } for (int i = offset + length - 1; i >= offset; i--) { buf[i] = (byte) val; [CLASS] TarUtils 1 [METHOD] formatLongBinary [RETURN_TYPE] void  final long value final byte[] buf final int offset final int length final boolean negative [VARIABLES] byte[] buf boolean negative ZipEncoding DEFAULT_ENCODING FALLBACK_ENCODING encoding int BYTE_MASK bits current end i idx len length limit offset remaining start long max val value  	projects/Compress45/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java	1.0	500	500	1	add	
11	[BUG] [BUGGY] if (negative) { [FE] IllegalArgumentException [CONTEXT] private static void formatLongBinary(final long value, final byte[] buf, final int offset, final int length, final boolean negative) { final int bits = (length - 1) * 8; final long max = 1l << bits; long val = Math.abs(value); // Long.MIN_VALUE stays Long.MIN_VALUE if (val < 0 || val >= max) { throw new IllegalArgumentException("Value " + value + " is too large for " + length + " byte field."); } [BUGGY] if (negative) { [BUGGY] val ^= max - 1; val++; val |= 0xffl << bits; } for (int i = offset + length - 1; i >= offset; i--) { buf[i] = (byte) val; val >>= 8; } } [CLASS] TarUtils 1 [METHOD] formatLongBinary [RETURN_TYPE] void  final long value final byte[] buf final int offset final int length final boolean negative [VARIABLES] byte[] buf boolean negative ZipEncoding DEFAULT_ENCODING FALLBACK_ENCODING encoding int BYTE_MASK bits current end i idx len length limit offset remaining start long max val value  	projects/Compress45/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java	1.0	504	504	1	replace	
12	[BUG] [BUGGY] [FE] IllegalArgumentException [CONTEXT] private static void formatLongBinary(final long value, final byte[] buf, final int offset, final int length, final boolean negative) { final int bits = (length - 1) * 8; final long max = 1l << bits; long val = Math.abs(value); // Long.MIN_VALUE stays Long.MIN_VALUE if (val < 0 || val >= max) { throw new IllegalArgumentException("Value " + value + " is too large for " + length + " byte field."); } [BUGGY] [BUGGY] if (negative) { val ^= max - 1; val++; val |= 0xffl << bits; } for (int i = offset + length - 1; i >= offset; i--) { buf[i] = (byte) val; val >>= 8; } } [CLASS] TarUtils 1 [METHOD] formatLongBinary [RETURN_TYPE] void  final long value final byte[] buf final int offset final int length final boolean negative [VARIABLES] byte[] buf boolean negative ZipEncoding DEFAULT_ENCODING FALLBACK_ENCODING encoding int BYTE_MASK bits current end i idx len length limit offset remaining start long max val value  	projects/Compress45/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java	1.0	504	504	1	add	
13	[BUG] [BUGGY] val ^= max - 1; [FE] IllegalArgumentException [CONTEXT] final int offset, final int length, final boolean negative) { final int bits = (length - 1) * 8; final long max = 1l << bits; long val = Math.abs(value); // Long.MIN_VALUE stays Long.MIN_VALUE if (val < 0 || val >= max) { throw new IllegalArgumentException("Value " + value + " is too large for " + length + " byte field."); } if (negative) { [BUGGY] val ^= max - 1; [BUGGY] val++; val |= 0xffl << bits; } for (int i = offset + length - 1; i >= offset; i--) { buf[i] = (byte) val; val >>= 8; } } [CLASS] TarUtils 1 [METHOD] formatLongBinary [RETURN_TYPE] void  final long value final byte[] buf final int offset final int length final boolean negative [VARIABLES] byte[] buf boolean negative ZipEncoding DEFAULT_ENCODING FALLBACK_ENCODING encoding int BYTE_MASK bits current end i idx len length limit offset remaining start long max val value  	projects/Compress45/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java	1.0	505	505	1	replace	
14	[BUG] [BUGGY] [FE] IllegalArgumentException [CONTEXT] final int offset, final int length, final boolean negative) { final int bits = (length - 1) * 8; final long max = 1l << bits; long val = Math.abs(value); // Long.MIN_VALUE stays Long.MIN_VALUE if (val < 0 || val >= max) { throw new IllegalArgumentException("Value " + value + " is too large for " + length + " byte field."); } if (negative) { [BUGGY] [BUGGY] val ^= max - 1; val++; val |= 0xffl << bits; } for (int i = offset + length - 1; i >= offset; i--) { buf[i] = (byte) val; val >>= 8; } } [CLASS] TarUtils 1 [METHOD] formatLongBinary [RETURN_TYPE] void  final long value final byte[] buf final int offset final int length final boolean negative [VARIABLES] byte[] buf boolean negative ZipEncoding DEFAULT_ENCODING FALLBACK_ENCODING encoding int BYTE_MASK bits current end i idx len length limit offset remaining start long max val value  	projects/Compress45/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java	1.0	505	505	1	add	
15	[BUG] [BUGGY] val++; [FE] IllegalArgumentException [CONTEXT] final boolean negative) { final int bits = (length - 1) * 8; final long max = 1l << bits; long val = Math.abs(value); // Long.MIN_VALUE stays Long.MIN_VALUE if (val < 0 || val >= max) { throw new IllegalArgumentException("Value " + value + " is too large for " + length + " byte field."); } if (negative) { val ^= max - 1; [BUGGY] val++; [BUGGY] val |= 0xffl << bits; } for (int i = offset + length - 1; i >= offset; i--) { buf[i] = (byte) val; val >>= 8; } } [CLASS] TarUtils 1 [METHOD] formatLongBinary [RETURN_TYPE] void  final long value final byte[] buf final int offset final int length final boolean negative [VARIABLES] byte[] buf boolean negative ZipEncoding DEFAULT_ENCODING FALLBACK_ENCODING encoding int BYTE_MASK bits current end i idx len length limit offset remaining start long max val value  	projects/Compress45/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java	1.0	506	506	1	replace	
16	[BUG] [BUGGY] [FE] IllegalArgumentException [CONTEXT] final boolean negative) { final int bits = (length - 1) * 8; final long max = 1l << bits; long val = Math.abs(value); // Long.MIN_VALUE stays Long.MIN_VALUE if (val < 0 || val >= max) { throw new IllegalArgumentException("Value " + value + " is too large for " + length + " byte field."); } if (negative) { val ^= max - 1; [BUGGY] [BUGGY] val++; val |= 0xffl << bits; } for (int i = offset + length - 1; i >= offset; i--) { buf[i] = (byte) val; val >>= 8; } } [CLASS] TarUtils 1 [METHOD] formatLongBinary [RETURN_TYPE] void  final long value final byte[] buf final int offset final int length final boolean negative [VARIABLES] byte[] buf boolean negative ZipEncoding DEFAULT_ENCODING FALLBACK_ENCODING encoding int BYTE_MASK bits current end i idx len length limit offset remaining start long max val value  	projects/Compress45/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java	1.0	506	506	1	add	
17	[BUG] [BUGGY] val |= 0xffl << bits; [FE] IllegalArgumentException [CONTEXT] final int bits = (length - 1) * 8; final long max = 1l << bits; long val = Math.abs(value); // Long.MIN_VALUE stays Long.MIN_VALUE if (val < 0 || val >= max) { throw new IllegalArgumentException("Value " + value + " is too large for " + length + " byte field."); } if (negative) { val ^= max - 1; val++; [BUGGY] val |= 0xffl << bits; [BUGGY] } for (int i = offset + length - 1; i >= offset; i--) { buf[i] = (byte) val; val >>= 8; } } [CLASS] TarUtils 1 [METHOD] formatLongBinary [RETURN_TYPE] void  final long value final byte[] buf final int offset final int length final boolean negative [VARIABLES] byte[] buf boolean negative ZipEncoding DEFAULT_ENCODING FALLBACK_ENCODING encoding int BYTE_MASK bits current end i idx len length limit offset remaining start long max val value  	projects/Compress45/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java	1.0	507	507	1	replace	
18	[BUG] [BUGGY] [FE] IllegalArgumentException [CONTEXT] final int bits = (length - 1) * 8; final long max = 1l << bits; long val = Math.abs(value); // Long.MIN_VALUE stays Long.MIN_VALUE if (val < 0 || val >= max) { throw new IllegalArgumentException("Value " + value + " is too large for " + length + " byte field."); } if (negative) { val ^= max - 1; val++; [BUGGY] [BUGGY] val |= 0xffl << bits; } for (int i = offset + length - 1; i >= offset; i--) { buf[i] = (byte) val; val >>= 8; } } [CLASS] TarUtils 1 [METHOD] formatLongBinary [RETURN_TYPE] void  final long value final byte[] buf final int offset final int length final boolean negative [VARIABLES] byte[] buf boolean negative ZipEncoding DEFAULT_ENCODING FALLBACK_ENCODING encoding int BYTE_MASK bits current end i idx len length limit offset remaining start long max val value  	projects/Compress45/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java	1.0	507	507	1	add	
19	[BUG] [BUGGY] for (int i = offset + length - 1; i >= offset; i--) { [FE] IllegalArgumentException [CONTEXT] long val = Math.abs(value); // Long.MIN_VALUE stays Long.MIN_VALUE if (val < 0 || val >= max) { throw new IllegalArgumentException("Value " + value + " is too large for " + length + " byte field."); } if (negative) { val ^= max - 1; val++; val |= 0xffl << bits; } [BUGGY] for (int i = offset + length - 1; i >= offset; i--) { [BUGGY] buf[i] = (byte) val; val >>= 8; } } [CLASS] TarUtils 1 [METHOD] formatLongBinary [RETURN_TYPE] void  final long value final byte[] buf final int offset final int length final boolean negative [VARIABLES] byte[] buf boolean negative ZipEncoding DEFAULT_ENCODING FALLBACK_ENCODING encoding int BYTE_MASK bits current end i idx len length limit offset remaining start long max val value  	projects/Compress45/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java	1.0	509	509	1	replace	
20	[BUG] [BUGGY] [FE] IllegalArgumentException [CONTEXT] long val = Math.abs(value); // Long.MIN_VALUE stays Long.MIN_VALUE if (val < 0 || val >= max) { throw new IllegalArgumentException("Value " + value + " is too large for " + length + " byte field."); } if (negative) { val ^= max - 1; val++; val |= 0xffl << bits; } [BUGGY] [BUGGY] for (int i = offset + length - 1; i >= offset; i--) { buf[i] = (byte) val; val >>= 8; } } [CLASS] TarUtils 1 [METHOD] formatLongBinary [RETURN_TYPE] void  final long value final byte[] buf final int offset final int length final boolean negative [VARIABLES] byte[] buf boolean negative ZipEncoding DEFAULT_ENCODING FALLBACK_ENCODING encoding int BYTE_MASK bits current end i idx len length limit offset remaining start long max val value  	projects/Compress45/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java	1.0	509	509	1	add	
21	[BUG] [BUGGY] buf[i] = (byte) val; [FE] IllegalArgumentException [CONTEXT] if (val < 0 || val >= max) { throw new IllegalArgumentException("Value " + value + " is too large for " + length + " byte field."); } if (negative) { val ^= max - 1; val++; val |= 0xffl << bits; } for (int i = offset + length - 1; i >= offset; i--) { [BUGGY] buf[i] = (byte) val; [BUGGY] val >>= 8; } } [CLASS] TarUtils 1 [METHOD] formatLongBinary [RETURN_TYPE] void  final long value final byte[] buf final int offset final int length final boolean negative [VARIABLES] byte[] buf boolean negative ZipEncoding DEFAULT_ENCODING FALLBACK_ENCODING encoding int BYTE_MASK bits current end i idx len length limit offset remaining start long max val value  	projects/Compress45/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java	1.0	510	510	1	replace	
22	[BUG] [BUGGY] [FE] IllegalArgumentException [CONTEXT] if (val < 0 || val >= max) { throw new IllegalArgumentException("Value " + value + " is too large for " + length + " byte field."); } if (negative) { val ^= max - 1; val++; val |= 0xffl << bits; } for (int i = offset + length - 1; i >= offset; i--) { [BUGGY] [BUGGY] buf[i] = (byte) val; val >>= 8; } } [CLASS] TarUtils 1 [METHOD] formatLongBinary [RETURN_TYPE] void  final long value final byte[] buf final int offset final int length final boolean negative [VARIABLES] byte[] buf boolean negative ZipEncoding DEFAULT_ENCODING FALLBACK_ENCODING encoding int BYTE_MASK bits current end i idx len length limit offset remaining start long max val value  	projects/Compress45/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java	1.0	510	510	1	add	
23	[BUG] [BUGGY] val >>= 8; [FE] IllegalArgumentException [CONTEXT] throw new IllegalArgumentException("Value " + value + " is too large for " + length + " byte field."); } if (negative) { val ^= max - 1; val++; val |= 0xffl << bits; } for (int i = offset + length - 1; i >= offset; i--) { buf[i] = (byte) val; [BUGGY] val >>= 8; [BUGGY] } } [CLASS] TarUtils 1 [METHOD] formatLongBinary [RETURN_TYPE] void  final long value final byte[] buf final int offset final int length final boolean negative [VARIABLES] byte[] buf boolean negative ZipEncoding DEFAULT_ENCODING FALLBACK_ENCODING encoding int BYTE_MASK bits current end i idx len length limit offset remaining start long max val value  	projects/Compress45/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java	1.0	511	511	1	replace	
24	[BUG] [BUGGY] [FE] IllegalArgumentException [CONTEXT] throw new IllegalArgumentException("Value " + value + " is too large for " + length + " byte field."); } if (negative) { val ^= max - 1; val++; val |= 0xffl << bits; } for (int i = offset + length - 1; i >= offset; i--) { buf[i] = (byte) val; [BUGGY] [BUGGY] val >>= 8; } } [CLASS] TarUtils 1 [METHOD] formatLongBinary [RETURN_TYPE] void  final long value final byte[] buf final int offset final int length final boolean negative [VARIABLES] byte[] buf boolean negative ZipEncoding DEFAULT_ENCODING FALLBACK_ENCODING encoding int BYTE_MASK bits current end i idx len length limit offset remaining start long max val value  	projects/Compress45/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java	1.0	511	511	1	add	
25	[BUG] [BUGGY] } [FE] IllegalArgumentException [CONTEXT] } if (negative) { val ^= max - 1; val++; val |= 0xffl << bits; } for (int i = offset + length - 1; i >= offset; i--) { buf[i] = (byte) val; val >>= 8; } [BUGGY] } [BUGGY]  [CLASS] TarUtils 1 [METHOD] formatLongBinary [RETURN_TYPE] void  final long value final byte[] buf final int offset final int length final boolean negative [VARIABLES] byte[] buf boolean negative ZipEncoding DEFAULT_ENCODING FALLBACK_ENCODING encoding int BYTE_MASK bits current end i idx len length limit offset remaining start long max val value  	projects/Compress45/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java	1.0	513	513	1	replace	
26	[BUG] [BUGGY] [FE] IllegalArgumentException [CONTEXT] } if (negative) { val ^= max - 1; val++; val |= 0xffl << bits; } for (int i = offset + length - 1; i >= offset; i--) { buf[i] = (byte) val; val >>= 8; } [BUGGY] [BUGGY] } [CLASS] TarUtils 1 [METHOD] formatLongBinary [RETURN_TYPE] void  final long value final byte[] buf final int offset final int length final boolean negative [VARIABLES] byte[] buf boolean negative ZipEncoding DEFAULT_ENCODING FALLBACK_ENCODING encoding int BYTE_MASK bits current end i idx len length limit offset remaining start long max val value  	projects/Compress45/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java	1.0	513	513	1	add	
27	[BUG] [BUGGY] throw new IllegalArgumentException("Value " + value + " is too large for " + length + " byte field."); [FE] IllegalArgumentException [CONTEXT] private static void formatBigIntegerBinary(final long value, final byte[] buf, final int offset, final int length, final boolean negative) { final BigInteger val = BigInteger.valueOf(value); final byte[] b = val.toByteArray(); final int len = b.length; if (len > length - 1) { [BUGGY] throw new IllegalArgumentException("Value " + value +    " is too large for " + length + " byte field."); [BUGGY] " is too large for " + length + " byte field."); } final int off = offset + length - len; System.arraycopy(b, 0, buf, off, len); final byte fill = (byte) (negative ? 0xff : 0); for (int i = offset + 1; i < off; i++) { buf[i] = fill; } } [CLASS] TarUtils 1 [METHOD] formatBigIntegerBinary [RETURN_TYPE] void  final long value final byte[] buf final int offset final int length final boolean negative [VARIABLES] byte[] b buf boolean negative ZipEncoding DEFAULT_ENCODING FALLBACK_ENCODING encoding byte fill BigInteger val int BYTE_MASK bits current end i idx len length limit off offset remaining start long value  	projects/Compress45/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java	1.0	523	524	1	replace	
28	[BUG] [BUGGY] [FE] IllegalArgumentException [CONTEXT] private static void formatBigIntegerBinary(final long value, final byte[] buf, final int offset, final int length, final boolean negative) { final BigInteger val = BigInteger.valueOf(value); final byte[] b = val.toByteArray(); final int len = b.length; if (len > length - 1) { [BUGGY] [BUGGY] throw new IllegalArgumentException("Value " + value +    " is too large for " + length + " byte field."); " is too large for " + length + " byte field."); } final int off = offset + length - len; System.arraycopy(b, 0, buf, off, len); final byte fill = (byte) (negative ? 0xff : 0); for (int i = offset + 1; i < off; i++) { buf[i] = fill; } } [CLASS] TarUtils 1 [METHOD] formatBigIntegerBinary [RETURN_TYPE] void  final long value final byte[] buf final int offset final int length final boolean negative [VARIABLES] byte[] b buf boolean negative ZipEncoding DEFAULT_ENCODING FALLBACK_ENCODING encoding byte fill BigInteger val int BYTE_MASK bits current end i idx len length limit off offset remaining start long value  	projects/Compress45/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java	1.0	523	524	1	add	
29	[BUG] [BUGGY] final long maxAsOctalChar = length == TarConstants.UIDLEN ? TarConstants.MAXID : TarConstants.MAXSIZE; [FE] IllegalArgumentException [CONTEXT] public static int formatLongOctalOrBinaryBytes( final long value, final byte[] buf, final int offset, final int length) {  [BUGGY] final long maxAsOctalChar = length == TarConstants.UIDLEN ? TarConstants.MAXID : TarConstants.MAXSIZE; [BUGGY]  final boolean negative = value < 0; if (!negative && value <= maxAsOctalChar) { // OK to store as octal chars return formatLongOctalBytes(value, buf, offset, length); } if (length < 9) { formatLongBinary(value, buf, offset, length, negative); } formatBigIntegerBinary(value, buf, offset, length, negative); [CLASS] TarUtils 1 [METHOD] formatLongOctalOrBinaryBytes [RETURN_TYPE] int  final long value final byte[] buf final int offset final int length [VARIABLES] byte[] buf boolean negative ZipEncoding DEFAULT_ENCODING FALLBACK_ENCODING encoding int BYTE_MASK current end i idx len length limit offset remaining start long maxAsOctalChar value  	projects/Compress45/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java	0.7071067811865475	478	478	1	replace	
30	[BUG] [BUGGY] [FE] IllegalArgumentException [CONTEXT] public static int formatLongOctalOrBinaryBytes( final long value, final byte[] buf, final int offset, final int length) {  [BUGGY] [BUGGY] final long maxAsOctalChar = length == TarConstants.UIDLEN ? TarConstants.MAXID : TarConstants.MAXSIZE; final boolean negative = value < 0; if (!negative && value <= maxAsOctalChar) { // OK to store as octal chars return formatLongOctalBytes(value, buf, offset, length); } if (length < 9) { formatLongBinary(value, buf, offset, length, negative); } formatBigIntegerBinary(value, buf, offset, length, negative); [CLASS] TarUtils 1 [METHOD] formatLongOctalOrBinaryBytes [RETURN_TYPE] int  final long value final byte[] buf final int offset final int length [VARIABLES] byte[] buf boolean negative ZipEncoding DEFAULT_ENCODING FALLBACK_ENCODING encoding int BYTE_MASK current end i idx len length limit offset remaining start long maxAsOctalChar value  	projects/Compress45/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java	0.7071067811865475	478	478	1	add	
31	[BUG] [BUGGY] final boolean negative = value < 0; [FE] IllegalArgumentException [CONTEXT] public static int formatLongOctalOrBinaryBytes( final long value, final byte[] buf, final int offset, final int length) {  final long maxAsOctalChar = length == TarConstants.UIDLEN ? TarConstants.MAXID : TarConstants.MAXSIZE; [BUGGY] final boolean negative = value < 0; [BUGGY] if (!negative && value <= maxAsOctalChar) { // OK to store as octal chars return formatLongOctalBytes(value, buf, offset, length); } if (length < 9) { formatLongBinary(value, buf, offset, length, negative); } formatBigIntegerBinary(value, buf, offset, length, negative); buf[offset] = (byte) (negative ? 0xff : 0x80); [CLASS] TarUtils 1 [METHOD] formatLongOctalOrBinaryBytes [RETURN_TYPE] int  final long value final byte[] buf final int offset final int length [VARIABLES] byte[] buf boolean negative ZipEncoding DEFAULT_ENCODING FALLBACK_ENCODING encoding int BYTE_MASK current end i idx len length limit offset remaining start long maxAsOctalChar value  	projects/Compress45/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java	0.7071067811865475	480	480	1	replace	
32	[BUG] [BUGGY] [FE] IllegalArgumentException [CONTEXT] public static int formatLongOctalOrBinaryBytes( final long value, final byte[] buf, final int offset, final int length) {  final long maxAsOctalChar = length == TarConstants.UIDLEN ? TarConstants.MAXID : TarConstants.MAXSIZE; [BUGGY] [BUGGY] final boolean negative = value < 0; if (!negative && value <= maxAsOctalChar) { // OK to store as octal chars return formatLongOctalBytes(value, buf, offset, length); } if (length < 9) { formatLongBinary(value, buf, offset, length, negative); } formatBigIntegerBinary(value, buf, offset, length, negative); buf[offset] = (byte) (negative ? 0xff : 0x80); [CLASS] TarUtils 1 [METHOD] formatLongOctalOrBinaryBytes [RETURN_TYPE] int  final long value final byte[] buf final int offset final int length [VARIABLES] byte[] buf boolean negative ZipEncoding DEFAULT_ENCODING FALLBACK_ENCODING encoding int BYTE_MASK current end i idx len length limit offset remaining start long maxAsOctalChar value  	projects/Compress45/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java	0.7071067811865475	480	480	1	add	
33	[BUG] [BUGGY] if (!negative && value <= maxAsOctalChar) { // OK to store as octal chars return formatLongOctalBytes(value, buf, offset, length); [FE] IllegalArgumentException [CONTEXT] public static int formatLongOctalOrBinaryBytes( final long value, final byte[] buf, final int offset, final int length) {  final long maxAsOctalChar = length == TarConstants.UIDLEN ? TarConstants.MAXID : TarConstants.MAXSIZE; final boolean negative = value < 0; [BUGGY] if (!negative && value <= maxAsOctalChar) { // OK to store as octal chars   return formatLongOctalBytes(value, buf, offset, length); [BUGGY] return formatLongOctalBytes(value, buf, offset, length); } if (length < 9) { formatLongBinary(value, buf, offset, length, negative); } formatBigIntegerBinary(value, buf, offset, length, negative); buf[offset] = (byte) (negative ? 0xff : 0x80); return offset + length; [CLASS] TarUtils 1 [METHOD] formatLongOctalOrBinaryBytes [RETURN_TYPE] int  final long value final byte[] buf final int offset final int length [VARIABLES] byte[] buf boolean negative ZipEncoding DEFAULT_ENCODING FALLBACK_ENCODING encoding int BYTE_MASK current end i idx len length limit offset remaining start long maxAsOctalChar value  	projects/Compress45/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java	0.7071067811865475	481	482	1	replace	
34	[BUG] [BUGGY] [FE] IllegalArgumentException [CONTEXT] public static int formatLongOctalOrBinaryBytes( final long value, final byte[] buf, final int offset, final int length) {  final long maxAsOctalChar = length == TarConstants.UIDLEN ? TarConstants.MAXID : TarConstants.MAXSIZE; final boolean negative = value < 0; [BUGGY] [BUGGY] if (!negative && value <= maxAsOctalChar) { // OK to store as octal chars   return formatLongOctalBytes(value, buf, offset, length); return formatLongOctalBytes(value, buf, offset, length); } if (length < 9) { formatLongBinary(value, buf, offset, length, negative); } formatBigIntegerBinary(value, buf, offset, length, negative); buf[offset] = (byte) (negative ? 0xff : 0x80); return offset + length; [CLASS] TarUtils 1 [METHOD] formatLongOctalOrBinaryBytes [RETURN_TYPE] int  final long value final byte[] buf final int offset final int length [VARIABLES] byte[] buf boolean negative ZipEncoding DEFAULT_ENCODING FALLBACK_ENCODING encoding int BYTE_MASK current end i idx len length limit offset remaining start long maxAsOctalChar value  	projects/Compress45/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java	0.7071067811865475	481	482	1	add	
35	[BUG] [BUGGY] return formatLongOctalBytes(value, buf, offset, length); [FE] IllegalArgumentException [CONTEXT] public static int formatLongOctalOrBinaryBytes( final long value, final byte[] buf, final int offset, final int length) {  final long maxAsOctalChar = length == TarConstants.UIDLEN ? TarConstants.MAXID : TarConstants.MAXSIZE; final boolean negative = value < 0; if (!negative && value <= maxAsOctalChar) { // OK to store as octal chars [BUGGY] return formatLongOctalBytes(value, buf, offset, length); [BUGGY] } if (length < 9) { formatLongBinary(value, buf, offset, length, negative); } formatBigIntegerBinary(value, buf, offset, length, negative); buf[offset] = (byte) (negative ? 0xff : 0x80); return offset + length; } [CLASS] TarUtils 1 [METHOD] formatLongOctalOrBinaryBytes [RETURN_TYPE] int  final long value final byte[] buf final int offset final int length [VARIABLES] byte[] buf boolean negative ZipEncoding DEFAULT_ENCODING FALLBACK_ENCODING encoding int BYTE_MASK current end i idx len length limit offset remaining start long maxAsOctalChar value  	projects/Compress45/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java	0.7071067811865475	482	482	1	replace	
36	[BUG] [BUGGY] [FE] IllegalArgumentException [CONTEXT] public static int formatLongOctalOrBinaryBytes( final long value, final byte[] buf, final int offset, final int length) {  final long maxAsOctalChar = length == TarConstants.UIDLEN ? TarConstants.MAXID : TarConstants.MAXSIZE; final boolean negative = value < 0; if (!negative && value <= maxAsOctalChar) { // OK to store as octal chars [BUGGY] [BUGGY] return formatLongOctalBytes(value, buf, offset, length); } if (length < 9) { formatLongBinary(value, buf, offset, length, negative); } formatBigIntegerBinary(value, buf, offset, length, negative); buf[offset] = (byte) (negative ? 0xff : 0x80); return offset + length; } [CLASS] TarUtils 1 [METHOD] formatLongOctalOrBinaryBytes [RETURN_TYPE] int  final long value final byte[] buf final int offset final int length [VARIABLES] byte[] buf boolean negative ZipEncoding DEFAULT_ENCODING FALLBACK_ENCODING encoding int BYTE_MASK current end i idx len length limit offset remaining start long maxAsOctalChar value  	projects/Compress45/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java	0.7071067811865475	482	482	1	add	
37	[BUG] [BUGGY] if (length < 9) { [FE] IllegalArgumentException [CONTEXT] final long value, final byte[] buf, final int offset, final int length) {  final long maxAsOctalChar = length == TarConstants.UIDLEN ? TarConstants.MAXID : TarConstants.MAXSIZE; final boolean negative = value < 0; if (!negative && value <= maxAsOctalChar) { // OK to store as octal chars return formatLongOctalBytes(value, buf, offset, length); } [BUGGY] if (length < 9) { [BUGGY] formatLongBinary(value, buf, offset, length, negative); } formatBigIntegerBinary(value, buf, offset, length, negative); buf[offset] = (byte) (negative ? 0xff : 0x80); return offset + length; } [CLASS] TarUtils 1 [METHOD] formatLongOctalOrBinaryBytes [RETURN_TYPE] int  final long value final byte[] buf final int offset final int length [VARIABLES] byte[] buf boolean negative ZipEncoding DEFAULT_ENCODING FALLBACK_ENCODING encoding int BYTE_MASK current end i idx len length limit offset remaining start long maxAsOctalChar value  	projects/Compress45/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java	0.7071067811865475	485	485	1	replace	
38	[BUG] [BUGGY] [FE] IllegalArgumentException [CONTEXT] final long value, final byte[] buf, final int offset, final int length) {  final long maxAsOctalChar = length == TarConstants.UIDLEN ? TarConstants.MAXID : TarConstants.MAXSIZE; final boolean negative = value < 0; if (!negative && value <= maxAsOctalChar) { // OK to store as octal chars return formatLongOctalBytes(value, buf, offset, length); } [BUGGY] [BUGGY] if (length < 9) { formatLongBinary(value, buf, offset, length, negative); } formatBigIntegerBinary(value, buf, offset, length, negative); buf[offset] = (byte) (negative ? 0xff : 0x80); return offset + length; } [CLASS] TarUtils 1 [METHOD] formatLongOctalOrBinaryBytes [RETURN_TYPE] int  final long value final byte[] buf final int offset final int length [VARIABLES] byte[] buf boolean negative ZipEncoding DEFAULT_ENCODING FALLBACK_ENCODING encoding int BYTE_MASK current end i idx len length limit offset remaining start long maxAsOctalChar value  	projects/Compress45/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java	0.7071067811865475	485	485	1	add	
39	[BUG] [BUGGY] formatBigIntegerBinary(value, buf, offset, length, negative); [FE] IllegalArgumentException [CONTEXT] final long maxAsOctalChar = length == TarConstants.UIDLEN ? TarConstants.MAXID : TarConstants.MAXSIZE; final boolean negative = value < 0; if (!negative && value <= maxAsOctalChar) { // OK to store as octal chars return formatLongOctalBytes(value, buf, offset, length); } if (length < 9) { formatLongBinary(value, buf, offset, length, negative); } [BUGGY] formatBigIntegerBinary(value, buf, offset, length, negative); [BUGGY]  buf[offset] = (byte) (negative ? 0xff : 0x80); return offset + length; } [CLASS] TarUtils 1 [METHOD] formatLongOctalOrBinaryBytes [RETURN_TYPE] int  final long value final byte[] buf final int offset final int length [VARIABLES] byte[] buf boolean negative ZipEncoding DEFAULT_ENCODING FALLBACK_ENCODING encoding int BYTE_MASK current end i idx len length limit offset remaining start long maxAsOctalChar value  	projects/Compress45/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java	0.7071067811865475	488	488	1	replace	
40	[BUG] [BUGGY] [FE] IllegalArgumentException [CONTEXT] final long maxAsOctalChar = length == TarConstants.UIDLEN ? TarConstants.MAXID : TarConstants.MAXSIZE; final boolean negative = value < 0; if (!negative && value <= maxAsOctalChar) { // OK to store as octal chars return formatLongOctalBytes(value, buf, offset, length); } if (length < 9) { formatLongBinary(value, buf, offset, length, negative); } [BUGGY] [BUGGY] formatBigIntegerBinary(value, buf, offset, length, negative); buf[offset] = (byte) (negative ? 0xff : 0x80); return offset + length; } [CLASS] TarUtils 1 [METHOD] formatLongOctalOrBinaryBytes [RETURN_TYPE] int  final long value final byte[] buf final int offset final int length [VARIABLES] byte[] buf boolean negative ZipEncoding DEFAULT_ENCODING FALLBACK_ENCODING encoding int BYTE_MASK current end i idx len length limit offset remaining start long maxAsOctalChar value  	projects/Compress45/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java	0.7071067811865475	488	488	1	add	
41	[BUG] [BUGGY] buf[offset] = (byte) (negative ? 0xff : 0x80); [FE] IllegalArgumentException [CONTEXT] final boolean negative = value < 0; if (!negative && value <= maxAsOctalChar) { // OK to store as octal chars return formatLongOctalBytes(value, buf, offset, length); } if (length < 9) { formatLongBinary(value, buf, offset, length, negative); } formatBigIntegerBinary(value, buf, offset, length, negative); [BUGGY] buf[offset] = (byte) (negative ? 0xff : 0x80); [BUGGY] return offset + length; } [CLASS] TarUtils 1 [METHOD] formatLongOctalOrBinaryBytes [RETURN_TYPE] int  final long value final byte[] buf final int offset final int length [VARIABLES] byte[] buf boolean negative ZipEncoding DEFAULT_ENCODING FALLBACK_ENCODING encoding int BYTE_MASK current end i idx len length limit offset remaining start long maxAsOctalChar value  	projects/Compress45/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java	0.7071067811865475	490	490	1	replace	
42	[BUG] [BUGGY] [FE] IllegalArgumentException [CONTEXT] final boolean negative = value < 0; if (!negative && value <= maxAsOctalChar) { // OK to store as octal chars return formatLongOctalBytes(value, buf, offset, length); } if (length < 9) { formatLongBinary(value, buf, offset, length, negative); } formatBigIntegerBinary(value, buf, offset, length, negative); [BUGGY] [BUGGY] buf[offset] = (byte) (negative ? 0xff : 0x80); return offset + length; } [CLASS] TarUtils 1 [METHOD] formatLongOctalOrBinaryBytes [RETURN_TYPE] int  final long value final byte[] buf final int offset final int length [VARIABLES] byte[] buf boolean negative ZipEncoding DEFAULT_ENCODING FALLBACK_ENCODING encoding int BYTE_MASK current end i idx len length limit offset remaining start long maxAsOctalChar value  	projects/Compress45/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java	0.7071067811865475	490	490	1	add	
43	[BUG] [BUGGY] return offset + length; [FE] IllegalArgumentException [CONTEXT] if (!negative && value <= maxAsOctalChar) { // OK to store as octal chars return formatLongOctalBytes(value, buf, offset, length); } if (length < 9) { formatLongBinary(value, buf, offset, length, negative); } formatBigIntegerBinary(value, buf, offset, length, negative); buf[offset] = (byte) (negative ? 0xff : 0x80); [BUGGY] return offset + length; [BUGGY] } [CLASS] TarUtils 1 [METHOD] formatLongOctalOrBinaryBytes [RETURN_TYPE] int  final long value final byte[] buf final int offset final int length [VARIABLES] byte[] buf boolean negative ZipEncoding DEFAULT_ENCODING FALLBACK_ENCODING encoding int BYTE_MASK current end i idx len length limit offset remaining start long maxAsOctalChar value  	projects/Compress45/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java	0.7071067811865475	491	491	1	replace	
44	[BUG] [BUGGY] [FE] IllegalArgumentException [CONTEXT] if (!negative && value <= maxAsOctalChar) { // OK to store as octal chars return formatLongOctalBytes(value, buf, offset, length); } if (length < 9) { formatLongBinary(value, buf, offset, length, negative); } formatBigIntegerBinary(value, buf, offset, length, negative); buf[offset] = (byte) (negative ? 0xff : 0x80); [BUGGY] [BUGGY] return offset + length; } [CLASS] TarUtils 1 [METHOD] formatLongOctalOrBinaryBytes [RETURN_TYPE] int  final long value final byte[] buf final int offset final int length [VARIABLES] byte[] buf boolean negative ZipEncoding DEFAULT_ENCODING FALLBACK_ENCODING encoding int BYTE_MASK current end i idx len length limit offset remaining start long maxAsOctalChar value  	projects/Compress45/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java	0.7071067811865475	491	491	1	add	
45	[BUG] [BUGGY] final BigInteger val = BigInteger.valueOf(value); [FE] IllegalArgumentException [CONTEXT] private static void formatBigIntegerBinary(final long value, final byte[] buf, final int offset, final int length, final boolean negative) { [BUGGY] final BigInteger val = BigInteger.valueOf(value); [BUGGY] final byte[] b = val.toByteArray(); final int len = b.length; if (len > length - 1) { throw new IllegalArgumentException("Value " + value + " is too large for " + length + " byte field."); } final int off = offset + length - len; System.arraycopy(b, 0, buf, off, len); final byte fill = (byte) (negative ? 0xff : 0); for (int i = offset + 1; i < off; i++) { [CLASS] TarUtils 1 [METHOD] formatBigIntegerBinary [RETURN_TYPE] void  final long value final byte[] buf final int offset final int length final boolean negative [VARIABLES] byte[] b buf boolean negative ZipEncoding DEFAULT_ENCODING FALLBACK_ENCODING encoding byte fill BigInteger val int BYTE_MASK bits current end i idx len length limit off offset remaining start long value  	projects/Compress45/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java	0.7071067811865475	519	519	1	replace	
46	[BUG] [BUGGY] [FE] IllegalArgumentException [CONTEXT] private static void formatBigIntegerBinary(final long value, final byte[] buf, final int offset, final int length, final boolean negative) { [BUGGY] [BUGGY] final BigInteger val = BigInteger.valueOf(value); final byte[] b = val.toByteArray(); final int len = b.length; if (len > length - 1) { throw new IllegalArgumentException("Value " + value + " is too large for " + length + " byte field."); } final int off = offset + length - len; System.arraycopy(b, 0, buf, off, len); final byte fill = (byte) (negative ? 0xff : 0); for (int i = offset + 1; i < off; i++) { [CLASS] TarUtils 1 [METHOD] formatBigIntegerBinary [RETURN_TYPE] void  final long value final byte[] buf final int offset final int length final boolean negative [VARIABLES] byte[] b buf boolean negative ZipEncoding DEFAULT_ENCODING FALLBACK_ENCODING encoding byte fill BigInteger val int BYTE_MASK bits current end i idx len length limit off offset remaining start long value  	projects/Compress45/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java	0.7071067811865475	519	519	1	add	
47	[BUG] [BUGGY] final byte[] b = val.toByteArray(); [FE] IllegalArgumentException [CONTEXT] private static void formatBigIntegerBinary(final long value, final byte[] buf, final int offset, final int length, final boolean negative) { final BigInteger val = BigInteger.valueOf(value); [BUGGY] final byte[] b = val.toByteArray(); [BUGGY] final int len = b.length; if (len > length - 1) { throw new IllegalArgumentException("Value " + value + " is too large for " + length + " byte field."); } final int off = offset + length - len; System.arraycopy(b, 0, buf, off, len); final byte fill = (byte) (negative ? 0xff : 0); for (int i = offset + 1; i < off; i++) { buf[i] = fill; [CLASS] TarUtils 1 [METHOD] formatBigIntegerBinary [RETURN_TYPE] void  final long value final byte[] buf final int offset final int length final boolean negative [VARIABLES] byte[] b buf boolean negative ZipEncoding DEFAULT_ENCODING FALLBACK_ENCODING encoding byte fill BigInteger val int BYTE_MASK bits current end i idx len length limit off offset remaining start long value  	projects/Compress45/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java	0.7071067811865475	520	520	1	replace	
48	[BUG] [BUGGY] [FE] IllegalArgumentException [CONTEXT] private static void formatBigIntegerBinary(final long value, final byte[] buf, final int offset, final int length, final boolean negative) { final BigInteger val = BigInteger.valueOf(value); [BUGGY] [BUGGY] final byte[] b = val.toByteArray(); final int len = b.length; if (len > length - 1) { throw new IllegalArgumentException("Value " + value + " is too large for " + length + " byte field."); } final int off = offset + length - len; System.arraycopy(b, 0, buf, off, len); final byte fill = (byte) (negative ? 0xff : 0); for (int i = offset + 1; i < off; i++) { buf[i] = fill; [CLASS] TarUtils 1 [METHOD] formatBigIntegerBinary [RETURN_TYPE] void  final long value final byte[] buf final int offset final int length final boolean negative [VARIABLES] byte[] b buf boolean negative ZipEncoding DEFAULT_ENCODING FALLBACK_ENCODING encoding byte fill BigInteger val int BYTE_MASK bits current end i idx len length limit off offset remaining start long value  	projects/Compress45/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java	0.7071067811865475	520	520	1	add	
49	[BUG] [BUGGY] final int len = b.length; [FE] IllegalArgumentException [CONTEXT] private static void formatBigIntegerBinary(final long value, final byte[] buf, final int offset, final int length, final boolean negative) { final BigInteger val = BigInteger.valueOf(value); final byte[] b = val.toByteArray(); [BUGGY] final int len = b.length; [BUGGY] if (len > length - 1) { throw new IllegalArgumentException("Value " + value + " is too large for " + length + " byte field."); } final int off = offset + length - len; System.arraycopy(b, 0, buf, off, len); final byte fill = (byte) (negative ? 0xff : 0); for (int i = offset + 1; i < off; i++) { buf[i] = fill; } [CLASS] TarUtils 1 [METHOD] formatBigIntegerBinary [RETURN_TYPE] void  final long value final byte[] buf final int offset final int length final boolean negative [VARIABLES] byte[] b buf boolean negative ZipEncoding DEFAULT_ENCODING FALLBACK_ENCODING encoding byte fill BigInteger val int BYTE_MASK bits current end i idx len length limit off offset remaining start long value  	projects/Compress45/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java	0.7071067811865475	521	521	1	replace	
50	[BUG] [BUGGY] [FE] IllegalArgumentException [CONTEXT] private static void formatBigIntegerBinary(final long value, final byte[] buf, final int offset, final int length, final boolean negative) { final BigInteger val = BigInteger.valueOf(value); final byte[] b = val.toByteArray(); [BUGGY] [BUGGY] final int len = b.length; if (len > length - 1) { throw new IllegalArgumentException("Value " + value + " is too large for " + length + " byte field."); } final int off = offset + length - len; System.arraycopy(b, 0, buf, off, len); final byte fill = (byte) (negative ? 0xff : 0); for (int i = offset + 1; i < off; i++) { buf[i] = fill; } [CLASS] TarUtils 1 [METHOD] formatBigIntegerBinary [RETURN_TYPE] void  final long value final byte[] buf final int offset final int length final boolean negative [VARIABLES] byte[] b buf boolean negative ZipEncoding DEFAULT_ENCODING FALLBACK_ENCODING encoding byte fill BigInteger val int BYTE_MASK bits current end i idx len length limit off offset remaining start long value  	projects/Compress45/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java	0.7071067811865475	521	521	1	add	
51	[BUG] [BUGGY] if (len > length - 1) { [FE] IllegalArgumentException [CONTEXT] private static void formatBigIntegerBinary(final long value, final byte[] buf, final int offset, final int length, final boolean negative) { final BigInteger val = BigInteger.valueOf(value); final byte[] b = val.toByteArray(); final int len = b.length; [BUGGY] if (len > length - 1) { [BUGGY] throw new IllegalArgumentException("Value " + value + " is too large for " + length + " byte field."); } final int off = offset + length - len; System.arraycopy(b, 0, buf, off, len); final byte fill = (byte) (negative ? 0xff : 0); for (int i = offset + 1; i < off; i++) { buf[i] = fill; } } [CLASS] TarUtils 1 [METHOD] formatBigIntegerBinary [RETURN_TYPE] void  final long value final byte[] buf final int offset final int length final boolean negative [VARIABLES] byte[] b buf boolean negative ZipEncoding DEFAULT_ENCODING FALLBACK_ENCODING encoding byte fill BigInteger val int BYTE_MASK bits current end i idx len length limit off offset remaining start long value  	projects/Compress45/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java	0.7071067811865475	522	522	1	replace	
52	[BUG] [BUGGY] [FE] IllegalArgumentException [CONTEXT] private static void formatBigIntegerBinary(final long value, final byte[] buf, final int offset, final int length, final boolean negative) { final BigInteger val = BigInteger.valueOf(value); final byte[] b = val.toByteArray(); final int len = b.length; [BUGGY] [BUGGY] if (len > length - 1) { throw new IllegalArgumentException("Value " + value + " is too large for " + length + " byte field."); } final int off = offset + length - len; System.arraycopy(b, 0, buf, off, len); final byte fill = (byte) (negative ? 0xff : 0); for (int i = offset + 1; i < off; i++) { buf[i] = fill; } } [CLASS] TarUtils 1 [METHOD] formatBigIntegerBinary [RETURN_TYPE] void  final long value final byte[] buf final int offset final int length final boolean negative [VARIABLES] byte[] b buf boolean negative ZipEncoding DEFAULT_ENCODING FALLBACK_ENCODING encoding byte fill BigInteger val int BYTE_MASK bits current end i idx len length limit off offset remaining start long value  	projects/Compress45/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java	0.7071067811865475	522	522	1	add	
53	[BUG] [BUGGY] final int off = offset + length - len; [FE] IllegalArgumentException [CONTEXT] final int offset, final int length, final boolean negative) { final BigInteger val = BigInteger.valueOf(value); final byte[] b = val.toByteArray(); final int len = b.length; if (len > length - 1) { throw new IllegalArgumentException("Value " + value + " is too large for " + length + " byte field."); } [BUGGY] final int off = offset + length - len; [BUGGY] System.arraycopy(b, 0, buf, off, len); final byte fill = (byte) (negative ? 0xff : 0); for (int i = offset + 1; i < off; i++) { buf[i] = fill; } } [CLASS] TarUtils 1 [METHOD] formatBigIntegerBinary [RETURN_TYPE] void  final long value final byte[] buf final int offset final int length final boolean negative [VARIABLES] byte[] b buf boolean negative ZipEncoding DEFAULT_ENCODING FALLBACK_ENCODING encoding byte fill BigInteger val int BYTE_MASK bits current end i idx len length limit off offset remaining start long value  	projects/Compress45/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java	0.7071067811865475	526	526	1	replace	
54	[BUG] [BUGGY] [FE] IllegalArgumentException [CONTEXT] final int offset, final int length, final boolean negative) { final BigInteger val = BigInteger.valueOf(value); final byte[] b = val.toByteArray(); final int len = b.length; if (len > length - 1) { throw new IllegalArgumentException("Value " + value + " is too large for " + length + " byte field."); } [BUGGY] [BUGGY] final int off = offset + length - len; System.arraycopy(b, 0, buf, off, len); final byte fill = (byte) (negative ? 0xff : 0); for (int i = offset + 1; i < off; i++) { buf[i] = fill; } } [CLASS] TarUtils 1 [METHOD] formatBigIntegerBinary [RETURN_TYPE] void  final long value final byte[] buf final int offset final int length final boolean negative [VARIABLES] byte[] b buf boolean negative ZipEncoding DEFAULT_ENCODING FALLBACK_ENCODING encoding byte fill BigInteger val int BYTE_MASK bits current end i idx len length limit off offset remaining start long value  	projects/Compress45/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java	0.7071067811865475	526	526	1	add	
55	[BUG] [BUGGY] System.arraycopy(b, 0, buf, off, len); [FE] IllegalArgumentException [CONTEXT] final int length, final boolean negative) { final BigInteger val = BigInteger.valueOf(value); final byte[] b = val.toByteArray(); final int len = b.length; if (len > length - 1) { throw new IllegalArgumentException("Value " + value + " is too large for " + length + " byte field."); } final int off = offset + length - len; [BUGGY] System.arraycopy(b, 0, buf, off, len); [BUGGY] final byte fill = (byte) (negative ? 0xff : 0); for (int i = offset + 1; i < off; i++) { buf[i] = fill; } } [CLASS] TarUtils 1 [METHOD] formatBigIntegerBinary [RETURN_TYPE] void  final long value final byte[] buf final int offset final int length final boolean negative [VARIABLES] byte[] b buf boolean negative ZipEncoding DEFAULT_ENCODING FALLBACK_ENCODING encoding byte fill BigInteger val int BYTE_MASK bits current end i idx len length limit off offset remaining start long value  	projects/Compress45/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java	0.7071067811865475	527	527	1	replace	
56	[BUG] [BUGGY] [FE] IllegalArgumentException [CONTEXT] final int length, final boolean negative) { final BigInteger val = BigInteger.valueOf(value); final byte[] b = val.toByteArray(); final int len = b.length; if (len > length - 1) { throw new IllegalArgumentException("Value " + value + " is too large for " + length + " byte field."); } final int off = offset + length - len; [BUGGY] [BUGGY] System.arraycopy(b, 0, buf, off, len); final byte fill = (byte) (negative ? 0xff : 0); for (int i = offset + 1; i < off; i++) { buf[i] = fill; } } [CLASS] TarUtils 1 [METHOD] formatBigIntegerBinary [RETURN_TYPE] void  final long value final byte[] buf final int offset final int length final boolean negative [VARIABLES] byte[] b buf boolean negative ZipEncoding DEFAULT_ENCODING FALLBACK_ENCODING encoding byte fill BigInteger val int BYTE_MASK bits current end i idx len length limit off offset remaining start long value  	projects/Compress45/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java	0.7071067811865475	527	527	1	add	
57	[BUG] [BUGGY] final byte fill = (byte) (negative ? 0xff : 0); [FE] IllegalArgumentException [CONTEXT] final boolean negative) { final BigInteger val = BigInteger.valueOf(value); final byte[] b = val.toByteArray(); final int len = b.length; if (len > length - 1) { throw new IllegalArgumentException("Value " + value + " is too large for " + length + " byte field."); } final int off = offset + length - len; System.arraycopy(b, 0, buf, off, len); [BUGGY] final byte fill = (byte) (negative ? 0xff : 0); [BUGGY] for (int i = offset + 1; i < off; i++) { buf[i] = fill; } } [CLASS] TarUtils 1 [METHOD] formatBigIntegerBinary [RETURN_TYPE] void  final long value final byte[] buf final int offset final int length final boolean negative [VARIABLES] byte[] b buf boolean negative ZipEncoding DEFAULT_ENCODING FALLBACK_ENCODING encoding byte fill BigInteger val int BYTE_MASK bits current end i idx len length limit off offset remaining start long value  	projects/Compress45/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java	0.7071067811865475	528	528	1	replace	
58	[BUG] [BUGGY] [FE] IllegalArgumentException [CONTEXT] final boolean negative) { final BigInteger val = BigInteger.valueOf(value); final byte[] b = val.toByteArray(); final int len = b.length; if (len > length - 1) { throw new IllegalArgumentException("Value " + value + " is too large for " + length + " byte field."); } final int off = offset + length - len; System.arraycopy(b, 0, buf, off, len); [BUGGY] [BUGGY] final byte fill = (byte) (negative ? 0xff : 0); for (int i = offset + 1; i < off; i++) { buf[i] = fill; } } [CLASS] TarUtils 1 [METHOD] formatBigIntegerBinary [RETURN_TYPE] void  final long value final byte[] buf final int offset final int length final boolean negative [VARIABLES] byte[] b buf boolean negative ZipEncoding DEFAULT_ENCODING FALLBACK_ENCODING encoding byte fill BigInteger val int BYTE_MASK bits current end i idx len length limit off offset remaining start long value  	projects/Compress45/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java	0.7071067811865475	528	528	1	add	
59	[BUG] [BUGGY] for (int i = offset + 1; i < off; i++) { [FE] IllegalArgumentException [CONTEXT] final BigInteger val = BigInteger.valueOf(value); final byte[] b = val.toByteArray(); final int len = b.length; if (len > length - 1) { throw new IllegalArgumentException("Value " + value + " is too large for " + length + " byte field."); } final int off = offset + length - len; System.arraycopy(b, 0, buf, off, len); final byte fill = (byte) (negative ? 0xff : 0); [BUGGY] for (int i = offset + 1; i < off; i++) { [BUGGY] buf[i] = fill; } } [CLASS] TarUtils 1 [METHOD] formatBigIntegerBinary [RETURN_TYPE] void  final long value final byte[] buf final int offset final int length final boolean negative [VARIABLES] byte[] b buf boolean negative ZipEncoding DEFAULT_ENCODING FALLBACK_ENCODING encoding byte fill BigInteger val int BYTE_MASK bits current end i idx len length limit off offset remaining start long value  	projects/Compress45/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java	0.7071067811865475	529	529	1	replace	
60	[BUG] [BUGGY] [FE] IllegalArgumentException [CONTEXT] final BigInteger val = BigInteger.valueOf(value); final byte[] b = val.toByteArray(); final int len = b.length; if (len > length - 1) { throw new IllegalArgumentException("Value " + value + " is too large for " + length + " byte field."); } final int off = offset + length - len; System.arraycopy(b, 0, buf, off, len); final byte fill = (byte) (negative ? 0xff : 0); [BUGGY] [BUGGY] for (int i = offset + 1; i < off; i++) { buf[i] = fill; } } [CLASS] TarUtils 1 [METHOD] formatBigIntegerBinary [RETURN_TYPE] void  final long value final byte[] buf final int offset final int length final boolean negative [VARIABLES] byte[] b buf boolean negative ZipEncoding DEFAULT_ENCODING FALLBACK_ENCODING encoding byte fill BigInteger val int BYTE_MASK bits current end i idx len length limit off offset remaining start long value  	projects/Compress45/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java	0.7071067811865475	529	529	1	add	
61	[BUG] [BUGGY] buf[i] = fill; [FE] IllegalArgumentException [CONTEXT] final byte[] b = val.toByteArray(); final int len = b.length; if (len > length - 1) { throw new IllegalArgumentException("Value " + value + " is too large for " + length + " byte field."); } final int off = offset + length - len; System.arraycopy(b, 0, buf, off, len); final byte fill = (byte) (negative ? 0xff : 0); for (int i = offset + 1; i < off; i++) { [BUGGY] buf[i] = fill; [BUGGY] } } [CLASS] TarUtils 1 [METHOD] formatBigIntegerBinary [RETURN_TYPE] void  final long value final byte[] buf final int offset final int length final boolean negative [VARIABLES] byte[] b buf boolean negative ZipEncoding DEFAULT_ENCODING FALLBACK_ENCODING encoding byte fill BigInteger val int BYTE_MASK bits current end i idx len length limit off offset remaining start long value  	projects/Compress45/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java	0.7071067811865475	530	530	1	replace	
62	[BUG] [BUGGY] [FE] IllegalArgumentException [CONTEXT] final byte[] b = val.toByteArray(); final int len = b.length; if (len > length - 1) { throw new IllegalArgumentException("Value " + value + " is too large for " + length + " byte field."); } final int off = offset + length - len; System.arraycopy(b, 0, buf, off, len); final byte fill = (byte) (negative ? 0xff : 0); for (int i = offset + 1; i < off; i++) { [BUGGY] [BUGGY] buf[i] = fill; } } [CLASS] TarUtils 1 [METHOD] formatBigIntegerBinary [RETURN_TYPE] void  final long value final byte[] buf final int offset final int length final boolean negative [VARIABLES] byte[] b buf boolean negative ZipEncoding DEFAULT_ENCODING FALLBACK_ENCODING encoding byte fill BigInteger val int BYTE_MASK bits current end i idx len length limit off offset remaining start long value  	projects/Compress45/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java	0.7071067811865475	530	530	1	add	
63	[BUG] [BUGGY] } [FE] IllegalArgumentException [CONTEXT] if (len > length - 1) { throw new IllegalArgumentException("Value " + value + " is too large for " + length + " byte field."); } final int off = offset + length - len; System.arraycopy(b, 0, buf, off, len); final byte fill = (byte) (negative ? 0xff : 0); for (int i = offset + 1; i < off; i++) { buf[i] = fill; } [BUGGY] } [BUGGY]  [CLASS] TarUtils 1 [METHOD] formatBigIntegerBinary [RETURN_TYPE] void  final long value final byte[] buf final int offset final int length final boolean negative [VARIABLES] byte[] b buf boolean negative ZipEncoding DEFAULT_ENCODING FALLBACK_ENCODING encoding byte fill BigInteger val int BYTE_MASK bits current end i idx len length limit off offset remaining start long value  	projects/Compress45/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java	0.7071067811865475	532	532	1	replace	
64	[BUG] [BUGGY] [FE] IllegalArgumentException [CONTEXT] if (len > length - 1) { throw new IllegalArgumentException("Value " + value + " is too large for " + length + " byte field."); } final int off = offset + length - len; System.arraycopy(b, 0, buf, off, len); final byte fill = (byte) (negative ? 0xff : 0); for (int i = offset + 1; i < off; i++) { buf[i] = fill; } [BUGGY] [BUGGY] } [CLASS] TarUtils 1 [METHOD] formatBigIntegerBinary [RETURN_TYPE] void  final long value final byte[] buf final int offset final int length final boolean negative [VARIABLES] byte[] b buf boolean negative ZipEncoding DEFAULT_ENCODING FALLBACK_ENCODING encoding byte fill BigInteger val int BYTE_MASK bits current end i idx len length limit off offset remaining start long value  	projects/Compress45/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java	0.7071067811865475	532	532	1	add	
65	[BUG] [BUGGY] return parseOctal(buffer, offset, length); [FE] IllegalArgumentException [CONTEXT] public static long parseOctalOrBinary(final byte[] buffer, final int offset, final int length) { if ((buffer[offset] & 0x80) == 0) { [BUGGY] return parseOctal(buffer, offset, length); [BUGGY] } final boolean negative = buffer[offset] == (byte) 0xff; if (length < 9) { return parseBinaryLong(buffer, offset, length, negative); } return parseBinaryBigInteger(buffer, offset, length, negative); } [CLASS] TarUtils 1 [METHOD] parseOctalOrBinary [RETURN_TYPE] long  final byte[] buffer final int offset final int length [VARIABLES] byte[] buffer boolean negative ZipEncoding DEFAULT_ENCODING FALLBACK_ENCODING int BYTE_MASK end i length offset start  	projects/Compress45/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java	0.5773502691896258	171	171	1	replace	
66	[BUG] [BUGGY] [FE] IllegalArgumentException [CONTEXT] public static long parseOctalOrBinary(final byte[] buffer, final int offset, final int length) { if ((buffer[offset] & 0x80) == 0) { [BUGGY] [BUGGY] return parseOctal(buffer, offset, length); } final boolean negative = buffer[offset] == (byte) 0xff; if (length < 9) { return parseBinaryLong(buffer, offset, length, negative); } return parseBinaryBigInteger(buffer, offset, length, negative); } [CLASS] TarUtils 1 [METHOD] parseOctalOrBinary [RETURN_TYPE] long  final byte[] buffer final int offset final int length [VARIABLES] byte[] buffer boolean negative ZipEncoding DEFAULT_ENCODING FALLBACK_ENCODING int BYTE_MASK end i length offset start  	projects/Compress45/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java	0.5773502691896258	171	171	1	add	
67	[BUG] [BUGGY] return parseBinaryLong(buffer, offset, length, negative); [FE] IllegalArgumentException [CONTEXT] public static long parseOctalOrBinary(final byte[] buffer, final int offset, final int length) { if ((buffer[offset] & 0x80) == 0) { return parseOctal(buffer, offset, length); } final boolean negative = buffer[offset] == (byte) 0xff; if (length < 9) { [BUGGY] return parseBinaryLong(buffer, offset, length, negative); [BUGGY] } return parseBinaryBigInteger(buffer, offset, length, negative); } [CLASS] TarUtils 1 [METHOD] parseOctalOrBinary [RETURN_TYPE] long  final byte[] buffer final int offset final int length [VARIABLES] byte[] buffer boolean negative ZipEncoding DEFAULT_ENCODING FALLBACK_ENCODING int BYTE_MASK end i length offset start  	projects/Compress45/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java	0.5773502691896258	175	175	1	replace	
68	[BUG] [BUGGY] [FE] IllegalArgumentException [CONTEXT] public static long parseOctalOrBinary(final byte[] buffer, final int offset, final int length) { if ((buffer[offset] & 0x80) == 0) { return parseOctal(buffer, offset, length); } final boolean negative = buffer[offset] == (byte) 0xff; if (length < 9) { [BUGGY] [BUGGY] return parseBinaryLong(buffer, offset, length, negative); } return parseBinaryBigInteger(buffer, offset, length, negative); } [CLASS] TarUtils 1 [METHOD] parseOctalOrBinary [RETURN_TYPE] long  final byte[] buffer final int offset final int length [VARIABLES] byte[] buffer boolean negative ZipEncoding DEFAULT_ENCODING FALLBACK_ENCODING int BYTE_MASK end i length offset start  	projects/Compress45/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java	0.5773502691896258	175	175	1	add	
69	[BUG] [BUGGY] if (length >= 9) { [FE] IllegalArgumentException [CONTEXT] private static long parseBinaryLong(final byte[] buffer, final int offset, final int length, final boolean negative) { [BUGGY] if (length >= 9) { [BUGGY] throw new IllegalArgumentException("At offset " + offset + ", " + length + " byte binary number" + " exceeds maximum signed long" + " value"); } long val = 0; for (int i = 1; i < length; i++) { val = (val << 8) + (buffer[offset + i] & 0xff); } if (negative) { [CLASS] TarUtils 1 [METHOD] parseBinaryLong [RETURN_TYPE] long  final byte[] buffer final int offset final int length final boolean negative [VARIABLES] byte[] buffer boolean negative ZipEncoding DEFAULT_ENCODING FALLBACK_ENCODING int BYTE_MASK end i length offset start long val  	projects/Compress45/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java	0.5773502691896258	183	183	1	replace	
70	[BUG] [BUGGY] [FE] IllegalArgumentException [CONTEXT] private static long parseBinaryLong(final byte[] buffer, final int offset, final int length, final boolean negative) { [BUGGY] [BUGGY] if (length >= 9) { throw new IllegalArgumentException("At offset " + offset + ", " + length + " byte binary number" + " exceeds maximum signed long" + " value"); } long val = 0; for (int i = 1; i < length; i++) { val = (val << 8) + (buffer[offset + i] & 0xff); } if (negative) { [CLASS] TarUtils 1 [METHOD] parseBinaryLong [RETURN_TYPE] long  final byte[] buffer final int offset final int length final boolean negative [VARIABLES] byte[] buffer boolean negative ZipEncoding DEFAULT_ENCODING FALLBACK_ENCODING int BYTE_MASK end i length offset start long val  	projects/Compress45/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java	0.5773502691896258	183	183	1	add	
71	[BUG] [BUGGY] long val = 0; [FE] IllegalArgumentException [CONTEXT] private static long parseBinaryLong(final byte[] buffer, final int offset, final int length, final boolean negative) { if (length >= 9) { throw new IllegalArgumentException("At offset " + offset + ", " + length + " byte binary number" + " exceeds maximum signed long" + " value"); } [BUGGY] long val = 0; [BUGGY] for (int i = 1; i < length; i++) { val = (val << 8) + (buffer[offset + i] & 0xff); } if (negative) {  val--; val ^= (long) Math.pow(2.0, (length - 1) * 8.0) - 1; } return negative ? -val : val; } [CLASS] TarUtils 1 [METHOD] parseBinaryLong [RETURN_TYPE] long  final byte[] buffer final int offset final int length final boolean negative [VARIABLES] byte[] buffer boolean negative ZipEncoding DEFAULT_ENCODING FALLBACK_ENCODING int BYTE_MASK end i length offset start long val  	projects/Compress45/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java	0.5773502691896258	189	189	1	replace	
72	[BUG] [BUGGY] [FE] IllegalArgumentException [CONTEXT] private static long parseBinaryLong(final byte[] buffer, final int offset, final int length, final boolean negative) { if (length >= 9) { throw new IllegalArgumentException("At offset " + offset + ", " + length + " byte binary number" + " exceeds maximum signed long" + " value"); } [BUGGY] [BUGGY] long val = 0; for (int i = 1; i < length; i++) { val = (val << 8) + (buffer[offset + i] & 0xff); } if (negative) {  val--; val ^= (long) Math.pow(2.0, (length - 1) * 8.0) - 1; } return negative ? -val : val; } [CLASS] TarUtils 1 [METHOD] parseBinaryLong [RETURN_TYPE] long  final byte[] buffer final int offset final int length final boolean negative [VARIABLES] byte[] buffer boolean negative ZipEncoding DEFAULT_ENCODING FALLBACK_ENCODING int BYTE_MASK end i length offset start long val  	projects/Compress45/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java	0.5773502691896258	189	189	1	add	
73	[BUG] [BUGGY] for (int i = 1; i < length; i++) { [FE] IllegalArgumentException [CONTEXT] private static long parseBinaryLong(final byte[] buffer, final int offset, final int length, final boolean negative) { if (length >= 9) { throw new IllegalArgumentException("At offset " + offset + ", " + length + " byte binary number" + " exceeds maximum signed long" + " value"); } long val = 0; [BUGGY] for (int i = 1; i < length; i++) { [BUGGY] val = (val << 8) + (buffer[offset + i] & 0xff); } if (negative) {  val--; val ^= (long) Math.pow(2.0, (length - 1) * 8.0) - 1; } return negative ? -val : val; } [CLASS] TarUtils 1 [METHOD] parseBinaryLong [RETURN_TYPE] long  final byte[] buffer final int offset final int length final boolean negative [VARIABLES] byte[] buffer boolean negative ZipEncoding DEFAULT_ENCODING FALLBACK_ENCODING int BYTE_MASK end i length offset start long val  	projects/Compress45/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java	0.5773502691896258	190	190	1	replace	
74	[BUG] [BUGGY] [FE] IllegalArgumentException [CONTEXT] private static long parseBinaryLong(final byte[] buffer, final int offset, final int length, final boolean negative) { if (length >= 9) { throw new IllegalArgumentException("At offset " + offset + ", " + length + " byte binary number" + " exceeds maximum signed long" + " value"); } long val = 0; [BUGGY] [BUGGY] for (int i = 1; i < length; i++) { val = (val << 8) + (buffer[offset + i] & 0xff); } if (negative) {  val--; val ^= (long) Math.pow(2.0, (length - 1) * 8.0) - 1; } return negative ? -val : val; } [CLASS] TarUtils 1 [METHOD] parseBinaryLong [RETURN_TYPE] long  final byte[] buffer final int offset final int length final boolean negative [VARIABLES] byte[] buffer boolean negative ZipEncoding DEFAULT_ENCODING FALLBACK_ENCODING int BYTE_MASK end i length offset start long val  	projects/Compress45/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java	0.5773502691896258	190	190	1	add	
75	[BUG] [BUGGY] val = (val << 8) + (buffer[offset + i] & 0xff); [FE] IllegalArgumentException [CONTEXT] final int length, final boolean negative) { if (length >= 9) { throw new IllegalArgumentException("At offset " + offset + ", " + length + " byte binary number" + " exceeds maximum signed long" + " value"); } long val = 0; for (int i = 1; i < length; i++) { [BUGGY] val = (val << 8) + (buffer[offset + i] & 0xff); [BUGGY] } if (negative) {  val--; val ^= (long) Math.pow(2.0, (length - 1) * 8.0) - 1; } return negative ? -val : val; } [CLASS] TarUtils 1 [METHOD] parseBinaryLong [RETURN_TYPE] long  final byte[] buffer final int offset final int length final boolean negative [VARIABLES] byte[] buffer boolean negative ZipEncoding DEFAULT_ENCODING FALLBACK_ENCODING int BYTE_MASK end i length offset start long val  	projects/Compress45/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java	0.5773502691896258	191	191	1	replace	
76	[BUG] [BUGGY] [FE] IllegalArgumentException [CONTEXT] final int length, final boolean negative) { if (length >= 9) { throw new IllegalArgumentException("At offset " + offset + ", " + length + " byte binary number" + " exceeds maximum signed long" + " value"); } long val = 0; for (int i = 1; i < length; i++) { [BUGGY] [BUGGY] val = (val << 8) + (buffer[offset + i] & 0xff); } if (negative) {  val--; val ^= (long) Math.pow(2.0, (length - 1) * 8.0) - 1; } return negative ? -val : val; } [CLASS] TarUtils 1 [METHOD] parseBinaryLong [RETURN_TYPE] long  final byte[] buffer final int offset final int length final boolean negative [VARIABLES] byte[] buffer boolean negative ZipEncoding DEFAULT_ENCODING FALLBACK_ENCODING int BYTE_MASK end i length offset start long val  	projects/Compress45/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java	0.5773502691896258	191	191	1	add	
77	[BUG] [BUGGY] if (negative) { [FE] IllegalArgumentException [CONTEXT] if (length >= 9) { throw new IllegalArgumentException("At offset " + offset + ", " + length + " byte binary number" + " exceeds maximum signed long" + " value"); } long val = 0; for (int i = 1; i < length; i++) { val = (val << 8) + (buffer[offset + i] & 0xff); } [BUGGY] if (negative) { [BUGGY]  val--; val ^= (long) Math.pow(2.0, (length - 1) * 8.0) - 1; } return negative ? -val : val; } [CLASS] TarUtils 1 [METHOD] parseBinaryLong [RETURN_TYPE] long  final byte[] buffer final int offset final int length final boolean negative [VARIABLES] byte[] buffer boolean negative ZipEncoding DEFAULT_ENCODING FALLBACK_ENCODING int BYTE_MASK end i length offset start long val  	projects/Compress45/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java	0.5773502691896258	193	193	1	replace	
78	[BUG] [BUGGY] [FE] IllegalArgumentException [CONTEXT] if (length >= 9) { throw new IllegalArgumentException("At offset " + offset + ", " + length + " byte binary number" + " exceeds maximum signed long" + " value"); } long val = 0; for (int i = 1; i < length; i++) { val = (val << 8) + (buffer[offset + i] & 0xff); } [BUGGY] [BUGGY] if (negative) {  val--; val ^= (long) Math.pow(2.0, (length - 1) * 8.0) - 1; } return negative ? -val : val; } [CLASS] TarUtils 1 [METHOD] parseBinaryLong [RETURN_TYPE] long  final byte[] buffer final int offset final int length final boolean negative [VARIABLES] byte[] buffer boolean negative ZipEncoding DEFAULT_ENCODING FALLBACK_ENCODING int BYTE_MASK end i length offset start long val  	projects/Compress45/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java	0.5773502691896258	193	193	1	add	
79	[BUG] [BUGGY] val--; [FE] IllegalArgumentException [CONTEXT] + length + " byte binary number" + " exceeds maximum signed long" + " value"); } long val = 0; for (int i = 1; i < length; i++) { val = (val << 8) + (buffer[offset + i] & 0xff); } if (negative) {  [BUGGY] val--; [BUGGY] val ^= (long) Math.pow(2.0, (length - 1) * 8.0) - 1; } return negative ? -val : val; } [CLASS] TarUtils 1 [METHOD] parseBinaryLong [RETURN_TYPE] long  final byte[] buffer final int offset final int length final boolean negative [VARIABLES] byte[] buffer boolean negative ZipEncoding DEFAULT_ENCODING FALLBACK_ENCODING int BYTE_MASK end i length offset start long val  	projects/Compress45/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java	0.5773502691896258	195	195	1	replace	
80	[BUG] [BUGGY] [FE] IllegalArgumentException [CONTEXT] + length + " byte binary number" + " exceeds maximum signed long" + " value"); } long val = 0; for (int i = 1; i < length; i++) { val = (val << 8) + (buffer[offset + i] & 0xff); } if (negative) {  [BUGGY] [BUGGY] val--; val ^= (long) Math.pow(2.0, (length - 1) * 8.0) - 1; } return negative ? -val : val; } [CLASS] TarUtils 1 [METHOD] parseBinaryLong [RETURN_TYPE] long  final byte[] buffer final int offset final int length final boolean negative [VARIABLES] byte[] buffer boolean negative ZipEncoding DEFAULT_ENCODING FALLBACK_ENCODING int BYTE_MASK end i length offset start long val  	projects/Compress45/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java	0.5773502691896258	195	195	1	add	
81	[BUG] [BUGGY] val ^= (long) Math.pow(2.0, (length - 1) * 8.0) - 1; [FE] IllegalArgumentException [CONTEXT] + " exceeds maximum signed long" + " value"); } long val = 0; for (int i = 1; i < length; i++) { val = (val << 8) + (buffer[offset + i] & 0xff); } if (negative) {  val--; [BUGGY] val ^= (long) Math.pow(2.0, (length - 1) * 8.0) - 1; [BUGGY] } return negative ? -val : val; } [CLASS] TarUtils 1 [METHOD] parseBinaryLong [RETURN_TYPE] long  final byte[] buffer final int offset final int length final boolean negative [VARIABLES] byte[] buffer boolean negative ZipEncoding DEFAULT_ENCODING FALLBACK_ENCODING int BYTE_MASK end i length offset start long val  	projects/Compress45/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java	0.5773502691896258	196	196	1	replace	
82	[BUG] [BUGGY] [FE] IllegalArgumentException [CONTEXT] + " exceeds maximum signed long" + " value"); } long val = 0; for (int i = 1; i < length; i++) { val = (val << 8) + (buffer[offset + i] & 0xff); } if (negative) {  val--; [BUGGY] [BUGGY] val ^= (long) Math.pow(2.0, (length - 1) * 8.0) - 1; } return negative ? -val : val; } [CLASS] TarUtils 1 [METHOD] parseBinaryLong [RETURN_TYPE] long  final byte[] buffer final int offset final int length final boolean negative [VARIABLES] byte[] buffer boolean negative ZipEncoding DEFAULT_ENCODING FALLBACK_ENCODING int BYTE_MASK end i length offset start long val  	projects/Compress45/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java	0.5773502691896258	196	196	1	add	
83	[BUG] [BUGGY] return negative ? -val : val; [FE] IllegalArgumentException [CONTEXT] } long val = 0; for (int i = 1; i < length; i++) { val = (val << 8) + (buffer[offset + i] & 0xff); } if (negative) {  val--; val ^= (long) Math.pow(2.0, (length - 1) * 8.0) - 1; } [BUGGY] return negative ? -val : val; [BUGGY] } [CLASS] TarUtils 1 [METHOD] parseBinaryLong [RETURN_TYPE] long  final byte[] buffer final int offset final int length final boolean negative [VARIABLES] byte[] buffer boolean negative ZipEncoding DEFAULT_ENCODING FALLBACK_ENCODING int BYTE_MASK end i length offset start long val  	projects/Compress45/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java	0.5773502691896258	198	198	1	replace	
84	[BUG] [BUGGY] [FE] IllegalArgumentException [CONTEXT] } long val = 0; for (int i = 1; i < length; i++) { val = (val << 8) + (buffer[offset + i] & 0xff); } if (negative) {  val--; val ^= (long) Math.pow(2.0, (length - 1) * 8.0) - 1; } [BUGGY] [BUGGY] return negative ? -val : val; } [CLASS] TarUtils 1 [METHOD] parseBinaryLong [RETURN_TYPE] long  final byte[] buffer final int offset final int length final boolean negative [VARIABLES] byte[] buffer boolean negative ZipEncoding DEFAULT_ENCODING FALLBACK_ENCODING int BYTE_MASK end i length offset start long val  	projects/Compress45/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java	0.5773502691896258	198	198	1	add	
85	[BUG] [BUGGY] buffer[offset + remaining--] = (byte) '0'; [FE] IllegalArgumentException [CONTEXT] public static void formatUnsignedOctalString(final long value, final byte[] buffer, final int offset, final int length) { int remaining = length; remaining--; if (value == 0) { [BUGGY] buffer[offset + remaining--] = (byte) '0'; [BUGGY] } else { long val = value; for (; remaining >= 0 && val != 0; --remaining) {  buffer[offset + remaining] = (byte) ((byte) '0' + (byte) (val & 7)); val = val >>> 3;  } if (val != 0){ throw new IllegalArgumentException [CLASS] TarUtils 1 [METHOD] formatUnsignedOctalString [RETURN_TYPE] void  final long value final byte[] buffer final int offset final int length [VARIABLES] byte[] buffer boolean ZipEncoding DEFAULT_ENCODING FALLBACK_ENCODING encoding int BYTE_MASK current end i len length limit offset remaining start long val value  	projects/Compress45/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java	0.5773502691896258	388	388	1	replace	
86	[BUG] [BUGGY] [FE] IllegalArgumentException [CONTEXT] public static void formatUnsignedOctalString(final long value, final byte[] buffer, final int offset, final int length) { int remaining = length; remaining--; if (value == 0) { [BUGGY] [BUGGY] buffer[offset + remaining--] = (byte) '0'; } else { long val = value; for (; remaining >= 0 && val != 0; --remaining) {  buffer[offset + remaining] = (byte) ((byte) '0' + (byte) (val & 7)); val = val >>> 3;  } if (val != 0){ throw new IllegalArgumentException [CLASS] TarUtils 1 [METHOD] formatUnsignedOctalString [RETURN_TYPE] void  final long value final byte[] buffer final int offset final int length [VARIABLES] byte[] buffer boolean ZipEncoding DEFAULT_ENCODING FALLBACK_ENCODING encoding int BYTE_MASK current end i len length limit offset remaining start long val value  	projects/Compress45/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java	0.5773502691896258	388	388	1	add	
87	[BUG] [BUGGY] buffer[offset + remaining] = (byte) '0'; [FE] IllegalArgumentException [CONTEXT] val = val >>> 3;  } if (val != 0){ throw new IllegalArgumentException (value+"="+Long.toOctalString(value)+ " will not fit in octal number buffer of length "+length); } } for (; remaining >= 0; --remaining) { // leading zeros [BUGGY] buffer[offset + remaining] = (byte) '0'; [BUGGY] } } [CLASS] TarUtils 1 [METHOD] formatUnsignedOctalString [RETURN_TYPE] void  final long value final byte[] buffer final int offset final int length [VARIABLES] byte[] buffer boolean ZipEncoding DEFAULT_ENCODING FALLBACK_ENCODING encoding int BYTE_MASK current end i len length limit offset remaining start long val value  	projects/Compress45/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java	0.5	404	404	1	replace	
88	[BUG] [BUGGY] [FE] IllegalArgumentException [CONTEXT] val = val >>> 3;  } if (val != 0){ throw new IllegalArgumentException (value+"="+Long.toOctalString(value)+ " will not fit in octal number buffer of length "+length); } } for (; remaining >= 0; --remaining) { // leading zeros [BUGGY] [BUGGY] buffer[offset + remaining] = (byte) '0'; } } [CLASS] TarUtils 1 [METHOD] formatUnsignedOctalString [RETURN_TYPE] void  final long value final byte[] buffer final int offset final int length [VARIABLES] byte[] buffer boolean ZipEncoding DEFAULT_ENCODING FALLBACK_ENCODING encoding int BYTE_MASK current end i len length limit offset remaining start long val value  	projects/Compress45/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java	0.5	404	404	1	add	
89	[BUG] [BUGGY] final int idx=length-1; // For space formatUnsignedOctalString(value, buf, offset, idx); [FE] IllegalArgumentException [CONTEXT] public static int formatLongOctalBytes(final long value, final byte[] buf, final int offset, final int length) { [BUGGY] final int idx=length-1; // For space    formatUnsignedOctalString(value, buf, offset, idx); [BUGGY]  formatUnsignedOctalString(value, buf, offset, idx); buf[offset + idx] = (byte) ' '; // Trailing space return offset + length; } [CLASS] TarUtils 1 [METHOD] formatLongOctalBytes [RETURN_TYPE] int  final long value final byte[] buf final int offset final int length [VARIABLES] byte[] buf boolean ZipEncoding DEFAULT_ENCODING FALLBACK_ENCODING encoding int BYTE_MASK current end i idx len length limit offset remaining start long value  	projects/Compress45/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java	0.5	449	451	1	replace	
90	[BUG] [BUGGY] [FE] IllegalArgumentException [CONTEXT] public static int formatLongOctalBytes(final long value, final byte[] buf, final int offset, final int length) { [BUGGY] [BUGGY] final int idx=length-1; // For space    formatUnsignedOctalString(value, buf, offset, idx); formatUnsignedOctalString(value, buf, offset, idx); buf[offset + idx] = (byte) ' '; // Trailing space return offset + length; } [CLASS] TarUtils 1 [METHOD] formatLongOctalBytes [RETURN_TYPE] int  final long value final byte[] buf final int offset final int length [VARIABLES] byte[] buf boolean ZipEncoding DEFAULT_ENCODING FALLBACK_ENCODING encoding int BYTE_MASK current end i idx len length limit offset remaining start long value  	projects/Compress45/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java	0.5	449	451	1	add	
91	[BUG] [BUGGY] formatUnsignedOctalString(value, buf, offset, idx); [FE] IllegalArgumentException [CONTEXT] public static int formatLongOctalBytes(final long value, final byte[] buf, final int offset, final int length) { final int idx=length-1; // For space [BUGGY] formatUnsignedOctalString(value, buf, offset, idx); [BUGGY] buf[offset + idx] = (byte) ' '; // Trailing space return offset + length; } [CLASS] TarUtils 1 [METHOD] formatLongOctalBytes [RETURN_TYPE] int  final long value final byte[] buf final int offset final int length [VARIABLES] byte[] buf boolean ZipEncoding DEFAULT_ENCODING FALLBACK_ENCODING encoding int BYTE_MASK current end i idx len length limit offset remaining start long value  	projects/Compress45/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java	0.5	451	451	1	replace	
92	[BUG] [BUGGY] [FE] IllegalArgumentException [CONTEXT] public static int formatLongOctalBytes(final long value, final byte[] buf, final int offset, final int length) { final int idx=length-1; // For space [BUGGY] [BUGGY] formatUnsignedOctalString(value, buf, offset, idx); buf[offset + idx] = (byte) ' '; // Trailing space return offset + length; } [CLASS] TarUtils 1 [METHOD] formatLongOctalBytes [RETURN_TYPE] int  final long value final byte[] buf final int offset final int length [VARIABLES] byte[] buf boolean ZipEncoding DEFAULT_ENCODING FALLBACK_ENCODING encoding int BYTE_MASK current end i idx len length limit offset remaining start long value  	projects/Compress45/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java	0.5	451	451	1	add	
93	[BUG] [BUGGY] buf[offset + idx] = (byte) ' '; // Trailing space return offset + length; [FE] IllegalArgumentException [CONTEXT] public static int formatLongOctalBytes(final long value, final byte[] buf, final int offset, final int length) { final int idx=length-1; // For space formatUnsignedOctalString(value, buf, offset, idx); [BUGGY] buf[offset + idx] = (byte) ' '; // Trailing space    return offset + length; [BUGGY]  return offset + length; } [CLASS] TarUtils 1 [METHOD] formatLongOctalBytes [RETURN_TYPE] int  final long value final byte[] buf final int offset final int length [VARIABLES] byte[] buf boolean ZipEncoding DEFAULT_ENCODING FALLBACK_ENCODING encoding int BYTE_MASK current end i idx len length limit offset remaining start long value  	projects/Compress45/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java	0.5	452	454	1	replace	
94	[BUG] [BUGGY] [FE] IllegalArgumentException [CONTEXT] public static int formatLongOctalBytes(final long value, final byte[] buf, final int offset, final int length) { final int idx=length-1; // For space formatUnsignedOctalString(value, buf, offset, idx); [BUGGY] [BUGGY] buf[offset + idx] = (byte) ' '; // Trailing space    return offset + length; return offset + length; } [CLASS] TarUtils 1 [METHOD] formatLongOctalBytes [RETURN_TYPE] int  final long value final byte[] buf final int offset final int length [VARIABLES] byte[] buf boolean ZipEncoding DEFAULT_ENCODING FALLBACK_ENCODING encoding int BYTE_MASK current end i idx len length limit offset remaining start long value  	projects/Compress45/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java	0.5	452	454	1	add	
95	[BUG] [BUGGY] return offset + length; [FE] IllegalArgumentException [CONTEXT] public static int formatLongOctalBytes(final long value, final byte[] buf, final int offset, final int length) { final int idx=length-1; // For space formatUnsignedOctalString(value, buf, offset, idx); buf[offset + idx] = (byte) ' '; // Trailing space [BUGGY] return offset + length; [BUGGY] } [CLASS] TarUtils 1 [METHOD] formatLongOctalBytes [RETURN_TYPE] int  final long value final byte[] buf final int offset final int length [VARIABLES] byte[] buf boolean ZipEncoding DEFAULT_ENCODING FALLBACK_ENCODING encoding int BYTE_MASK current end i idx len length limit offset remaining start long value  	projects/Compress45/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java	0.5	454	454	1	replace	
96	[BUG] [BUGGY] [FE] IllegalArgumentException [CONTEXT] public static int formatLongOctalBytes(final long value, final byte[] buf, final int offset, final int length) { final int idx=length-1; // For space formatUnsignedOctalString(value, buf, offset, idx); buf[offset + idx] = (byte) ' '; // Trailing space [BUGGY] [BUGGY] return offset + length; } [CLASS] TarUtils 1 [METHOD] formatLongOctalBytes [RETURN_TYPE] int  final long value final byte[] buf final int offset final int length [VARIABLES] byte[] buf boolean ZipEncoding DEFAULT_ENCODING FALLBACK_ENCODING encoding int BYTE_MASK current end i idx len length limit offset remaining start long value  	projects/Compress45/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java	0.5	454	454	1	add	
97	[BUG] [BUGGY] final boolean negative = buffer[offset] == (byte) 0xff; [FE] IllegalArgumentException [CONTEXT] public static long parseOctalOrBinary(final byte[] buffer, final int offset, final int length) { if ((buffer[offset] & 0x80) == 0) { return parseOctal(buffer, offset, length); } [BUGGY] final boolean negative = buffer[offset] == (byte) 0xff; [BUGGY] if (length < 9) { return parseBinaryLong(buffer, offset, length, negative); } return parseBinaryBigInteger(buffer, offset, length, negative); } [CLASS] TarUtils 1 [METHOD] parseOctalOrBinary [RETURN_TYPE] long  final byte[] buffer final int offset final int length [VARIABLES] byte[] buffer boolean negative ZipEncoding DEFAULT_ENCODING FALLBACK_ENCODING int BYTE_MASK end i length offset start  	projects/Compress45/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java	0.4472135954999579	173	173	1	replace	
98	[BUG] [BUGGY] [FE] IllegalArgumentException [CONTEXT] public static long parseOctalOrBinary(final byte[] buffer, final int offset, final int length) { if ((buffer[offset] & 0x80) == 0) { return parseOctal(buffer, offset, length); } [BUGGY] [BUGGY] final boolean negative = buffer[offset] == (byte) 0xff; if (length < 9) { return parseBinaryLong(buffer, offset, length, negative); } return parseBinaryBigInteger(buffer, offset, length, negative); } [CLASS] TarUtils 1 [METHOD] parseOctalOrBinary [RETURN_TYPE] long  final byte[] buffer final int offset final int length [VARIABLES] byte[] buffer boolean negative ZipEncoding DEFAULT_ENCODING FALLBACK_ENCODING int BYTE_MASK end i length offset start  	projects/Compress45/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java	0.4472135954999579	173	173	1	add	
99	[BUG] [BUGGY] if (length < 9) { [FE] IllegalArgumentException [CONTEXT] public static long parseOctalOrBinary(final byte[] buffer, final int offset, final int length) { if ((buffer[offset] & 0x80) == 0) { return parseOctal(buffer, offset, length); } final boolean negative = buffer[offset] == (byte) 0xff; [BUGGY] if (length < 9) { [BUGGY] return parseBinaryLong(buffer, offset, length, negative); } return parseBinaryBigInteger(buffer, offset, length, negative); } [CLASS] TarUtils 1 [METHOD] parseOctalOrBinary [RETURN_TYPE] long  final byte[] buffer final int offset final int length [VARIABLES] byte[] buffer boolean negative ZipEncoding DEFAULT_ENCODING FALLBACK_ENCODING int BYTE_MASK end i length offset start  	projects/Compress45/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java	0.4472135954999579	174	174	1	replace	
100	[BUG] [BUGGY] [FE] IllegalArgumentException [CONTEXT] public static long parseOctalOrBinary(final byte[] buffer, final int offset, final int length) { if ((buffer[offset] & 0x80) == 0) { return parseOctal(buffer, offset, length); } final boolean negative = buffer[offset] == (byte) 0xff; [BUGGY] [BUGGY] if (length < 9) { return parseBinaryLong(buffer, offset, length, negative); } return parseBinaryBigInteger(buffer, offset, length, negative); } [CLASS] TarUtils 1 [METHOD] parseOctalOrBinary [RETURN_TYPE] long  final byte[] buffer final int offset final int length [VARIABLES] byte[] buffer boolean negative ZipEncoding DEFAULT_ENCODING FALLBACK_ENCODING int BYTE_MASK end i length offset start  	projects/Compress45/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java	0.4472135954999579	174	174	1	add	
