bugid	buggy	buggy_class	suspiciousness	buggy_line	endbuggycode	original_failing_test_number	action	patch	original_buggy	execution_result	diagnosis	previous_bug_id	new_failing_test_number	this_action
1	[BUG]  [BUGGY]  removeChild(n);  [CE]  ')'  expected  [FE]          AssertionFailedError    [CONTEXT]    AND_PRECEDENCE))  {  return  n;  }  n.removeChild(cond);  Node  and  =  new  Node(Token.AND,  cond,  expr.removeFirstChild())  .copyInformationFrom(n);  Node  newExpr  =  NodeUtil.newExpr(and);  parent.replaceChild(n,  newExpr);    [BUGGY]  removeChild(n);  [BUGGY]      return  newExpr;  }  return  n;  }      [CLASS]  PeepholeSubstituteAlternateSyntax  1  2  3  FoldArrayAction  [METHOD]  tryMinimizeIf  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Pattern  REGEXP_FLAGS_RE  FoldArrayAction  NOT_SAFE_TO_FOLD  SAFE_TO_FOLD_WITHOUT_ARGS  SAFE_TO_FOLD_WITH_ARGS  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  ImmutableSet  STANDARD_OBJECT_CONSTRUCTORS  DiagnosticType  INVALID_REGULAR_EXPRESSION_FLAGS  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  Predicate  DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.5773502691896258	314	314	1	replace	removeChild(n);	  repaint();    	non-compiled	[CE]  ')'  expected	9	None	replace
2	[BUG]  [BUGGY]  replaceChild(n,  newExpr);  [CE]  ')'  expected  [FE]            AssertionFailedError    [CONTEXT]    AND_PRECEDENCE))  {  return  n;  }  n.removeChild(cond);  Node  and  =  new  Node(Token.AND,  cond,  expr.removeFirstChild())  .copyInformationFrom(n);  Node  newExpr  =  NodeUtil.newExpr(and);  parent.replaceChild(n,  newExpr);    [BUGGY]  replaceChild(n,  newExpr);  [BUGGY]      return  newExpr;  }  return  n;  }      [CLASS]  PeepholeSubstituteAlternateSyntax  1  2  3  FoldArrayAction  [METHOD]  tryMinimizeIf  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Pattern  REGEXP_FLAGS_RE  FoldArrayAction  NOT_SAFE_TO_FOLD  SAFE_TO_FOLD_WITHOUT_ARGS  SAFE_TO_FOLD_WITH_ARGS  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  ImmutableSet  STANDARD_OBJECT_CONSTRUCTORS  DiagnosticType  INVALID_REGULAR_EXPRESSION_FLAGS  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  Predicate  DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.5773502691896258	314	314	1	replace	replaceChild(n,  newExpr);	  repaint();    	non-compiled	[CE]  ')'  expected	9	None	replace
3	[BUG]  [BUGGY]  removeChild(newExpr);  [CE]  ')'  expected  [FE]              AssertionFailedError    [CONTEXT]    AND_PRECEDENCE))  {  return  n;  }  n.removeChild(cond);  Node  and  =  new  Node(Token.AND,  cond,  expr.removeFirstChild())  .copyInformationFrom(n);  Node  newExpr  =  NodeUtil.newExpr(and);  parent.replaceChild(n,  newExpr);    [BUGGY]  removeChild(newExpr);  [BUGGY]      return  newExpr;  }  return  n;  }      [CLASS]  PeepholeSubstituteAlternateSyntax  1  2  3  FoldArrayAction  [METHOD]  tryMinimizeIf  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Pattern  REGEXP_FLAGS_RE  FoldArrayAction  NOT_SAFE_TO_FOLD  SAFE_TO_FOLD_WITHOUT_ARGS  SAFE_TO_FOLD_WITH_ARGS  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  ImmutableSet  STANDARD_OBJECT_CONSTRUCTORS  DiagnosticType  INVALID_REGULAR_EXPRESSION_FLAGS  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  Predicate  DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.5773502691896258	314	314	1	replace	removeChild(newExpr);	  repaint();    	non-compiled	[CE]  ')'  expected	9	None	replace
4	[BUG]  [BUGGY]  returnNode();  [CE]  ')'  expected  [FE]                AssertionFailedError    [CONTEXT]    AND_PRECEDENCE))  {  return  n;  }  n.removeChild(cond);  Node  and  =  new  Node(Token.AND,  cond,  expr.removeFirstChild())  .copyInformationFrom(n);  Node  newExpr  =  NodeUtil.newExpr(and);  parent.replaceChild(n,  newExpr);    [BUGGY]  returnNode();  [BUGGY]      return  newExpr;  }  return  n;  }      [CLASS]  PeepholeSubstituteAlternateSyntax  1  2  3  FoldArrayAction  [METHOD]  tryMinimizeIf  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Pattern  REGEXP_FLAGS_RE  FoldArrayAction  NOT_SAFE_TO_FOLD  SAFE_TO_FOLD_WITHOUT_ARGS  SAFE_TO_FOLD_WITH_ARGS  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  ImmutableSet  STANDARD_OBJECT_CONSTRUCTORS  DiagnosticType  INVALID_REGULAR_EXPRESSION_FLAGS  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  Predicate  DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.5773502691896258	314	314	1	replace	returnNode();	  repaint();    	non-compiled	[CE]  ')'  expected	9	None	replace
5	[BUG]  [BUGGY]  removeChild(cond);  [CE]  ')'  expected  [FE]                  AssertionFailedError    [CONTEXT]    AND_PRECEDENCE))  {  return  n;  }  n.removeChild(cond);  Node  and  =  new  Node(Token.AND,  cond,  expr.removeFirstChild())  .copyInformationFrom(n);  Node  newExpr  =  NodeUtil.newExpr(and);  parent.replaceChild(n,  newExpr);    [BUGGY]  removeChild(cond);  [BUGGY]      return  newExpr;  }  return  n;  }      [CLASS]  PeepholeSubstituteAlternateSyntax  1  2  3  FoldArrayAction  [METHOD]  tryMinimizeIf  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Pattern  REGEXP_FLAGS_RE  FoldArrayAction  NOT_SAFE_TO_FOLD  SAFE_TO_FOLD_WITHOUT_ARGS  SAFE_TO_FOLD_WITH_ARGS  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  ImmutableSet  STANDARD_OBJECT_CONSTRUCTORS  DiagnosticType  INVALID_REGULAR_EXPRESSION_FLAGS  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  Predicate  DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.5773502691896258	314	314	1	replace	removeChild(cond);	  repaint();    	non-compiled	[CE]  ')'  expected	9	None	replace
6	[BUG]  [BUGGY]  removeChild(parent);  [CE]  ')'  expected  [FE]                    AssertionFailedError    [CONTEXT]    AND_PRECEDENCE))  {  return  n;  }  n.removeChild(cond);  Node  and  =  new  Node(Token.AND,  cond,  expr.removeFirstChild())  .copyInformationFrom(n);  Node  newExpr  =  NodeUtil.newExpr(and);  parent.replaceChild(n,  newExpr);    [BUGGY]  removeChild(parent);  [BUGGY]      return  newExpr;  }  return  n;  }      [CLASS]  PeepholeSubstituteAlternateSyntax  1  2  3  FoldArrayAction  [METHOD]  tryMinimizeIf  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Pattern  REGEXP_FLAGS_RE  FoldArrayAction  NOT_SAFE_TO_FOLD  SAFE_TO_FOLD_WITHOUT_ARGS  SAFE_TO_FOLD_WITH_ARGS  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  ImmutableSet  STANDARD_OBJECT_CONSTRUCTORS  DiagnosticType  INVALID_REGULAR_EXPRESSION_FLAGS  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  Predicate  DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.5773502691896258	314	314	1	replace	removeChild(parent);	  repaint();    	non-compiled	[CE]  ')'  expected	9	None	replace
7	[BUG]  [BUGGY]  newExpr.removeChild(cond);  [CE]  ')'  expected  [FE]                AssertionFailedError    [CONTEXT]    AND_PRECEDENCE))  {  return  n;  }  n.removeChild(cond);  Node  and  =  new  Node(Token.AND,  cond,  expr.removeFirstChild())  .copyInformationFrom(n);  Node  newExpr  =  NodeUtil.newExpr(and);  parent.replaceChild(n,  newExpr);    [BUGGY]  newExpr.removeChild(cond);  [BUGGY]      return  newExpr;  }  return  n;  }      [CLASS]  PeepholeSubstituteAlternateSyntax  1  2  3  FoldArrayAction  [METHOD]  tryMinimizeIf  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Pattern  REGEXP_FLAGS_RE  FoldArrayAction  NOT_SAFE_TO_FOLD  SAFE_TO_FOLD_WITHOUT_ARGS  SAFE_TO_FOLD_WITH_ARGS  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  ImmutableSet  STANDARD_OBJECT_CONSTRUCTORS  DiagnosticType  INVALID_REGULAR_EXPRESSION_FLAGS  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  Predicate  DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.5773502691896258	314	314	1	replace	newExpr.removeChild(cond);	      	non-compiled	[CE]  ')'  expected	5	None	replace
8	[BUG]  [BUGGY]  NodeUtil.copyInformationFrom(n,  parent);  [CE]  ')'  expected  [FE]                  AssertionFailedError    [CONTEXT]    AND_PRECEDENCE))  {  return  n;  }  n.removeChild(cond);  Node  and  =  new  Node(Token.AND,  cond,  expr.removeFirstChild())  .copyInformationFrom(n);  Node  newExpr  =  NodeUtil.newExpr(and);  parent.replaceChild(n,  newExpr);    [BUGGY]  NodeUtil.copyInformationFrom(n,  parent);  [BUGGY]      return  newExpr;  }  return  n;  }      [CLASS]  PeepholeSubstituteAlternateSyntax  1  2  3  FoldArrayAction  [METHOD]  tryMinimizeIf  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Pattern  REGEXP_FLAGS_RE  FoldArrayAction  NOT_SAFE_TO_FOLD  SAFE_TO_FOLD_WITHOUT_ARGS  SAFE_TO_FOLD_WITH_ARGS  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  ImmutableSet  STANDARD_OBJECT_CONSTRUCTORS  DiagnosticType  INVALID_REGULAR_EXPRESSION_FLAGS  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  Predicate  DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.5773502691896258	314	314	1	replace	NodeUtil.copyInformationFrom(n,  parent);	      	non-compiled	[CE]  ')'  expected	5	None	replace
9	[BUG]  [BUGGY]  NodeUtil.copyInformationFrom(n,  newExpr);  [CE]  ')'  expected  [FE]                    AssertionFailedError    [CONTEXT]    AND_PRECEDENCE))  {  return  n;  }  n.removeChild(cond);  Node  and  =  new  Node(Token.AND,  cond,  expr.removeFirstChild())  .copyInformationFrom(n);  Node  newExpr  =  NodeUtil.newExpr(and);  parent.replaceChild(n,  newExpr);    [BUGGY]  NodeUtil.copyInformationFrom(n,  newExpr);  [BUGGY]      return  newExpr;  }  return  n;  }      [CLASS]  PeepholeSubstituteAlternateSyntax  1  2  3  FoldArrayAction  [METHOD]  tryMinimizeIf  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Pattern  REGEXP_FLAGS_RE  FoldArrayAction  NOT_SAFE_TO_FOLD  SAFE_TO_FOLD_WITHOUT_ARGS  SAFE_TO_FOLD_WITH_ARGS  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  ImmutableSet  STANDARD_OBJECT_CONSTRUCTORS  DiagnosticType  INVALID_REGULAR_EXPRESSION_FLAGS  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  Predicate  DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.5773502691896258	314	314	1	replace	NodeUtil.copyInformationFrom(n,  newExpr);	      	non-compiled	[CE]  ')'  expected	5	None	replace
10	[BUG]  [BUGGY]  NodeUtil.copyInformationFrom(parent,  newExpr);  [CE]  ')'  expected  [FE]                      AssertionFailedError    [CONTEXT]    AND_PRECEDENCE))  {  return  n;  }  n.removeChild(cond);  Node  and  =  new  Node(Token.AND,  cond,  expr.removeFirstChild())  .copyInformationFrom(n);  Node  newExpr  =  NodeUtil.newExpr(and);  parent.replaceChild(n,  newExpr);    [BUGGY]  NodeUtil.copyInformationFrom(parent,  newExpr);  [BUGGY]      return  newExpr;  }  return  n;  }      [CLASS]  PeepholeSubstituteAlternateSyntax  1  2  3  FoldArrayAction  [METHOD]  tryMinimizeIf  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Pattern  REGEXP_FLAGS_RE  FoldArrayAction  NOT_SAFE_TO_FOLD  SAFE_TO_FOLD_WITHOUT_ARGS  SAFE_TO_FOLD_WITH_ARGS  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  ImmutableSet  STANDARD_OBJECT_CONSTRUCTORS  DiagnosticType  INVALID_REGULAR_EXPRESSION_FLAGS  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  Predicate  DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.5773502691896258	314	314	1	replace	NodeUtil.copyInformationFrom(parent,  newExpr);	      	non-compiled	[CE]  ')'  expected	5	None	replace
11	[BUG]  [BUGGY]  parent.removeChild(expr);  [CE]  ')'  expected  [FE]        AssertionFailedError    [CONTEXT]    AND_PRECEDENCE))  {  return  n;  }  n.removeChild(cond);  Node  and  =  new  Node(Token.AND,  cond,  expr.removeFirstChild())  .copyInformationFrom(n);  Node  newExpr  =  NodeUtil.newExpr(and);  parent.replaceChild(n,  newExpr);    [BUGGY]  parent.removeChild(expr);  [BUGGY]      return  newExpr;  }  return  n;  }      [CLASS]  PeepholeSubstituteAlternateSyntax  1  2  3  FoldArrayAction  [METHOD]  tryMinimizeIf  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Pattern  REGEXP_FLAGS_RE  FoldArrayAction  NOT_SAFE_TO_FOLD  SAFE_TO_FOLD_WITHOUT_ARGS  SAFE_TO_FOLD_WITH_ARGS  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  ImmutableSet  STANDARD_OBJECT_CONSTRUCTORS  DiagnosticType  INVALID_REGULAR_EXPRESSION_FLAGS  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  Predicate  DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.5773502691896258	314	314	1	replace	parent.removeChild(expr);	  n.removeChild(expr);    	non-compiled	[CE]  ')'  expected	6	None	replace
12	[BUG]  [BUGGY]  parent.removeChild(cond);  [CE]  ')'  expected  [FE]        AssertionFailedError    [CONTEXT]    AND_PRECEDENCE))  {  return  n;  }  n.removeChild(cond);  Node  and  =  new  Node(Token.AND,  cond,  expr.removeFirstChild())  .copyInformationFrom(n);  Node  newExpr  =  NodeUtil.newExpr(and);  parent.replaceChild(n,  newExpr);    [BUGGY]  parent.removeChild(cond);  [BUGGY]      return  newExpr;  }  return  n;  }      [CLASS]  PeepholeSubstituteAlternateSyntax  1  2  3  FoldArrayAction  [METHOD]  tryMinimizeIf  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Pattern  REGEXP_FLAGS_RE  FoldArrayAction  NOT_SAFE_TO_FOLD  SAFE_TO_FOLD_WITHOUT_ARGS  SAFE_TO_FOLD_WITH_ARGS  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  ImmutableSet  STANDARD_OBJECT_CONSTRUCTORS  DiagnosticType  INVALID_REGULAR_EXPRESSION_FLAGS  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  Predicate  DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.5773502691896258	314	314	1	replace	parent.removeChild(cond);	  parent.removeChild(n);    	non-compiled	[CE]  ')'  expected	8	None	replace
13	[BUG]  [BUGGY]  parent.removeChild(newExpr);  [CE]  ')'  expected  [FE]          AssertionFailedError    [CONTEXT]    AND_PRECEDENCE))  {  return  n;  }  n.removeChild(cond);  Node  and  =  new  Node(Token.AND,  cond,  expr.removeFirstChild())  .copyInformationFrom(n);  Node  newExpr  =  NodeUtil.newExpr(and);  parent.replaceChild(n,  newExpr);    [BUGGY]  parent.removeChild(newExpr);  [BUGGY]      return  newExpr;  }  return  n;  }      [CLASS]  PeepholeSubstituteAlternateSyntax  1  2  3  FoldArrayAction  [METHOD]  tryMinimizeIf  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Pattern  REGEXP_FLAGS_RE  FoldArrayAction  NOT_SAFE_TO_FOLD  SAFE_TO_FOLD_WITHOUT_ARGS  SAFE_TO_FOLD_WITH_ARGS  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  ImmutableSet  STANDARD_OBJECT_CONSTRUCTORS  DiagnosticType  INVALID_REGULAR_EXPRESSION_FLAGS  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  Predicate  DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.5773502691896258	314	314	1	replace	parent.removeChild(newExpr);	  parent.removeChild(n);    	non-compiled	[CE]  ')'  expected	8	None	replace
14	[BUG]  [BUGGY]  parent.replaceChild(n,  newExpr,  expr);  [CE]  ')'  expected  [FE]        AssertionFailedError    [CONTEXT]    AND_PRECEDENCE))  {  return  n;  }  n.removeChild(cond);  Node  and  =  new  Node(Token.AND,  cond,  expr.removeFirstChild())  .copyInformationFrom(n);  Node  newExpr  =  NodeUtil.newExpr(and);  parent.replaceChild(n,  newExpr);    [BUGGY]  parent.replaceChild(n,  newExpr,  expr);  [BUGGY]      return  newExpr;  }  return  n;  }      [CLASS]  PeepholeSubstituteAlternateSyntax  1  2  3  FoldArrayAction  [METHOD]  tryMinimizeIf  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Pattern  REGEXP_FLAGS_RE  FoldArrayAction  NOT_SAFE_TO_FOLD  SAFE_TO_FOLD_WITHOUT_ARGS  SAFE_TO_FOLD_WITH_ARGS  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  ImmutableSet  STANDARD_OBJECT_CONSTRUCTORS  DiagnosticType  INVALID_REGULAR_EXPRESSION_FLAGS  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  Predicate  DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.5773502691896258	314	314	1	replace	parent.replaceChild(n,  newExpr,  expr);	  parent.replaceChild(n,    newExpr);    	non-compiled	[CE]  ')'  expected	1	None	replace
15	[BUG]  [BUGGY]  newExpr.removeChild(parent);  [CE]  ')'  expected  [FE]          AssertionFailedError    [CONTEXT]    AND_PRECEDENCE))  {  return  n;  }  n.removeChild(cond);  Node  and  =  new  Node(Token.AND,  cond,  expr.removeFirstChild())  .copyInformationFrom(n);  Node  newExpr  =  NodeUtil.newExpr(and);  parent.replaceChild(n,  newExpr);    [BUGGY]  newExpr.removeChild(parent);  [BUGGY]      return  newExpr;  }  return  n;  }      [CLASS]  PeepholeSubstituteAlternateSyntax  1  2  3  FoldArrayAction  [METHOD]  tryMinimizeIf  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Pattern  REGEXP_FLAGS_RE  FoldArrayAction  NOT_SAFE_TO_FOLD  SAFE_TO_FOLD_WITHOUT_ARGS  SAFE_TO_FOLD_WITH_ARGS  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  ImmutableSet  STANDARD_OBJECT_CONSTRUCTORS  DiagnosticType  INVALID_REGULAR_EXPRESSION_FLAGS  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  Predicate  DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.5773502691896258	314	314	1	replace	newExpr.removeChild(parent);	  parent.replaceChild(n,    newExpr);    	non-compiled	[CE]  ')'  expected	1	None	replace
16	[BUG]  [BUGGY]  parent.replaceChild(n,  newExpr  -  1);  [CE]  ')'  expected  [FE]            AssertionFailedError    [CONTEXT]    AND_PRECEDENCE))  {  return  n;  }  n.removeChild(cond);  Node  and  =  new  Node(Token.AND,  cond,  expr.removeFirstChild())  .copyInformationFrom(n);  Node  newExpr  =  NodeUtil.newExpr(and);  parent.replaceChild(n,  newExpr);    [BUGGY]  parent.replaceChild(n,  newExpr  -  1);  [BUGGY]      return  newExpr;  }  return  n;  }      [CLASS]  PeepholeSubstituteAlternateSyntax  1  2  3  FoldArrayAction  [METHOD]  tryMinimizeIf  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Pattern  REGEXP_FLAGS_RE  FoldArrayAction  NOT_SAFE_TO_FOLD  SAFE_TO_FOLD_WITHOUT_ARGS  SAFE_TO_FOLD_WITH_ARGS  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  ImmutableSet  STANDARD_OBJECT_CONSTRUCTORS  DiagnosticType  INVALID_REGULAR_EXPRESSION_FLAGS  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  Predicate  DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.5773502691896258	314	314	1	replace	parent.replaceChild(n,  newExpr  -  1);	  parent.replaceChild(n,    newExpr);    	non-compiled	[CE]  ')'  expected	1	None	replace
17	[BUG]  [BUGGY]  n.replaceChild(n,  newExpr);  [CE]  ')'  expected  [FE]            AssertionFailedError    [CONTEXT]    AND_PRECEDENCE))  {  return  n;  }  n.removeChild(cond);  Node  and  =  new  Node(Token.AND,  cond,  expr.removeFirstChild())  .copyInformationFrom(n);  Node  newExpr  =  NodeUtil.newExpr(and);  parent.replaceChild(n,  newExpr);    [BUGGY]  n.replaceChild(n,  newExpr);  [BUGGY]      return  newExpr;  }  return  n;  }      [CLASS]  PeepholeSubstituteAlternateSyntax  1  2  3  FoldArrayAction  [METHOD]  tryMinimizeIf  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Pattern  REGEXP_FLAGS_RE  FoldArrayAction  NOT_SAFE_TO_FOLD  SAFE_TO_FOLD_WITHOUT_ARGS  SAFE_TO_FOLD_WITH_ARGS  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  ImmutableSet  STANDARD_OBJECT_CONSTRUCTORS  DiagnosticType  INVALID_REGULAR_EXPRESSION_FLAGS  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  Predicate  DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.5773502691896258	314	314	1	replace	n.replaceChild(n,  newExpr);	  n.removeChild(n);    	non-compiled	[CE]  ')'  expected	3	None	replace
18	[BUG]  [BUGGY]  n.removeChild(old);  [CE]  ')'  expected  [FE]              AssertionFailedError    [CONTEXT]    AND_PRECEDENCE))  {  return  n;  }  n.removeChild(cond);  Node  and  =  new  Node(Token.AND,  cond,  expr.removeFirstChild())  .copyInformationFrom(n);  Node  newExpr  =  NodeUtil.newExpr(and);  parent.replaceChild(n,  newExpr);    [BUGGY]  n.removeChild(old);  [BUGGY]      return  newExpr;  }  return  n;  }      [CLASS]  PeepholeSubstituteAlternateSyntax  1  2  3  FoldArrayAction  [METHOD]  tryMinimizeIf  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Pattern  REGEXP_FLAGS_RE  FoldArrayAction  NOT_SAFE_TO_FOLD  SAFE_TO_FOLD_WITHOUT_ARGS  SAFE_TO_FOLD_WITH_ARGS  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  ImmutableSet  STANDARD_OBJECT_CONSTRUCTORS  DiagnosticType  INVALID_REGULAR_EXPRESSION_FLAGS  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  Predicate  DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.5773502691896258	314	314	1	replace	n.removeChild(old);	  n.removeChild(n);    	non-compiled	[CE]  ')'  expected	3	None	replace
19	[BUG]  [BUGGY]  n.removeChild(assign);  [CE]  ')'  expected  [FE]                AssertionFailedError    [CONTEXT]    AND_PRECEDENCE))  {  return  n;  }  n.removeChild(cond);  Node  and  =  new  Node(Token.AND,  cond,  expr.removeFirstChild())  .copyInformationFrom(n);  Node  newExpr  =  NodeUtil.newExpr(and);  parent.replaceChild(n,  newExpr);    [BUGGY]  n.removeChild(assign);  [BUGGY]      return  newExpr;  }  return  n;  }      [CLASS]  PeepholeSubstituteAlternateSyntax  1  2  3  FoldArrayAction  [METHOD]  tryMinimizeIf  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Pattern  REGEXP_FLAGS_RE  FoldArrayAction  NOT_SAFE_TO_FOLD  SAFE_TO_FOLD_WITHOUT_ARGS  SAFE_TO_FOLD_WITH_ARGS  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  ImmutableSet  STANDARD_OBJECT_CONSTRUCTORS  DiagnosticType  INVALID_REGULAR_EXPRESSION_FLAGS  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  Predicate  DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.5773502691896258	314	314	1	replace	n.removeChild(assign);	  n.removeChild(n);    	non-compiled	[CE]  ')'  expected	3	None	replace
20	[BUG]  [BUGGY]  n.addChildToFront(newExpr);  [CE]  ')'  expected  [FE]        AssertionFailedError    [CONTEXT]    AND_PRECEDENCE))  {  return  n;  }  n.removeChild(cond);  Node  and  =  new  Node(Token.AND,  cond,  expr.removeFirstChild())  .copyInformationFrom(n);  Node  newExpr  =  NodeUtil.newExpr(and);  parent.replaceChild(n,  newExpr);    [BUGGY]  n.addChildToFront(newExpr);  [BUGGY]      return  newExpr;  }  return  n;  }      [CLASS]  PeepholeSubstituteAlternateSyntax  1  2  3  FoldArrayAction  [METHOD]  tryMinimizeIf  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Pattern  REGEXP_FLAGS_RE  FoldArrayAction  NOT_SAFE_TO_FOLD  SAFE_TO_FOLD_WITHOUT_ARGS  SAFE_TO_FOLD_WITH_ARGS  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  ImmutableSet  STANDARD_OBJECT_CONSTRUCTORS  DiagnosticType  INVALID_REGULAR_EXPRESSION_FLAGS  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  Predicate  DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.5773502691896258	314	314	1	replace	n.addChildToFront(newExpr);	  n.removeChild(expr);    	non-compiled	[CE]  ')'  expected	6	None	replace
21	[BUG]  [BUGGY]  parent.replaceChild(n,  expr);  [CE]  ')'  expected  [FE]        AssertionFailedError    [CONTEXT]    AND_PRECEDENCE))  {  return  n;  }  n.removeChild(cond);  Node  and  =  new  Node(Token.AND,  cond,  expr.removeFirstChild())  .copyInformationFrom(n);  Node  newExpr  =  NodeUtil.newExpr(and);  parent.replaceChild(n,  newExpr);    [BUGGY]  parent.replaceChild(n,  expr);  [BUGGY]      return  newExpr;  }  return  n;  }      [CLASS]  PeepholeSubstituteAlternateSyntax  1  2  3  FoldArrayAction  [METHOD]  tryMinimizeIf  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Pattern  REGEXP_FLAGS_RE  FoldArrayAction  NOT_SAFE_TO_FOLD  SAFE_TO_FOLD_WITHOUT_ARGS  SAFE_TO_FOLD_WITH_ARGS  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  ImmutableSet  STANDARD_OBJECT_CONSTRUCTORS  DiagnosticType  INVALID_REGULAR_EXPRESSION_FLAGS  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  Predicate  DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.5773502691896258	314	314	1	replace	parent.replaceChild(n,  expr);	  parent.replaceChild(n,    newExpr);    	non-compiled	[CE]  ')'  expected	1	None	replace
22	[BUG]  [BUGGY]  recalculateLocalVars();  [CE]  ')'  expected  [FE]          AssertionFailedError    [CONTEXT]    AND_PRECEDENCE))  {  return  n;  }  n.removeChild(cond);  Node  and  =  new  Node(Token.AND,  cond,  expr.removeFirstChild())  .copyInformationFrom(n);  Node  newExpr  =  NodeUtil.newExpr(and);  parent.replaceChild(n,  newExpr);    [BUGGY]  recalculateLocalVars();  [BUGGY]      return  newExpr;  }  return  n;  }      [CLASS]  PeepholeSubstituteAlternateSyntax  1  2  3  FoldArrayAction  [METHOD]  tryMinimizeIf  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Pattern  REGEXP_FLAGS_RE  FoldArrayAction  NOT_SAFE_TO_FOLD  SAFE_TO_FOLD_WITHOUT_ARGS  SAFE_TO_FOLD_WITH_ARGS  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  ImmutableSet  STANDARD_OBJECT_CONSTRUCTORS  DiagnosticType  INVALID_REGULAR_EXPRESSION_FLAGS  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  Predicate  DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.5773502691896258	314	314	1	replace	recalculateLocalVars();	  repaint();    	non-compiled	[CE]  ')'  expected	9	None	replace
23	[BUG]  [BUGGY]  removeChild(expr);  [CE]  ')'  expected  [FE]            AssertionFailedError    [CONTEXT]    AND_PRECEDENCE))  {  return  n;  }  n.removeChild(cond);  Node  and  =  new  Node(Token.AND,  cond,  expr.removeFirstChild())  .copyInformationFrom(n);  Node  newExpr  =  NodeUtil.newExpr(and);  parent.replaceChild(n,  newExpr);    [BUGGY]  removeChild(expr);  [BUGGY]      return  newExpr;  }  return  n;  }      [CLASS]  PeepholeSubstituteAlternateSyntax  1  2  3  FoldArrayAction  [METHOD]  tryMinimizeIf  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Pattern  REGEXP_FLAGS_RE  FoldArrayAction  NOT_SAFE_TO_FOLD  SAFE_TO_FOLD_WITHOUT_ARGS  SAFE_TO_FOLD_WITH_ARGS  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  ImmutableSet  STANDARD_OBJECT_CONSTRUCTORS  DiagnosticType  INVALID_REGULAR_EXPRESSION_FLAGS  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  Predicate  DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.5773502691896258	314	314	1	replace	removeChild(expr);	  repaint();    	non-compiled	[CE]  ')'  expected	9	None	replace
24	[BUG]  [BUGGY]  newExpr.removeChild(expr);  [CE]  ')'  expected  [FE]                AssertionFailedError    [CONTEXT]    AND_PRECEDENCE))  {  return  n;  }  n.removeChild(cond);  Node  and  =  new  Node(Token.AND,  cond,  expr.removeFirstChild())  .copyInformationFrom(n);  Node  newExpr  =  NodeUtil.newExpr(and);  parent.replaceChild(n,  newExpr);    [BUGGY]  newExpr.removeChild(expr);  [BUGGY]      return  newExpr;  }  return  n;  }      [CLASS]  PeepholeSubstituteAlternateSyntax  1  2  3  FoldArrayAction  [METHOD]  tryMinimizeIf  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Pattern  REGEXP_FLAGS_RE  FoldArrayAction  NOT_SAFE_TO_FOLD  SAFE_TO_FOLD_WITHOUT_ARGS  SAFE_TO_FOLD_WITH_ARGS  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  ImmutableSet  STANDARD_OBJECT_CONSTRUCTORS  DiagnosticType  INVALID_REGULAR_EXPRESSION_FLAGS  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  Predicate  DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.5773502691896258	314	314	1	replace	newExpr.removeChild(expr);	      	non-compiled	[CE]  ')'  expected	5	None	replace
25	[BUG]  [BUGGY]  NodeUtil.copyInformationFrom(parent,  n);  [CE]  ')'  expected  [FE]                  AssertionFailedError    [CONTEXT]    AND_PRECEDENCE))  {  return  n;  }  n.removeChild(cond);  Node  and  =  new  Node(Token.AND,  cond,  expr.removeFirstChild())  .copyInformationFrom(n);  Node  newExpr  =  NodeUtil.newExpr(and);  parent.replaceChild(n,  newExpr);    [BUGGY]  NodeUtil.copyInformationFrom(parent,  n);  [BUGGY]      return  newExpr;  }  return  n;  }      [CLASS]  PeepholeSubstituteAlternateSyntax  1  2  3  FoldArrayAction  [METHOD]  tryMinimizeIf  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Pattern  REGEXP_FLAGS_RE  FoldArrayAction  NOT_SAFE_TO_FOLD  SAFE_TO_FOLD_WITHOUT_ARGS  SAFE_TO_FOLD_WITH_ARGS  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  ImmutableSet  STANDARD_OBJECT_CONSTRUCTORS  DiagnosticType  INVALID_REGULAR_EXPRESSION_FLAGS  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  Predicate  DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.5773502691896258	314	314	1	replace	NodeUtil.copyInformationFrom(parent,  n);	      	non-compiled	[CE]  ')'  expected	5	None	replace
26	[BUG]  [BUGGY]  newExpr.removeChild(n);  [CE]  ')'  expected  [FE]                    AssertionFailedError    [CONTEXT]    AND_PRECEDENCE))  {  return  n;  }  n.removeChild(cond);  Node  and  =  new  Node(Token.AND,  cond,  expr.removeFirstChild())  .copyInformationFrom(n);  Node  newExpr  =  NodeUtil.newExpr(and);  parent.replaceChild(n,  newExpr);    [BUGGY]  newExpr.removeChild(n);  [BUGGY]      return  newExpr;  }  return  n;  }      [CLASS]  PeepholeSubstituteAlternateSyntax  1  2  3  FoldArrayAction  [METHOD]  tryMinimizeIf  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Pattern  REGEXP_FLAGS_RE  FoldArrayAction  NOT_SAFE_TO_FOLD  SAFE_TO_FOLD_WITHOUT_ARGS  SAFE_TO_FOLD_WITH_ARGS  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  ImmutableSet  STANDARD_OBJECT_CONSTRUCTORS  DiagnosticType  INVALID_REGULAR_EXPRESSION_FLAGS  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  Predicate  DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.5773502691896258	314	314	1	replace	newExpr.removeChild(n);	      	non-compiled	[CE]  ')'  expected	5	None	replace
27	[BUG]  [BUGGY]  NodeUtil.copyInformationFrom(newExpr);  [CE]  ')'  expected  [FE]                      AssertionFailedError    [CONTEXT]    AND_PRECEDENCE))  {  return  n;  }  n.removeChild(cond);  Node  and  =  new  Node(Token.AND,  cond,  expr.removeFirstChild())  .copyInformationFrom(n);  Node  newExpr  =  NodeUtil.newExpr(and);  parent.replaceChild(n,  newExpr);    [BUGGY]  NodeUtil.copyInformationFrom(newExpr);  [BUGGY]      return  newExpr;  }  return  n;  }      [CLASS]  PeepholeSubstituteAlternateSyntax  1  2  3  FoldArrayAction  [METHOD]  tryMinimizeIf  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Pattern  REGEXP_FLAGS_RE  FoldArrayAction  NOT_SAFE_TO_FOLD  SAFE_TO_FOLD_WITHOUT_ARGS  SAFE_TO_FOLD_WITH_ARGS  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  ImmutableSet  STANDARD_OBJECT_CONSTRUCTORS  DiagnosticType  INVALID_REGULAR_EXPRESSION_FLAGS  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  Predicate  DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.5773502691896258	314	314	1	replace	NodeUtil.copyInformationFrom(newExpr);	      	non-compiled	[CE]  ')'  expected	5	None	replace
28	[BUG]  [BUGGY]  n.replaceChild(cond,  newExpr);  [CE]  ')'  expected  [FE]        AssertionFailedError    [CONTEXT]    AND_PRECEDENCE))  {  return  n;  }  n.removeChild(cond);  Node  and  =  new  Node(Token.AND,  cond,  expr.removeFirstChild())  .copyInformationFrom(n);  Node  newExpr  =  NodeUtil.newExpr(and);  parent.replaceChild(n,  newExpr);    [BUGGY]  n.replaceChild(cond,  newExpr);  [BUGGY]      return  newExpr;  }  return  n;  }      [CLASS]  PeepholeSubstituteAlternateSyntax  1  2  3  FoldArrayAction  [METHOD]  tryMinimizeIf  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Pattern  REGEXP_FLAGS_RE  FoldArrayAction  NOT_SAFE_TO_FOLD  SAFE_TO_FOLD_WITHOUT_ARGS  SAFE_TO_FOLD_WITH_ARGS  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  ImmutableSet  STANDARD_OBJECT_CONSTRUCTORS  DiagnosticType  INVALID_REGULAR_EXPRESSION_FLAGS  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  Predicate  DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.5773502691896258	314	314	1	replace	n.replaceChild(cond,  newExpr);	  n.removeChild(expr);    	non-compiled	[CE]  ')'  expected	6	None	replace
29	[BUG]  [BUGGY]  newExpr.addChildToFront(cond);  [CE]  ')'  expected  [FE]                AssertionFailedError    [CONTEXT]    AND_PRECEDENCE))  {  return  n;  }  n.removeChild(cond);  Node  and  =  new  Node(Token.AND,  cond,  expr.removeFirstChild())  .copyInformationFrom(n);  Node  newExpr  =  NodeUtil.newExpr(and);  parent.replaceChild(n,  newExpr);    [BUGGY]  newExpr.addChildToFront(cond);  [BUGGY]      return  newExpr;  }  return  n;  }      [CLASS]  PeepholeSubstituteAlternateSyntax  1  2  3  FoldArrayAction  [METHOD]  tryMinimizeIf  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Pattern  REGEXP_FLAGS_RE  FoldArrayAction  NOT_SAFE_TO_FOLD  SAFE_TO_FOLD_WITHOUT_ARGS  SAFE_TO_FOLD_WITH_ARGS  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  ImmutableSet  STANDARD_OBJECT_CONSTRUCTORS  DiagnosticType  INVALID_REGULAR_EXPRESSION_FLAGS  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  Predicate  DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.5773502691896258	314	314	1	replace	newExpr.addChildToFront(cond);	      	non-compiled	[CE]  ')'  expected	5	None	replace
30	[BUG]  [BUGGY]  NodeUtil.copyInformationFrom(n);  newExpr.removeChild(cond);  [CE]  ')'  expected  [FE]                  AssertionFailedError    [CONTEXT]    AND_PRECEDENCE))  {  return  n;  }  n.removeChild(cond);  Node  and  =  new  Node(Token.AND,  cond,  expr.removeFirstChild())  .copyInformationFrom(n);  Node  newExpr  =  NodeUtil.newExpr(and);  parent.replaceChild(n,  newExpr);    [BUGGY]  NodeUtil.copyInformationFrom(n);  newExpr.removeChild(cond);  [BUGGY]      return  newExpr;  }  return  n;  }      [CLASS]  PeepholeSubstituteAlternateSyntax  1  2  3  FoldArrayAction  [METHOD]  tryMinimizeIf  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Pattern  REGEXP_FLAGS_RE  FoldArrayAction  NOT_SAFE_TO_FOLD  SAFE_TO_FOLD_WITHOUT_ARGS  SAFE_TO_FOLD_WITH_ARGS  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  ImmutableSet  STANDARD_OBJECT_CONSTRUCTORS  DiagnosticType  INVALID_REGULAR_EXPRESSION_FLAGS  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  Predicate  DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.5773502691896258	314	314	1	replace	NodeUtil.copyInformationFrom(n);  newExpr.removeChild(cond);	      	non-compiled	[CE]  ')'  expected	5	None	replace
31	[BUG]  [BUGGY]  NodeUtil.copyInformationFrom(n,  expr.removeFirstChild());  [CE]  ')'  expected  [FE]                    AssertionFailedError    [CONTEXT]    AND_PRECEDENCE))  {  return  n;  }  n.removeChild(cond);  Node  and  =  new  Node(Token.AND,  cond,  expr.removeFirstChild())  .copyInformationFrom(n);  Node  newExpr  =  NodeUtil.newExpr(and);  parent.replaceChild(n,  newExpr);    [BUGGY]  NodeUtil.copyInformationFrom(n,  expr.removeFirstChild());  [BUGGY]      return  newExpr;  }  return  n;  }      [CLASS]  PeepholeSubstituteAlternateSyntax  1  2  3  FoldArrayAction  [METHOD]  tryMinimizeIf  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Pattern  REGEXP_FLAGS_RE  FoldArrayAction  NOT_SAFE_TO_FOLD  SAFE_TO_FOLD_WITHOUT_ARGS  SAFE_TO_FOLD_WITH_ARGS  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  ImmutableSet  STANDARD_OBJECT_CONSTRUCTORS  DiagnosticType  INVALID_REGULAR_EXPRESSION_FLAGS  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  Predicate  DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.5773502691896258	314	314	1	replace	NodeUtil.copyInformationFrom(n,  expr.removeFirstChild());	      	non-compiled	[CE]  ')'  expected	5	None	replace
32	[BUG]  [BUGGY]  ReflectionProvider  v  =  new  ReflectionProvider(n.getFirstChild());  [CE]  ')'  expected  [FE]          AssertionFailedError    [CONTEXT]    AND_PRECEDENCE))  {  return  n;  }  n.removeChild(cond);  Node  and  =  new  Node(Token.AND,  cond,  expr.removeFirstChild())  .copyInformationFrom(n);  Node  newExpr  =  NodeUtil.newExpr(and);  parent.replaceChild(n,  newExpr);    [BUGGY]  ReflectionProvider  v  =  new  ReflectionProvider(n.getFirstChild());  [BUGGY]      return  newExpr;  }  return  n;  }      [CLASS]  PeepholeSubstituteAlternateSyntax  1  2  3  FoldArrayAction  [METHOD]  tryMinimizeIf  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Pattern  REGEXP_FLAGS_RE  FoldArrayAction  NOT_SAFE_TO_FOLD  SAFE_TO_FOLD_WITHOUT_ARGS  SAFE_TO_FOLD_WITH_ARGS  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  ImmutableSet  STANDARD_OBJECT_CONSTRUCTORS  DiagnosticType  INVALID_REGULAR_EXPRESSION_FLAGS  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  Predicate  DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.5773502691896258	314	314	1	replace	ReflectionProvider  v  =  new  ReflectionProvider(n.getFirstChild());	  repaint();    	non-compiled	[CE]  ')'  expected	9	None	replace
33	[BUG]  [BUGGY]  ReflectionProvider  v  =  new  ReflectionProvider(n,  expr.removeFirstChild());  [CE]  ')'  expected  [FE]            AssertionFailedError    [CONTEXT]    AND_PRECEDENCE))  {  return  n;  }  n.removeChild(cond);  Node  and  =  new  Node(Token.AND,  cond,  expr.removeFirstChild())  .copyInformationFrom(n);  Node  newExpr  =  NodeUtil.newExpr(and);  parent.replaceChild(n,  newExpr);    [BUGGY]  ReflectionProvider  v  =  new  ReflectionProvider(n,  expr.removeFirstChild());  [BUGGY]      return  newExpr;  }  return  n;  }      [CLASS]  PeepholeSubstituteAlternateSyntax  1  2  3  FoldArrayAction  [METHOD]  tryMinimizeIf  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Pattern  REGEXP_FLAGS_RE  FoldArrayAction  NOT_SAFE_TO_FOLD  SAFE_TO_FOLD_WITHOUT_ARGS  SAFE_TO_FOLD_WITH_ARGS  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  ImmutableSet  STANDARD_OBJECT_CONSTRUCTORS  DiagnosticType  INVALID_REGULAR_EXPRESSION_FLAGS  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  Predicate  DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.5773502691896258	314	314	1	replace	ReflectionProvider  v  =  new  ReflectionProvider(n,  expr.removeFirstChild());	  repaint();    	non-compiled	[CE]  ')'  expected	9	None	replace
34	[BUG]  [BUGGY]  ReflectionProvider  provider  =  new  ReflectionProvider(n.getFirstChild(),  expr);  [CE]  ')'  expected  [FE]              AssertionFailedError    [CONTEXT]    AND_PRECEDENCE))  {  return  n;  }  n.removeChild(cond);  Node  and  =  new  Node(Token.AND,  cond,  expr.removeFirstChild())  .copyInformationFrom(n);  Node  newExpr  =  NodeUtil.newExpr(and);  parent.replaceChild(n,  newExpr);    [BUGGY]  ReflectionProvider  provider  =  new  ReflectionProvider(n.getFirstChild(),  expr);  [BUGGY]      return  newExpr;  }  return  n;  }      [CLASS]  PeepholeSubstituteAlternateSyntax  1  2  3  FoldArrayAction  [METHOD]  tryMinimizeIf  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Pattern  REGEXP_FLAGS_RE  FoldArrayAction  NOT_SAFE_TO_FOLD  SAFE_TO_FOLD_WITHOUT_ARGS  SAFE_TO_FOLD_WITH_ARGS  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  ImmutableSet  STANDARD_OBJECT_CONSTRUCTORS  DiagnosticType  INVALID_REGULAR_EXPRESSION_FLAGS  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  Predicate  DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.5773502691896258	314	314	1	replace	ReflectionProvider  provider  =  new  ReflectionProvider(n.getFirstChild(),  expr);	  repaint();    	non-compiled	[CE]  ')'  expected	9	None	replace
35	[BUG]  [BUGGY]  ReflectionProvider  provider  =  new  ReflectionProvider(n.getFirstChild(),  cond);  [CE]  ')'  expected  [FE]                AssertionFailedError    [CONTEXT]    AND_PRECEDENCE))  {  return  n;  }  n.removeChild(cond);  Node  and  =  new  Node(Token.AND,  cond,  expr.removeFirstChild())  .copyInformationFrom(n);  Node  newExpr  =  NodeUtil.newExpr(and);  parent.replaceChild(n,  newExpr);    [BUGGY]  ReflectionProvider  provider  =  new  ReflectionProvider(n.getFirstChild(),  cond);  [BUGGY]      return  newExpr;  }  return  n;  }      [CLASS]  PeepholeSubstituteAlternateSyntax  1  2  3  FoldArrayAction  [METHOD]  tryMinimizeIf  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Pattern  REGEXP_FLAGS_RE  FoldArrayAction  NOT_SAFE_TO_FOLD  SAFE_TO_FOLD_WITHOUT_ARGS  SAFE_TO_FOLD_WITH_ARGS  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  ImmutableSet  STANDARD_OBJECT_CONSTRUCTORS  DiagnosticType  INVALID_REGULAR_EXPRESSION_FLAGS  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  Predicate  DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.5773502691896258	314	314	1	replace	ReflectionProvider  provider  =  new  ReflectionProvider(n.getFirstChild(),  cond);	  repaint();    	non-compiled	[CE]  ')'  expected	9	None	replace
36	[BUG]  [BUGGY]  ReflectionProvider  v  =  new  ReflectionProvider(n.getLastChild());  [CE]  ')'  expected  [FE]                  AssertionFailedError    [CONTEXT]    AND_PRECEDENCE))  {  return  n;  }  n.removeChild(cond);  Node  and  =  new  Node(Token.AND,  cond,  expr.removeFirstChild())  .copyInformationFrom(n);  Node  newExpr  =  NodeUtil.newExpr(and);  parent.replaceChild(n,  newExpr);    [BUGGY]  ReflectionProvider  v  =  new  ReflectionProvider(n.getLastChild());  [BUGGY]      return  newExpr;  }  return  n;  }      [CLASS]  PeepholeSubstituteAlternateSyntax  1  2  3  FoldArrayAction  [METHOD]  tryMinimizeIf  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Pattern  REGEXP_FLAGS_RE  FoldArrayAction  NOT_SAFE_TO_FOLD  SAFE_TO_FOLD_WITHOUT_ARGS  SAFE_TO_FOLD_WITH_ARGS  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  ImmutableSet  STANDARD_OBJECT_CONSTRUCTORS  DiagnosticType  INVALID_REGULAR_EXPRESSION_FLAGS  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  Predicate  DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.5773502691896258	314	314	1	replace	ReflectionProvider  v  =  new  ReflectionProvider(n.getLastChild());	  repaint();    	non-compiled	[CE]  ')'  expected	9	None	replace
37	[BUG]  [BUGGY]  ReflectionProvider  provider  =  new  ReflectionProvider(n.getFirstChild());  [CE]  ')'  expected  [FE]                    AssertionFailedError    [CONTEXT]    AND_PRECEDENCE))  {  return  n;  }  n.removeChild(cond);  Node  and  =  new  Node(Token.AND,  cond,  expr.removeFirstChild())  .copyInformationFrom(n);  Node  newExpr  =  NodeUtil.newExpr(and);  parent.replaceChild(n,  newExpr);    [BUGGY]  ReflectionProvider  provider  =  new  ReflectionProvider(n.getFirstChild());  [BUGGY]      return  newExpr;  }  return  n;  }      [CLASS]  PeepholeSubstituteAlternateSyntax  1  2  3  FoldArrayAction  [METHOD]  tryMinimizeIf  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Pattern  REGEXP_FLAGS_RE  FoldArrayAction  NOT_SAFE_TO_FOLD  SAFE_TO_FOLD_WITHOUT_ARGS  SAFE_TO_FOLD_WITH_ARGS  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  ImmutableSet  STANDARD_OBJECT_CONSTRUCTORS  DiagnosticType  INVALID_REGULAR_EXPRESSION_FLAGS  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  Predicate  DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.5773502691896258	314	314	1	replace	ReflectionProvider  provider  =  new  ReflectionProvider(n.getFirstChild());	  repaint();    	non-compiled	[CE]  ')'  expected	9	None	replace
