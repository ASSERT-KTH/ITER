bugid	buggy	buggy_class	suspiciousness	buggy_line	endbuggycode	failing_test_number	action	patch
1	[BUG] [BUGGY] return n; [FE] AssertionFailedError [CONTEXT] private Node tryMinimizeIf(Node n) { Node parent = n.getParent(); Node cond = n.getFirstChild();    if (NodeUtil.isLiteralValue(cond, true)) { [BUGGY] return n; [BUGGY] } Node thenBranch = cond.getNext(); Node elseBranch = thenBranch.getNext(); if (elseBranch == null) { if (isFoldableExpressBlock(thenBranch)) { Node expr = getBlockExpression(thenBranch); if (isPropertyAssignmentInExpression(expr)) {  [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] tryMinimizeIf [RETURN_TYPE] Node  Node n [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean elseBranchIsExpressionBlock elseBranchIsVar thenBranchIsExpressionBlock thenBranchIsVar ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node and assign assignName cond elseAssign elseBranch elseExpr elseOp expr hookNode lhs maybeName1 maybeName2 n name1 name2 newExpr or parent returnNode thenAssign thenBranch thenExpr thenOp var int AND_PRECEDENCE OR_PRECEDENCE complementOperator Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	1.0	268	268	1	replace	
2	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] private Node tryMinimizeIf(Node n) { Node parent = n.getParent(); Node cond = n.getFirstChild();    if (NodeUtil.isLiteralValue(cond, true)) { [BUGGY] [BUGGY] return n; } Node thenBranch = cond.getNext(); Node elseBranch = thenBranch.getNext(); if (elseBranch == null) { if (isFoldableExpressBlock(thenBranch)) { Node expr = getBlockExpression(thenBranch); if (isPropertyAssignmentInExpression(expr)) {  [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] tryMinimizeIf [RETURN_TYPE] Node  Node n [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean elseBranchIsExpressionBlock elseBranchIsVar thenBranchIsExpressionBlock thenBranchIsVar ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node and assign assignName cond elseAssign elseBranch elseExpr elseOp expr hookNode lhs maybeName1 maybeName2 n name1 name2 newExpr or parent returnNode thenAssign thenBranch thenExpr thenOp var int AND_PRECEDENCE OR_PRECEDENCE complementOperator Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	1.0	268	268	1	add	
3	[BUG] [BUGGY] n.removeChild(cond); [FE] AssertionFailedError [CONTEXT] }  if (isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) || isLowerPrecedenceInExpression(expr.getFirstChild(), AND_PRECEDENCE)) {  return n; } [BUGGY] n.removeChild(cond); [BUGGY] Node and = new Node(Token.AND, cond, expr.removeFirstChild()) .copyInformationFrom(n); Node newExpr = NodeUtil.newExpr(and); parent.replaceChild(n, newExpr); reportCodeChange(); return newExpr; } return n; [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] tryMinimizeIf [RETURN_TYPE] Node  Node n [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean elseBranchIsExpressionBlock elseBranchIsVar thenBranchIsExpressionBlock thenBranchIsVar ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node and assign assignName cond elseAssign elseBranch elseExpr elseOp expr hookNode lhs maybeName1 maybeName2 n name1 name2 newExpr or parent returnNode thenAssign thenBranch thenExpr thenOp var int AND_PRECEDENCE OR_PRECEDENCE complementOperator Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.5773502691896258	309	309	1	replace	
4	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] }  if (isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) || isLowerPrecedenceInExpression(expr.getFirstChild(), AND_PRECEDENCE)) {  return n; } [BUGGY] [BUGGY] n.removeChild(cond); Node and = new Node(Token.AND, cond, expr.removeFirstChild()) .copyInformationFrom(n); Node newExpr = NodeUtil.newExpr(and); parent.replaceChild(n, newExpr); reportCodeChange(); return newExpr; } return n; [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] tryMinimizeIf [RETURN_TYPE] Node  Node n [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean elseBranchIsExpressionBlock elseBranchIsVar thenBranchIsExpressionBlock thenBranchIsVar ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node and assign assignName cond elseAssign elseBranch elseExpr elseOp expr hookNode lhs maybeName1 maybeName2 n name1 name2 newExpr or parent returnNode thenAssign thenBranch thenExpr thenOp var int AND_PRECEDENCE OR_PRECEDENCE complementOperator Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.5773502691896258	309	309	1	add	
5	[BUG] [BUGGY] Node and = new Node(Token.AND, cond, expr.removeFirstChild())  .copyInformationFrom(n); [FE] AssertionFailedError [CONTEXT]  if (isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) || isLowerPrecedenceInExpression(expr.getFirstChild(), AND_PRECEDENCE)) {  return n; } n.removeChild(cond); [BUGGY] Node and = new Node(Token.AND, cond, expr.removeFirstChild())      .copyInformationFrom(n); [BUGGY] .copyInformationFrom(n); Node newExpr = NodeUtil.newExpr(and); parent.replaceChild(n, newExpr); reportCodeChange(); return newExpr; } return n; } [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] tryMinimizeIf [RETURN_TYPE] Node  Node n [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean elseBranchIsExpressionBlock elseBranchIsVar thenBranchIsExpressionBlock thenBranchIsVar ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node and assign assignName cond elseAssign elseBranch elseExpr elseOp expr hookNode lhs maybeName1 maybeName2 n name1 name2 newExpr or parent returnNode thenAssign thenBranch thenExpr thenOp var int AND_PRECEDENCE OR_PRECEDENCE complementOperator Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.5773502691896258	310	311	1	replace	
6	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT]  if (isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) || isLowerPrecedenceInExpression(expr.getFirstChild(), AND_PRECEDENCE)) {  return n; } n.removeChild(cond); [BUGGY] [BUGGY] Node and = new Node(Token.AND, cond, expr.removeFirstChild())      .copyInformationFrom(n); .copyInformationFrom(n); Node newExpr = NodeUtil.newExpr(and); parent.replaceChild(n, newExpr); reportCodeChange(); return newExpr; } return n; } [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] tryMinimizeIf [RETURN_TYPE] Node  Node n [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean elseBranchIsExpressionBlock elseBranchIsVar thenBranchIsExpressionBlock thenBranchIsVar ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node and assign assignName cond elseAssign elseBranch elseExpr elseOp expr hookNode lhs maybeName1 maybeName2 n name1 name2 newExpr or parent returnNode thenAssign thenBranch thenExpr thenOp var int AND_PRECEDENCE OR_PRECEDENCE complementOperator Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.5773502691896258	310	311	1	add	
7	[BUG] [BUGGY] Node newExpr = NodeUtil.newExpr(and); [FE] AssertionFailedError [CONTEXT] if (isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) || isLowerPrecedenceInExpression(expr.getFirstChild(), AND_PRECEDENCE)) {  return n; } n.removeChild(cond); Node and = new Node(Token.AND, cond, expr.removeFirstChild()) .copyInformationFrom(n); [BUGGY] Node newExpr = NodeUtil.newExpr(and); [BUGGY] parent.replaceChild(n, newExpr); reportCodeChange(); return newExpr; } return n; }   [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] tryMinimizeIf [RETURN_TYPE] Node  Node n [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean elseBranchIsExpressionBlock elseBranchIsVar thenBranchIsExpressionBlock thenBranchIsVar ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node and assign assignName cond elseAssign elseBranch elseExpr elseOp expr hookNode lhs maybeName1 maybeName2 n name1 name2 newExpr or parent returnNode thenAssign thenBranch thenExpr thenOp var int AND_PRECEDENCE OR_PRECEDENCE complementOperator Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.5773502691896258	312	312	1	replace	
8	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] if (isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) || isLowerPrecedenceInExpression(expr.getFirstChild(), AND_PRECEDENCE)) {  return n; } n.removeChild(cond); Node and = new Node(Token.AND, cond, expr.removeFirstChild()) .copyInformationFrom(n); [BUGGY] [BUGGY] Node newExpr = NodeUtil.newExpr(and); parent.replaceChild(n, newExpr); reportCodeChange(); return newExpr; } return n; }   [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] tryMinimizeIf [RETURN_TYPE] Node  Node n [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean elseBranchIsExpressionBlock elseBranchIsVar thenBranchIsExpressionBlock thenBranchIsVar ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node and assign assignName cond elseAssign elseBranch elseExpr elseOp expr hookNode lhs maybeName1 maybeName2 n name1 name2 newExpr or parent returnNode thenAssign thenBranch thenExpr thenOp var int AND_PRECEDENCE OR_PRECEDENCE complementOperator Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.5773502691896258	312	312	1	add	
9	[BUG] [BUGGY] parent.replaceChild(n, newExpr); [FE] AssertionFailedError [CONTEXT] isLowerPrecedenceInExpression(expr.getFirstChild(), AND_PRECEDENCE)) {  return n; } n.removeChild(cond); Node and = new Node(Token.AND, cond, expr.removeFirstChild()) .copyInformationFrom(n); Node newExpr = NodeUtil.newExpr(and); [BUGGY] parent.replaceChild(n, newExpr); [BUGGY] reportCodeChange(); return newExpr; } return n; }    [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] tryMinimizeIf [RETURN_TYPE] Node  Node n [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean elseBranchIsExpressionBlock elseBranchIsVar thenBranchIsExpressionBlock thenBranchIsVar ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node and assign assignName cond elseAssign elseBranch elseExpr elseOp expr hookNode lhs maybeName1 maybeName2 n name1 name2 newExpr or parent returnNode thenAssign thenBranch thenExpr thenOp var int AND_PRECEDENCE OR_PRECEDENCE complementOperator Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.5773502691896258	313	313	1	replace	
10	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] isLowerPrecedenceInExpression(expr.getFirstChild(), AND_PRECEDENCE)) {  return n; } n.removeChild(cond); Node and = new Node(Token.AND, cond, expr.removeFirstChild()) .copyInformationFrom(n); Node newExpr = NodeUtil.newExpr(and); [BUGGY] [BUGGY] parent.replaceChild(n, newExpr); reportCodeChange(); return newExpr; } return n; }    [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] tryMinimizeIf [RETURN_TYPE] Node  Node n [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean elseBranchIsExpressionBlock elseBranchIsVar thenBranchIsExpressionBlock thenBranchIsVar ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node and assign assignName cond elseAssign elseBranch elseExpr elseOp expr hookNode lhs maybeName1 maybeName2 n name1 name2 newExpr or parent returnNode thenAssign thenBranch thenExpr thenOp var int AND_PRECEDENCE OR_PRECEDENCE complementOperator Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.5773502691896258	313	313	1	add	
11	[BUG] [BUGGY] reportCodeChange(); [FE] AssertionFailedError [CONTEXT] AND_PRECEDENCE)) {  return n; } n.removeChild(cond); Node and = new Node(Token.AND, cond, expr.removeFirstChild()) .copyInformationFrom(n); Node newExpr = NodeUtil.newExpr(and); parent.replaceChild(n, newExpr); [BUGGY] reportCodeChange(); [BUGGY]  return newExpr; } return n; }     [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] tryMinimizeIf [RETURN_TYPE] Node  Node n [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean elseBranchIsExpressionBlock elseBranchIsVar thenBranchIsExpressionBlock thenBranchIsVar ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node and assign assignName cond elseAssign elseBranch elseExpr elseOp expr hookNode lhs maybeName1 maybeName2 n name1 name2 newExpr or parent returnNode thenAssign thenBranch thenExpr thenOp var int AND_PRECEDENCE OR_PRECEDENCE complementOperator Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.5773502691896258	314	314	1	replace	
12	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] AND_PRECEDENCE)) {  return n; } n.removeChild(cond); Node and = new Node(Token.AND, cond, expr.removeFirstChild()) .copyInformationFrom(n); Node newExpr = NodeUtil.newExpr(and); parent.replaceChild(n, newExpr); [BUGGY] [BUGGY] reportCodeChange(); return newExpr; } return n; }     [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] tryMinimizeIf [RETURN_TYPE] Node  Node n [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean elseBranchIsExpressionBlock elseBranchIsVar thenBranchIsExpressionBlock thenBranchIsVar ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node and assign assignName cond elseAssign elseBranch elseExpr elseOp expr hookNode lhs maybeName1 maybeName2 n name1 name2 newExpr or parent returnNode thenAssign thenBranch thenExpr thenOp var int AND_PRECEDENCE OR_PRECEDENCE complementOperator Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.5773502691896258	314	314	1	add	
13	[BUG] [BUGGY] return newExpr; [FE] AssertionFailedError [CONTEXT] return n; } n.removeChild(cond); Node and = new Node(Token.AND, cond, expr.removeFirstChild()) .copyInformationFrom(n); Node newExpr = NodeUtil.newExpr(and); parent.replaceChild(n, newExpr); reportCodeChange(); [BUGGY] return newExpr; [BUGGY] } return n; }    tryRemoveRepeatedStatements(n);  [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] tryMinimizeIf [RETURN_TYPE] Node  Node n [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean elseBranchIsExpressionBlock elseBranchIsVar thenBranchIsExpressionBlock thenBranchIsVar ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node and assign assignName cond elseAssign elseBranch elseExpr elseOp expr hookNode lhs maybeName1 maybeName2 n name1 name2 newExpr or parent returnNode thenAssign thenBranch thenExpr thenOp var int AND_PRECEDENCE OR_PRECEDENCE complementOperator Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.5773502691896258	316	316	1	replace	
14	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] return n; } n.removeChild(cond); Node and = new Node(Token.AND, cond, expr.removeFirstChild()) .copyInformationFrom(n); Node newExpr = NodeUtil.newExpr(and); parent.replaceChild(n, newExpr); reportCodeChange(); [BUGGY] [BUGGY] return newExpr; } return n; }    tryRemoveRepeatedStatements(n);  [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] tryMinimizeIf [RETURN_TYPE] Node  Node n [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean elseBranchIsExpressionBlock elseBranchIsVar thenBranchIsExpressionBlock thenBranchIsVar ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node and assign assignName cond elseAssign elseBranch elseExpr elseOp expr hookNode lhs maybeName1 maybeName2 n name1 name2 newExpr or parent returnNode thenAssign thenBranch thenExpr thenOp var int AND_PRECEDENCE OR_PRECEDENCE complementOperator Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.5773502691896258	316	316	1	add	
15	[BUG] [BUGGY] Node expr = getBlockExpression(thenBranch); [FE] AssertionFailedError [CONTEXT]  if (NodeUtil.isLiteralValue(cond, true)) { return n; } Node thenBranch = cond.getNext(); Node elseBranch = thenBranch.getNext(); if (elseBranch == null) { if (isFoldableExpressBlock(thenBranch)) { [BUGGY] Node expr = getBlockExpression(thenBranch); [BUGGY] if (isPropertyAssignmentInExpression(expr)) {   return n; } if (cond.getType() == Token.NOT) {  if (isLowerPrecedenceInExpression(cond, OR_PRECEDENCE) && isLowerPrecedenceInExpression(expr.getFirstChild(), [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] tryMinimizeIf [RETURN_TYPE] Node  Node n [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean elseBranchIsExpressionBlock elseBranchIsVar thenBranchIsExpressionBlock thenBranchIsVar ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node and assign assignName cond elseAssign elseBranch elseExpr elseOp expr hookNode lhs maybeName1 maybeName2 n name1 name2 newExpr or parent returnNode thenAssign thenBranch thenExpr thenOp var int AND_PRECEDENCE OR_PRECEDENCE complementOperator Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.4082482904638631	276	276	1	replace	
16	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT]  if (NodeUtil.isLiteralValue(cond, true)) { return n; } Node thenBranch = cond.getNext(); Node elseBranch = thenBranch.getNext(); if (elseBranch == null) { if (isFoldableExpressBlock(thenBranch)) { [BUGGY] [BUGGY] Node expr = getBlockExpression(thenBranch); if (isPropertyAssignmentInExpression(expr)) {   return n; } if (cond.getType() == Token.NOT) {  if (isLowerPrecedenceInExpression(cond, OR_PRECEDENCE) && isLowerPrecedenceInExpression(expr.getFirstChild(), [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] tryMinimizeIf [RETURN_TYPE] Node  Node n [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean elseBranchIsExpressionBlock elseBranchIsVar thenBranchIsExpressionBlock thenBranchIsVar ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node and assign assignName cond elseAssign elseBranch elseExpr elseOp expr hookNode lhs maybeName1 maybeName2 n name1 name2 newExpr or parent returnNode thenAssign thenBranch thenExpr thenOp var int AND_PRECEDENCE OR_PRECEDENCE complementOperator Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.4082482904638631	276	276	1	add	
17	[BUG] [BUGGY] if (isPropertyAssignmentInExpression(expr)) { [FE] AssertionFailedError [CONTEXT] if (NodeUtil.isLiteralValue(cond, true)) { return n; } Node thenBranch = cond.getNext(); Node elseBranch = thenBranch.getNext(); if (elseBranch == null) { if (isFoldableExpressBlock(thenBranch)) { Node expr = getBlockExpression(thenBranch); [BUGGY] if (isPropertyAssignmentInExpression(expr)) { [BUGGY]   return n; } if (cond.getType() == Token.NOT) {  if (isLowerPrecedenceInExpression(cond, OR_PRECEDENCE) && isLowerPrecedenceInExpression(expr.getFirstChild(), OR_PRECEDENCE)) { [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] tryMinimizeIf [RETURN_TYPE] Node  Node n [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean elseBranchIsExpressionBlock elseBranchIsVar thenBranchIsExpressionBlock thenBranchIsVar ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node and assign assignName cond elseAssign elseBranch elseExpr elseOp expr hookNode lhs maybeName1 maybeName2 n name1 name2 newExpr or parent returnNode thenAssign thenBranch thenExpr thenOp var int AND_PRECEDENCE OR_PRECEDENCE complementOperator Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.4082482904638631	277	277	1	replace	
18	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] if (NodeUtil.isLiteralValue(cond, true)) { return n; } Node thenBranch = cond.getNext(); Node elseBranch = thenBranch.getNext(); if (elseBranch == null) { if (isFoldableExpressBlock(thenBranch)) { Node expr = getBlockExpression(thenBranch); [BUGGY] [BUGGY] if (isPropertyAssignmentInExpression(expr)) {   return n; } if (cond.getType() == Token.NOT) {  if (isLowerPrecedenceInExpression(cond, OR_PRECEDENCE) && isLowerPrecedenceInExpression(expr.getFirstChild(), OR_PRECEDENCE)) { [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] tryMinimizeIf [RETURN_TYPE] Node  Node n [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean elseBranchIsExpressionBlock elseBranchIsVar thenBranchIsExpressionBlock thenBranchIsVar ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node and assign assignName cond elseAssign elseBranch elseExpr elseOp expr hookNode lhs maybeName1 maybeName2 n name1 name2 newExpr or parent returnNode thenAssign thenBranch thenExpr thenOp var int AND_PRECEDENCE OR_PRECEDENCE complementOperator Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.4082482904638631	277	277	1	add	
19	[BUG] [BUGGY] if (cond.getType() == Token.NOT) { [FE] AssertionFailedError [CONTEXT] if (elseBranch == null) { if (isFoldableExpressBlock(thenBranch)) { Node expr = getBlockExpression(thenBranch); if (isPropertyAssignmentInExpression(expr)) {   return n; } [BUGGY] if (cond.getType() == Token.NOT) { [BUGGY]  if (isLowerPrecedenceInExpression(cond, OR_PRECEDENCE) && isLowerPrecedenceInExpression(expr.getFirstChild(), OR_PRECEDENCE)) {  return n; } Node or = new Node(Token.OR, cond.removeFirstChild(), expr.removeFirstChild()).copyInformationFrom(n); [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] tryMinimizeIf [RETURN_TYPE] Node  Node n [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean elseBranchIsExpressionBlock elseBranchIsVar thenBranchIsExpressionBlock thenBranchIsVar ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node and assign assignName cond elseAssign elseBranch elseExpr elseOp expr hookNode lhs maybeName1 maybeName2 n name1 name2 newExpr or parent returnNode thenAssign thenBranch thenExpr thenOp var int AND_PRECEDENCE OR_PRECEDENCE complementOperator Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.4082482904638631	283	283	1	replace	
20	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] if (elseBranch == null) { if (isFoldableExpressBlock(thenBranch)) { Node expr = getBlockExpression(thenBranch); if (isPropertyAssignmentInExpression(expr)) {   return n; } [BUGGY] [BUGGY] if (cond.getType() == Token.NOT) {  if (isLowerPrecedenceInExpression(cond, OR_PRECEDENCE) && isLowerPrecedenceInExpression(expr.getFirstChild(), OR_PRECEDENCE)) {  return n; } Node or = new Node(Token.OR, cond.removeFirstChild(), expr.removeFirstChild()).copyInformationFrom(n); [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] tryMinimizeIf [RETURN_TYPE] Node  Node n [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean elseBranchIsExpressionBlock elseBranchIsVar thenBranchIsExpressionBlock thenBranchIsVar ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node and assign assignName cond elseAssign elseBranch elseExpr elseOp expr hookNode lhs maybeName1 maybeName2 n name1 name2 newExpr or parent returnNode thenAssign thenBranch thenExpr thenOp var int AND_PRECEDENCE OR_PRECEDENCE complementOperator Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.4082482904638631	283	283	1	add	
21	[BUG] [BUGGY] if (isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) || isLowerPrecedenceInExpression(expr.getFirstChild(),  AND_PRECEDENCE)) { [FE] AssertionFailedError [CONTEXT] Node or = new Node(Token.OR, cond.removeFirstChild(), expr.removeFirstChild()).copyInformationFrom(n); Node newExpr = NodeUtil.newExpr(or); parent.replaceChild(n, newExpr); reportCodeChange(); return newExpr; }  [BUGGY] if (isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) ||   isLowerPrecedenceInExpression(expr.getFirstChild(),        AND_PRECEDENCE)) { [BUGGY] isLowerPrecedenceInExpression(expr.getFirstChild(), AND_PRECEDENCE)) {  return n; } n.removeChild(cond); Node and = new Node(Token.AND, cond, expr.removeFirstChild()) .copyInformationFrom(n); Node newExpr = NodeUtil.newExpr(and); [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] tryMinimizeIf [RETURN_TYPE] Node  Node n [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean elseBranchIsExpressionBlock elseBranchIsVar thenBranchIsExpressionBlock thenBranchIsVar ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node and assign assignName cond elseAssign elseBranch elseExpr elseOp expr hookNode lhs maybeName1 maybeName2 n name1 name2 newExpr or parent returnNode thenAssign thenBranch thenExpr thenOp var int AND_PRECEDENCE OR_PRECEDENCE complementOperator Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.4082482904638631	302	304	1	replace	
22	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] Node or = new Node(Token.OR, cond.removeFirstChild(), expr.removeFirstChild()).copyInformationFrom(n); Node newExpr = NodeUtil.newExpr(or); parent.replaceChild(n, newExpr); reportCodeChange(); return newExpr; }  [BUGGY] [BUGGY] if (isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) ||   isLowerPrecedenceInExpression(expr.getFirstChild(),        AND_PRECEDENCE)) { isLowerPrecedenceInExpression(expr.getFirstChild(), AND_PRECEDENCE)) {  return n; } n.removeChild(cond); Node and = new Node(Token.AND, cond, expr.removeFirstChild()) .copyInformationFrom(n); Node newExpr = NodeUtil.newExpr(and); [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] tryMinimizeIf [RETURN_TYPE] Node  Node n [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean elseBranchIsExpressionBlock elseBranchIsVar thenBranchIsExpressionBlock thenBranchIsVar ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node and assign assignName cond elseAssign elseBranch elseExpr elseOp expr hookNode lhs maybeName1 maybeName2 n name1 name2 newExpr or parent returnNode thenAssign thenBranch thenExpr thenOp var int AND_PRECEDENCE OR_PRECEDENCE complementOperator Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.4082482904638631	302	304	1	add	
23	[BUG] [BUGGY] Predicate<Node> isLowerPrecedencePredicate = new Predicate<Node>() { [FE] AssertionFailedError [CONTEXT] private boolean isLowerPrecedenceInExpression(Node n, final int precedence) { [BUGGY] Predicate<Node> isLowerPrecedencePredicate = new Predicate<Node>() { [BUGGY] @Override public boolean apply(Node input) { return NodeUtil.precedence(input.getType()) < precedence; } }; return NodeUtil.has(n, isLowerPrecedencePredicate, DONT_TRAVERSE_FUNCTIONS_PREDICATE); } [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] isLowerPrecedenceInExpression [RETURN_TYPE] boolean  Node n final int precedence [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node input n int AND_PRECEDENCE OR_PRECEDENCE complementOperator precedence Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE isLowerPrecedencePredicate  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.4082482904638631	630	630	1	replace	
24	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] private boolean isLowerPrecedenceInExpression(Node n, final int precedence) { [BUGGY] [BUGGY] Predicate<Node> isLowerPrecedencePredicate = new Predicate<Node>() { @Override public boolean apply(Node input) { return NodeUtil.precedence(input.getType()) < precedence; } }; return NodeUtil.has(n, isLowerPrecedencePredicate, DONT_TRAVERSE_FUNCTIONS_PREDICATE); } [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] isLowerPrecedenceInExpression [RETURN_TYPE] boolean  Node n final int precedence [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node input n int AND_PRECEDENCE OR_PRECEDENCE complementOperator precedence Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE isLowerPrecedencePredicate  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.4082482904638631	630	630	1	add	
25	[BUG] [BUGGY] return NodeUtil.has(n, isLowerPrecedencePredicate, DONT_TRAVERSE_FUNCTIONS_PREDICATE); [FE] AssertionFailedError [CONTEXT] private boolean isLowerPrecedenceInExpression(Node n, final int precedence) { Predicate<Node> isLowerPrecedencePredicate = new Predicate<Node>() { @Override public boolean apply(Node input) { return NodeUtil.precedence(input.getType()) < precedence; } }; [BUGGY] return NodeUtil.has(n, isLowerPrecedencePredicate,  DONT_TRAVERSE_FUNCTIONS_PREDICATE); [BUGGY] DONT_TRAVERSE_FUNCTIONS_PREDICATE); } [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] isLowerPrecedenceInExpression [RETURN_TYPE] boolean  Node n final int precedence [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node input n int AND_PRECEDENCE OR_PRECEDENCE complementOperator precedence Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE isLowerPrecedencePredicate  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.4082482904638631	637	638	1	replace	
26	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] private boolean isLowerPrecedenceInExpression(Node n, final int precedence) { Predicate<Node> isLowerPrecedencePredicate = new Predicate<Node>() { @Override public boolean apply(Node input) { return NodeUtil.precedence(input.getType()) < precedence; } }; [BUGGY] [BUGGY] return NodeUtil.has(n, isLowerPrecedencePredicate,  DONT_TRAVERSE_FUNCTIONS_PREDICATE); DONT_TRAVERSE_FUNCTIONS_PREDICATE); } [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] isLowerPrecedenceInExpression [RETURN_TYPE] boolean  Node n final int precedence [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node input n int AND_PRECEDENCE OR_PRECEDENCE complementOperator precedence Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE isLowerPrecedencePredicate  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.4082482904638631	637	638	1	add	
27	[BUG] [BUGGY] Predicate<Node> isPropertyAssignmentInExpressionPredicate = new Predicate<Node>() { [FE] AssertionFailedError [CONTEXT] private boolean isPropertyAssignmentInExpression(Node n) { [BUGGY] Predicate<Node> isPropertyAssignmentInExpressionPredicate =  new Predicate<Node>() { [BUGGY] new Predicate<Node>() { @Override public boolean apply(Node input) { return (input.getType() == Token.GETPROP && input.getParent().getType() == Token.ASSIGN); } }; return NodeUtil.has(n, isPropertyAssignmentInExpressionPredicate, DONT_TRAVERSE_FUNCTIONS_PREDICATE); [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] isPropertyAssignmentInExpression [RETURN_TYPE] boolean  Node n [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node input n int AND_PRECEDENCE OR_PRECEDENCE complementOperator precedence Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE isLowerPrecedencePredicate isPropertyAssignmentInExpressionPredicate  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.4082482904638631	645	646	1	replace	
28	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] private boolean isPropertyAssignmentInExpression(Node n) { [BUGGY] [BUGGY] Predicate<Node> isPropertyAssignmentInExpressionPredicate =  new Predicate<Node>() { new Predicate<Node>() { @Override public boolean apply(Node input) { return (input.getType() == Token.GETPROP && input.getParent().getType() == Token.ASSIGN); } }; return NodeUtil.has(n, isPropertyAssignmentInExpressionPredicate, DONT_TRAVERSE_FUNCTIONS_PREDICATE); [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] isPropertyAssignmentInExpression [RETURN_TYPE] boolean  Node n [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node input n int AND_PRECEDENCE OR_PRECEDENCE complementOperator precedence Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE isLowerPrecedencePredicate isPropertyAssignmentInExpressionPredicate  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.4082482904638631	645	646	1	add	
29	[BUG] [BUGGY] return NodeUtil.has(n, isPropertyAssignmentInExpressionPredicate, DONT_TRAVERSE_FUNCTIONS_PREDICATE); [FE] AssertionFailedError [CONTEXT] private boolean isPropertyAssignmentInExpression(Node n) { Predicate<Node> isPropertyAssignmentInExpressionPredicate = new Predicate<Node>() { @Override public boolean apply(Node input) { return (input.getType() == Token.GETPROP && input.getParent().getType() == Token.ASSIGN); } }; [BUGGY] return NodeUtil.has(n, isPropertyAssignmentInExpressionPredicate,  DONT_TRAVERSE_FUNCTIONS_PREDICATE); [BUGGY] DONT_TRAVERSE_FUNCTIONS_PREDICATE); } [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] isPropertyAssignmentInExpression [RETURN_TYPE] boolean  Node n [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node input n int AND_PRECEDENCE OR_PRECEDENCE complementOperator precedence Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE isLowerPrecedencePredicate isPropertyAssignmentInExpressionPredicate  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.4082482904638631	654	655	1	replace	
30	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] private boolean isPropertyAssignmentInExpression(Node n) { Predicate<Node> isPropertyAssignmentInExpressionPredicate = new Predicate<Node>() { @Override public boolean apply(Node input) { return (input.getType() == Token.GETPROP && input.getParent().getType() == Token.ASSIGN); } }; [BUGGY] [BUGGY] return NodeUtil.has(n, isPropertyAssignmentInExpressionPredicate,  DONT_TRAVERSE_FUNCTIONS_PREDICATE); DONT_TRAVERSE_FUNCTIONS_PREDICATE); } [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] isPropertyAssignmentInExpression [RETURN_TYPE] boolean  Node n [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node input n int AND_PRECEDENCE OR_PRECEDENCE complementOperator precedence Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE isLowerPrecedencePredicate isPropertyAssignmentInExpressionPredicate  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.4082482904638631	654	655	1	add	
31	[BUG] [BUGGY] parent.replaceChild(n, newNode); [FE] AssertionFailedError [CONTEXT] private Node maybeReplaceChildWithNumber(Node n, Node parent, int num) { Node newNode = Node.newNumber(num); if (!newNode.isEquivalentTo(n)) { [BUGGY] parent.replaceChild(n, newNode); [BUGGY] reportCodeChange(); return newNode; } return n; } [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] maybeReplaceChildWithNumber [RETURN_TYPE] Node  Node n Node parent int num [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node n newNode parent int AND_PRECEDENCE OR_PRECEDENCE complementOperator equivalentResult newOp num precedence type Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE isLowerPrecedencePredicate isPropertyAssignmentInExpressionPredicate  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.4082482904638631	820	820	1	replace	
32	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] private Node maybeReplaceChildWithNumber(Node n, Node parent, int num) { Node newNode = Node.newNumber(num); if (!newNode.isEquivalentTo(n)) { [BUGGY] [BUGGY] parent.replaceChild(n, newNode); reportCodeChange(); return newNode; } return n; } [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] maybeReplaceChildWithNumber [RETURN_TYPE] Node  Node n Node parent int num [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node n newNode parent int AND_PRECEDENCE OR_PRECEDENCE complementOperator equivalentResult newOp num precedence type Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE isLowerPrecedencePredicate isPropertyAssignmentInExpressionPredicate  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.4082482904638631	820	820	1	add	
33	[BUG] [BUGGY] reportCodeChange(); [FE] AssertionFailedError [CONTEXT] private Node maybeReplaceChildWithNumber(Node n, Node parent, int num) { Node newNode = Node.newNumber(num); if (!newNode.isEquivalentTo(n)) { parent.replaceChild(n, newNode); [BUGGY] reportCodeChange(); [BUGGY]  return newNode; } return n; } [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] maybeReplaceChildWithNumber [RETURN_TYPE] Node  Node n Node parent int num [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node n newNode parent int AND_PRECEDENCE OR_PRECEDENCE complementOperator equivalentResult newOp num precedence type Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE isLowerPrecedencePredicate isPropertyAssignmentInExpressionPredicate  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.4082482904638631	821	821	1	replace	
34	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] private Node maybeReplaceChildWithNumber(Node n, Node parent, int num) { Node newNode = Node.newNumber(num); if (!newNode.isEquivalentTo(n)) { parent.replaceChild(n, newNode); [BUGGY] [BUGGY] reportCodeChange(); return newNode; } return n; } [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] maybeReplaceChildWithNumber [RETURN_TYPE] Node  Node n Node parent int num [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node n newNode parent int AND_PRECEDENCE OR_PRECEDENCE complementOperator equivalentResult newOp num precedence type Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE isLowerPrecedencePredicate isPropertyAssignmentInExpressionPredicate  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.4082482904638631	821	821	1	add	
35	[BUG] [BUGGY] return newNode; [FE] AssertionFailedError [CONTEXT] private Node maybeReplaceChildWithNumber(Node n, Node parent, int num) { Node newNode = Node.newNumber(num); if (!newNode.isEquivalentTo(n)) { parent.replaceChild(n, newNode); reportCodeChange(); [BUGGY] return newNode; [BUGGY] } return n; } [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] maybeReplaceChildWithNumber [RETURN_TYPE] Node  Node n Node parent int num [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node n newNode parent int AND_PRECEDENCE OR_PRECEDENCE complementOperator equivalentResult newOp num precedence type Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE isLowerPrecedencePredicate isPropertyAssignmentInExpressionPredicate  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.4082482904638631	823	823	1	replace	
36	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] private Node maybeReplaceChildWithNumber(Node n, Node parent, int num) { Node newNode = Node.newNumber(num); if (!newNode.isEquivalentTo(n)) { parent.replaceChild(n, newNode); reportCodeChange(); [BUGGY] [BUGGY] return newNode; } return n; } [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] maybeReplaceChildWithNumber [RETURN_TYPE] Node  Node n Node parent int num [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node n newNode parent int AND_PRECEDENCE OR_PRECEDENCE complementOperator equivalentResult newOp num precedence type Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE isLowerPrecedencePredicate isPropertyAssignmentInExpressionPredicate  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.4082482904638631	823	823	1	add	
37	[BUG] [BUGGY] return n; [FE] AssertionFailedError [CONTEXT] replacement = right; } if (replacement != null) { n.detachChildren(); parent.replaceChild(n, replacement); reportCodeChange(); return replacement; } } [BUGGY] return n; [BUGGY] } case Token.HOOK: { Node condition = n.getFirstChild(); Node trueNode = n.getFirstChild().getNext(); Node falseNode = n.getLastChild();     [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] tryMinimizeCondition [RETURN_TYPE] Node  Node n [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean result rval ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node condition falseNode first left leftParent n newRoot parent replacement right rightParent trueNode TernaryValue nVal rightVal int AND_PRECEDENCE OR_PRECEDENCE complementOperator equivalentResult newOp precedence type Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE isLowerPrecedencePredicate isPropertyAssignmentInExpressionPredicate  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.3779644730092272	749	749	1	replace	
38	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] replacement = right; } if (replacement != null) { n.detachChildren(); parent.replaceChild(n, replacement); reportCodeChange(); return replacement; } } [BUGGY] [BUGGY] return n; } case Token.HOOK: { Node condition = n.getFirstChild(); Node trueNode = n.getFirstChild().getNext(); Node falseNode = n.getLastChild();     [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] tryMinimizeCondition [RETURN_TYPE] Node  Node n [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean result rval ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node condition falseNode first left leftParent n newRoot parent replacement right rightParent trueNode TernaryValue nVal rightVal int AND_PRECEDENCE OR_PRECEDENCE complementOperator equivalentResult newOp precedence type Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE isLowerPrecedencePredicate isPropertyAssignmentInExpressionPredicate  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.3779644730092272	749	749	1	add	
39	[BUG] [BUGGY] boolean result = nVal.toBoolean(true); [FE] AssertionFailedError [CONTEXT] reportCodeChange(); } return n; } default:  TernaryValue nVal = NodeUtil.getBooleanValue(n); if (nVal != TernaryValue.UNKNOWN) { [BUGGY] boolean result = nVal.toBoolean(true); [BUGGY] int equivalentResult = result ? 1 : 0; return maybeReplaceChildWithNumber(n, parent, equivalentResult); }  return n; } } [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] tryMinimizeCondition [RETURN_TYPE] Node  Node n [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean result rval ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node condition falseNode first left leftParent n newRoot parent replacement right rightParent trueNode TernaryValue nVal rightVal int AND_PRECEDENCE OR_PRECEDENCE complementOperator equivalentResult newOp precedence type Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE isLowerPrecedencePredicate isPropertyAssignmentInExpressionPredicate  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.3779644730092272	802	802	1	replace	
40	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] reportCodeChange(); } return n; } default:  TernaryValue nVal = NodeUtil.getBooleanValue(n); if (nVal != TernaryValue.UNKNOWN) { [BUGGY] [BUGGY] boolean result = nVal.toBoolean(true); int equivalentResult = result ? 1 : 0; return maybeReplaceChildWithNumber(n, parent, equivalentResult); }  return n; } } [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] tryMinimizeCondition [RETURN_TYPE] Node  Node n [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean result rval ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node condition falseNode first left leftParent n newRoot parent replacement right rightParent trueNode TernaryValue nVal rightVal int AND_PRECEDENCE OR_PRECEDENCE complementOperator equivalentResult newOp precedence type Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE isLowerPrecedencePredicate isPropertyAssignmentInExpressionPredicate  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.3779644730092272	802	802	1	add	
41	[BUG] [BUGGY] int equivalentResult = result ? 1 : 0; [FE] AssertionFailedError [CONTEXT] } return n; } default:  TernaryValue nVal = NodeUtil.getBooleanValue(n); if (nVal != TernaryValue.UNKNOWN) { boolean result = nVal.toBoolean(true); [BUGGY] int equivalentResult = result ? 1 : 0; [BUGGY] return maybeReplaceChildWithNumber(n, parent, equivalentResult); }  return n; } } [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] tryMinimizeCondition [RETURN_TYPE] Node  Node n [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean result rval ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node condition falseNode first left leftParent n newRoot parent replacement right rightParent trueNode TernaryValue nVal rightVal int AND_PRECEDENCE OR_PRECEDENCE complementOperator equivalentResult newOp precedence type Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE isLowerPrecedencePredicate isPropertyAssignmentInExpressionPredicate  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.3779644730092272	803	803	1	replace	
42	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] } return n; } default:  TernaryValue nVal = NodeUtil.getBooleanValue(n); if (nVal != TernaryValue.UNKNOWN) { boolean result = nVal.toBoolean(true); [BUGGY] [BUGGY] int equivalentResult = result ? 1 : 0; return maybeReplaceChildWithNumber(n, parent, equivalentResult); }  return n; } } [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] tryMinimizeCondition [RETURN_TYPE] Node  Node n [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean result rval ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node condition falseNode first left leftParent n newRoot parent replacement right rightParent trueNode TernaryValue nVal rightVal int AND_PRECEDENCE OR_PRECEDENCE complementOperator equivalentResult newOp precedence type Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE isLowerPrecedencePredicate isPropertyAssignmentInExpressionPredicate  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.3779644730092272	803	803	1	add	
43	[BUG] [BUGGY] return maybeReplaceChildWithNumber(n, parent, equivalentResult); [FE] AssertionFailedError [CONTEXT] return n; } default:  TernaryValue nVal = NodeUtil.getBooleanValue(n); if (nVal != TernaryValue.UNKNOWN) { boolean result = nVal.toBoolean(true); int equivalentResult = result ? 1 : 0; [BUGGY] return maybeReplaceChildWithNumber(n, parent, equivalentResult); [BUGGY] }  return n; } } [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] tryMinimizeCondition [RETURN_TYPE] Node  Node n [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean result rval ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node condition falseNode first left leftParent n newRoot parent replacement right rightParent trueNode TernaryValue nVal rightVal int AND_PRECEDENCE OR_PRECEDENCE complementOperator equivalentResult newOp precedence type Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE isLowerPrecedencePredicate isPropertyAssignmentInExpressionPredicate  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.3779644730092272	804	804	1	replace	
44	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] return n; } default:  TernaryValue nVal = NodeUtil.getBooleanValue(n); if (nVal != TernaryValue.UNKNOWN) { boolean result = nVal.toBoolean(true); int equivalentResult = result ? 1 : 0; [BUGGY] [BUGGY] return maybeReplaceChildWithNumber(n, parent, equivalentResult); }  return n; } } [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] tryMinimizeCondition [RETURN_TYPE] Node  Node n [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean result rval ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node condition falseNode first left leftParent n newRoot parent replacement right rightParent trueNode TernaryValue nVal rightVal int AND_PRECEDENCE OR_PRECEDENCE complementOperator equivalentResult newOp precedence type Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE isLowerPrecedencePredicate isPropertyAssignmentInExpressionPredicate  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.3779644730092272	804	804	1	add	
45	[BUG] [BUGGY] Node newNode = Node.newNumber(num); [FE] AssertionFailedError [CONTEXT] private Node maybeReplaceChildWithNumber(Node n, Node parent, int num) { [BUGGY] Node newNode = Node.newNumber(num); [BUGGY] if (!newNode.isEquivalentTo(n)) { parent.replaceChild(n, newNode); reportCodeChange(); return newNode; } return n; } [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] maybeReplaceChildWithNumber [RETURN_TYPE] Node  Node n Node parent int num [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node n newNode parent int AND_PRECEDENCE OR_PRECEDENCE complementOperator equivalentResult newOp num precedence type Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE isLowerPrecedencePredicate isPropertyAssignmentInExpressionPredicate  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.3779644730092272	818	818	1	replace	
46	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] private Node maybeReplaceChildWithNumber(Node n, Node parent, int num) { [BUGGY] [BUGGY] Node newNode = Node.newNumber(num); if (!newNode.isEquivalentTo(n)) { parent.replaceChild(n, newNode); reportCodeChange(); return newNode; } return n; } [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] maybeReplaceChildWithNumber [RETURN_TYPE] Node  Node n Node parent int num [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node n newNode parent int AND_PRECEDENCE OR_PRECEDENCE complementOperator equivalentResult newOp num precedence type Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE isLowerPrecedencePredicate isPropertyAssignmentInExpressionPredicate  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.3779644730092272	818	818	1	add	
47	[BUG] [BUGGY] if (!newNode.isEquivalentTo(n)) { [FE] AssertionFailedError [CONTEXT] private Node maybeReplaceChildWithNumber(Node n, Node parent, int num) { Node newNode = Node.newNumber(num); [BUGGY] if (!newNode.isEquivalentTo(n)) { [BUGGY] parent.replaceChild(n, newNode); reportCodeChange(); return newNode; } return n; } [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] maybeReplaceChildWithNumber [RETURN_TYPE] Node  Node n Node parent int num [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node n newNode parent int AND_PRECEDENCE OR_PRECEDENCE complementOperator equivalentResult newOp num precedence type Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE isLowerPrecedencePredicate isPropertyAssignmentInExpressionPredicate  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.3779644730092272	819	819	1	replace	
48	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] private Node maybeReplaceChildWithNumber(Node n, Node parent, int num) { Node newNode = Node.newNumber(num); [BUGGY] [BUGGY] if (!newNode.isEquivalentTo(n)) { parent.replaceChild(n, newNode); reportCodeChange(); return newNode; } return n; } [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] maybeReplaceChildWithNumber [RETURN_TYPE] Node  Node n Node parent int num [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node n newNode parent int AND_PRECEDENCE OR_PRECEDENCE complementOperator equivalentResult newOp num precedence type Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE isLowerPrecedencePredicate isPropertyAssignmentInExpressionPredicate  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.3779644730092272	819	819	1	add	
49	[BUG] [BUGGY] return n; [FE] AssertionFailedError [CONTEXT] private Node maybeReplaceChildWithNumber(Node n, Node parent, int num) { Node newNode = Node.newNumber(num); if (!newNode.isEquivalentTo(n)) { parent.replaceChild(n, newNode); reportCodeChange(); return newNode; } [BUGGY] return n; [BUGGY] } [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] maybeReplaceChildWithNumber [RETURN_TYPE] Node  Node n Node parent int num [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node n newNode parent int AND_PRECEDENCE OR_PRECEDENCE complementOperator equivalentResult newOp num precedence type Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE isLowerPrecedencePredicate isPropertyAssignmentInExpressionPredicate  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.3779644730092272	826	826	1	replace	
50	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] private Node maybeReplaceChildWithNumber(Node n, Node parent, int num) { Node newNode = Node.newNumber(num); if (!newNode.isEquivalentTo(n)) { parent.replaceChild(n, newNode); reportCodeChange(); return newNode; } [BUGGY] [BUGGY] return n; } [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] maybeReplaceChildWithNumber [RETURN_TYPE] Node  Node n Node parent int num [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node n newNode parent int AND_PRECEDENCE OR_PRECEDENCE complementOperator equivalentResult newOp num precedence type Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE isLowerPrecedencePredicate isPropertyAssignmentInExpressionPredicate  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.3779644730092272	826	826	1	add	
51	[BUG] [BUGGY] Preconditions.checkState(isFoldableExpressBlock(n)); [FE] AssertionFailedError [CONTEXT] private Node getBlockExpression(Node n) { [BUGGY] Preconditions.checkState(isFoldableExpressBlock(n)); [BUGGY] return n.getFirstChild(); } [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] getBlockExpression [RETURN_TYPE] Node  Node n [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node n int AND_PRECEDENCE OR_PRECEDENCE complementOperator Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.35355339059327373	544	544	1	replace	
52	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] private Node getBlockExpression(Node n) { [BUGGY] [BUGGY] Preconditions.checkState(isFoldableExpressBlock(n)); return n.getFirstChild(); } [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] getBlockExpression [RETURN_TYPE] Node  Node n [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node n int AND_PRECEDENCE OR_PRECEDENCE complementOperator Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.35355339059327373	544	544	1	add	
53	[BUG] [BUGGY] return n.getFirstChild(); [FE] AssertionFailedError [CONTEXT] private Node getBlockExpression(Node n) { Preconditions.checkState(isFoldableExpressBlock(n)); [BUGGY] return n.getFirstChild(); [BUGGY] } [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] getBlockExpression [RETURN_TYPE] Node  Node n [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node n int AND_PRECEDENCE OR_PRECEDENCE complementOperator Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.35355339059327373	545	545	1	replace	
54	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] private Node getBlockExpression(Node n) { Preconditions.checkState(isFoldableExpressBlock(n)); [BUGGY] [BUGGY] return n.getFirstChild(); } [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] getBlockExpression [RETURN_TYPE] Node  Node n [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node n int AND_PRECEDENCE OR_PRECEDENCE complementOperator Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.35355339059327373	545	545	1	add	
55	[BUG] [BUGGY] Node left = n.getFirstChild(); [FE] AssertionFailedError [CONTEXT] } } break; }   return n; case Token.OR: case Token.AND: { [BUGGY] Node left = n.getFirstChild(); [BUGGY] Node right = n.getLastChild();   left = tryMinimizeCondition(left); right = tryMinimizeCondition(right);     [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] tryMinimizeCondition [RETURN_TYPE] Node  Node n [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean result rval ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node condition falseNode first left leftParent n newRoot parent replacement right rightParent trueNode TernaryValue nVal rightVal int AND_PRECEDENCE OR_PRECEDENCE complementOperator equivalentResult newOp precedence type Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE isLowerPrecedencePredicate isPropertyAssignmentInExpressionPredicate  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.35355339059327373	713	713	1	replace	
56	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] } } break; }   return n; case Token.OR: case Token.AND: { [BUGGY] [BUGGY] Node left = n.getFirstChild(); Node right = n.getLastChild();   left = tryMinimizeCondition(left); right = tryMinimizeCondition(right);     [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] tryMinimizeCondition [RETURN_TYPE] Node  Node n [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean result rval ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node condition falseNode first left leftParent n newRoot parent replacement right rightParent trueNode TernaryValue nVal rightVal int AND_PRECEDENCE OR_PRECEDENCE complementOperator equivalentResult newOp precedence type Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE isLowerPrecedencePredicate isPropertyAssignmentInExpressionPredicate  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.35355339059327373	713	713	1	add	
57	[BUG] [BUGGY] Node right = n.getLastChild(); [FE] AssertionFailedError [CONTEXT] } break; }   return n; case Token.OR: case Token.AND: { Node left = n.getFirstChild(); [BUGGY] Node right = n.getLastChild(); [BUGGY]    left = tryMinimizeCondition(left); right = tryMinimizeCondition(right);      [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] tryMinimizeCondition [RETURN_TYPE] Node  Node n [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean result rval ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node condition falseNode first left leftParent n newRoot parent replacement right rightParent trueNode TernaryValue nVal rightVal int AND_PRECEDENCE OR_PRECEDENCE complementOperator equivalentResult newOp precedence type Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE isLowerPrecedencePredicate isPropertyAssignmentInExpressionPredicate  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.35355339059327373	714	714	1	replace	
58	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] } break; }   return n; case Token.OR: case Token.AND: { Node left = n.getFirstChild(); [BUGGY] [BUGGY] Node right = n.getLastChild();   left = tryMinimizeCondition(left); right = tryMinimizeCondition(right);      [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] tryMinimizeCondition [RETURN_TYPE] Node  Node n [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean result rval ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node condition falseNode first left leftParent n newRoot parent replacement right rightParent trueNode TernaryValue nVal rightVal int AND_PRECEDENCE OR_PRECEDENCE complementOperator equivalentResult newOp precedence type Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE isLowerPrecedencePredicate isPropertyAssignmentInExpressionPredicate  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.35355339059327373	714	714	1	add	
59	[BUG] [BUGGY] left = tryMinimizeCondition(left); [FE] AssertionFailedError [CONTEXT]  return n; case Token.OR: case Token.AND: { Node left = n.getFirstChild(); Node right = n.getLastChild();   [BUGGY] left = tryMinimizeCondition(left); [BUGGY] right = tryMinimizeCondition(right);       TernaryValue rightVal = NodeUtil.getBooleanValue(right); if (NodeUtil.getBooleanValue(right) != TernaryValue.UNKNOWN) { [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] tryMinimizeCondition [RETURN_TYPE] Node  Node n [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean result rval ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node condition falseNode first left leftParent n newRoot parent replacement right rightParent trueNode TernaryValue nVal rightVal int AND_PRECEDENCE OR_PRECEDENCE complementOperator equivalentResult newOp precedence type Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE isLowerPrecedencePredicate isPropertyAssignmentInExpressionPredicate  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.35355339059327373	718	718	1	replace	
60	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT]  return n; case Token.OR: case Token.AND: { Node left = n.getFirstChild(); Node right = n.getLastChild();   [BUGGY] [BUGGY] left = tryMinimizeCondition(left); right = tryMinimizeCondition(right);       TernaryValue rightVal = NodeUtil.getBooleanValue(right); if (NodeUtil.getBooleanValue(right) != TernaryValue.UNKNOWN) { [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] tryMinimizeCondition [RETURN_TYPE] Node  Node n [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean result rval ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node condition falseNode first left leftParent n newRoot parent replacement right rightParent trueNode TernaryValue nVal rightVal int AND_PRECEDENCE OR_PRECEDENCE complementOperator equivalentResult newOp precedence type Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE isLowerPrecedencePredicate isPropertyAssignmentInExpressionPredicate  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.35355339059327373	718	718	1	add	
61	[BUG] [BUGGY] right = tryMinimizeCondition(right); [FE] AssertionFailedError [CONTEXT] return n; case Token.OR: case Token.AND: { Node left = n.getFirstChild(); Node right = n.getLastChild();   left = tryMinimizeCondition(left); [BUGGY] right = tryMinimizeCondition(right); [BUGGY]        TernaryValue rightVal = NodeUtil.getBooleanValue(right); if (NodeUtil.getBooleanValue(right) != TernaryValue.UNKNOWN) { int type = n.getType(); [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] tryMinimizeCondition [RETURN_TYPE] Node  Node n [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean result rval ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node condition falseNode first left leftParent n newRoot parent replacement right rightParent trueNode TernaryValue nVal rightVal int AND_PRECEDENCE OR_PRECEDENCE complementOperator equivalentResult newOp precedence type Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE isLowerPrecedencePredicate isPropertyAssignmentInExpressionPredicate  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.35355339059327373	719	719	1	replace	
62	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] return n; case Token.OR: case Token.AND: { Node left = n.getFirstChild(); Node right = n.getLastChild();   left = tryMinimizeCondition(left); [BUGGY] [BUGGY] right = tryMinimizeCondition(right);       TernaryValue rightVal = NodeUtil.getBooleanValue(right); if (NodeUtil.getBooleanValue(right) != TernaryValue.UNKNOWN) { int type = n.getType(); [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] tryMinimizeCondition [RETURN_TYPE] Node  Node n [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean result rval ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node condition falseNode first left leftParent n newRoot parent replacement right rightParent trueNode TernaryValue nVal rightVal int AND_PRECEDENCE OR_PRECEDENCE complementOperator equivalentResult newOp precedence type Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE isLowerPrecedencePredicate isPropertyAssignmentInExpressionPredicate  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.35355339059327373	719	719	1	add	
63	[BUG] [BUGGY] TernaryValue rightVal = NodeUtil.getBooleanValue(right); [FE] AssertionFailedError [CONTEXT]  left = tryMinimizeCondition(left); right = tryMinimizeCondition(right);       [BUGGY] TernaryValue rightVal = NodeUtil.getBooleanValue(right); [BUGGY] if (NodeUtil.getBooleanValue(right) != TernaryValue.UNKNOWN) { int type = n.getType(); Node replacement = null; boolean rval = rightVal.toBoolean(true);   if (type == Token.OR && !rval || type == Token.AND && rval) { replacement = left; [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] tryMinimizeCondition [RETURN_TYPE] Node  Node n [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean result rval ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node condition falseNode first left leftParent n newRoot parent replacement right rightParent trueNode TernaryValue nVal rightVal int AND_PRECEDENCE OR_PRECEDENCE complementOperator equivalentResult newOp precedence type Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE isLowerPrecedencePredicate isPropertyAssignmentInExpressionPredicate  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.35355339059327373	727	727	1	replace	
64	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT]  left = tryMinimizeCondition(left); right = tryMinimizeCondition(right);       [BUGGY] [BUGGY] TernaryValue rightVal = NodeUtil.getBooleanValue(right); if (NodeUtil.getBooleanValue(right) != TernaryValue.UNKNOWN) { int type = n.getType(); Node replacement = null; boolean rval = rightVal.toBoolean(true);   if (type == Token.OR && !rval || type == Token.AND && rval) { replacement = left; [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] tryMinimizeCondition [RETURN_TYPE] Node  Node n [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean result rval ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node condition falseNode first left leftParent n newRoot parent replacement right rightParent trueNode TernaryValue nVal rightVal int AND_PRECEDENCE OR_PRECEDENCE complementOperator equivalentResult newOp precedence type Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE isLowerPrecedencePredicate isPropertyAssignmentInExpressionPredicate  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.35355339059327373	727	727	1	add	
65	[BUG] [BUGGY] if (NodeUtil.getBooleanValue(right) != TernaryValue.UNKNOWN) { [FE] AssertionFailedError [CONTEXT] left = tryMinimizeCondition(left); right = tryMinimizeCondition(right);       TernaryValue rightVal = NodeUtil.getBooleanValue(right); [BUGGY] if (NodeUtil.getBooleanValue(right) != TernaryValue.UNKNOWN) { [BUGGY] int type = n.getType(); Node replacement = null; boolean rval = rightVal.toBoolean(true);   if (type == Token.OR && !rval || type == Token.AND && rval) { replacement = left; } else if (!mayHaveSideEffects(left)) { [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] tryMinimizeCondition [RETURN_TYPE] Node  Node n [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean result rval ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node condition falseNode first left leftParent n newRoot parent replacement right rightParent trueNode TernaryValue nVal rightVal int AND_PRECEDENCE OR_PRECEDENCE complementOperator equivalentResult newOp precedence type Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE isLowerPrecedencePredicate isPropertyAssignmentInExpressionPredicate  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.35355339059327373	728	728	1	replace	
66	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] left = tryMinimizeCondition(left); right = tryMinimizeCondition(right);       TernaryValue rightVal = NodeUtil.getBooleanValue(right); [BUGGY] [BUGGY] if (NodeUtil.getBooleanValue(right) != TernaryValue.UNKNOWN) { int type = n.getType(); Node replacement = null; boolean rval = rightVal.toBoolean(true);   if (type == Token.OR && !rval || type == Token.AND && rval) { replacement = left; } else if (!mayHaveSideEffects(left)) { [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] tryMinimizeCondition [RETURN_TYPE] Node  Node n [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean result rval ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node condition falseNode first left leftParent n newRoot parent replacement right rightParent trueNode TernaryValue nVal rightVal int AND_PRECEDENCE OR_PRECEDENCE complementOperator equivalentResult newOp precedence type Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE isLowerPrecedencePredicate isPropertyAssignmentInExpressionPredicate  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.35355339059327373	728	728	1	add	
67	[BUG] [BUGGY] if (isFoldableExpressBlock(thenBranch)) { [FE] AssertionFailedError [CONTEXT]   if (NodeUtil.isLiteralValue(cond, true)) { return n; } Node thenBranch = cond.getNext(); Node elseBranch = thenBranch.getNext(); if (elseBranch == null) { [BUGGY] if (isFoldableExpressBlock(thenBranch)) { [BUGGY] Node expr = getBlockExpression(thenBranch); if (isPropertyAssignmentInExpression(expr)) {   return n; } if (cond.getType() == Token.NOT) {  if (isLowerPrecedenceInExpression(cond, OR_PRECEDENCE) && [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] tryMinimizeIf [RETURN_TYPE] Node  Node n [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean elseBranchIsExpressionBlock elseBranchIsVar thenBranchIsExpressionBlock thenBranchIsVar ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node and assign assignName cond elseAssign elseBranch elseExpr elseOp expr hookNode lhs maybeName1 maybeName2 n name1 name2 newExpr or parent returnNode thenAssign thenBranch thenExpr thenOp var int AND_PRECEDENCE OR_PRECEDENCE complementOperator Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.3333333333333333	275	275	1	replace	
68	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT]   if (NodeUtil.isLiteralValue(cond, true)) { return n; } Node thenBranch = cond.getNext(); Node elseBranch = thenBranch.getNext(); if (elseBranch == null) { [BUGGY] [BUGGY] if (isFoldableExpressBlock(thenBranch)) { Node expr = getBlockExpression(thenBranch); if (isPropertyAssignmentInExpression(expr)) {   return n; } if (cond.getType() == Token.NOT) {  if (isLowerPrecedenceInExpression(cond, OR_PRECEDENCE) && [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] tryMinimizeIf [RETURN_TYPE] Node  Node n [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean elseBranchIsExpressionBlock elseBranchIsVar thenBranchIsExpressionBlock thenBranchIsVar ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node and assign assignName cond elseAssign elseBranch elseExpr elseOp expr hookNode lhs maybeName1 maybeName2 n name1 name2 newExpr or parent returnNode thenAssign thenBranch thenExpr thenOp var int AND_PRECEDENCE OR_PRECEDENCE complementOperator Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.3333333333333333	275	275	1	add	
69	[BUG] [BUGGY] Node maybeExpr = n.getFirstChild(); [FE] AssertionFailedError [CONTEXT] private boolean isFoldableExpressBlock(Node n) { if (n.getType() == Token.BLOCK) { if (n.hasOneChild()) { [BUGGY] Node maybeExpr = n.getFirstChild(); [BUGGY]           [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] isFoldableExpressBlock [RETURN_TYPE] boolean  Node n [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node maybeExpr n int AND_PRECEDENCE OR_PRECEDENCE complementOperator Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.30151134457776363	522	522	1	replace	
70	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] private boolean isFoldableExpressBlock(Node n) { if (n.getType() == Token.BLOCK) { if (n.hasOneChild()) { [BUGGY] [BUGGY] Node maybeExpr = n.getFirstChild();          [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] isFoldableExpressBlock [RETURN_TYPE] boolean  Node n [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node maybeExpr n int AND_PRECEDENCE OR_PRECEDENCE complementOperator Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.30151134457776363	522	522	1	add	
71	[BUG] [BUGGY] return NodeUtil.isExpressionNode(maybeExpr); [FE] AssertionFailedError [CONTEXT]          [BUGGY] return NodeUtil.isExpressionNode(maybeExpr); [BUGGY] } } return false; } [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] isFoldableExpressBlock [RETURN_TYPE] boolean  Node n [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node maybeExpr n int AND_PRECEDENCE OR_PRECEDENCE complementOperator Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.30151134457776363	533	533	1	replace	
72	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT]          [BUGGY] [BUGGY] return NodeUtil.isExpressionNode(maybeExpr); } } return false; } [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] isFoldableExpressBlock [RETURN_TYPE] boolean  Node n [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node maybeExpr n int AND_PRECEDENCE OR_PRECEDENCE complementOperator Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.30151134457776363	533	533	1	add	
73	[BUG] [BUGGY] tryMinimizeCondition(node.getFirstChild()); [FE] AssertionFailedError [CONTEXT] public Node optimizeSubtree(Node node) { switch(node.getType()) { case Token.RETURN: return tryReduceReturn(node); case Token.NOT: tryMinimizeCondition(node.getFirstChild()); return tryMinimizeNot(node); case Token.IF: [BUGGY] tryMinimizeCondition(node.getFirstChild()); [BUGGY] return tryMinimizeIf(node); case Token.EXPR_RESULT: tryMinimizeCondition(node.getFirstChild()); return node; case Token.HOOK: tryMinimizeCondition(node.getFirstChild()); return node;  [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] optimizeSubtree [RETURN_TYPE] Node  Node node [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node node int AND_PRECEDENCE OR_PRECEDENCE Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.2886751345948129	68	68	1	replace	
74	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] public Node optimizeSubtree(Node node) { switch(node.getType()) { case Token.RETURN: return tryReduceReturn(node); case Token.NOT: tryMinimizeCondition(node.getFirstChild()); return tryMinimizeNot(node); case Token.IF: [BUGGY] [BUGGY] tryMinimizeCondition(node.getFirstChild()); return tryMinimizeIf(node); case Token.EXPR_RESULT: tryMinimizeCondition(node.getFirstChild()); return node; case Token.HOOK: tryMinimizeCondition(node.getFirstChild()); return node;  [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] optimizeSubtree [RETURN_TYPE] Node  Node node [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node node int AND_PRECEDENCE OR_PRECEDENCE Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.2886751345948129	68	68	1	add	
75	[BUG] [BUGGY] return tryMinimizeIf(node); [FE] AssertionFailedError [CONTEXT] switch(node.getType()) { case Token.RETURN: return tryReduceReturn(node); case Token.NOT: tryMinimizeCondition(node.getFirstChild()); return tryMinimizeNot(node); case Token.IF: tryMinimizeCondition(node.getFirstChild()); [BUGGY] return tryMinimizeIf(node); [BUGGY]  case Token.EXPR_RESULT: tryMinimizeCondition(node.getFirstChild()); return node; case Token.HOOK: tryMinimizeCondition(node.getFirstChild()); return node; case Token.WHILE: [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] optimizeSubtree [RETURN_TYPE] Node  Node node [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node node int AND_PRECEDENCE OR_PRECEDENCE Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.2886751345948129	69	69	1	replace	
76	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] switch(node.getType()) { case Token.RETURN: return tryReduceReturn(node); case Token.NOT: tryMinimizeCondition(node.getFirstChild()); return tryMinimizeNot(node); case Token.IF: tryMinimizeCondition(node.getFirstChild()); [BUGGY] [BUGGY] return tryMinimizeIf(node); case Token.EXPR_RESULT: tryMinimizeCondition(node.getFirstChild()); return node; case Token.HOOK: tryMinimizeCondition(node.getFirstChild()); return node; case Token.WHILE: [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] optimizeSubtree [RETURN_TYPE] Node  Node node [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node node int AND_PRECEDENCE OR_PRECEDENCE Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.2886751345948129	69	69	1	add	
77	[BUG] [BUGGY] Node parent = n.getParent(); [FE] AssertionFailedError [CONTEXT] private Node tryMinimizeIf(Node n) { [BUGGY] Node parent = n.getParent(); [BUGGY]  Node cond = n.getFirstChild();    if (NodeUtil.isLiteralValue(cond, true)) { return n; }  [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] tryMinimizeIf [RETURN_TYPE] Node  Node n [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean elseBranchIsExpressionBlock elseBranchIsVar thenBranchIsExpressionBlock thenBranchIsVar ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node and assign assignName cond elseAssign elseBranch elseExpr elseOp expr hookNode lhs maybeName1 maybeName2 n name1 name2 newExpr or parent returnNode thenAssign thenBranch thenExpr thenOp var int AND_PRECEDENCE OR_PRECEDENCE complementOperator Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.2886751345948129	260	260	1	replace	
78	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] private Node tryMinimizeIf(Node n) { [BUGGY] [BUGGY] Node parent = n.getParent(); Node cond = n.getFirstChild();    if (NodeUtil.isLiteralValue(cond, true)) { return n; }  [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] tryMinimizeIf [RETURN_TYPE] Node  Node n [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean elseBranchIsExpressionBlock elseBranchIsVar thenBranchIsExpressionBlock thenBranchIsVar ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node and assign assignName cond elseAssign elseBranch elseExpr elseOp expr hookNode lhs maybeName1 maybeName2 n name1 name2 newExpr or parent returnNode thenAssign thenBranch thenExpr thenOp var int AND_PRECEDENCE OR_PRECEDENCE complementOperator Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.2886751345948129	260	260	1	add	
79	[BUG] [BUGGY] Node cond = n.getFirstChild(); [FE] AssertionFailedError [CONTEXT] private Node tryMinimizeIf(Node n) { Node parent = n.getParent(); [BUGGY] Node cond = n.getFirstChild(); [BUGGY]     if (NodeUtil.isLiteralValue(cond, true)) { return n; } Node thenBranch = cond.getNext(); Node elseBranch = thenBranch.getNext(); [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] tryMinimizeIf [RETURN_TYPE] Node  Node n [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean elseBranchIsExpressionBlock elseBranchIsVar thenBranchIsExpressionBlock thenBranchIsVar ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node and assign assignName cond elseAssign elseBranch elseExpr elseOp expr hookNode lhs maybeName1 maybeName2 n name1 name2 newExpr or parent returnNode thenAssign thenBranch thenExpr thenOp var int AND_PRECEDENCE OR_PRECEDENCE complementOperator Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.2886751345948129	262	262	1	replace	
80	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] private Node tryMinimizeIf(Node n) { Node parent = n.getParent(); [BUGGY] [BUGGY] Node cond = n.getFirstChild();    if (NodeUtil.isLiteralValue(cond, true)) { return n; } Node thenBranch = cond.getNext(); Node elseBranch = thenBranch.getNext(); [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] tryMinimizeIf [RETURN_TYPE] Node  Node n [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean elseBranchIsExpressionBlock elseBranchIsVar thenBranchIsExpressionBlock thenBranchIsVar ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node and assign assignName cond elseAssign elseBranch elseExpr elseOp expr hookNode lhs maybeName1 maybeName2 n name1 name2 newExpr or parent returnNode thenAssign thenBranch thenExpr thenOp var int AND_PRECEDENCE OR_PRECEDENCE complementOperator Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.2886751345948129	262	262	1	add	
81	[BUG] [BUGGY] if (NodeUtil.isLiteralValue(cond, true)) { [FE] AssertionFailedError [CONTEXT] private Node tryMinimizeIf(Node n) { Node parent = n.getParent(); Node cond = n.getFirstChild();    [BUGGY] if (NodeUtil.isLiteralValue(cond, true)) { [BUGGY] return n; } Node thenBranch = cond.getNext(); Node elseBranch = thenBranch.getNext(); if (elseBranch == null) { if (isFoldableExpressBlock(thenBranch)) { Node expr = getBlockExpression(thenBranch); if (isPropertyAssignmentInExpression(expr)) { [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] tryMinimizeIf [RETURN_TYPE] Node  Node n [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean elseBranchIsExpressionBlock elseBranchIsVar thenBranchIsExpressionBlock thenBranchIsVar ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node and assign assignName cond elseAssign elseBranch elseExpr elseOp expr hookNode lhs maybeName1 maybeName2 n name1 name2 newExpr or parent returnNode thenAssign thenBranch thenExpr thenOp var int AND_PRECEDENCE OR_PRECEDENCE complementOperator Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.2886751345948129	267	267	1	replace	
82	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] private Node tryMinimizeIf(Node n) { Node parent = n.getParent(); Node cond = n.getFirstChild();    [BUGGY] [BUGGY] if (NodeUtil.isLiteralValue(cond, true)) { return n; } Node thenBranch = cond.getNext(); Node elseBranch = thenBranch.getNext(); if (elseBranch == null) { if (isFoldableExpressBlock(thenBranch)) { Node expr = getBlockExpression(thenBranch); if (isPropertyAssignmentInExpression(expr)) { [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] tryMinimizeIf [RETURN_TYPE] Node  Node n [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean elseBranchIsExpressionBlock elseBranchIsVar thenBranchIsExpressionBlock thenBranchIsVar ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node and assign assignName cond elseAssign elseBranch elseExpr elseOp expr hookNode lhs maybeName1 maybeName2 n name1 name2 newExpr or parent returnNode thenAssign thenBranch thenExpr thenOp var int AND_PRECEDENCE OR_PRECEDENCE complementOperator Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.2886751345948129	267	267	1	add	
83	[BUG] [BUGGY] Node thenBranch = cond.getNext(); [FE] AssertionFailedError [CONTEXT] Node cond = n.getFirstChild();    if (NodeUtil.isLiteralValue(cond, true)) { return n; } [BUGGY] Node thenBranch = cond.getNext(); [BUGGY] Node elseBranch = thenBranch.getNext(); if (elseBranch == null) { if (isFoldableExpressBlock(thenBranch)) { Node expr = getBlockExpression(thenBranch); if (isPropertyAssignmentInExpression(expr)) {   return n; } [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] tryMinimizeIf [RETURN_TYPE] Node  Node n [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean elseBranchIsExpressionBlock elseBranchIsVar thenBranchIsExpressionBlock thenBranchIsVar ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node and assign assignName cond elseAssign elseBranch elseExpr elseOp expr hookNode lhs maybeName1 maybeName2 n name1 name2 newExpr or parent returnNode thenAssign thenBranch thenExpr thenOp var int AND_PRECEDENCE OR_PRECEDENCE complementOperator Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.2886751345948129	271	271	1	replace	
84	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] Node cond = n.getFirstChild();    if (NodeUtil.isLiteralValue(cond, true)) { return n; } [BUGGY] [BUGGY] Node thenBranch = cond.getNext(); Node elseBranch = thenBranch.getNext(); if (elseBranch == null) { if (isFoldableExpressBlock(thenBranch)) { Node expr = getBlockExpression(thenBranch); if (isPropertyAssignmentInExpression(expr)) {   return n; } [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] tryMinimizeIf [RETURN_TYPE] Node  Node n [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean elseBranchIsExpressionBlock elseBranchIsVar thenBranchIsExpressionBlock thenBranchIsVar ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node and assign assignName cond elseAssign elseBranch elseExpr elseOp expr hookNode lhs maybeName1 maybeName2 n name1 name2 newExpr or parent returnNode thenAssign thenBranch thenExpr thenOp var int AND_PRECEDENCE OR_PRECEDENCE complementOperator Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.2886751345948129	271	271	1	add	
85	[BUG] [BUGGY] Node elseBranch = thenBranch.getNext(); [FE] AssertionFailedError [CONTEXT] Node cond = n.getFirstChild();    if (NodeUtil.isLiteralValue(cond, true)) { return n; } Node thenBranch = cond.getNext(); [BUGGY] Node elseBranch = thenBranch.getNext(); [BUGGY]  if (elseBranch == null) { if (isFoldableExpressBlock(thenBranch)) { Node expr = getBlockExpression(thenBranch); if (isPropertyAssignmentInExpression(expr)) {   return n; }  [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] tryMinimizeIf [RETURN_TYPE] Node  Node n [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean elseBranchIsExpressionBlock elseBranchIsVar thenBranchIsExpressionBlock thenBranchIsVar ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node and assign assignName cond elseAssign elseBranch elseExpr elseOp expr hookNode lhs maybeName1 maybeName2 n name1 name2 newExpr or parent returnNode thenAssign thenBranch thenExpr thenOp var int AND_PRECEDENCE OR_PRECEDENCE complementOperator Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.2886751345948129	272	272	1	replace	
86	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] Node cond = n.getFirstChild();    if (NodeUtil.isLiteralValue(cond, true)) { return n; } Node thenBranch = cond.getNext(); [BUGGY] [BUGGY] Node elseBranch = thenBranch.getNext(); if (elseBranch == null) { if (isFoldableExpressBlock(thenBranch)) { Node expr = getBlockExpression(thenBranch); if (isPropertyAssignmentInExpression(expr)) {   return n; }  [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] tryMinimizeIf [RETURN_TYPE] Node  Node n [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean elseBranchIsExpressionBlock elseBranchIsVar thenBranchIsExpressionBlock thenBranchIsVar ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node and assign assignName cond elseAssign elseBranch elseExpr elseOp expr hookNode lhs maybeName1 maybeName2 n name1 name2 newExpr or parent returnNode thenAssign thenBranch thenExpr thenOp var int AND_PRECEDENCE OR_PRECEDENCE complementOperator Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.2886751345948129	272	272	1	add	
87	[BUG] [BUGGY] if (elseBranch == null) { [FE] AssertionFailedError [CONTEXT]    if (NodeUtil.isLiteralValue(cond, true)) { return n; } Node thenBranch = cond.getNext(); Node elseBranch = thenBranch.getNext(); [BUGGY] if (elseBranch == null) { [BUGGY] if (isFoldableExpressBlock(thenBranch)) { Node expr = getBlockExpression(thenBranch); if (isPropertyAssignmentInExpression(expr)) {   return n; } if (cond.getType() == Token.NOT) {  [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] tryMinimizeIf [RETURN_TYPE] Node  Node n [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean elseBranchIsExpressionBlock elseBranchIsVar thenBranchIsExpressionBlock thenBranchIsVar ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node and assign assignName cond elseAssign elseBranch elseExpr elseOp expr hookNode lhs maybeName1 maybeName2 n name1 name2 newExpr or parent returnNode thenAssign thenBranch thenExpr thenOp var int AND_PRECEDENCE OR_PRECEDENCE complementOperator Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.2886751345948129	274	274	1	replace	
88	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT]    if (NodeUtil.isLiteralValue(cond, true)) { return n; } Node thenBranch = cond.getNext(); Node elseBranch = thenBranch.getNext(); [BUGGY] [BUGGY] if (elseBranch == null) { if (isFoldableExpressBlock(thenBranch)) { Node expr = getBlockExpression(thenBranch); if (isPropertyAssignmentInExpression(expr)) {   return n; } if (cond.getType() == Token.NOT) {  [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] tryMinimizeIf [RETURN_TYPE] Node  Node n [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean elseBranchIsExpressionBlock elseBranchIsVar thenBranchIsExpressionBlock thenBranchIsVar ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node and assign assignName cond elseAssign elseBranch elseExpr elseOp expr hookNode lhs maybeName1 maybeName2 n name1 name2 newExpr or parent returnNode thenAssign thenBranch thenExpr thenOp var int AND_PRECEDENCE OR_PRECEDENCE complementOperator Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.2886751345948129	274	274	1	add	
89	[BUG] [BUGGY] if (n.getType() == Token.BLOCK) { [FE] AssertionFailedError [CONTEXT] private boolean isFoldableExpressBlock(Node n) { [BUGGY] if (n.getType() == Token.BLOCK) { [BUGGY] if (n.hasOneChild()) { Node maybeExpr = n.getFirstChild();         [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] isFoldableExpressBlock [RETURN_TYPE] boolean  Node n [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node maybeExpr n int AND_PRECEDENCE OR_PRECEDENCE complementOperator Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.2886751345948129	520	520	1	replace	
90	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] private boolean isFoldableExpressBlock(Node n) { [BUGGY] [BUGGY] if (n.getType() == Token.BLOCK) { if (n.hasOneChild()) { Node maybeExpr = n.getFirstChild();         [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] isFoldableExpressBlock [RETURN_TYPE] boolean  Node n [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node maybeExpr n int AND_PRECEDENCE OR_PRECEDENCE complementOperator Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.2886751345948129	520	520	1	add	
91	[BUG] [BUGGY] if (n.hasOneChild()) { [FE] AssertionFailedError [CONTEXT] private boolean isFoldableExpressBlock(Node n) { if (n.getType() == Token.BLOCK) { [BUGGY] if (n.hasOneChild()) { [BUGGY] Node maybeExpr = n.getFirstChild();          [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] isFoldableExpressBlock [RETURN_TYPE] boolean  Node n [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node maybeExpr n int AND_PRECEDENCE OR_PRECEDENCE complementOperator Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.2886751345948129	521	521	1	replace	
92	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] private boolean isFoldableExpressBlock(Node n) { if (n.getType() == Token.BLOCK) { [BUGGY] [BUGGY] if (n.hasOneChild()) { Node maybeExpr = n.getFirstChild();          [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] isFoldableExpressBlock [RETURN_TYPE] boolean  Node n [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node maybeExpr n int AND_PRECEDENCE OR_PRECEDENCE complementOperator Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.2886751345948129	521	521	1	add	
93	[BUG] [BUGGY] return n; [FE] AssertionFailedError [CONTEXT] } } if (newLiteralNode != null) { n.getParent().replaceChild(n, newLiteralNode); reportCodeChange(); return newLiteralNode; } } } [BUGGY] return n; [BUGGY] } [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] tryFoldLiteralConstructor [RETURN_TYPE] Node  Node n [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS action boolean constructorHasArgs ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node arg0 constructorNameNode n newLiteralNode String className int AND_PRECEDENCE OR_PRECEDENCE complementOperator equivalentResult newOp num precedence type Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE isLowerPrecedencePredicate isPropertyAssignmentInExpressionPredicate  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.23570226039551587	913	913	1	replace	
94	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] } } if (newLiteralNode != null) { n.getParent().replaceChild(n, newLiteralNode); reportCodeChange(); return newLiteralNode; } } } [BUGGY] [BUGGY] return n; } [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] tryFoldLiteralConstructor [RETURN_TYPE] Node  Node n [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS action boolean constructorHasArgs ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node arg0 constructorNameNode n newLiteralNode String className int AND_PRECEDENCE OR_PRECEDENCE complementOperator equivalentResult newOp num precedence type Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE isLowerPrecedencePredicate isPropertyAssignmentInExpressionPredicate  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.23570226039551587	913	913	1	add	
95	[BUG] [BUGGY] tryMinimizeCondition(node.getFirstChild()); [FE] AssertionFailedError [CONTEXT] case Token.NOT: tryMinimizeCondition(node.getFirstChild()); return tryMinimizeNot(node); case Token.IF: tryMinimizeCondition(node.getFirstChild()); return tryMinimizeIf(node); case Token.EXPR_RESULT: [BUGGY] tryMinimizeCondition(node.getFirstChild()); [BUGGY] return node; case Token.HOOK: tryMinimizeCondition(node.getFirstChild()); return node; case Token.WHILE: case Token.DO: tryMinimizeCondition(NodeUtil.getConditionExpression(node)); return node; [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] optimizeSubtree [RETURN_TYPE] Node  Node node [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node node int AND_PRECEDENCE OR_PRECEDENCE Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.22941573387056174	72	72	1	replace	
96	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] case Token.NOT: tryMinimizeCondition(node.getFirstChild()); return tryMinimizeNot(node); case Token.IF: tryMinimizeCondition(node.getFirstChild()); return tryMinimizeIf(node); case Token.EXPR_RESULT: [BUGGY] [BUGGY] tryMinimizeCondition(node.getFirstChild()); return node; case Token.HOOK: tryMinimizeCondition(node.getFirstChild()); return node; case Token.WHILE: case Token.DO: tryMinimizeCondition(NodeUtil.getConditionExpression(node)); return node; [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] optimizeSubtree [RETURN_TYPE] Node  Node node [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node node int AND_PRECEDENCE OR_PRECEDENCE Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.22941573387056174	72	72	1	add	
97	[BUG] [BUGGY] return node; [FE] AssertionFailedError [CONTEXT] case Token.NOT: tryMinimizeCondition(node.getFirstChild()); return tryMinimizeNot(node); case Token.IF: tryMinimizeCondition(node.getFirstChild()); return tryMinimizeIf(node); case Token.EXPR_RESULT: tryMinimizeCondition(node.getFirstChild()); [BUGGY] return node; [BUGGY]  case Token.HOOK: tryMinimizeCondition(node.getFirstChild()); return node; case Token.WHILE: case Token.DO: tryMinimizeCondition(NodeUtil.getConditionExpression(node)); return node;  [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] optimizeSubtree [RETURN_TYPE] Node  Node node [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node node int AND_PRECEDENCE OR_PRECEDENCE Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.22941573387056174	73	73	1	replace	
98	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] case Token.NOT: tryMinimizeCondition(node.getFirstChild()); return tryMinimizeNot(node); case Token.IF: tryMinimizeCondition(node.getFirstChild()); return tryMinimizeIf(node); case Token.EXPR_RESULT: tryMinimizeCondition(node.getFirstChild()); [BUGGY] [BUGGY] return node; case Token.HOOK: tryMinimizeCondition(node.getFirstChild()); return node; case Token.WHILE: case Token.DO: tryMinimizeCondition(NodeUtil.getConditionExpression(node)); return node;  [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] optimizeSubtree [RETURN_TYPE] Node  Node node [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node node int AND_PRECEDENCE OR_PRECEDENCE Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.22941573387056174	73	73	1	add	
99	[BUG] [BUGGY] return tryFoldLiteralConstructor(node); [FE] AssertionFailedError [CONTEXT] return node; case Token.NEW: node = tryFoldStandardConstructors(node); if (node.getType() != Token.CALL) { return node; }   case Token.CALL: [BUGGY] return tryFoldLiteralConstructor(node); [BUGGY]  default: return node; //Nothing changed } } [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] optimizeSubtree [RETURN_TYPE] Node  Node node [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node node int AND_PRECEDENCE OR_PRECEDENCE Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.22360679774997896	98	98	1	replace	
100	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] return node; case Token.NEW: node = tryFoldStandardConstructors(node); if (node.getType() != Token.CALL) { return node; }   case Token.CALL: [BUGGY] [BUGGY] return tryFoldLiteralConstructor(node); default: return node; //Nothing changed } } [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] optimizeSubtree [RETURN_TYPE] Node  Node node [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node node int AND_PRECEDENCE OR_PRECEDENCE Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.22360679774997896	98	98	1	add	
