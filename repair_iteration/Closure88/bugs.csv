bugid	buggy	buggy_class	suspiciousness	buggy_line	endbuggycode	failing_test_number	action	patch
1	[BUG] [BUGGY] return false; [FE] AssertionFailedError [CONTEXT] while (n != exprRoot) { for(Node sibling = n.getNext(); sibling != null; sibling = sibling.getNext()) { if (!ControlFlowGraph.isEnteringNewCfgNode(sibling)) { VariableLiveness state = isVariableReadBeforeKill(sibling, variable);  if (state == VariableLiveness.READ) { return true; } else if (state == VariableLiveness.KILL) { [BUGGY] return false; [BUGGY] } } } n = n.getParent(); } return false; } [CLASS] DeadAssignmentsElimination 1 VariableLiveness [METHOD] isVariableStillLiveWithinExpression [RETURN_TYPE] boolean  Node n Node exprRoot String variable [VARIABLES] AbstractCompiler compiler boolean Node exprRoot n sibling String variable VariableLiveness KILL MAYBE_LIVE READ state LiveVariablesAnalysis liveness Predicate matchRemovableAssigns  	projects/Closure88/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java	0.9258200997725514	302	302	6	replace	
2	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] while (n != exprRoot) { for(Node sibling = n.getNext(); sibling != null; sibling = sibling.getNext()) { if (!ControlFlowGraph.isEnteringNewCfgNode(sibling)) { VariableLiveness state = isVariableReadBeforeKill(sibling, variable);  if (state == VariableLiveness.READ) { return true; } else if (state == VariableLiveness.KILL) { [BUGGY] [BUGGY] return false; } } } n = n.getParent(); } return false; } [CLASS] DeadAssignmentsElimination 1 VariableLiveness [METHOD] isVariableStillLiveWithinExpression [RETURN_TYPE] boolean  Node n Node exprRoot String variable [VARIABLES] AbstractCompiler compiler boolean Node exprRoot n sibling String variable VariableLiveness KILL MAYBE_LIVE READ state LiveVariablesAnalysis liveness Predicate matchRemovableAssigns  	projects/Closure88/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java	0.9258200997725514	302	302	6	add	
3	[BUG] [BUGGY] return VariableLiveness.KILL; [FE] AssertionFailedError [CONTEXT] private VariableLiveness isVariableReadBeforeKill( Node n, String variable) { if (NodeUtil.isName(n) && variable.equals(n.getString())) { if (NodeUtil.isLhs(n, n.getParent())) {    [BUGGY] return VariableLiveness.KILL; [BUGGY] } else { return VariableLiveness.READ; } }  for (Node child = n.getFirstChild(); child != null; child = child.getNext()) { if (!ControlFlowGraph.isEnteringNewCfgNode(child)) { // Not a FUNCTION VariableLiveness state = isVariableReadBeforeKill(child, variable); [CLASS] DeadAssignmentsElimination 1 VariableLiveness [METHOD] isVariableReadBeforeKill [RETURN_TYPE] DeadAssignmentsElimination$VariableLiveness  Node n String variable [VARIABLES] AbstractCompiler compiler boolean Node child n String variable VariableLiveness KILL MAYBE_LIVE READ state LiveVariablesAnalysis liveness Predicate matchRemovableAssigns  	projects/Closure88/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java	0.9258200997725514	330	330	6	replace	
4	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] private VariableLiveness isVariableReadBeforeKill( Node n, String variable) { if (NodeUtil.isName(n) && variable.equals(n.getString())) { if (NodeUtil.isLhs(n, n.getParent())) {    [BUGGY] [BUGGY] return VariableLiveness.KILL; } else { return VariableLiveness.READ; } }  for (Node child = n.getFirstChild(); child != null; child = child.getNext()) { if (!ControlFlowGraph.isEnteringNewCfgNode(child)) { // Not a FUNCTION VariableLiveness state = isVariableReadBeforeKill(child, variable); [CLASS] DeadAssignmentsElimination 1 VariableLiveness [METHOD] isVariableReadBeforeKill [RETURN_TYPE] DeadAssignmentsElimination$VariableLiveness  Node n String variable [VARIABLES] AbstractCompiler compiler boolean Node child n String variable VariableLiveness KILL MAYBE_LIVE READ state LiveVariablesAnalysis liveness Predicate matchRemovableAssigns  	projects/Closure88/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java	0.9258200997725514	330	330	6	add	
5	[BUG] [BUGGY] } else if (state == VariableLiveness.KILL) { [FE] AssertionFailedError [CONTEXT] Node n, Node exprRoot, String variable) { while (n != exprRoot) { for(Node sibling = n.getNext(); sibling != null; sibling = sibling.getNext()) { if (!ControlFlowGraph.isEnteringNewCfgNode(sibling)) { VariableLiveness state = isVariableReadBeforeKill(sibling, variable);  if (state == VariableLiveness.READ) { return true; [BUGGY] } else if (state == VariableLiveness.KILL) { [BUGGY] return false; } } } n = n.getParent(); } return false; } [CLASS] DeadAssignmentsElimination 1 VariableLiveness [METHOD] isVariableStillLiveWithinExpression [RETURN_TYPE] boolean  Node n Node exprRoot String variable [VARIABLES] AbstractCompiler compiler boolean Node exprRoot n sibling String variable VariableLiveness KILL MAYBE_LIVE READ state LiveVariablesAnalysis liveness Predicate matchRemovableAssigns  	projects/Closure88/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java	0.816496580927726	301	301	6	replace	
6	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] Node n, Node exprRoot, String variable) { while (n != exprRoot) { for(Node sibling = n.getNext(); sibling != null; sibling = sibling.getNext()) { if (!ControlFlowGraph.isEnteringNewCfgNode(sibling)) { VariableLiveness state = isVariableReadBeforeKill(sibling, variable);  if (state == VariableLiveness.READ) { return true; [BUGGY] [BUGGY] } else if (state == VariableLiveness.KILL) { return false; } } } n = n.getParent(); } return false; } [CLASS] DeadAssignmentsElimination 1 VariableLiveness [METHOD] isVariableStillLiveWithinExpression [RETURN_TYPE] boolean  Node n Node exprRoot String variable [VARIABLES] AbstractCompiler compiler boolean Node exprRoot n sibling String variable VariableLiveness KILL MAYBE_LIVE READ state LiveVariablesAnalysis liveness Predicate matchRemovableAssigns  	projects/Closure88/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java	0.816496580927726	301	301	6	add	
7	[BUG] [BUGGY] if (NodeUtil.isLhs(n, n.getParent())) { [FE] AssertionFailedError [CONTEXT] private VariableLiveness isVariableReadBeforeKill( Node n, String variable) { if (NodeUtil.isName(n) && variable.equals(n.getString())) { [BUGGY] if (NodeUtil.isLhs(n, n.getParent())) { [BUGGY]    return VariableLiveness.KILL; } else { return VariableLiveness.READ; } }   [CLASS] DeadAssignmentsElimination 1 VariableLiveness [METHOD] isVariableReadBeforeKill [RETURN_TYPE] DeadAssignmentsElimination$VariableLiveness  Node n String variable [VARIABLES] AbstractCompiler compiler boolean Node child n String variable VariableLiveness KILL MAYBE_LIVE READ state LiveVariablesAnalysis liveness Predicate matchRemovableAssigns  	projects/Closure88/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java	0.7745966692414834	326	326	6	replace	
8	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] private VariableLiveness isVariableReadBeforeKill( Node n, String variable) { if (NodeUtil.isName(n) && variable.equals(n.getString())) { [BUGGY] [BUGGY] if (NodeUtil.isLhs(n, n.getParent())) {    return VariableLiveness.KILL; } else { return VariableLiveness.READ; } }   [CLASS] DeadAssignmentsElimination 1 VariableLiveness [METHOD] isVariableReadBeforeKill [RETURN_TYPE] DeadAssignmentsElimination$VariableLiveness  Node n String variable [VARIABLES] AbstractCompiler compiler boolean Node child n String variable VariableLiveness KILL MAYBE_LIVE READ state LiveVariablesAnalysis liveness Predicate matchRemovableAssigns  	projects/Closure88/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java	0.7745966692414834	326	326	6	add	
9	[BUG] [BUGGY] if (!ControlFlowGraph.isEnteringNewCfgNode(child)) { // Not a FUNCTION VariableLiveness state = isVariableReadBeforeKill(child, variable); [FE] AssertionFailedError [CONTEXT]  return VariableLiveness.KILL; } else { return VariableLiveness.READ; } }  for (Node child = n.getFirstChild(); child != null; child = child.getNext()) { [BUGGY] if (!ControlFlowGraph.isEnteringNewCfgNode(child)) { // Not a FUNCTION  VariableLiveness state = isVariableReadBeforeKill(child, variable); [BUGGY] VariableLiveness state = isVariableReadBeforeKill(child, variable); if (state != VariableLiveness.MAYBE_LIVE) { return state; } } } return VariableLiveness.MAYBE_LIVE; } [CLASS] DeadAssignmentsElimination 1 VariableLiveness [METHOD] isVariableReadBeforeKill [RETURN_TYPE] DeadAssignmentsElimination$VariableLiveness  Node n String variable [VARIABLES] AbstractCompiler compiler boolean Node child n String variable VariableLiveness KILL MAYBE_LIVE READ state LiveVariablesAnalysis liveness Predicate matchRemovableAssigns  	projects/Closure88/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java	0.7745966692414834	339	340	6	replace	
10	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT]  return VariableLiveness.KILL; } else { return VariableLiveness.READ; } }  for (Node child = n.getFirstChild(); child != null; child = child.getNext()) { [BUGGY] [BUGGY] if (!ControlFlowGraph.isEnteringNewCfgNode(child)) { // Not a FUNCTION  VariableLiveness state = isVariableReadBeforeKill(child, variable); VariableLiveness state = isVariableReadBeforeKill(child, variable); if (state != VariableLiveness.MAYBE_LIVE) { return state; } } } return VariableLiveness.MAYBE_LIVE; } [CLASS] DeadAssignmentsElimination 1 VariableLiveness [METHOD] isVariableReadBeforeKill [RETURN_TYPE] DeadAssignmentsElimination$VariableLiveness  Node n String variable [VARIABLES] AbstractCompiler compiler boolean Node child n String variable VariableLiveness KILL MAYBE_LIVE READ state LiveVariablesAnalysis liveness Predicate matchRemovableAssigns  	projects/Closure88/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java	0.7745966692414834	339	340	6	add	
11	[BUG] [BUGGY] VariableLiveness state = isVariableReadBeforeKill(child, variable); [FE] AssertionFailedError [CONTEXT] return VariableLiveness.KILL; } else { return VariableLiveness.READ; } }  for (Node child = n.getFirstChild(); child != null; child = child.getNext()) { if (!ControlFlowGraph.isEnteringNewCfgNode(child)) { // Not a FUNCTION [BUGGY] VariableLiveness state = isVariableReadBeforeKill(child, variable); [BUGGY] if (state != VariableLiveness.MAYBE_LIVE) { return state; } } } return VariableLiveness.MAYBE_LIVE; } [CLASS] DeadAssignmentsElimination 1 VariableLiveness [METHOD] isVariableReadBeforeKill [RETURN_TYPE] DeadAssignmentsElimination$VariableLiveness  Node n String variable [VARIABLES] AbstractCompiler compiler boolean Node child n String variable VariableLiveness KILL MAYBE_LIVE READ state LiveVariablesAnalysis liveness Predicate matchRemovableAssigns  	projects/Closure88/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java	0.7745966692414834	340	340	6	replace	
12	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] return VariableLiveness.KILL; } else { return VariableLiveness.READ; } }  for (Node child = n.getFirstChild(); child != null; child = child.getNext()) { if (!ControlFlowGraph.isEnteringNewCfgNode(child)) { // Not a FUNCTION [BUGGY] [BUGGY] VariableLiveness state = isVariableReadBeforeKill(child, variable); if (state != VariableLiveness.MAYBE_LIVE) { return state; } } } return VariableLiveness.MAYBE_LIVE; } [CLASS] DeadAssignmentsElimination 1 VariableLiveness [METHOD] isVariableReadBeforeKill [RETURN_TYPE] DeadAssignmentsElimination$VariableLiveness  Node n String variable [VARIABLES] AbstractCompiler compiler boolean Node child n String variable VariableLiveness KILL MAYBE_LIVE READ state LiveVariablesAnalysis liveness Predicate matchRemovableAssigns  	projects/Closure88/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java	0.7745966692414834	340	340	6	add	
13	[BUG] [BUGGY] if (state != VariableLiveness.MAYBE_LIVE) { [FE] AssertionFailedError [CONTEXT] } else { return VariableLiveness.READ; } }  for (Node child = n.getFirstChild(); child != null; child = child.getNext()) { if (!ControlFlowGraph.isEnteringNewCfgNode(child)) { // Not a FUNCTION VariableLiveness state = isVariableReadBeforeKill(child, variable); [BUGGY] if (state != VariableLiveness.MAYBE_LIVE) { [BUGGY] return state; } } } return VariableLiveness.MAYBE_LIVE; } [CLASS] DeadAssignmentsElimination 1 VariableLiveness [METHOD] isVariableReadBeforeKill [RETURN_TYPE] DeadAssignmentsElimination$VariableLiveness  Node n String variable [VARIABLES] AbstractCompiler compiler boolean Node child n String variable VariableLiveness KILL MAYBE_LIVE READ state LiveVariablesAnalysis liveness Predicate matchRemovableAssigns  	projects/Closure88/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java	0.7745966692414834	341	341	6	replace	
14	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] } else { return VariableLiveness.READ; } }  for (Node child = n.getFirstChild(); child != null; child = child.getNext()) { if (!ControlFlowGraph.isEnteringNewCfgNode(child)) { // Not a FUNCTION VariableLiveness state = isVariableReadBeforeKill(child, variable); [BUGGY] [BUGGY] if (state != VariableLiveness.MAYBE_LIVE) { return state; } } } return VariableLiveness.MAYBE_LIVE; } [CLASS] DeadAssignmentsElimination 1 VariableLiveness [METHOD] isVariableReadBeforeKill [RETURN_TYPE] DeadAssignmentsElimination$VariableLiveness  Node n String variable [VARIABLES] AbstractCompiler compiler boolean Node child n String variable VariableLiveness KILL MAYBE_LIVE READ state LiveVariablesAnalysis liveness Predicate matchRemovableAssigns  	projects/Closure88/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java	0.7745966692414834	341	341	6	add	
15	[BUG] [BUGGY] return state; [FE] AssertionFailedError [CONTEXT] return VariableLiveness.READ; } }  for (Node child = n.getFirstChild(); child != null; child = child.getNext()) { if (!ControlFlowGraph.isEnteringNewCfgNode(child)) { // Not a FUNCTION VariableLiveness state = isVariableReadBeforeKill(child, variable); if (state != VariableLiveness.MAYBE_LIVE) { [BUGGY] return state; [BUGGY] } } } return VariableLiveness.MAYBE_LIVE; } [CLASS] DeadAssignmentsElimination 1 VariableLiveness [METHOD] isVariableReadBeforeKill [RETURN_TYPE] DeadAssignmentsElimination$VariableLiveness  Node n String variable [VARIABLES] AbstractCompiler compiler boolean Node child n String variable VariableLiveness KILL MAYBE_LIVE READ state LiveVariablesAnalysis liveness Predicate matchRemovableAssigns  	projects/Closure88/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java	0.7745966692414834	342	342	6	replace	
16	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] return VariableLiveness.READ; } }  for (Node child = n.getFirstChild(); child != null; child = child.getNext()) { if (!ControlFlowGraph.isEnteringNewCfgNode(child)) { // Not a FUNCTION VariableLiveness state = isVariableReadBeforeKill(child, variable); if (state != VariableLiveness.MAYBE_LIVE) { [BUGGY] [BUGGY] return state; } } } return VariableLiveness.MAYBE_LIVE; } [CLASS] DeadAssignmentsElimination 1 VariableLiveness [METHOD] isVariableReadBeforeKill [RETURN_TYPE] DeadAssignmentsElimination$VariableLiveness  Node n String variable [VARIABLES] AbstractCompiler compiler boolean Node child n String variable VariableLiveness KILL MAYBE_LIVE READ state LiveVariablesAnalysis liveness Predicate matchRemovableAssigns  	projects/Closure88/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java	0.7745966692414834	342	342	6	add	
17	[BUG] [BUGGY] if (!ControlFlowGraph.isEnteringNewCfgNode(sibling)) { [FE] AssertionFailedError [CONTEXT] private boolean isVariableStillLiveWithinExpression( Node n, Node exprRoot, String variable) { while (n != exprRoot) { for(Node sibling = n.getNext(); sibling != null; sibling = sibling.getNext()) { [BUGGY] if (!ControlFlowGraph.isEnteringNewCfgNode(sibling)) { [BUGGY] VariableLiveness state = isVariableReadBeforeKill(sibling, variable);  if (state == VariableLiveness.READ) { return true; } else if (state == VariableLiveness.KILL) { return false; } } } [CLASS] DeadAssignmentsElimination 1 VariableLiveness [METHOD] isVariableStillLiveWithinExpression [RETURN_TYPE] boolean  Node n Node exprRoot String variable [VARIABLES] AbstractCompiler compiler boolean Node exprRoot n sibling String variable VariableLiveness KILL MAYBE_LIVE READ state LiveVariablesAnalysis liveness Predicate matchRemovableAssigns  	projects/Closure88/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java	0.7071067811865476	295	295	6	replace	
18	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] private boolean isVariableStillLiveWithinExpression( Node n, Node exprRoot, String variable) { while (n != exprRoot) { for(Node sibling = n.getNext(); sibling != null; sibling = sibling.getNext()) { [BUGGY] [BUGGY] if (!ControlFlowGraph.isEnteringNewCfgNode(sibling)) { VariableLiveness state = isVariableReadBeforeKill(sibling, variable);  if (state == VariableLiveness.READ) { return true; } else if (state == VariableLiveness.KILL) { return false; } } } [CLASS] DeadAssignmentsElimination 1 VariableLiveness [METHOD] isVariableStillLiveWithinExpression [RETURN_TYPE] boolean  Node n Node exprRoot String variable [VARIABLES] AbstractCompiler compiler boolean Node exprRoot n sibling String variable VariableLiveness KILL MAYBE_LIVE READ state LiveVariablesAnalysis liveness Predicate matchRemovableAssigns  	projects/Closure88/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java	0.7071067811865476	295	295	6	add	
19	[BUG] [BUGGY] VariableLiveness state = isVariableReadBeforeKill(sibling, variable); [FE] AssertionFailedError [CONTEXT] private boolean isVariableStillLiveWithinExpression( Node n, Node exprRoot, String variable) { while (n != exprRoot) { for(Node sibling = n.getNext(); sibling != null; sibling = sibling.getNext()) { if (!ControlFlowGraph.isEnteringNewCfgNode(sibling)) { [BUGGY] VariableLiveness state = isVariableReadBeforeKill(sibling, variable); [BUGGY]   if (state == VariableLiveness.READ) { return true; } else if (state == VariableLiveness.KILL) { return false; } } } n = n.getParent(); [CLASS] DeadAssignmentsElimination 1 VariableLiveness [METHOD] isVariableStillLiveWithinExpression [RETURN_TYPE] boolean  Node n Node exprRoot String variable [VARIABLES] AbstractCompiler compiler boolean Node exprRoot n sibling String variable VariableLiveness KILL MAYBE_LIVE READ state LiveVariablesAnalysis liveness Predicate matchRemovableAssigns  	projects/Closure88/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java	0.7071067811865476	296	296	6	replace	
20	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] private boolean isVariableStillLiveWithinExpression( Node n, Node exprRoot, String variable) { while (n != exprRoot) { for(Node sibling = n.getNext(); sibling != null; sibling = sibling.getNext()) { if (!ControlFlowGraph.isEnteringNewCfgNode(sibling)) { [BUGGY] [BUGGY] VariableLiveness state = isVariableReadBeforeKill(sibling, variable);  if (state == VariableLiveness.READ) { return true; } else if (state == VariableLiveness.KILL) { return false; } } } n = n.getParent(); [CLASS] DeadAssignmentsElimination 1 VariableLiveness [METHOD] isVariableStillLiveWithinExpression [RETURN_TYPE] boolean  Node n Node exprRoot String variable [VARIABLES] AbstractCompiler compiler boolean Node exprRoot n sibling String variable VariableLiveness KILL MAYBE_LIVE READ state LiveVariablesAnalysis liveness Predicate matchRemovableAssigns  	projects/Closure88/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java	0.7071067811865476	296	296	6	add	
21	[BUG] [BUGGY] if (state == VariableLiveness.READ) { [FE] AssertionFailedError [CONTEXT] private boolean isVariableStillLiveWithinExpression( Node n, Node exprRoot, String variable) { while (n != exprRoot) { for(Node sibling = n.getNext(); sibling != null; sibling = sibling.getNext()) { if (!ControlFlowGraph.isEnteringNewCfgNode(sibling)) { VariableLiveness state = isVariableReadBeforeKill(sibling, variable);  [BUGGY] if (state == VariableLiveness.READ) { [BUGGY] return true; } else if (state == VariableLiveness.KILL) { return false; } } } n = n.getParent(); } return false; } [CLASS] DeadAssignmentsElimination 1 VariableLiveness [METHOD] isVariableStillLiveWithinExpression [RETURN_TYPE] boolean  Node n Node exprRoot String variable [VARIABLES] AbstractCompiler compiler boolean Node exprRoot n sibling String variable VariableLiveness KILL MAYBE_LIVE READ state LiveVariablesAnalysis liveness Predicate matchRemovableAssigns  	projects/Closure88/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java	0.7071067811865476	299	299	6	replace	
22	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] private boolean isVariableStillLiveWithinExpression( Node n, Node exprRoot, String variable) { while (n != exprRoot) { for(Node sibling = n.getNext(); sibling != null; sibling = sibling.getNext()) { if (!ControlFlowGraph.isEnteringNewCfgNode(sibling)) { VariableLiveness state = isVariableReadBeforeKill(sibling, variable);  [BUGGY] [BUGGY] if (state == VariableLiveness.READ) { return true; } else if (state == VariableLiveness.KILL) { return false; } } } n = n.getParent(); } return false; } [CLASS] DeadAssignmentsElimination 1 VariableLiveness [METHOD] isVariableStillLiveWithinExpression [RETURN_TYPE] boolean  Node n Node exprRoot String variable [VARIABLES] AbstractCompiler compiler boolean Node exprRoot n sibling String variable VariableLiveness KILL MAYBE_LIVE READ state LiveVariablesAnalysis liveness Predicate matchRemovableAssigns  	projects/Closure88/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java	0.7071067811865476	299	299	6	add	
23	[BUG] [BUGGY] if (NodeUtil.isName(n) && variable.equals(n.getString())) { [FE] AssertionFailedError [CONTEXT] private VariableLiveness isVariableReadBeforeKill( Node n, String variable) { [BUGGY] if (NodeUtil.isName(n) && variable.equals(n.getString())) { [BUGGY] if (NodeUtil.isLhs(n, n.getParent())) {    return VariableLiveness.KILL; } else { return VariableLiveness.READ; } }  [CLASS] DeadAssignmentsElimination 1 VariableLiveness [METHOD] isVariableReadBeforeKill [RETURN_TYPE] DeadAssignmentsElimination$VariableLiveness  Node n String variable [VARIABLES] AbstractCompiler compiler boolean Node child n String variable VariableLiveness KILL MAYBE_LIVE READ state LiveVariablesAnalysis liveness Predicate matchRemovableAssigns  	projects/Closure88/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java	0.7071067811865476	325	325	6	replace	
24	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] private VariableLiveness isVariableReadBeforeKill( Node n, String variable) { [BUGGY] [BUGGY] if (NodeUtil.isName(n) && variable.equals(n.getString())) { if (NodeUtil.isLhs(n, n.getParent())) {    return VariableLiveness.KILL; } else { return VariableLiveness.READ; } }  [CLASS] DeadAssignmentsElimination 1 VariableLiveness [METHOD] isVariableReadBeforeKill [RETURN_TYPE] DeadAssignmentsElimination$VariableLiveness  Node n String variable [VARIABLES] AbstractCompiler compiler boolean Node child n String variable VariableLiveness KILL MAYBE_LIVE READ state LiveVariablesAnalysis liveness Predicate matchRemovableAssigns  	projects/Closure88/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java	0.7071067811865476	325	325	6	add	
25	[BUG] [BUGGY] for (Node child = n.getFirstChild(); [FE] AssertionFailedError [CONTEXT]    return VariableLiveness.KILL; } else { return VariableLiveness.READ; } }  [BUGGY] for (Node child = n.getFirstChild(); [BUGGY] child != null; child = child.getNext()) { if (!ControlFlowGraph.isEnteringNewCfgNode(child)) { // Not a FUNCTION VariableLiveness state = isVariableReadBeforeKill(child, variable); if (state != VariableLiveness.MAYBE_LIVE) { return state; } } } return VariableLiveness.MAYBE_LIVE; } [CLASS] DeadAssignmentsElimination 1 VariableLiveness [METHOD] isVariableReadBeforeKill [RETURN_TYPE] DeadAssignmentsElimination$VariableLiveness  Node n String variable [VARIABLES] AbstractCompiler compiler boolean Node child n String variable VariableLiveness KILL MAYBE_LIVE READ state LiveVariablesAnalysis liveness Predicate matchRemovableAssigns  	projects/Closure88/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java	0.7071067811865476	337	337	6	replace	
26	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT]    return VariableLiveness.KILL; } else { return VariableLiveness.READ; } }  [BUGGY] [BUGGY] for (Node child = n.getFirstChild(); child != null; child = child.getNext()) { if (!ControlFlowGraph.isEnteringNewCfgNode(child)) { // Not a FUNCTION VariableLiveness state = isVariableReadBeforeKill(child, variable); if (state != VariableLiveness.MAYBE_LIVE) { return state; } } } return VariableLiveness.MAYBE_LIVE; } [CLASS] DeadAssignmentsElimination 1 VariableLiveness [METHOD] isVariableReadBeforeKill [RETURN_TYPE] DeadAssignmentsElimination$VariableLiveness  Node n String variable [VARIABLES] AbstractCompiler compiler boolean Node child n String variable VariableLiveness KILL MAYBE_LIVE READ state LiveVariablesAnalysis liveness Predicate matchRemovableAssigns  	projects/Closure88/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java	0.7071067811865476	337	337	6	add	
27	[BUG] [BUGGY] child != null; child = child.getNext()) { [FE] AssertionFailedError [CONTEXT]   return VariableLiveness.KILL; } else { return VariableLiveness.READ; } }  for (Node child = n.getFirstChild(); [BUGGY] child != null; child = child.getNext()) { [BUGGY] if (!ControlFlowGraph.isEnteringNewCfgNode(child)) { // Not a FUNCTION VariableLiveness state = isVariableReadBeforeKill(child, variable); if (state != VariableLiveness.MAYBE_LIVE) { return state; } } } return VariableLiveness.MAYBE_LIVE; } [CLASS] DeadAssignmentsElimination 1 VariableLiveness [METHOD] isVariableReadBeforeKill [RETURN_TYPE] DeadAssignmentsElimination$VariableLiveness  Node n String variable [VARIABLES] AbstractCompiler compiler boolean Node child n String variable VariableLiveness KILL MAYBE_LIVE READ state LiveVariablesAnalysis liveness Predicate matchRemovableAssigns  	projects/Closure88/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java	0.7071067811865476	338	338	6	replace	
28	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT]   return VariableLiveness.KILL; } else { return VariableLiveness.READ; } }  for (Node child = n.getFirstChild(); [BUGGY] [BUGGY] child != null; child = child.getNext()) { if (!ControlFlowGraph.isEnteringNewCfgNode(child)) { // Not a FUNCTION VariableLiveness state = isVariableReadBeforeKill(child, variable); if (state != VariableLiveness.MAYBE_LIVE) { return state; } } } return VariableLiveness.MAYBE_LIVE; } [CLASS] DeadAssignmentsElimination 1 VariableLiveness [METHOD] isVariableReadBeforeKill [RETURN_TYPE] DeadAssignmentsElimination$VariableLiveness  Node n String variable [VARIABLES] AbstractCompiler compiler boolean Node child n String variable VariableLiveness KILL MAYBE_LIVE READ state LiveVariablesAnalysis liveness Predicate matchRemovableAssigns  	projects/Closure88/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java	0.7071067811865476	338	338	6	add	
29	[BUG] [BUGGY] if (n.hasChildren()) { [FE] AssertionFailedError [CONTEXT] continue; case Token.FOR: if (!NodeUtil.isForIn(n)) { tryRemoveAssignment( t, NodeUtil.getConditionExpression(n), state); } continue; case Token.SWITCH: case Token.CASE: case Token.RETURN: [BUGGY] if (n.hasChildren()) { [BUGGY] tryRemoveAssignment(t, n.getFirstChild(), state); } continue;  } tryRemoveAssignment(t, n, state); } } [CLASS] DeadAssignmentsElimination 1 VariableLiveness [METHOD] tryRemoveDeadAssignments [RETURN_TYPE] void  NodeTraversal t Node> cfg [VARIABLES] AbstractCompiler compiler DiGraphNode cfgNode FlowState state boolean Iterable nodes NodeTraversal t ControlFlowGraph cfg Node n VariableLiveness KILL MAYBE_LIVE READ LiveVariablesAnalysis liveness Predicate matchRemovableAssigns  	projects/Closure88/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java	0.5892556509887896	143	143	6	replace	
30	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] continue; case Token.FOR: if (!NodeUtil.isForIn(n)) { tryRemoveAssignment( t, NodeUtil.getConditionExpression(n), state); } continue; case Token.SWITCH: case Token.CASE: case Token.RETURN: [BUGGY] [BUGGY] if (n.hasChildren()) { tryRemoveAssignment(t, n.getFirstChild(), state); } continue;  } tryRemoveAssignment(t, n, state); } } [CLASS] DeadAssignmentsElimination 1 VariableLiveness [METHOD] tryRemoveDeadAssignments [RETURN_TYPE] void  NodeTraversal t Node> cfg [VARIABLES] AbstractCompiler compiler DiGraphNode cfgNode FlowState state boolean Iterable nodes NodeTraversal t ControlFlowGraph cfg Node n VariableLiveness KILL MAYBE_LIVE READ LiveVariablesAnalysis liveness Predicate matchRemovableAssigns  	projects/Closure88/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java	0.5892556509887896	143	143	6	add	
31	[BUG] [BUGGY] tryRemoveAssignment(t, n.getFirstChild(), state); [FE] AssertionFailedError [CONTEXT] case Token.FOR: if (!NodeUtil.isForIn(n)) { tryRemoveAssignment( t, NodeUtil.getConditionExpression(n), state); } continue; case Token.SWITCH: case Token.CASE: case Token.RETURN: if (n.hasChildren()) { [BUGGY] tryRemoveAssignment(t, n.getFirstChild(), state); [BUGGY] } continue;  } tryRemoveAssignment(t, n, state); } } [CLASS] DeadAssignmentsElimination 1 VariableLiveness [METHOD] tryRemoveDeadAssignments [RETURN_TYPE] void  NodeTraversal t Node> cfg [VARIABLES] AbstractCompiler compiler DiGraphNode cfgNode FlowState state boolean Iterable nodes NodeTraversal t ControlFlowGraph cfg Node n VariableLiveness KILL MAYBE_LIVE READ LiveVariablesAnalysis liveness Predicate matchRemovableAssigns  	projects/Closure88/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java	0.5892556509887896	144	144	6	replace	
32	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] case Token.FOR: if (!NodeUtil.isForIn(n)) { tryRemoveAssignment( t, NodeUtil.getConditionExpression(n), state); } continue; case Token.SWITCH: case Token.CASE: case Token.RETURN: if (n.hasChildren()) { [BUGGY] [BUGGY] tryRemoveAssignment(t, n.getFirstChild(), state); } continue;  } tryRemoveAssignment(t, n, state); } } [CLASS] DeadAssignmentsElimination 1 VariableLiveness [METHOD] tryRemoveDeadAssignments [RETURN_TYPE] void  NodeTraversal t Node> cfg [VARIABLES] AbstractCompiler compiler DiGraphNode cfgNode FlowState state boolean Iterable nodes NodeTraversal t ControlFlowGraph cfg Node n VariableLiveness KILL MAYBE_LIVE READ LiveVariablesAnalysis liveness Predicate matchRemovableAssigns  	projects/Closure88/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java	0.5892556509887896	144	144	6	add	
33	[BUG] [BUGGY] for(Node sibling = n.getNext(); sibling != null; [FE] AssertionFailedError [CONTEXT] private boolean isVariableStillLiveWithinExpression( Node n, Node exprRoot, String variable) { while (n != exprRoot) { [BUGGY] for(Node sibling = n.getNext(); sibling != null; [BUGGY] sibling = sibling.getNext()) { if (!ControlFlowGraph.isEnteringNewCfgNode(sibling)) { VariableLiveness state = isVariableReadBeforeKill(sibling, variable);  if (state == VariableLiveness.READ) { return true; } else if (state == VariableLiveness.KILL) { return false; } [CLASS] DeadAssignmentsElimination 1 VariableLiveness [METHOD] isVariableStillLiveWithinExpression [RETURN_TYPE] boolean  Node n Node exprRoot String variable [VARIABLES] AbstractCompiler compiler boolean Node exprRoot n sibling String variable VariableLiveness KILL MAYBE_LIVE READ state LiveVariablesAnalysis liveness Predicate matchRemovableAssigns  	projects/Closure88/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java	0.5619514869490164	293	293	6	replace	
34	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] private boolean isVariableStillLiveWithinExpression( Node n, Node exprRoot, String variable) { while (n != exprRoot) { [BUGGY] [BUGGY] for(Node sibling = n.getNext(); sibling != null; sibling = sibling.getNext()) { if (!ControlFlowGraph.isEnteringNewCfgNode(sibling)) { VariableLiveness state = isVariableReadBeforeKill(sibling, variable);  if (state == VariableLiveness.READ) { return true; } else if (state == VariableLiveness.KILL) { return false; } [CLASS] DeadAssignmentsElimination 1 VariableLiveness [METHOD] isVariableStillLiveWithinExpression [RETURN_TYPE] boolean  Node n Node exprRoot String variable [VARIABLES] AbstractCompiler compiler boolean Node exprRoot n sibling String variable VariableLiveness KILL MAYBE_LIVE READ state LiveVariablesAnalysis liveness Predicate matchRemovableAssigns  	projects/Closure88/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java	0.5619514869490164	293	293	6	add	
35	[BUG] [BUGGY] while (n != exprRoot) { [FE] AssertionFailedError [CONTEXT] private boolean isVariableStillLiveWithinExpression( Node n, Node exprRoot, String variable) { [BUGGY] while (n != exprRoot) { [BUGGY] for(Node sibling = n.getNext(); sibling != null; sibling = sibling.getNext()) { if (!ControlFlowGraph.isEnteringNewCfgNode(sibling)) { VariableLiveness state = isVariableReadBeforeKill(sibling, variable);  if (state == VariableLiveness.READ) { return true; } else if (state == VariableLiveness.KILL) { return false; [CLASS] DeadAssignmentsElimination 1 VariableLiveness [METHOD] isVariableStillLiveWithinExpression [RETURN_TYPE] boolean  Node n Node exprRoot String variable [VARIABLES] AbstractCompiler compiler boolean Node exprRoot n sibling String variable VariableLiveness KILL MAYBE_LIVE READ state LiveVariablesAnalysis liveness Predicate matchRemovableAssigns  	projects/Closure88/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java	0.5477225575051661	292	292	6	replace	
36	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] private boolean isVariableStillLiveWithinExpression( Node n, Node exprRoot, String variable) { [BUGGY] [BUGGY] while (n != exprRoot) { for(Node sibling = n.getNext(); sibling != null; sibling = sibling.getNext()) { if (!ControlFlowGraph.isEnteringNewCfgNode(sibling)) { VariableLiveness state = isVariableReadBeforeKill(sibling, variable);  if (state == VariableLiveness.READ) { return true; } else if (state == VariableLiveness.KILL) { return false; [CLASS] DeadAssignmentsElimination 1 VariableLiveness [METHOD] isVariableStillLiveWithinExpression [RETURN_TYPE] boolean  Node n Node exprRoot String variable [VARIABLES] AbstractCompiler compiler boolean Node exprRoot n sibling String variable VariableLiveness KILL MAYBE_LIVE READ state LiveVariablesAnalysis liveness Predicate matchRemovableAssigns  	projects/Closure88/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java	0.5477225575051661	292	292	6	add	
37	[BUG] [BUGGY] n = n.getParent(); [FE] AssertionFailedError [CONTEXT] VariableLiveness state = isVariableReadBeforeKill(sibling, variable);  if (state == VariableLiveness.READ) { return true; } else if (state == VariableLiveness.KILL) { return false; } } } [BUGGY] n = n.getParent(); [BUGGY] } return false; } [CLASS] DeadAssignmentsElimination 1 VariableLiveness [METHOD] isVariableStillLiveWithinExpression [RETURN_TYPE] boolean  Node n Node exprRoot String variable [VARIABLES] AbstractCompiler compiler boolean Node exprRoot n sibling String variable VariableLiveness KILL MAYBE_LIVE READ state LiveVariablesAnalysis liveness Predicate matchRemovableAssigns  	projects/Closure88/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java	0.4811252243246881	306	306	6	replace	
38	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] VariableLiveness state = isVariableReadBeforeKill(sibling, variable);  if (state == VariableLiveness.READ) { return true; } else if (state == VariableLiveness.KILL) { return false; } } } [BUGGY] [BUGGY] n = n.getParent(); } return false; } [CLASS] DeadAssignmentsElimination 1 VariableLiveness [METHOD] isVariableStillLiveWithinExpression [RETURN_TYPE] boolean  Node n Node exprRoot String variable [VARIABLES] AbstractCompiler compiler boolean Node exprRoot n sibling String variable VariableLiveness KILL MAYBE_LIVE READ state LiveVariablesAnalysis liveness Predicate matchRemovableAssigns  	projects/Closure88/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java	0.4811252243246881	306	306	6	add	
39	[BUG] [BUGGY] n.removeChild(rhs); [FE] AssertionFailedError [CONTEXT]       return; } if (NodeUtil.isAssign(n)) { [BUGGY] n.removeChild(rhs); [BUGGY] n.getParent().replaceChild(n, rhs); } else if (NodeUtil.isAssignmentOp(n)) { n.removeChild(rhs); n.removeChild(lhs); Node op = new Node(NodeUtil.getOpFromAssignmentOp(n), lhs, rhs); parent.replaceChild(n, op); } else if (n.getType() == Token.INC || n.getType() == Token.DEC) { if (NodeUtil.isExpressionNode(parent)) { parent.replaceChild(n, new Node(Token.VOID, Node.newNumber(0).copyInformationFrom(n))); [CLASS] DeadAssignmentsElimination 1 VariableLiveness [METHOD] tryRemoveAssignment [RETURN_TYPE] void  NodeTraversal t Node n Node exprRoot LiveVariableLattice> state [VARIABLES] AbstractCompiler compiler FlowState state boolean Scope scope NodeTraversal t Var var Node c exprRoot lhs n next op parent rhs String name VariableLiveness KILL MAYBE_LIVE READ LiveVariablesAnalysis liveness Predicate matchRemovableAssigns  	projects/Closure88/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java	0.48038446141526137	234	234	6	replace	
40	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT]       return; } if (NodeUtil.isAssign(n)) { [BUGGY] [BUGGY] n.removeChild(rhs); n.getParent().replaceChild(n, rhs); } else if (NodeUtil.isAssignmentOp(n)) { n.removeChild(rhs); n.removeChild(lhs); Node op = new Node(NodeUtil.getOpFromAssignmentOp(n), lhs, rhs); parent.replaceChild(n, op); } else if (n.getType() == Token.INC || n.getType() == Token.DEC) { if (NodeUtil.isExpressionNode(parent)) { parent.replaceChild(n, new Node(Token.VOID, Node.newNumber(0).copyInformationFrom(n))); [CLASS] DeadAssignmentsElimination 1 VariableLiveness [METHOD] tryRemoveAssignment [RETURN_TYPE] void  NodeTraversal t Node n Node exprRoot LiveVariableLattice> state [VARIABLES] AbstractCompiler compiler FlowState state boolean Scope scope NodeTraversal t Var var Node c exprRoot lhs n next op parent rhs String name VariableLiveness KILL MAYBE_LIVE READ LiveVariablesAnalysis liveness Predicate matchRemovableAssigns  	projects/Closure88/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java	0.48038446141526137	234	234	6	add	
41	[BUG] [BUGGY] n.getParent().replaceChild(n, rhs); [FE] AssertionFailedError [CONTEXT]      return; } if (NodeUtil.isAssign(n)) { n.removeChild(rhs); [BUGGY] n.getParent().replaceChild(n, rhs); [BUGGY] } else if (NodeUtil.isAssignmentOp(n)) { n.removeChild(rhs); n.removeChild(lhs); Node op = new Node(NodeUtil.getOpFromAssignmentOp(n), lhs, rhs); parent.replaceChild(n, op); } else if (n.getType() == Token.INC || n.getType() == Token.DEC) { if (NodeUtil.isExpressionNode(parent)) { parent.replaceChild(n, new Node(Token.VOID, Node.newNumber(0).copyInformationFrom(n))); } else if(n.getType() == Token.COMMA && n != parent.getLastChild()) { [CLASS] DeadAssignmentsElimination 1 VariableLiveness [METHOD] tryRemoveAssignment [RETURN_TYPE] void  NodeTraversal t Node n Node exprRoot LiveVariableLattice> state [VARIABLES] AbstractCompiler compiler FlowState state boolean Scope scope NodeTraversal t Var var Node c exprRoot lhs n next op parent rhs String name VariableLiveness KILL MAYBE_LIVE READ LiveVariablesAnalysis liveness Predicate matchRemovableAssigns  	projects/Closure88/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java	0.48038446141526137	235	235	6	replace	
42	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT]      return; } if (NodeUtil.isAssign(n)) { n.removeChild(rhs); [BUGGY] [BUGGY] n.getParent().replaceChild(n, rhs); } else if (NodeUtil.isAssignmentOp(n)) { n.removeChild(rhs); n.removeChild(lhs); Node op = new Node(NodeUtil.getOpFromAssignmentOp(n), lhs, rhs); parent.replaceChild(n, op); } else if (n.getType() == Token.INC || n.getType() == Token.DEC) { if (NodeUtil.isExpressionNode(parent)) { parent.replaceChild(n, new Node(Token.VOID, Node.newNumber(0).copyInformationFrom(n))); } else if(n.getType() == Token.COMMA && n != parent.getLastChild()) { [CLASS] DeadAssignmentsElimination 1 VariableLiveness [METHOD] tryRemoveAssignment [RETURN_TYPE] void  NodeTraversal t Node n Node exprRoot LiveVariableLattice> state [VARIABLES] AbstractCompiler compiler FlowState state boolean Scope scope NodeTraversal t Var var Node c exprRoot lhs n next op parent rhs String name VariableLiveness KILL MAYBE_LIVE READ LiveVariablesAnalysis liveness Predicate matchRemovableAssigns  	projects/Closure88/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java	0.48038446141526137	235	235	6	add	
43	[BUG] [BUGGY] return false; [FE] AssertionFailedError [CONTEXT]  if (state == VariableLiveness.READ) { return true; } else if (state == VariableLiveness.KILL) { return false; } } } n = n.getParent(); } [BUGGY] return false; [BUGGY] } [CLASS] DeadAssignmentsElimination 1 VariableLiveness [METHOD] isVariableStillLiveWithinExpression [RETURN_TYPE] boolean  Node n Node exprRoot String variable [VARIABLES] AbstractCompiler compiler boolean Node exprRoot n sibling String variable VariableLiveness KILL MAYBE_LIVE READ state LiveVariablesAnalysis liveness Predicate matchRemovableAssigns  	projects/Closure88/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java	0.468292905790847	308	308	6	replace	
44	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT]  if (state == VariableLiveness.READ) { return true; } else if (state == VariableLiveness.KILL) { return false; } } } n = n.getParent(); } [BUGGY] [BUGGY] return false; } [CLASS] DeadAssignmentsElimination 1 VariableLiveness [METHOD] isVariableStillLiveWithinExpression [RETURN_TYPE] boolean  Node n Node exprRoot String variable [VARIABLES] AbstractCompiler compiler boolean Node exprRoot n sibling String variable VariableLiveness KILL MAYBE_LIVE READ state LiveVariablesAnalysis liveness Predicate matchRemovableAssigns  	projects/Closure88/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java	0.468292905790847	308	308	6	add	
45	[BUG] [BUGGY] compiler.reportCodeChange(); [FE] AssertionFailedError [CONTEXT] } else {   return; } } else {  Preconditions.checkState(false, "Unknown statement"); } [BUGGY] compiler.reportCodeChange(); [BUGGY] return; } else { for (Node c = n.getFirstChild(); c != null;) { Node next = c.getNext(); if (!ControlFlowGraph.isEnteringNewCfgNode(c)) { tryRemoveAssignment(t, c, exprRoot, state); } c = next; } [CLASS] DeadAssignmentsElimination 1 VariableLiveness [METHOD] tryRemoveAssignment [RETURN_TYPE] void  NodeTraversal t Node n Node exprRoot LiveVariableLattice> state [VARIABLES] AbstractCompiler compiler FlowState state boolean Scope scope NodeTraversal t Var var Node c exprRoot lhs n next op parent rhs String name VariableLiveness KILL MAYBE_LIVE READ LiveVariablesAnalysis liveness Predicate matchRemovableAssigns  	projects/Closure88/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java	0.454858826147342	260	260	6	replace	
46	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] } else {   return; } } else {  Preconditions.checkState(false, "Unknown statement"); } [BUGGY] [BUGGY] compiler.reportCodeChange(); return; } else { for (Node c = n.getFirstChild(); c != null;) { Node next = c.getNext(); if (!ControlFlowGraph.isEnteringNewCfgNode(c)) { tryRemoveAssignment(t, c, exprRoot, state); } c = next; } [CLASS] DeadAssignmentsElimination 1 VariableLiveness [METHOD] tryRemoveAssignment [RETURN_TYPE] void  NodeTraversal t Node n Node exprRoot LiveVariableLattice> state [VARIABLES] AbstractCompiler compiler FlowState state boolean Scope scope NodeTraversal t Var var Node c exprRoot lhs n next op parent rhs String name VariableLiveness KILL MAYBE_LIVE READ LiveVariablesAnalysis liveness Predicate matchRemovableAssigns  	projects/Closure88/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java	0.454858826147342	260	260	6	add	
47	[BUG] [BUGGY] return; [FE] AssertionFailedError [CONTEXT]   return; } } else {  Preconditions.checkState(false, "Unknown statement"); } compiler.reportCodeChange(); [BUGGY] return; [BUGGY]  } else { for (Node c = n.getFirstChild(); c != null;) { Node next = c.getNext(); if (!ControlFlowGraph.isEnteringNewCfgNode(c)) { tryRemoveAssignment(t, c, exprRoot, state); } c = next; } return; [CLASS] DeadAssignmentsElimination 1 VariableLiveness [METHOD] tryRemoveAssignment [RETURN_TYPE] void  NodeTraversal t Node n Node exprRoot LiveVariableLattice> state [VARIABLES] AbstractCompiler compiler FlowState state boolean Scope scope NodeTraversal t Var var Node c exprRoot lhs n next op parent rhs String name VariableLiveness KILL MAYBE_LIVE READ LiveVariablesAnalysis liveness Predicate matchRemovableAssigns  	projects/Closure88/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java	0.454858826147342	261	261	6	replace	
48	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT]   return; } } else {  Preconditions.checkState(false, "Unknown statement"); } compiler.reportCodeChange(); [BUGGY] [BUGGY] return; } else { for (Node c = n.getFirstChild(); c != null;) { Node next = c.getNext(); if (!ControlFlowGraph.isEnteringNewCfgNode(c)) { tryRemoveAssignment(t, c, exprRoot, state); } c = next; } return; [CLASS] DeadAssignmentsElimination 1 VariableLiveness [METHOD] tryRemoveAssignment [RETURN_TYPE] void  NodeTraversal t Node n Node exprRoot LiveVariableLattice> state [VARIABLES] AbstractCompiler compiler FlowState state boolean Scope scope NodeTraversal t Var var Node c exprRoot lhs n next op parent rhs String name VariableLiveness KILL MAYBE_LIVE READ LiveVariablesAnalysis liveness Predicate matchRemovableAssigns  	projects/Closure88/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java	0.454858826147342	261	261	6	add	
49	[BUG] [BUGGY] if (state.getIn().isLive(var) && isVariableStillLiveWithinExpression(n, exprRoot, var.name)) { [FE] AssertionFailedError [CONTEXT] n.removeChild(rhs); n.getParent().replaceChild(n, rhs); compiler.reportCodeChange(); return; } if (state.getOut().isLive(var)) { return; // Variable not dead. } [BUGGY] if (state.getIn().isLive(var) &&   isVariableStillLiveWithinExpression(n, exprRoot, var.name)) { [BUGGY] isVariableStillLiveWithinExpression(n, exprRoot, var.name)) {          [CLASS] DeadAssignmentsElimination 1 VariableLiveness [METHOD] tryRemoveAssignment [RETURN_TYPE] void  NodeTraversal t Node n Node exprRoot LiveVariableLattice> state [VARIABLES] AbstractCompiler compiler FlowState state boolean Scope scope NodeTraversal t Var var Node c exprRoot lhs n next op parent rhs String name VariableLiveness KILL MAYBE_LIVE READ LiveVariablesAnalysis liveness Predicate matchRemovableAssigns  	projects/Closure88/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java	0.4472135954999579	218	219	6	replace	
50	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] n.removeChild(rhs); n.getParent().replaceChild(n, rhs); compiler.reportCodeChange(); return; } if (state.getOut().isLive(var)) { return; // Variable not dead. } [BUGGY] [BUGGY] if (state.getIn().isLive(var) &&   isVariableStillLiveWithinExpression(n, exprRoot, var.name)) { isVariableStillLiveWithinExpression(n, exprRoot, var.name)) {          [CLASS] DeadAssignmentsElimination 1 VariableLiveness [METHOD] tryRemoveAssignment [RETURN_TYPE] void  NodeTraversal t Node n Node exprRoot LiveVariableLattice> state [VARIABLES] AbstractCompiler compiler FlowState state boolean Scope scope NodeTraversal t Var var Node c exprRoot lhs n next op parent rhs String name VariableLiveness KILL MAYBE_LIVE READ LiveVariablesAnalysis liveness Predicate matchRemovableAssigns  	projects/Closure88/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java	0.4472135954999579	218	219	6	add	
51	[BUG] [BUGGY] if (NodeUtil.isAssign(n)) { [FE] AssertionFailedError [CONTEXT]        return; } [BUGGY] if (NodeUtil.isAssign(n)) { [BUGGY] n.removeChild(rhs); n.getParent().replaceChild(n, rhs); } else if (NodeUtil.isAssignmentOp(n)) { n.removeChild(rhs); n.removeChild(lhs); Node op = new Node(NodeUtil.getOpFromAssignmentOp(n), lhs, rhs); parent.replaceChild(n, op); } else if (n.getType() == Token.INC || n.getType() == Token.DEC) { if (NodeUtil.isExpressionNode(parent)) { parent.replaceChild(n, [CLASS] DeadAssignmentsElimination 1 VariableLiveness [METHOD] tryRemoveAssignment [RETURN_TYPE] void  NodeTraversal t Node n Node exprRoot LiveVariableLattice> state [VARIABLES] AbstractCompiler compiler FlowState state boolean Scope scope NodeTraversal t Var var Node c exprRoot lhs n next op parent rhs String name VariableLiveness KILL MAYBE_LIVE READ LiveVariablesAnalysis liveness Predicate matchRemovableAssigns  	projects/Closure88/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java	0.4472135954999579	233	233	6	replace	
52	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT]        return; } [BUGGY] [BUGGY] if (NodeUtil.isAssign(n)) { n.removeChild(rhs); n.getParent().replaceChild(n, rhs); } else if (NodeUtil.isAssignmentOp(n)) { n.removeChild(rhs); n.removeChild(lhs); Node op = new Node(NodeUtil.getOpFromAssignmentOp(n), lhs, rhs); parent.replaceChild(n, op); } else if (n.getType() == Token.INC || n.getType() == Token.DEC) { if (NodeUtil.isExpressionNode(parent)) { parent.replaceChild(n, [CLASS] DeadAssignmentsElimination 1 VariableLiveness [METHOD] tryRemoveAssignment [RETURN_TYPE] void  NodeTraversal t Node n Node exprRoot LiveVariableLattice> state [VARIABLES] AbstractCompiler compiler FlowState state boolean Scope scope NodeTraversal t Var var Node c exprRoot lhs n next op parent rhs String name VariableLiveness KILL MAYBE_LIVE READ LiveVariablesAnalysis liveness Predicate matchRemovableAssigns  	projects/Closure88/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java	0.4472135954999579	233	233	6	add	
53	[BUG] [BUGGY] if (state.getOut().isLive(var)) { [FE] AssertionFailedError [CONTEXT] if (rhs != null && NodeUtil.isName(rhs) && rhs.getString().equals(var.name) && NodeUtil.isAssign(n)) { n.removeChild(rhs); n.getParent().replaceChild(n, rhs); compiler.reportCodeChange(); return; } [BUGGY] if (state.getOut().isLive(var)) { [BUGGY] return; // Variable not dead. } if (state.getIn().isLive(var) && isVariableStillLiveWithinExpression(n, exprRoot, var.name)) {      [CLASS] DeadAssignmentsElimination 1 VariableLiveness [METHOD] tryRemoveAssignment [RETURN_TYPE] void  NodeTraversal t Node n Node exprRoot LiveVariableLattice> state [VARIABLES] AbstractCompiler compiler FlowState state boolean Scope scope NodeTraversal t Var var Node c exprRoot lhs n next op parent rhs String name VariableLiveness KILL MAYBE_LIVE READ LiveVariablesAnalysis liveness Predicate matchRemovableAssigns  	projects/Closure88/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java	0.41403933560541256	214	214	6	replace	
54	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] if (rhs != null && NodeUtil.isName(rhs) && rhs.getString().equals(var.name) && NodeUtil.isAssign(n)) { n.removeChild(rhs); n.getParent().replaceChild(n, rhs); compiler.reportCodeChange(); return; } [BUGGY] [BUGGY] if (state.getOut().isLive(var)) { return; // Variable not dead. } if (state.getIn().isLive(var) && isVariableStillLiveWithinExpression(n, exprRoot, var.name)) {      [CLASS] DeadAssignmentsElimination 1 VariableLiveness [METHOD] tryRemoveAssignment [RETURN_TYPE] void  NodeTraversal t Node n Node exprRoot LiveVariableLattice> state [VARIABLES] AbstractCompiler compiler FlowState state boolean Scope scope NodeTraversal t Var var Node c exprRoot lhs n next op parent rhs String name VariableLiveness KILL MAYBE_LIVE READ LiveVariablesAnalysis liveness Predicate matchRemovableAssigns  	projects/Closure88/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java	0.41403933560541256	214	214	6	add	
55	[BUG] [BUGGY] Var var = scope.getVar(name); [FE] AssertionFailedError [CONTEXT] } Scope scope = t.getScope(); if (!NodeUtil.isName(lhs)) { return; // Not a local variable assignment. } String name = lhs.getString(); if (!scope.isDeclared(name, false)) { return; } [BUGGY] Var var = scope.getVar(name); [BUGGY]  if (liveness.getEscapedLocals().contains(var)) { return; // Local variable that might be escaped due to closures. }    if (rhs != null && NodeUtil.isName(rhs) && [CLASS] DeadAssignmentsElimination 1 VariableLiveness [METHOD] tryRemoveAssignment [RETURN_TYPE] void  NodeTraversal t Node n Node exprRoot LiveVariableLattice> state [VARIABLES] AbstractCompiler compiler FlowState state boolean Scope scope NodeTraversal t Var var Node c exprRoot lhs n next op parent rhs String name VariableLiveness KILL MAYBE_LIVE READ LiveVariablesAnalysis liveness Predicate matchRemovableAssigns  	projects/Closure88/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java	0.4026936331284146	195	195	6	replace	
56	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] } Scope scope = t.getScope(); if (!NodeUtil.isName(lhs)) { return; // Not a local variable assignment. } String name = lhs.getString(); if (!scope.isDeclared(name, false)) { return; } [BUGGY] [BUGGY] Var var = scope.getVar(name); if (liveness.getEscapedLocals().contains(var)) { return; // Local variable that might be escaped due to closures. }    if (rhs != null && NodeUtil.isName(rhs) && [CLASS] DeadAssignmentsElimination 1 VariableLiveness [METHOD] tryRemoveAssignment [RETURN_TYPE] void  NodeTraversal t Node n Node exprRoot LiveVariableLattice> state [VARIABLES] AbstractCompiler compiler FlowState state boolean Scope scope NodeTraversal t Var var Node c exprRoot lhs n next op parent rhs String name VariableLiveness KILL MAYBE_LIVE READ LiveVariablesAnalysis liveness Predicate matchRemovableAssigns  	projects/Closure88/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java	0.4026936331284146	195	195	6	add	
57	[BUG] [BUGGY] if (liveness.getEscapedLocals().contains(var)) { [FE] AssertionFailedError [CONTEXT] Scope scope = t.getScope(); if (!NodeUtil.isName(lhs)) { return; // Not a local variable assignment. } String name = lhs.getString(); if (!scope.isDeclared(name, false)) { return; } Var var = scope.getVar(name); [BUGGY] if (liveness.getEscapedLocals().contains(var)) { [BUGGY] return; // Local variable that might be escaped due to closures. }    if (rhs != null && NodeUtil.isName(rhs) && rhs.getString().equals(var.name) && NodeUtil.isAssign(n)) { [CLASS] DeadAssignmentsElimination 1 VariableLiveness [METHOD] tryRemoveAssignment [RETURN_TYPE] void  NodeTraversal t Node n Node exprRoot LiveVariableLattice> state [VARIABLES] AbstractCompiler compiler FlowState state boolean Scope scope NodeTraversal t Var var Node c exprRoot lhs n next op parent rhs String name VariableLiveness KILL MAYBE_LIVE READ LiveVariablesAnalysis liveness Predicate matchRemovableAssigns  	projects/Closure88/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java	0.4026936331284146	197	197	6	replace	
58	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] Scope scope = t.getScope(); if (!NodeUtil.isName(lhs)) { return; // Not a local variable assignment. } String name = lhs.getString(); if (!scope.isDeclared(name, false)) { return; } Var var = scope.getVar(name); [BUGGY] [BUGGY] if (liveness.getEscapedLocals().contains(var)) { return; // Local variable that might be escaped due to closures. }    if (rhs != null && NodeUtil.isName(rhs) && rhs.getString().equals(var.name) && NodeUtil.isAssign(n)) { [CLASS] DeadAssignmentsElimination 1 VariableLiveness [METHOD] tryRemoveAssignment [RETURN_TYPE] void  NodeTraversal t Node n Node exprRoot LiveVariableLattice> state [VARIABLES] AbstractCompiler compiler FlowState state boolean Scope scope NodeTraversal t Var var Node c exprRoot lhs n next op parent rhs String name VariableLiveness KILL MAYBE_LIVE READ LiveVariablesAnalysis liveness Predicate matchRemovableAssigns  	projects/Closure88/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java	0.4026936331284146	197	197	6	add	
59	[BUG] [BUGGY] if (rhs != null && NodeUtil.isName(rhs) &&  rhs.getString().equals(var.name) && [FE] AssertionFailedError [CONTEXT] } Var var = scope.getVar(name); if (liveness.getEscapedLocals().contains(var)) { return; // Local variable that might be escaped due to closures. }    [BUGGY] if (rhs != null &&   NodeUtil.isName(rhs) &&     rhs.getString().equals(var.name) && [BUGGY] NodeUtil.isName(rhs) && rhs.getString().equals(var.name) && NodeUtil.isAssign(n)) { n.removeChild(rhs); n.getParent().replaceChild(n, rhs); compiler.reportCodeChange(); return; } if (state.getOut().isLive(var)) { [CLASS] DeadAssignmentsElimination 1 VariableLiveness [METHOD] tryRemoveAssignment [RETURN_TYPE] void  NodeTraversal t Node n Node exprRoot LiveVariableLattice> state [VARIABLES] AbstractCompiler compiler FlowState state boolean Scope scope NodeTraversal t Var var Node c exprRoot lhs n next op parent rhs String name VariableLiveness KILL MAYBE_LIVE READ LiveVariablesAnalysis liveness Predicate matchRemovableAssigns  	projects/Closure88/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java	0.4026936331284146	204	206	6	replace	
60	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] } Var var = scope.getVar(name); if (liveness.getEscapedLocals().contains(var)) { return; // Local variable that might be escaped due to closures. }    [BUGGY] [BUGGY] if (rhs != null &&   NodeUtil.isName(rhs) &&     rhs.getString().equals(var.name) && NodeUtil.isName(rhs) && rhs.getString().equals(var.name) && NodeUtil.isAssign(n)) { n.removeChild(rhs); n.getParent().replaceChild(n, rhs); compiler.reportCodeChange(); return; } if (state.getOut().isLive(var)) { [CLASS] DeadAssignmentsElimination 1 VariableLiveness [METHOD] tryRemoveAssignment [RETURN_TYPE] void  NodeTraversal t Node n Node exprRoot LiveVariableLattice> state [VARIABLES] AbstractCompiler compiler FlowState state boolean Scope scope NodeTraversal t Var var Node c exprRoot lhs n next op parent rhs String name VariableLiveness KILL MAYBE_LIVE READ LiveVariablesAnalysis liveness Predicate matchRemovableAssigns  	projects/Closure88/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java	0.4026936331284146	204	206	6	add	
61	[BUG] [BUGGY] tryRemoveAssignment(t, rhs, exprRoot, state); [FE] AssertionFailedError [CONTEXT] if (NodeUtil.isAssignmentOp(n) || n.getType() == Token.INC || n.getType() == Token.DEC) { Node lhs = n.getFirstChild(); Node rhs = lhs.getNext();   if (rhs != null) { [BUGGY] tryRemoveAssignment(t, rhs, exprRoot, state); [BUGGY] rhs = lhs.getNext(); } Scope scope = t.getScope(); if (!NodeUtil.isName(lhs)) { return; // Not a local variable assignment. } String name = lhs.getString(); if (!scope.isDeclared(name, false)) { return; [CLASS] DeadAssignmentsElimination 1 VariableLiveness [METHOD] tryRemoveAssignment [RETURN_TYPE] void  NodeTraversal t Node n Node exprRoot LiveVariableLattice> state [VARIABLES] AbstractCompiler compiler FlowState state boolean Scope scope NodeTraversal t Var var Node c exprRoot lhs n next op parent rhs String name VariableLiveness KILL MAYBE_LIVE READ LiveVariablesAnalysis liveness Predicate matchRemovableAssigns  	projects/Closure88/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java	0.39735970711951313	183	183	6	replace	
62	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] if (NodeUtil.isAssignmentOp(n) || n.getType() == Token.INC || n.getType() == Token.DEC) { Node lhs = n.getFirstChild(); Node rhs = lhs.getNext();   if (rhs != null) { [BUGGY] [BUGGY] tryRemoveAssignment(t, rhs, exprRoot, state); rhs = lhs.getNext(); } Scope scope = t.getScope(); if (!NodeUtil.isName(lhs)) { return; // Not a local variable assignment. } String name = lhs.getString(); if (!scope.isDeclared(name, false)) { return; [CLASS] DeadAssignmentsElimination 1 VariableLiveness [METHOD] tryRemoveAssignment [RETURN_TYPE] void  NodeTraversal t Node n Node exprRoot LiveVariableLattice> state [VARIABLES] AbstractCompiler compiler FlowState state boolean Scope scope NodeTraversal t Var var Node c exprRoot lhs n next op parent rhs String name VariableLiveness KILL MAYBE_LIVE READ LiveVariablesAnalysis liveness Predicate matchRemovableAssigns  	projects/Closure88/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java	0.39735970711951313	183	183	6	add	
63	[BUG] [BUGGY] rhs = lhs.getNext(); [FE] AssertionFailedError [CONTEXT] if (NodeUtil.isAssignmentOp(n) || n.getType() == Token.INC || n.getType() == Token.DEC) { Node lhs = n.getFirstChild(); Node rhs = lhs.getNext();   if (rhs != null) { tryRemoveAssignment(t, rhs, exprRoot, state); [BUGGY] rhs = lhs.getNext(); [BUGGY] } Scope scope = t.getScope(); if (!NodeUtil.isName(lhs)) { return; // Not a local variable assignment. } String name = lhs.getString(); if (!scope.isDeclared(name, false)) { return; } [CLASS] DeadAssignmentsElimination 1 VariableLiveness [METHOD] tryRemoveAssignment [RETURN_TYPE] void  NodeTraversal t Node n Node exprRoot LiveVariableLattice> state [VARIABLES] AbstractCompiler compiler FlowState state boolean Scope scope NodeTraversal t Var var Node c exprRoot lhs n next op parent rhs String name VariableLiveness KILL MAYBE_LIVE READ LiveVariablesAnalysis liveness Predicate matchRemovableAssigns  	projects/Closure88/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java	0.39735970711951313	184	184	6	replace	
64	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] if (NodeUtil.isAssignmentOp(n) || n.getType() == Token.INC || n.getType() == Token.DEC) { Node lhs = n.getFirstChild(); Node rhs = lhs.getNext();   if (rhs != null) { tryRemoveAssignment(t, rhs, exprRoot, state); [BUGGY] [BUGGY] rhs = lhs.getNext(); } Scope scope = t.getScope(); if (!NodeUtil.isName(lhs)) { return; // Not a local variable assignment. } String name = lhs.getString(); if (!scope.isDeclared(name, false)) { return; } [CLASS] DeadAssignmentsElimination 1 VariableLiveness [METHOD] tryRemoveAssignment [RETURN_TYPE] void  NodeTraversal t Node n Node exprRoot LiveVariableLattice> state [VARIABLES] AbstractCompiler compiler FlowState state boolean Scope scope NodeTraversal t Var var Node c exprRoot lhs n next op parent rhs String name VariableLiveness KILL MAYBE_LIVE READ LiveVariablesAnalysis liveness Predicate matchRemovableAssigns  	projects/Closure88/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java	0.39735970711951313	184	184	6	add	
65	[BUG] [BUGGY] ControlFlowGraph<Node> cfg = t.getControlFlowGraph(); [FE] AssertionFailedError [CONTEXT] }   if (!NodeUtil.has(fnBlock, matchRemovableAssigns, Predicates.<Node>alwaysTrue())) { return; }  [BUGGY] ControlFlowGraph<Node> cfg = t.getControlFlowGraph(); [BUGGY] liveness = new LiveVariablesAnalysis(cfg, scope, compiler); liveness.analyze(); tryRemoveDeadAssignments(t, cfg); } [CLASS] DeadAssignmentsElimination 1 VariableLiveness [METHOD] enterScope [RETURN_TYPE] void  NodeTraversal t [VARIABLES] AbstractCompiler compiler boolean Scope scope NodeTraversal t Node fnBlock ControlFlowGraph cfg VariableLiveness KILL MAYBE_LIVE READ LiveVariablesAnalysis liveness Predicate matchRemovableAssigns  	projects/Closure88/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java	0.39223227027636803	95	95	6	replace	
66	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] }   if (!NodeUtil.has(fnBlock, matchRemovableAssigns, Predicates.<Node>alwaysTrue())) { return; }  [BUGGY] [BUGGY] ControlFlowGraph<Node> cfg = t.getControlFlowGraph(); liveness = new LiveVariablesAnalysis(cfg, scope, compiler); liveness.analyze(); tryRemoveDeadAssignments(t, cfg); } [CLASS] DeadAssignmentsElimination 1 VariableLiveness [METHOD] enterScope [RETURN_TYPE] void  NodeTraversal t [VARIABLES] AbstractCompiler compiler boolean Scope scope NodeTraversal t Node fnBlock ControlFlowGraph cfg VariableLiveness KILL MAYBE_LIVE READ LiveVariablesAnalysis liveness Predicate matchRemovableAssigns  	projects/Closure88/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java	0.39223227027636803	95	95	6	add	
67	[BUG] [BUGGY] liveness = new LiveVariablesAnalysis(cfg, scope, compiler); [FE] AssertionFailedError [CONTEXT]   if (!NodeUtil.has(fnBlock, matchRemovableAssigns, Predicates.<Node>alwaysTrue())) { return; }  ControlFlowGraph<Node> cfg = t.getControlFlowGraph(); [BUGGY] liveness = new LiveVariablesAnalysis(cfg, scope, compiler); [BUGGY] liveness.analyze(); tryRemoveDeadAssignments(t, cfg); } [CLASS] DeadAssignmentsElimination 1 VariableLiveness [METHOD] enterScope [RETURN_TYPE] void  NodeTraversal t [VARIABLES] AbstractCompiler compiler boolean Scope scope NodeTraversal t Node fnBlock ControlFlowGraph cfg VariableLiveness KILL MAYBE_LIVE READ LiveVariablesAnalysis liveness Predicate matchRemovableAssigns  	projects/Closure88/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java	0.39223227027636803	96	96	6	replace	
68	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT]   if (!NodeUtil.has(fnBlock, matchRemovableAssigns, Predicates.<Node>alwaysTrue())) { return; }  ControlFlowGraph<Node> cfg = t.getControlFlowGraph(); [BUGGY] [BUGGY] liveness = new LiveVariablesAnalysis(cfg, scope, compiler); liveness.analyze(); tryRemoveDeadAssignments(t, cfg); } [CLASS] DeadAssignmentsElimination 1 VariableLiveness [METHOD] enterScope [RETURN_TYPE] void  NodeTraversal t [VARIABLES] AbstractCompiler compiler boolean Scope scope NodeTraversal t Node fnBlock ControlFlowGraph cfg VariableLiveness KILL MAYBE_LIVE READ LiveVariablesAnalysis liveness Predicate matchRemovableAssigns  	projects/Closure88/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java	0.39223227027636803	96	96	6	add	
69	[BUG] [BUGGY] liveness.analyze(); [FE] AssertionFailedError [CONTEXT]   if (!NodeUtil.has(fnBlock, matchRemovableAssigns, Predicates.<Node>alwaysTrue())) { return; }  ControlFlowGraph<Node> cfg = t.getControlFlowGraph(); liveness = new LiveVariablesAnalysis(cfg, scope, compiler); [BUGGY] liveness.analyze(); [BUGGY] tryRemoveDeadAssignments(t, cfg); } [CLASS] DeadAssignmentsElimination 1 VariableLiveness [METHOD] enterScope [RETURN_TYPE] void  NodeTraversal t [VARIABLES] AbstractCompiler compiler boolean Scope scope NodeTraversal t Node fnBlock ControlFlowGraph cfg VariableLiveness KILL MAYBE_LIVE READ LiveVariablesAnalysis liveness Predicate matchRemovableAssigns  	projects/Closure88/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java	0.39223227027636803	97	97	6	replace	
70	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT]   if (!NodeUtil.has(fnBlock, matchRemovableAssigns, Predicates.<Node>alwaysTrue())) { return; }  ControlFlowGraph<Node> cfg = t.getControlFlowGraph(); liveness = new LiveVariablesAnalysis(cfg, scope, compiler); [BUGGY] [BUGGY] liveness.analyze(); tryRemoveDeadAssignments(t, cfg); } [CLASS] DeadAssignmentsElimination 1 VariableLiveness [METHOD] enterScope [RETURN_TYPE] void  NodeTraversal t [VARIABLES] AbstractCompiler compiler boolean Scope scope NodeTraversal t Node fnBlock ControlFlowGraph cfg VariableLiveness KILL MAYBE_LIVE READ LiveVariablesAnalysis liveness Predicate matchRemovableAssigns  	projects/Closure88/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java	0.39223227027636803	97	97	6	add	
71	[BUG] [BUGGY] tryRemoveDeadAssignments(t, cfg); [FE] AssertionFailedError [CONTEXT]  if (!NodeUtil.has(fnBlock, matchRemovableAssigns, Predicates.<Node>alwaysTrue())) { return; }  ControlFlowGraph<Node> cfg = t.getControlFlowGraph(); liveness = new LiveVariablesAnalysis(cfg, scope, compiler); liveness.analyze(); [BUGGY] tryRemoveDeadAssignments(t, cfg); [BUGGY] } [CLASS] DeadAssignmentsElimination 1 VariableLiveness [METHOD] enterScope [RETURN_TYPE] void  NodeTraversal t [VARIABLES] AbstractCompiler compiler boolean Scope scope NodeTraversal t Node fnBlock ControlFlowGraph cfg VariableLiveness KILL MAYBE_LIVE READ LiveVariablesAnalysis liveness Predicate matchRemovableAssigns  	projects/Closure88/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java	0.39223227027636803	98	98	6	replace	
72	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT]  if (!NodeUtil.has(fnBlock, matchRemovableAssigns, Predicates.<Node>alwaysTrue())) { return; }  ControlFlowGraph<Node> cfg = t.getControlFlowGraph(); liveness = new LiveVariablesAnalysis(cfg, scope, compiler); liveness.analyze(); [BUGGY] [BUGGY] tryRemoveDeadAssignments(t, cfg); } [CLASS] DeadAssignmentsElimination 1 VariableLiveness [METHOD] enterScope [RETURN_TYPE] void  NodeTraversal t [VARIABLES] AbstractCompiler compiler boolean Scope scope NodeTraversal t Node fnBlock ControlFlowGraph cfg VariableLiveness KILL MAYBE_LIVE READ LiveVariablesAnalysis liveness Predicate matchRemovableAssigns  	projects/Closure88/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java	0.39223227027636803	98	98	6	add	
73	[BUG] [BUGGY] } [FE] AssertionFailedError [CONTEXT] if (!NodeUtil.has(fnBlock, matchRemovableAssigns, Predicates.<Node>alwaysTrue())) { return; }  ControlFlowGraph<Node> cfg = t.getControlFlowGraph(); liveness = new LiveVariablesAnalysis(cfg, scope, compiler); liveness.analyze(); tryRemoveDeadAssignments(t, cfg); [BUGGY] } [BUGGY]  [CLASS] DeadAssignmentsElimination 1 VariableLiveness [METHOD] enterScope [RETURN_TYPE] void  NodeTraversal t [VARIABLES] AbstractCompiler compiler boolean Scope scope NodeTraversal t Node fnBlock ControlFlowGraph cfg VariableLiveness KILL MAYBE_LIVE READ LiveVariablesAnalysis liveness Predicate matchRemovableAssigns  	projects/Closure88/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java	0.39223227027636803	99	99	6	replace	
74	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] if (!NodeUtil.has(fnBlock, matchRemovableAssigns, Predicates.<Node>alwaysTrue())) { return; }  ControlFlowGraph<Node> cfg = t.getControlFlowGraph(); liveness = new LiveVariablesAnalysis(cfg, scope, compiler); liveness.analyze(); tryRemoveDeadAssignments(t, cfg); [BUGGY] [BUGGY] } [CLASS] DeadAssignmentsElimination 1 VariableLiveness [METHOD] enterScope [RETURN_TYPE] void  NodeTraversal t [VARIABLES] AbstractCompiler compiler boolean Scope scope NodeTraversal t Node fnBlock ControlFlowGraph cfg VariableLiveness KILL MAYBE_LIVE READ LiveVariablesAnalysis liveness Predicate matchRemovableAssigns  	projects/Closure88/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java	0.39223227027636803	99	99	6	add	
75	[BUG] [BUGGY] Iterable<DiGraphNode<Node, Branch>> nodes = cfg.getDirectedGraphNodes(); [FE] AssertionFailedError [CONTEXT] ControlFlowGraph<Node> cfg) { [BUGGY] Iterable<DiGraphNode<Node, Branch>> nodes = cfg.getDirectedGraphNodes(); [BUGGY]  for (DiGraphNode<Node, Branch> cfgNode : nodes) { FlowState<LiveVariableLattice> state = cfgNode.getAnnotation(); Node n = cfgNode.getValue(); if (n == null) { continue; } switch (n.getType()) { case Token.IF: [CLASS] DeadAssignmentsElimination 1 VariableLiveness [METHOD] tryRemoveDeadAssignments [RETURN_TYPE] void  NodeTraversal t Node> cfg [VARIABLES] AbstractCompiler compiler DiGraphNode cfgNode FlowState state boolean Iterable nodes NodeTraversal t ControlFlowGraph cfg Node n VariableLiveness KILL MAYBE_LIVE READ LiveVariablesAnalysis liveness Predicate matchRemovableAssigns  	projects/Closure88/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java	0.39223227027636803	119	119	6	replace	
76	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] ControlFlowGraph<Node> cfg) { [BUGGY] [BUGGY] Iterable<DiGraphNode<Node, Branch>> nodes = cfg.getDirectedGraphNodes(); for (DiGraphNode<Node, Branch> cfgNode : nodes) { FlowState<LiveVariableLattice> state = cfgNode.getAnnotation(); Node n = cfgNode.getValue(); if (n == null) { continue; } switch (n.getType()) { case Token.IF: [CLASS] DeadAssignmentsElimination 1 VariableLiveness [METHOD] tryRemoveDeadAssignments [RETURN_TYPE] void  NodeTraversal t Node> cfg [VARIABLES] AbstractCompiler compiler DiGraphNode cfgNode FlowState state boolean Iterable nodes NodeTraversal t ControlFlowGraph cfg Node n VariableLiveness KILL MAYBE_LIVE READ LiveVariablesAnalysis liveness Predicate matchRemovableAssigns  	projects/Closure88/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java	0.39223227027636803	119	119	6	add	
77	[BUG] [BUGGY] for (DiGraphNode<Node, Branch> cfgNode : nodes) { [FE] AssertionFailedError [CONTEXT] ControlFlowGraph<Node> cfg) { Iterable<DiGraphNode<Node, Branch>> nodes = cfg.getDirectedGraphNodes(); [BUGGY] for (DiGraphNode<Node, Branch> cfgNode : nodes) { [BUGGY] FlowState<LiveVariableLattice> state = cfgNode.getAnnotation(); Node n = cfgNode.getValue(); if (n == null) { continue; } switch (n.getType()) { case Token.IF: case Token.WHILE: case Token.DO: [CLASS] DeadAssignmentsElimination 1 VariableLiveness [METHOD] tryRemoveDeadAssignments [RETURN_TYPE] void  NodeTraversal t Node> cfg [VARIABLES] AbstractCompiler compiler DiGraphNode cfgNode FlowState state boolean Iterable nodes NodeTraversal t ControlFlowGraph cfg Node n VariableLiveness KILL MAYBE_LIVE READ LiveVariablesAnalysis liveness Predicate matchRemovableAssigns  	projects/Closure88/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java	0.39223227027636803	121	121	6	replace	
78	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] ControlFlowGraph<Node> cfg) { Iterable<DiGraphNode<Node, Branch>> nodes = cfg.getDirectedGraphNodes(); [BUGGY] [BUGGY] for (DiGraphNode<Node, Branch> cfgNode : nodes) { FlowState<LiveVariableLattice> state = cfgNode.getAnnotation(); Node n = cfgNode.getValue(); if (n == null) { continue; } switch (n.getType()) { case Token.IF: case Token.WHILE: case Token.DO: [CLASS] DeadAssignmentsElimination 1 VariableLiveness [METHOD] tryRemoveDeadAssignments [RETURN_TYPE] void  NodeTraversal t Node> cfg [VARIABLES] AbstractCompiler compiler DiGraphNode cfgNode FlowState state boolean Iterable nodes NodeTraversal t ControlFlowGraph cfg Node n VariableLiveness KILL MAYBE_LIVE READ LiveVariablesAnalysis liveness Predicate matchRemovableAssigns  	projects/Closure88/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java	0.39223227027636803	121	121	6	add	
79	[BUG] [BUGGY] FlowState<LiveVariableLattice> state = cfgNode.getAnnotation(); [FE] AssertionFailedError [CONTEXT] ControlFlowGraph<Node> cfg) { Iterable<DiGraphNode<Node, Branch>> nodes = cfg.getDirectedGraphNodes(); for (DiGraphNode<Node, Branch> cfgNode : nodes) { [BUGGY] FlowState<LiveVariableLattice> state =   cfgNode.getAnnotation(); [BUGGY] cfgNode.getAnnotation(); Node n = cfgNode.getValue(); if (n == null) { continue; } switch (n.getType()) { case Token.IF: case Token.WHILE: case Token.DO: tryRemoveAssignment(t, NodeUtil.getConditionExpression(n), state); [CLASS] DeadAssignmentsElimination 1 VariableLiveness [METHOD] tryRemoveDeadAssignments [RETURN_TYPE] void  NodeTraversal t Node> cfg [VARIABLES] AbstractCompiler compiler DiGraphNode cfgNode FlowState state boolean Iterable nodes NodeTraversal t ControlFlowGraph cfg Node n VariableLiveness KILL MAYBE_LIVE READ LiveVariablesAnalysis liveness Predicate matchRemovableAssigns  	projects/Closure88/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java	0.39223227027636803	122	123	6	replace	
80	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] ControlFlowGraph<Node> cfg) { Iterable<DiGraphNode<Node, Branch>> nodes = cfg.getDirectedGraphNodes(); for (DiGraphNode<Node, Branch> cfgNode : nodes) { [BUGGY] [BUGGY] FlowState<LiveVariableLattice> state =   cfgNode.getAnnotation(); cfgNode.getAnnotation(); Node n = cfgNode.getValue(); if (n == null) { continue; } switch (n.getType()) { case Token.IF: case Token.WHILE: case Token.DO: tryRemoveAssignment(t, NodeUtil.getConditionExpression(n), state); [CLASS] DeadAssignmentsElimination 1 VariableLiveness [METHOD] tryRemoveDeadAssignments [RETURN_TYPE] void  NodeTraversal t Node> cfg [VARIABLES] AbstractCompiler compiler DiGraphNode cfgNode FlowState state boolean Iterable nodes NodeTraversal t ControlFlowGraph cfg Node n VariableLiveness KILL MAYBE_LIVE READ LiveVariablesAnalysis liveness Predicate matchRemovableAssigns  	projects/Closure88/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java	0.39223227027636803	122	123	6	add	
81	[BUG] [BUGGY] Node n = cfgNode.getValue(); [FE] AssertionFailedError [CONTEXT] ControlFlowGraph<Node> cfg) { Iterable<DiGraphNode<Node, Branch>> nodes = cfg.getDirectedGraphNodes(); for (DiGraphNode<Node, Branch> cfgNode : nodes) { FlowState<LiveVariableLattice> state = cfgNode.getAnnotation(); [BUGGY] Node n = cfgNode.getValue(); [BUGGY] if (n == null) { continue; } switch (n.getType()) { case Token.IF: case Token.WHILE: case Token.DO: tryRemoveAssignment(t, NodeUtil.getConditionExpression(n), state); continue; case Token.FOR: [CLASS] DeadAssignmentsElimination 1 VariableLiveness [METHOD] tryRemoveDeadAssignments [RETURN_TYPE] void  NodeTraversal t Node> cfg [VARIABLES] AbstractCompiler compiler DiGraphNode cfgNode FlowState state boolean Iterable nodes NodeTraversal t ControlFlowGraph cfg Node n VariableLiveness KILL MAYBE_LIVE READ LiveVariablesAnalysis liveness Predicate matchRemovableAssigns  	projects/Closure88/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java	0.39223227027636803	124	124	6	replace	
82	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] ControlFlowGraph<Node> cfg) { Iterable<DiGraphNode<Node, Branch>> nodes = cfg.getDirectedGraphNodes(); for (DiGraphNode<Node, Branch> cfgNode : nodes) { FlowState<LiveVariableLattice> state = cfgNode.getAnnotation(); [BUGGY] [BUGGY] Node n = cfgNode.getValue(); if (n == null) { continue; } switch (n.getType()) { case Token.IF: case Token.WHILE: case Token.DO: tryRemoveAssignment(t, NodeUtil.getConditionExpression(n), state); continue; case Token.FOR: [CLASS] DeadAssignmentsElimination 1 VariableLiveness [METHOD] tryRemoveDeadAssignments [RETURN_TYPE] void  NodeTraversal t Node> cfg [VARIABLES] AbstractCompiler compiler DiGraphNode cfgNode FlowState state boolean Iterable nodes NodeTraversal t ControlFlowGraph cfg Node n VariableLiveness KILL MAYBE_LIVE READ LiveVariablesAnalysis liveness Predicate matchRemovableAssigns  	projects/Closure88/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java	0.39223227027636803	124	124	6	add	
83	[BUG] [BUGGY] if (n == null) { [FE] AssertionFailedError [CONTEXT] ControlFlowGraph<Node> cfg) { Iterable<DiGraphNode<Node, Branch>> nodes = cfg.getDirectedGraphNodes(); for (DiGraphNode<Node, Branch> cfgNode : nodes) { FlowState<LiveVariableLattice> state = cfgNode.getAnnotation(); Node n = cfgNode.getValue(); [BUGGY] if (n == null) { [BUGGY] continue; } switch (n.getType()) { case Token.IF: case Token.WHILE: case Token.DO: tryRemoveAssignment(t, NodeUtil.getConditionExpression(n), state); continue; case Token.FOR: if (!NodeUtil.isForIn(n)) { [CLASS] DeadAssignmentsElimination 1 VariableLiveness [METHOD] tryRemoveDeadAssignments [RETURN_TYPE] void  NodeTraversal t Node> cfg [VARIABLES] AbstractCompiler compiler DiGraphNode cfgNode FlowState state boolean Iterable nodes NodeTraversal t ControlFlowGraph cfg Node n VariableLiveness KILL MAYBE_LIVE READ LiveVariablesAnalysis liveness Predicate matchRemovableAssigns  	projects/Closure88/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java	0.39223227027636803	125	125	6	replace	
84	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] ControlFlowGraph<Node> cfg) { Iterable<DiGraphNode<Node, Branch>> nodes = cfg.getDirectedGraphNodes(); for (DiGraphNode<Node, Branch> cfgNode : nodes) { FlowState<LiveVariableLattice> state = cfgNode.getAnnotation(); Node n = cfgNode.getValue(); [BUGGY] [BUGGY] if (n == null) { continue; } switch (n.getType()) { case Token.IF: case Token.WHILE: case Token.DO: tryRemoveAssignment(t, NodeUtil.getConditionExpression(n), state); continue; case Token.FOR: if (!NodeUtil.isForIn(n)) { [CLASS] DeadAssignmentsElimination 1 VariableLiveness [METHOD] tryRemoveDeadAssignments [RETURN_TYPE] void  NodeTraversal t Node> cfg [VARIABLES] AbstractCompiler compiler DiGraphNode cfgNode FlowState state boolean Iterable nodes NodeTraversal t ControlFlowGraph cfg Node n VariableLiveness KILL MAYBE_LIVE READ LiveVariablesAnalysis liveness Predicate matchRemovableAssigns  	projects/Closure88/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java	0.39223227027636803	125	125	6	add	
85	[BUG] [BUGGY] continue; [FE] AssertionFailedError [CONTEXT] ControlFlowGraph<Node> cfg) { Iterable<DiGraphNode<Node, Branch>> nodes = cfg.getDirectedGraphNodes(); for (DiGraphNode<Node, Branch> cfgNode : nodes) { FlowState<LiveVariableLattice> state = cfgNode.getAnnotation(); Node n = cfgNode.getValue(); if (n == null) { [BUGGY] continue; [BUGGY] } switch (n.getType()) { case Token.IF: case Token.WHILE: case Token.DO: tryRemoveAssignment(t, NodeUtil.getConditionExpression(n), state); continue; case Token.FOR: if (!NodeUtil.isForIn(n)) { tryRemoveAssignment( [CLASS] DeadAssignmentsElimination 1 VariableLiveness [METHOD] tryRemoveDeadAssignments [RETURN_TYPE] void  NodeTraversal t Node> cfg [VARIABLES] AbstractCompiler compiler DiGraphNode cfgNode FlowState state boolean Iterable nodes NodeTraversal t ControlFlowGraph cfg Node n VariableLiveness KILL MAYBE_LIVE READ LiveVariablesAnalysis liveness Predicate matchRemovableAssigns  	projects/Closure88/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java	0.39223227027636803	126	126	6	replace	
86	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] ControlFlowGraph<Node> cfg) { Iterable<DiGraphNode<Node, Branch>> nodes = cfg.getDirectedGraphNodes(); for (DiGraphNode<Node, Branch> cfgNode : nodes) { FlowState<LiveVariableLattice> state = cfgNode.getAnnotation(); Node n = cfgNode.getValue(); if (n == null) { [BUGGY] [BUGGY] continue; } switch (n.getType()) { case Token.IF: case Token.WHILE: case Token.DO: tryRemoveAssignment(t, NodeUtil.getConditionExpression(n), state); continue; case Token.FOR: if (!NodeUtil.isForIn(n)) { tryRemoveAssignment( [CLASS] DeadAssignmentsElimination 1 VariableLiveness [METHOD] tryRemoveDeadAssignments [RETURN_TYPE] void  NodeTraversal t Node> cfg [VARIABLES] AbstractCompiler compiler DiGraphNode cfgNode FlowState state boolean Iterable nodes NodeTraversal t ControlFlowGraph cfg Node n VariableLiveness KILL MAYBE_LIVE READ LiveVariablesAnalysis liveness Predicate matchRemovableAssigns  	projects/Closure88/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java	0.39223227027636803	126	126	6	add	
87	[BUG] [BUGGY] switch (n.getType()) { [FE] AssertionFailedError [CONTEXT] ControlFlowGraph<Node> cfg) { Iterable<DiGraphNode<Node, Branch>> nodes = cfg.getDirectedGraphNodes(); for (DiGraphNode<Node, Branch> cfgNode : nodes) { FlowState<LiveVariableLattice> state = cfgNode.getAnnotation(); Node n = cfgNode.getValue(); if (n == null) { continue; } [BUGGY] switch (n.getType()) { [BUGGY] case Token.IF: case Token.WHILE: case Token.DO: tryRemoveAssignment(t, NodeUtil.getConditionExpression(n), state); continue; case Token.FOR: if (!NodeUtil.isForIn(n)) { tryRemoveAssignment( t, NodeUtil.getConditionExpression(n), state); } [CLASS] DeadAssignmentsElimination 1 VariableLiveness [METHOD] tryRemoveDeadAssignments [RETURN_TYPE] void  NodeTraversal t Node> cfg [VARIABLES] AbstractCompiler compiler DiGraphNode cfgNode FlowState state boolean Iterable nodes NodeTraversal t ControlFlowGraph cfg Node n VariableLiveness KILL MAYBE_LIVE READ LiveVariablesAnalysis liveness Predicate matchRemovableAssigns  	projects/Closure88/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java	0.39223227027636803	128	128	6	replace	
88	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] ControlFlowGraph<Node> cfg) { Iterable<DiGraphNode<Node, Branch>> nodes = cfg.getDirectedGraphNodes(); for (DiGraphNode<Node, Branch> cfgNode : nodes) { FlowState<LiveVariableLattice> state = cfgNode.getAnnotation(); Node n = cfgNode.getValue(); if (n == null) { continue; } [BUGGY] [BUGGY] switch (n.getType()) { case Token.IF: case Token.WHILE: case Token.DO: tryRemoveAssignment(t, NodeUtil.getConditionExpression(n), state); continue; case Token.FOR: if (!NodeUtil.isForIn(n)) { tryRemoveAssignment( t, NodeUtil.getConditionExpression(n), state); } [CLASS] DeadAssignmentsElimination 1 VariableLiveness [METHOD] tryRemoveDeadAssignments [RETURN_TYPE] void  NodeTraversal t Node> cfg [VARIABLES] AbstractCompiler compiler DiGraphNode cfgNode FlowState state boolean Iterable nodes NodeTraversal t ControlFlowGraph cfg Node n VariableLiveness KILL MAYBE_LIVE READ LiveVariablesAnalysis liveness Predicate matchRemovableAssigns  	projects/Closure88/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java	0.39223227027636803	128	128	6	add	
89	[BUG] [BUGGY] tryRemoveAssignment(t, n, state); [FE] AssertionFailedError [CONTEXT] case Token.SWITCH: case Token.CASE: case Token.RETURN: if (n.hasChildren()) { tryRemoveAssignment(t, n.getFirstChild(), state); } continue;  } [BUGGY] tryRemoveAssignment(t, n, state); [BUGGY] } } [CLASS] DeadAssignmentsElimination 1 VariableLiveness [METHOD] tryRemoveDeadAssignments [RETURN_TYPE] void  NodeTraversal t Node> cfg [VARIABLES] AbstractCompiler compiler DiGraphNode cfgNode FlowState state boolean Iterable nodes NodeTraversal t ControlFlowGraph cfg Node n VariableLiveness KILL MAYBE_LIVE READ LiveVariablesAnalysis liveness Predicate matchRemovableAssigns  	projects/Closure88/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java	0.39223227027636803	150	150	6	replace	
90	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] case Token.SWITCH: case Token.CASE: case Token.RETURN: if (n.hasChildren()) { tryRemoveAssignment(t, n.getFirstChild(), state); } continue;  } [BUGGY] [BUGGY] tryRemoveAssignment(t, n, state); } } [CLASS] DeadAssignmentsElimination 1 VariableLiveness [METHOD] tryRemoveDeadAssignments [RETURN_TYPE] void  NodeTraversal t Node> cfg [VARIABLES] AbstractCompiler compiler DiGraphNode cfgNode FlowState state boolean Iterable nodes NodeTraversal t ControlFlowGraph cfg Node n VariableLiveness KILL MAYBE_LIVE READ LiveVariablesAnalysis liveness Predicate matchRemovableAssigns  	projects/Closure88/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java	0.39223227027636803	150	150	6	add	
91	[BUG] [BUGGY] } [FE] AssertionFailedError [CONTEXT] case Token.CASE: case Token.RETURN: if (n.hasChildren()) { tryRemoveAssignment(t, n.getFirstChild(), state); } continue;  } tryRemoveAssignment(t, n, state); [BUGGY] } [BUGGY] } [CLASS] DeadAssignmentsElimination 1 VariableLiveness [METHOD] tryRemoveDeadAssignments [RETURN_TYPE] void  NodeTraversal t Node> cfg [VARIABLES] AbstractCompiler compiler DiGraphNode cfgNode FlowState state boolean Iterable nodes NodeTraversal t ControlFlowGraph cfg Node n VariableLiveness KILL MAYBE_LIVE READ LiveVariablesAnalysis liveness Predicate matchRemovableAssigns  	projects/Closure88/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java	0.39223227027636803	151	151	6	replace	
92	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] case Token.CASE: case Token.RETURN: if (n.hasChildren()) { tryRemoveAssignment(t, n.getFirstChild(), state); } continue;  } tryRemoveAssignment(t, n, state); [BUGGY] [BUGGY] } } [CLASS] DeadAssignmentsElimination 1 VariableLiveness [METHOD] tryRemoveDeadAssignments [RETURN_TYPE] void  NodeTraversal t Node> cfg [VARIABLES] AbstractCompiler compiler DiGraphNode cfgNode FlowState state boolean Iterable nodes NodeTraversal t ControlFlowGraph cfg Node n VariableLiveness KILL MAYBE_LIVE READ LiveVariablesAnalysis liveness Predicate matchRemovableAssigns  	projects/Closure88/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java	0.39223227027636803	151	151	6	add	
93	[BUG] [BUGGY] } [FE] AssertionFailedError [CONTEXT] case Token.RETURN: if (n.hasChildren()) { tryRemoveAssignment(t, n.getFirstChild(), state); } continue;  } tryRemoveAssignment(t, n, state); } [BUGGY] } [BUGGY]  [CLASS] DeadAssignmentsElimination 1 VariableLiveness [METHOD] tryRemoveDeadAssignments [RETURN_TYPE] void  NodeTraversal t Node> cfg [VARIABLES] AbstractCompiler compiler DiGraphNode cfgNode FlowState state boolean Iterable nodes NodeTraversal t ControlFlowGraph cfg Node n VariableLiveness KILL MAYBE_LIVE READ LiveVariablesAnalysis liveness Predicate matchRemovableAssigns  	projects/Closure88/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java	0.39223227027636803	152	152	6	replace	
94	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] case Token.RETURN: if (n.hasChildren()) { tryRemoveAssignment(t, n.getFirstChild(), state); } continue;  } tryRemoveAssignment(t, n, state); } [BUGGY] [BUGGY] } [CLASS] DeadAssignmentsElimination 1 VariableLiveness [METHOD] tryRemoveDeadAssignments [RETURN_TYPE] void  NodeTraversal t Node> cfg [VARIABLES] AbstractCompiler compiler DiGraphNode cfgNode FlowState state boolean Iterable nodes NodeTraversal t ControlFlowGraph cfg Node n VariableLiveness KILL MAYBE_LIVE READ LiveVariablesAnalysis liveness Predicate matchRemovableAssigns  	projects/Closure88/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java	0.39223227027636803	152	152	6	add	
95	[BUG] [BUGGY] tryRemoveAssignment(t, n, n, state); [FE] AssertionFailedError [CONTEXT] private void tryRemoveAssignment(NodeTraversal t, Node n, FlowState<LiveVariableLattice> state) { [BUGGY] tryRemoveAssignment(t, n, n, state); [BUGGY] } [CLASS] DeadAssignmentsElimination 1 VariableLiveness [METHOD] tryRemoveAssignment [RETURN_TYPE] void  NodeTraversal t Node n LiveVariableLattice> state [VARIABLES] AbstractCompiler compiler FlowState state boolean NodeTraversal t Node n VariableLiveness KILL MAYBE_LIVE READ LiveVariablesAnalysis liveness Predicate matchRemovableAssigns  	projects/Closure88/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java	0.39223227027636803	156	156	6	replace	
96	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] private void tryRemoveAssignment(NodeTraversal t, Node n, FlowState<LiveVariableLattice> state) { [BUGGY] [BUGGY] tryRemoveAssignment(t, n, n, state); } [CLASS] DeadAssignmentsElimination 1 VariableLiveness [METHOD] tryRemoveAssignment [RETURN_TYPE] void  NodeTraversal t Node n LiveVariableLattice> state [VARIABLES] AbstractCompiler compiler FlowState state boolean NodeTraversal t Node n VariableLiveness KILL MAYBE_LIVE READ LiveVariablesAnalysis liveness Predicate matchRemovableAssigns  	projects/Closure88/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java	0.39223227027636803	156	156	6	add	
97	[BUG] [BUGGY] } [FE] AssertionFailedError [CONTEXT] private void tryRemoveAssignment(NodeTraversal t, Node n, FlowState<LiveVariableLattice> state) { tryRemoveAssignment(t, n, n, state); [BUGGY] } [BUGGY]  [CLASS] DeadAssignmentsElimination 1 VariableLiveness [METHOD] tryRemoveAssignment [RETURN_TYPE] void  NodeTraversal t Node n LiveVariableLattice> state [VARIABLES] AbstractCompiler compiler FlowState state boolean NodeTraversal t Node n VariableLiveness KILL MAYBE_LIVE READ LiveVariablesAnalysis liveness Predicate matchRemovableAssigns  	projects/Closure88/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java	0.39223227027636803	157	157	6	replace	
98	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] private void tryRemoveAssignment(NodeTraversal t, Node n, FlowState<LiveVariableLattice> state) { tryRemoveAssignment(t, n, n, state); [BUGGY] [BUGGY] } [CLASS] DeadAssignmentsElimination 1 VariableLiveness [METHOD] tryRemoveAssignment [RETURN_TYPE] void  NodeTraversal t Node n LiveVariableLattice> state [VARIABLES] AbstractCompiler compiler FlowState state boolean NodeTraversal t Node n VariableLiveness KILL MAYBE_LIVE READ LiveVariablesAnalysis liveness Predicate matchRemovableAssigns  	projects/Closure88/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java	0.39223227027636803	157	157	6	add	
99	[BUG] [BUGGY] Node parent = n.getParent(); [FE] AssertionFailedError [CONTEXT] FlowState<LiveVariableLattice> state) { [BUGGY] Node parent = n.getParent(); [BUGGY]  if (NodeUtil.isAssignmentOp(n) || n.getType() == Token.INC || n.getType() == Token.DEC) { Node lhs = n.getFirstChild(); Node rhs = lhs.getNext();   if (rhs != null) { [CLASS] DeadAssignmentsElimination 1 VariableLiveness [METHOD] tryRemoveAssignment [RETURN_TYPE] void  NodeTraversal t Node n Node exprRoot LiveVariableLattice> state [VARIABLES] AbstractCompiler compiler FlowState state boolean Scope scope NodeTraversal t Var var Node c exprRoot lhs n next op parent rhs String name VariableLiveness KILL MAYBE_LIVE READ LiveVariablesAnalysis liveness Predicate matchRemovableAssigns  	projects/Closure88/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java	0.39223227027636803	172	172	6	replace	
100	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] FlowState<LiveVariableLattice> state) { [BUGGY] [BUGGY] Node parent = n.getParent(); if (NodeUtil.isAssignmentOp(n) || n.getType() == Token.INC || n.getType() == Token.DEC) { Node lhs = n.getFirstChild(); Node rhs = lhs.getNext();   if (rhs != null) { [CLASS] DeadAssignmentsElimination 1 VariableLiveness [METHOD] tryRemoveAssignment [RETURN_TYPE] void  NodeTraversal t Node n Node exprRoot LiveVariableLattice> state [VARIABLES] AbstractCompiler compiler FlowState state boolean Scope scope NodeTraversal t Var var Node c exprRoot lhs n next op parent rhs String name VariableLiveness KILL MAYBE_LIVE READ LiveVariablesAnalysis liveness Predicate matchRemovableAssigns  	projects/Closure88/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java	0.39223227027636803	172	172	6	add	
