bugid	buggy	buggy_class	suspiciousness	buggy_line	endbuggycode	original_failing_test_number	action	patch	original_buggy	execution_result	diagnosis	previous_bug_id	new_failing_test_number	this_action
1	[BUG]  [BUGGY]  currentPropertyNames  =  this.implicitProto.getOwnPropertyNames();  [CE]  orphaned  case  [FE]    NullPointerException  [CONTEXT]    [BUGGY]  currentPropertyNames  =  this.implicitProto.getOwnPropertyNames();  [BUGGY]  for  (String  name  :  currentPropertyNames)  {  ObjectType  oType  =  properties.get(name);  if  (oType  !=  null)  {  if  (!interfaceType.getPropertyType(name).isEquivalentTo(  oType.getPropertyType(name)))  {  compiler.report(  t.makeError(n,  INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,  functionName,  name,  oType.toString(),  interfaceType.toString()));  }  [CLASS]  TypeCheck  [METHOD]  checkInterfaceConflictProperties  [RETURN_TYPE]  void  NodeTraversal  t  Node  n  String  functionName  ObjectType>  properties  ObjectType>  currentProperties  ObjectType  interfaceType  	projects/Closure2/src/com/google/javascript/jscomp/TypeCheck.java	0.24253562503633297	1574	1574	1	replace	currentPropertyNames  =  this.implicitProto.getOwnPropertyNames();	currentPropertyNames  =  implicitProto.getOwnPropertyNames();  	non-compiled	[CE]  orphaned  case	3	None	replace
2	[BUG]  [BUGGY]  currentPropertyNames  =  n.getOwnPropertyNames();  [CE]  orphaned  case  [FE]      NullPointerException  [CONTEXT]    [BUGGY]  currentPropertyNames  =  n.getOwnPropertyNames();  [BUGGY]  for  (String  name  :  currentPropertyNames)  {  ObjectType  oType  =  properties.get(name);  if  (oType  !=  null)  {  if  (!interfaceType.getPropertyType(name).isEquivalentTo(  oType.getPropertyType(name)))  {  compiler.report(  t.makeError(n,  INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,  functionName,  name,  oType.toString(),  interfaceType.toString()));  }  [CLASS]  TypeCheck  [METHOD]  checkInterfaceConflictProperties  [RETURN_TYPE]  void  NodeTraversal  t  Node  n  String  functionName  ObjectType>  properties  ObjectType>  currentProperties  ObjectType  interfaceType  	projects/Closure2/src/com/google/javascript/jscomp/TypeCheck.java	0.24253562503633297	1574	1574	1	replace	currentPropertyNames  =  n.getOwnPropertyNames();	currentPropertyNames  =  implicitProto.getOwnPropertyNames();  	non-compiled	[CE]  orphaned  case	3	None	replace
3	[BUG]  [BUGGY]  currentPropertyNames  =  getImplicitPrototype().getOwnPropertyNames();  [CE]  orphaned  case  [FE]        NullPointerException  [CONTEXT]    [BUGGY]  currentPropertyNames  =  getImplicitPrototype().getOwnPropertyNames();  [BUGGY]  for  (String  name  :  currentPropertyNames)  {  ObjectType  oType  =  properties.get(name);  if  (oType  !=  null)  {  if  (!interfaceType.getPropertyType(name).isEquivalentTo(  oType.getPropertyType(name)))  {  compiler.report(  t.makeError(n,  INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,  functionName,  name,  oType.toString(),  interfaceType.toString()));  }  [CLASS]  TypeCheck  [METHOD]  checkInterfaceConflictProperties  [RETURN_TYPE]  void  NodeTraversal  t  Node  n  String  functionName  ObjectType>  properties  ObjectType>  currentProperties  ObjectType  interfaceType  	projects/Closure2/src/com/google/javascript/jscomp/TypeCheck.java	0.24253562503633297	1574	1574	1	replace	currentPropertyNames  =  getImplicitPrototype().getOwnPropertyNames();	currentPropertyNames  =  implicitProto.getOwnPropertyNames();  	non-compiled	[CE]  orphaned  case	3	None	replace
4	[BUG]  [BUGGY]  currentPropertyNames  =  properties.get(implicitProto.getOwnPropertyNames());  [CE]  orphaned  case  [FE]          NullPointerException  [CONTEXT]    [BUGGY]  currentPropertyNames  =  properties.get(implicitProto.getOwnPropertyNames());  [BUGGY]  for  (String  name  :  currentPropertyNames)  {  ObjectType  oType  =  properties.get(name);  if  (oType  !=  null)  {  if  (!interfaceType.getPropertyType(name).isEquivalentTo(  oType.getPropertyType(name)))  {  compiler.report(  t.makeError(n,  INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,  functionName,  name,  oType.toString(),  interfaceType.toString()));  }  [CLASS]  TypeCheck  [METHOD]  checkInterfaceConflictProperties  [RETURN_TYPE]  void  NodeTraversal  t  Node  n  String  functionName  ObjectType>  properties  ObjectType>  currentProperties  ObjectType  interfaceType  	projects/Closure2/src/com/google/javascript/jscomp/TypeCheck.java	0.24253562503633297	1574	1574	1	replace	currentPropertyNames  =  properties.get(implicitProto.getOwnPropertyNames());	currentPropertyNames  =  implicitProto.getOwnPropertyNames();  	non-compiled	[CE]  orphaned  case	3	None	replace
5	[BUG]  [BUGGY]  currentPropertyNames  =  implicitProto.getPropertyNames();  [CE]  orphaned  case  [FE]            NullPointerException  [CONTEXT]    [BUGGY]  currentPropertyNames  =  implicitProto.getPropertyNames();  [BUGGY]  for  (String  name  :  currentPropertyNames)  {  ObjectType  oType  =  properties.get(name);  if  (oType  !=  null)  {  if  (!interfaceType.getPropertyType(name).isEquivalentTo(  oType.getPropertyType(name)))  {  compiler.report(  t.makeError(n,  INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,  functionName,  name,  oType.toString(),  interfaceType.toString()));  }  [CLASS]  TypeCheck  [METHOD]  checkInterfaceConflictProperties  [RETURN_TYPE]  void  NodeTraversal  t  Node  n  String  functionName  ObjectType>  properties  ObjectType>  currentProperties  ObjectType  interfaceType  	projects/Closure2/src/com/google/javascript/jscomp/TypeCheck.java	0.24253562503633297	1574	1574	1	replace	currentPropertyNames  =  implicitProto.getPropertyNames();	currentPropertyNames  =  implicitProto.getOwnPropertyNames();  	non-compiled	[CE]  orphaned  case	3	None	replace
6	[BUG]  [BUGGY]  currentPropertyNames  =  properties.get(implicitProto.getOwnPropertyName());  [CE]  orphaned  case  [FE]              NullPointerException  [CONTEXT]    [BUGGY]  currentPropertyNames  =  properties.get(implicitProto.getOwnPropertyName());  [BUGGY]  for  (String  name  :  currentPropertyNames)  {  ObjectType  oType  =  properties.get(name);  if  (oType  !=  null)  {  if  (!interfaceType.getPropertyType(name).isEquivalentTo(  oType.getPropertyType(name)))  {  compiler.report(  t.makeError(n,  INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,  functionName,  name,  oType.toString(),  interfaceType.toString()));  }  [CLASS]  TypeCheck  [METHOD]  checkInterfaceConflictProperties  [RETURN_TYPE]  void  NodeTraversal  t  Node  n  String  functionName  ObjectType>  properties  ObjectType>  currentProperties  ObjectType  interfaceType  	projects/Closure2/src/com/google/javascript/jscomp/TypeCheck.java	0.24253562503633297	1574	1574	1	replace	currentPropertyNames  =  properties.get(implicitProto.getOwnPropertyName());	currentPropertyNames  =  implicitProto.getOwnPropertyNames();  	non-compiled	[CE]  orphaned  case	3	None	replace
7	[BUG]  [BUGGY]    [CE]  orphaned  case  [FE]                NullPointerException  [CONTEXT]    [BUGGY]    [BUGGY]  for  (String  name  :  currentPropertyNames)  {  ObjectType  oType  =  properties.get(name);  if  (oType  !=  null)  {  if  (!interfaceType.getPropertyType(name).isEquivalentTo(  oType.getPropertyType(name)))  {  compiler.report(  t.makeError(n,  INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,  functionName,  name,  oType.toString(),  interfaceType.toString()));  }  [CLASS]  TypeCheck  [METHOD]  checkInterfaceConflictProperties  [RETURN_TYPE]  void  NodeTraversal  t  Node  n  String  functionName  ObjectType>  properties  ObjectType>  currentProperties  ObjectType  interfaceType  	projects/Closure2/src/com/google/javascript/jscomp/TypeCheck.java	0.24253562503633297	1574	1574	1	replace	  	currentPropertyNames  =  implicitProto.getOwnPropertyNames();  	non-compiled	[CE]  orphaned  case	3	None	replace
8	[BUG]  [BUGGY]  currentPropertyNames  =  properties.get(implicitProto).getOwnPropertyNames();  [CE]  orphaned  case  [FE]    NullPointerException  [CONTEXT]    [BUGGY]  currentPropertyNames  =  properties.get(implicitProto).getOwnPropertyNames();  [BUGGY]  for  (String  name  :  currentPropertyNames)  {  ObjectType  oType  =  properties.get(name);  if  (oType  !=  null)  {  if  (!interfaceType.getPropertyType(name).isEquivalentTo(  oType.getPropertyType(name)))  {  compiler.report(  t.makeError(n,  INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,  functionName,  name,  oType.toString(),  interfaceType.toString()));  }  [CLASS]  TypeCheck  [METHOD]  checkInterfaceConflictProperties  [RETURN_TYPE]  void  NodeTraversal  t  Node  n  String  functionName  ObjectType>  properties  ObjectType>  currentProperties  ObjectType  interfaceType  	projects/Closure2/src/com/google/javascript/jscomp/TypeCheck.java	0.24253562503633297	1574	1574	1	replace	currentPropertyNames  =  properties.get(implicitProto).getOwnPropertyNames();	currentPropertyNames  =  implicitProto.getOwnPropertyNames();  	non-compiled	[CE]  orphaned  case	3	None	replace
