bugid	buggy	buggy_class	suspiciousness	buggy_line	endbuggycode	original_failing_test_number	action	patch	original_buggy	execution_result	diagnosis	previous_bug_id	new_failing_test_number	this_action
1	[BUG]  [BUGGY]  currentPropertyNames  =  properties.get(n.getOwnPropertyName());  [CE]  orphaned  case  [FE]                  NullPointerException    [CONTEXT]      [BUGGY]  currentPropertyNames  =  properties.get(n.getOwnPropertyName());  [BUGGY]    for  (String  name  :  currentPropertyNames)  {  ObjectType  oType  =  properties.get(name);  if  (oType  !=  null)  {  if  (!interfaceType.getPropertyType(name).isEquivalentTo(  oType.getPropertyType(name)))  {  compiler.report(  t.makeError(n,  INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,  functionName,  name,  oType.toString(),  interfaceType.toString()));  }  [CLASS]  TypeCheck  [METHOD]  checkInterfaceConflictProperties  [RETURN_TYPE]  void  NodeTraversal  t  Node  n  String  functionName  ObjectType>  properties  ObjectType>  currentProperties  ObjectType  interfaceType  	projects/Closure2/src/com/google/javascript/jscomp/TypeCheck.java	0.24253562503633297	1574	1574	1	replace	currentPropertyNames  =  properties.get(n.getOwnPropertyName());	  currentPropertyNames    =    properties.get(implicitProto.getOwnPropertyName());    	non-compiled	[CE]  orphaned  case	6	None	replace
2	[BUG]  [BUGGY]  currentPropertyNames  =  properties.get(implicitProto.getImplicitPropertyName());  [CE]  orphaned  case  [FE]                    NullPointerException    [CONTEXT]      [BUGGY]  currentPropertyNames  =  properties.get(implicitProto.getImplicitPropertyName());  [BUGGY]    for  (String  name  :  currentPropertyNames)  {  ObjectType  oType  =  properties.get(name);  if  (oType  !=  null)  {  if  (!interfaceType.getPropertyType(name).isEquivalentTo(  oType.getPropertyType(name)))  {  compiler.report(  t.makeError(n,  INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,  functionName,  name,  oType.toString(),  interfaceType.toString()));  }  [CLASS]  TypeCheck  [METHOD]  checkInterfaceConflictProperties  [RETURN_TYPE]  void  NodeTraversal  t  Node  n  String  functionName  ObjectType>  properties  ObjectType>  currentProperties  ObjectType  interfaceType  	projects/Closure2/src/com/google/javascript/jscomp/TypeCheck.java	0.24253562503633297	1574	1574	1	replace	currentPropertyNames  =  properties.get(implicitProto.getImplicitPropertyName());	  currentPropertyNames    =    properties.get(implicitProto.getOwnPropertyName());    	non-compiled	[CE]  orphaned  case	6	None	replace
3	[BUG]  [BUGGY]  currentPropertyNames  =  properties.get(implicitProto.getOwnPropertyName(),  null);  [CE]  orphaned  case  [FE]                      NullPointerException    [CONTEXT]      [BUGGY]  currentPropertyNames  =  properties.get(implicitProto.getOwnPropertyName(),  null);  [BUGGY]    for  (String  name  :  currentPropertyNames)  {  ObjectType  oType  =  properties.get(name);  if  (oType  !=  null)  {  if  (!interfaceType.getPropertyType(name).isEquivalentTo(  oType.getPropertyType(name)))  {  compiler.report(  t.makeError(n,  INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,  functionName,  name,  oType.toString(),  interfaceType.toString()));  }  [CLASS]  TypeCheck  [METHOD]  checkInterfaceConflictProperties  [RETURN_TYPE]  void  NodeTraversal  t  Node  n  String  functionName  ObjectType>  properties  ObjectType>  currentProperties  ObjectType  interfaceType  	projects/Closure2/src/com/google/javascript/jscomp/TypeCheck.java	0.24253562503633297	1574	1574	1	replace	currentPropertyNames  =  properties.get(implicitProto.getOwnPropertyName(),  null);	  currentPropertyNames    =    properties.get(implicitProto.getOwnPropertyName());    	non-compiled	[CE]  orphaned  case	6	None	replace
4	[BUG]  [BUGGY]  currentPropertyNames  =  properties.get(properties.get(0).getOwnPropertyName());  [CE]  orphaned  case  [FE]                        NullPointerException    [CONTEXT]      [BUGGY]  currentPropertyNames  =  properties.get(properties.get(0).getOwnPropertyName());  [BUGGY]    for  (String  name  :  currentPropertyNames)  {  ObjectType  oType  =  properties.get(name);  if  (oType  !=  null)  {  if  (!interfaceType.getPropertyType(name).isEquivalentTo(  oType.getPropertyType(name)))  {  compiler.report(  t.makeError(n,  INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,  functionName,  name,  oType.toString(),  interfaceType.toString()));  }  [CLASS]  TypeCheck  [METHOD]  checkInterfaceConflictProperties  [RETURN_TYPE]  void  NodeTraversal  t  Node  n  String  functionName  ObjectType>  properties  ObjectType>  currentProperties  ObjectType  interfaceType  	projects/Closure2/src/com/google/javascript/jscomp/TypeCheck.java	0.24253562503633297	1574	1574	1	replace	currentPropertyNames  =  properties.get(properties.get(0).getOwnPropertyName());	  currentPropertyNames    =    properties.get(implicitProto.getOwnPropertyName());    	non-compiled	[CE]  orphaned  case	6	None	replace
5	[BUG]  [BUGGY]  currentPropertyNames  =  properties.get(implicitProto.getOwnPropertyName(),  true);  [CE]  orphaned  case  [FE]                          NullPointerException    [CONTEXT]      [BUGGY]  currentPropertyNames  =  properties.get(implicitProto.getOwnPropertyName(),  true);  [BUGGY]    for  (String  name  :  currentPropertyNames)  {  ObjectType  oType  =  properties.get(name);  if  (oType  !=  null)  {  if  (!interfaceType.getPropertyType(name).isEquivalentTo(  oType.getPropertyType(name)))  {  compiler.report(  t.makeError(n,  INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,  functionName,  name,  oType.toString(),  interfaceType.toString()));  }  [CLASS]  TypeCheck  [METHOD]  checkInterfaceConflictProperties  [RETURN_TYPE]  void  NodeTraversal  t  Node  n  String  functionName  ObjectType>  properties  ObjectType>  currentProperties  ObjectType  interfaceType  	projects/Closure2/src/com/google/javascript/jscomp/TypeCheck.java	0.24253562503633297	1574	1574	1	replace	currentPropertyNames  =  properties.get(implicitProto.getOwnPropertyName(),  true);	  currentPropertyNames    =    properties.get(implicitProto.getOwnPropertyName());    	non-compiled	[CE]  orphaned  case	6	None	replace
6	[BUG]  [BUGGY]  currentPropertyNames  =  properties.get(properties.get(implicitProto.getOwnPropertyName()));  [CE]  orphaned  case  [FE]                            NullPointerException    [CONTEXT]      [BUGGY]  currentPropertyNames  =  properties.get(properties.get(implicitProto.getOwnPropertyName()));  [BUGGY]    for  (String  name  :  currentPropertyNames)  {  ObjectType  oType  =  properties.get(name);  if  (oType  !=  null)  {  if  (!interfaceType.getPropertyType(name).isEquivalentTo(  oType.getPropertyType(name)))  {  compiler.report(  t.makeError(n,  INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,  functionName,  name,  oType.toString(),  interfaceType.toString()));  }  [CLASS]  TypeCheck  [METHOD]  checkInterfaceConflictProperties  [RETURN_TYPE]  void  NodeTraversal  t  Node  n  String  functionName  ObjectType>  properties  ObjectType>  currentProperties  ObjectType  interfaceType  	projects/Closure2/src/com/google/javascript/jscomp/TypeCheck.java	0.24253562503633297	1574	1574	1	replace	currentPropertyNames  =  properties.get(properties.get(implicitProto.getOwnPropertyName()));	  currentPropertyNames    =    properties.get(implicitProto.getOwnPropertyName());    	non-compiled	[CE]  orphaned  case	6	None	replace
7	[BUG]  [BUGGY]  currentPropertyNames  =  properties.get(name).getOwnPropertyNames();  [CE]  orphaned  case  [FE]        NullPointerException    [CONTEXT]      [BUGGY]  currentPropertyNames  =  properties.get(name).getOwnPropertyNames();  [BUGGY]    for  (String  name  :  currentPropertyNames)  {  ObjectType  oType  =  properties.get(name);  if  (oType  !=  null)  {  if  (!interfaceType.getPropertyType(name).isEquivalentTo(  oType.getPropertyType(name)))  {  compiler.report(  t.makeError(n,  INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,  functionName,  name,  oType.toString(),  interfaceType.toString()));  }  [CLASS]  TypeCheck  [METHOD]  checkInterfaceConflictProperties  [RETURN_TYPE]  void  NodeTraversal  t  Node  n  String  functionName  ObjectType>  properties  ObjectType>  currentProperties  ObjectType  interfaceType  	projects/Closure2/src/com/google/javascript/jscomp/TypeCheck.java	0.24253562503633297	1574	1574	1	replace	currentPropertyNames  =  properties.get(name).getOwnPropertyNames();	  currentPropertyNames    =    properties.get(implicitProto).getOwnPropertyNames();    	non-compiled	[CE]  orphaned  case	8	None	replace
8	[BUG]  [BUGGY]  currentPropertyNames  =  properties.get(properties).getOwnPropertyNames();  [CE]  orphaned  case  [FE]          NullPointerException    [CONTEXT]      [BUGGY]  currentPropertyNames  =  properties.get(properties).getOwnPropertyNames();  [BUGGY]    for  (String  name  :  currentPropertyNames)  {  ObjectType  oType  =  properties.get(name);  if  (oType  !=  null)  {  if  (!interfaceType.getPropertyType(name).isEquivalentTo(  oType.getPropertyType(name)))  {  compiler.report(  t.makeError(n,  INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,  functionName,  name,  oType.toString(),  interfaceType.toString()));  }  [CLASS]  TypeCheck  [METHOD]  checkInterfaceConflictProperties  [RETURN_TYPE]  void  NodeTraversal  t  Node  n  String  functionName  ObjectType>  properties  ObjectType>  currentProperties  ObjectType  interfaceType  	projects/Closure2/src/com/google/javascript/jscomp/TypeCheck.java	0.24253562503633297	1574	1574	1	replace	currentPropertyNames  =  properties.get(properties).getOwnPropertyNames();	  currentPropertyNames    =    properties.get(implicitProto).getOwnPropertyNames();    	non-compiled	[CE]  orphaned  case	8	None	replace
9	[BUG]  [BUGGY]  currentPropertyNames  =  properties.get(0).getOwnPropertyNames();  [CE]  orphaned  case  [FE]            NullPointerException    [CONTEXT]      [BUGGY]  currentPropertyNames  =  properties.get(0).getOwnPropertyNames();  [BUGGY]    for  (String  name  :  currentPropertyNames)  {  ObjectType  oType  =  properties.get(name);  if  (oType  !=  null)  {  if  (!interfaceType.getPropertyType(name).isEquivalentTo(  oType.getPropertyType(name)))  {  compiler.report(  t.makeError(n,  INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,  functionName,  name,  oType.toString(),  interfaceType.toString()));  }  [CLASS]  TypeCheck  [METHOD]  checkInterfaceConflictProperties  [RETURN_TYPE]  void  NodeTraversal  t  Node  n  String  functionName  ObjectType>  properties  ObjectType>  currentProperties  ObjectType  interfaceType  	projects/Closure2/src/com/google/javascript/jscomp/TypeCheck.java	0.24253562503633297	1574	1574	1	replace	currentPropertyNames  =  properties.get(0).getOwnPropertyNames();	  currentPropertyNames    =    properties.get(implicitProto).getOwnPropertyNames();    	non-compiled	[CE]  orphaned  case	8	None	replace
10	[BUG]  [BUGGY]  ObjectType  currentPropertyNames  =  properties.get(implicitProto).getOwnPropertyNames();  [CE]  orphaned  case  [FE]              NullPointerException    [CONTEXT]      [BUGGY]  ObjectType  currentPropertyNames  =  properties.get(implicitProto).getOwnPropertyNames();  [BUGGY]    for  (String  name  :  currentPropertyNames)  {  ObjectType  oType  =  properties.get(name);  if  (oType  !=  null)  {  if  (!interfaceType.getPropertyType(name).isEquivalentTo(  oType.getPropertyType(name)))  {  compiler.report(  t.makeError(n,  INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,  functionName,  name,  oType.toString(),  interfaceType.toString()));  }  [CLASS]  TypeCheck  [METHOD]  checkInterfaceConflictProperties  [RETURN_TYPE]  void  NodeTraversal  t  Node  n  String  functionName  ObjectType>  properties  ObjectType>  currentProperties  ObjectType  interfaceType  	projects/Closure2/src/com/google/javascript/jscomp/TypeCheck.java	0.24253562503633297	1574	1574	1	replace	ObjectType  currentPropertyNames  =  properties.get(implicitProto).getOwnPropertyNames();	  currentPropertyNames    =    properties.get(implicitProto).getOwnPropertyNames();    	non-compiled	[CE]  orphaned  case	8	None	replace
11	[BUG]  [BUGGY]  currentPropertyNames  =  properties.get(n).getOwnPropertyNames();  [CE]  orphaned  case  [FE]                NullPointerException    [CONTEXT]      [BUGGY]  currentPropertyNames  =  properties.get(n).getOwnPropertyNames();  [BUGGY]    for  (String  name  :  currentPropertyNames)  {  ObjectType  oType  =  properties.get(name);  if  (oType  !=  null)  {  if  (!interfaceType.getPropertyType(name).isEquivalentTo(  oType.getPropertyType(name)))  {  compiler.report(  t.makeError(n,  INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,  functionName,  name,  oType.toString(),  interfaceType.toString()));  }  [CLASS]  TypeCheck  [METHOD]  checkInterfaceConflictProperties  [RETURN_TYPE]  void  NodeTraversal  t  Node  n  String  functionName  ObjectType>  properties  ObjectType>  currentProperties  ObjectType  interfaceType  	projects/Closure2/src/com/google/javascript/jscomp/TypeCheck.java	0.24253562503633297	1574	1574	1	replace	currentPropertyNames  =  properties.get(n).getOwnPropertyNames();	  currentPropertyNames    =    properties.get(implicitProto).getOwnPropertyNames();    	non-compiled	[CE]  orphaned  case	8	None	replace
12	[BUG]  [BUGGY]  currentPropertyNames  =  properties.get(i).getOwnPropertyNames();  [CE]  orphaned  case  [FE]                  NullPointerException    [CONTEXT]      [BUGGY]  currentPropertyNames  =  properties.get(i).getOwnPropertyNames();  [BUGGY]    for  (String  name  :  currentPropertyNames)  {  ObjectType  oType  =  properties.get(name);  if  (oType  !=  null)  {  if  (!interfaceType.getPropertyType(name).isEquivalentTo(  oType.getPropertyType(name)))  {  compiler.report(  t.makeError(n,  INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,  functionName,  name,  oType.toString(),  interfaceType.toString()));  }  [CLASS]  TypeCheck  [METHOD]  checkInterfaceConflictProperties  [RETURN_TYPE]  void  NodeTraversal  t  Node  n  String  functionName  ObjectType>  properties  ObjectType>  currentProperties  ObjectType  interfaceType  	projects/Closure2/src/com/google/javascript/jscomp/TypeCheck.java	0.24253562503633297	1574	1574	1	replace	currentPropertyNames  =  properties.get(i).getOwnPropertyNames();	  currentPropertyNames    =    properties.get(implicitProto).getOwnPropertyNames();    	non-compiled	[CE]  orphaned  case	8	None	replace
13	[BUG]  [BUGGY]  if(getImplicitPrototype()!=  null)  {  currentPropertyNames  =  getImplicitPrototype().getOwnPropertyNames();  }  [CE]  orphaned  case  [FE]            NullPointerException    [CONTEXT]      [BUGGY]  if(getImplicitPrototype()!=  null)  {  currentPropertyNames  =  getImplicitPrototype().getOwnPropertyNames();  }  [BUGGY]    for  (String  name  :  currentPropertyNames)  {  ObjectType  oType  =  properties.get(name);  if  (oType  !=  null)  {  if  (!interfaceType.getPropertyType(name).isEquivalentTo(  oType.getPropertyType(name)))  {  compiler.report(  t.makeError(n,  INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,  functionName,  name,  oType.toString(),  interfaceType.toString()));  }  [CLASS]  TypeCheck  [METHOD]  checkInterfaceConflictProperties  [RETURN_TYPE]  void  NodeTraversal  t  Node  n  String  functionName  ObjectType>  properties  ObjectType>  currentProperties  ObjectType  interfaceType  	projects/Closure2/src/com/google/javascript/jscomp/TypeCheck.java	0.24253562503633297	1574	1574	1	replace	if(getImplicitPrototype()!=  null)  {  currentPropertyNames  =  getImplicitPrototype().getOwnPropertyNames();  }	  currentPropertyNames    =    getImplicitPrototype().getOwnPropertyNames();    	non-compiled	[CE]  orphaned  case	3	None	replace
14	[BUG]  [BUGGY]  if(currentPropertyNames!=  null)  {  currentPropertyNames  =  getImplicitPrototype().getOwnPropertyNames();  }  [CE]  orphaned  case  [FE]              NullPointerException    [CONTEXT]      [BUGGY]  if(currentPropertyNames!=  null)  {  currentPropertyNames  =  getImplicitPrototype().getOwnPropertyNames();  }  [BUGGY]    for  (String  name  :  currentPropertyNames)  {  ObjectType  oType  =  properties.get(name);  if  (oType  !=  null)  {  if  (!interfaceType.getPropertyType(name).isEquivalentTo(  oType.getPropertyType(name)))  {  compiler.report(  t.makeError(n,  INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,  functionName,  name,  oType.toString(),  interfaceType.toString()));  }  [CLASS]  TypeCheck  [METHOD]  checkInterfaceConflictProperties  [RETURN_TYPE]  void  NodeTraversal  t  Node  n  String  functionName  ObjectType>  properties  ObjectType>  currentProperties  ObjectType  interfaceType  	projects/Closure2/src/com/google/javascript/jscomp/TypeCheck.java	0.24253562503633297	1574	1574	1	replace	if(currentPropertyNames!=  null)  {  currentPropertyNames  =  getImplicitPrototype().getOwnPropertyNames();  }	  currentPropertyNames    =    getImplicitPrototype().getOwnPropertyNames();    	non-compiled	[CE]  orphaned  case	3	None	replace
15	[BUG]  [BUGGY]  currentPropertyNames  =  getImplicitPrototype().getPropertyNames();  [CE]  orphaned  case  [FE]                NullPointerException    [CONTEXT]      [BUGGY]  currentPropertyNames  =  getImplicitPrototype().getPropertyNames();  [BUGGY]    for  (String  name  :  currentPropertyNames)  {  ObjectType  oType  =  properties.get(name);  if  (oType  !=  null)  {  if  (!interfaceType.getPropertyType(name).isEquivalentTo(  oType.getPropertyType(name)))  {  compiler.report(  t.makeError(n,  INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,  functionName,  name,  oType.toString(),  interfaceType.toString()));  }  [CLASS]  TypeCheck  [METHOD]  checkInterfaceConflictProperties  [RETURN_TYPE]  void  NodeTraversal  t  Node  n  String  functionName  ObjectType>  properties  ObjectType>  currentProperties  ObjectType  interfaceType  	projects/Closure2/src/com/google/javascript/jscomp/TypeCheck.java	0.24253562503633297	1574	1574	1	replace	currentPropertyNames  =  getImplicitPrototype().getPropertyNames();	  currentPropertyNames    =    getImplicitPrototype().getOwnPropertyNames();    	non-compiled	[CE]  orphaned  case	3	None	replace
16	[BUG]  [BUGGY]  ObjectType  currentPropertyNames  =  getImplicitPrototype().getOwnPropertyNames();  [CE]  orphaned  case  [FE]                  NullPointerException    [CONTEXT]      [BUGGY]  ObjectType  currentPropertyNames  =  getImplicitPrototype().getOwnPropertyNames();  [BUGGY]    for  (String  name  :  currentPropertyNames)  {  ObjectType  oType  =  properties.get(name);  if  (oType  !=  null)  {  if  (!interfaceType.getPropertyType(name).isEquivalentTo(  oType.getPropertyType(name)))  {  compiler.report(  t.makeError(n,  INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,  functionName,  name,  oType.toString(),  interfaceType.toString()));  }  [CLASS]  TypeCheck  [METHOD]  checkInterfaceConflictProperties  [RETURN_TYPE]  void  NodeTraversal  t  Node  n  String  functionName  ObjectType>  properties  ObjectType>  currentProperties  ObjectType  interfaceType  	projects/Closure2/src/com/google/javascript/jscomp/TypeCheck.java	0.24253562503633297	1574	1574	1	replace	ObjectType  currentPropertyNames  =  getImplicitPrototype().getOwnPropertyNames();	  currentPropertyNames    =    getImplicitPrototype().getOwnPropertyNames();    	non-compiled	[CE]  orphaned  case	3	None	replace
17	[BUG]  [BUGGY]  if(getImplicitPrototype()!=  null)  {  currentPropertyNames  =  getImplicitPrototype().getOwnPropertyNames();  }  else  {  throw  new  IllegalArgumentException( " ");  }  [CE]  orphaned  case  [FE]                    NullPointerException    [CONTEXT]      [BUGGY]  if(getImplicitPrototype()!=  null)  {  currentPropertyNames  =  getImplicitPrototype().getOwnPropertyNames();  }  else  {  throw  new  IllegalArgumentException( " ");  }  [BUGGY]    for  (String  name  :  currentPropertyNames)  {  ObjectType  oType  =  properties.get(name);  if  (oType  !=  null)  {  if  (!interfaceType.getPropertyType(name).isEquivalentTo(  oType.getPropertyType(name)))  {  compiler.report(  t.makeError(n,  INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,  functionName,  name,  oType.toString(),  interfaceType.toString()));  }  [CLASS]  TypeCheck  [METHOD]  checkInterfaceConflictProperties  [RETURN_TYPE]  void  NodeTraversal  t  Node  n  String  functionName  ObjectType>  properties  ObjectType>  currentProperties  ObjectType  interfaceType  	projects/Closure2/src/com/google/javascript/jscomp/TypeCheck.java	0.24253562503633297	1574	1574	1	replace	if(getImplicitPrototype()!=  null)  {  currentPropertyNames  =  getImplicitPrototype().getOwnPropertyNames();  }  else  {  throw  new  IllegalArgumentException( " ");  }	  currentPropertyNames    =    getImplicitPrototype().getOwnPropertyNames();    	non-compiled	[CE]  orphaned  case	3	None	replace
18	[BUG]  [BUGGY]  CurrentPropertyNames  currentPropertyNames  =  getImplicitPrototype().getOwnPropertyNames();  [CE]  orphaned  case  [FE]                      NullPointerException    [CONTEXT]      [BUGGY]  CurrentPropertyNames  currentPropertyNames  =  getImplicitPrototype().getOwnPropertyNames();  [BUGGY]    for  (String  name  :  currentPropertyNames)  {  ObjectType  oType  =  properties.get(name);  if  (oType  !=  null)  {  if  (!interfaceType.getPropertyType(name).isEquivalentTo(  oType.getPropertyType(name)))  {  compiler.report(  t.makeError(n,  INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,  functionName,  name,  oType.toString(),  interfaceType.toString()));  }  [CLASS]  TypeCheck  [METHOD]  checkInterfaceConflictProperties  [RETURN_TYPE]  void  NodeTraversal  t  Node  n  String  functionName  ObjectType>  properties  ObjectType>  currentProperties  ObjectType  interfaceType  	projects/Closure2/src/com/google/javascript/jscomp/TypeCheck.java	0.24253562503633297	1574	1574	1	replace	CurrentPropertyNames  currentPropertyNames  =  getImplicitPrototype().getOwnPropertyNames();	  currentPropertyNames    =    getImplicitPrototype().getOwnPropertyNames();    	non-compiled	[CE]  orphaned  case	3	None	replace
19	[BUG]  [BUGGY]  if(implicitProto!=  null)  {  currentPropertyNames  =  implicitProto.getPropertyNames();  }  [CE]  orphaned  case  [FE]                NullPointerException    [CONTEXT]      [BUGGY]  if(implicitProto!=  null)  {  currentPropertyNames  =  implicitProto.getPropertyNames();  }  [BUGGY]    for  (String  name  :  currentPropertyNames)  {  ObjectType  oType  =  properties.get(name);  if  (oType  !=  null)  {  if  (!interfaceType.getPropertyType(name).isEquivalentTo(  oType.getPropertyType(name)))  {  compiler.report(  t.makeError(n,  INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,  functionName,  name,  oType.toString(),  interfaceType.toString()));  }  [CLASS]  TypeCheck  [METHOD]  checkInterfaceConflictProperties  [RETURN_TYPE]  void  NodeTraversal  t  Node  n  String  functionName  ObjectType>  properties  ObjectType>  currentProperties  ObjectType  interfaceType  	projects/Closure2/src/com/google/javascript/jscomp/TypeCheck.java	0.24253562503633297	1574	1574	1	replace	if(implicitProto!=  null)  {  currentPropertyNames  =  implicitProto.getPropertyNames();  }	  currentPropertyNames    =    implicitProto.getPropertyNames();    	non-compiled	[CE]  orphaned  case	5	None	replace
20	[BUG]  [BUGGY]  currentPropertyNames  =  n.getPropertyNames();  [CE]  orphaned  case  [FE]                  NullPointerException    [CONTEXT]      [BUGGY]  currentPropertyNames  =  n.getPropertyNames();  [BUGGY]    for  (String  name  :  currentPropertyNames)  {  ObjectType  oType  =  properties.get(name);  if  (oType  !=  null)  {  if  (!interfaceType.getPropertyType(name).isEquivalentTo(  oType.getPropertyType(name)))  {  compiler.report(  t.makeError(n,  INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,  functionName,  name,  oType.toString(),  interfaceType.toString()));  }  [CLASS]  TypeCheck  [METHOD]  checkInterfaceConflictProperties  [RETURN_TYPE]  void  NodeTraversal  t  Node  n  String  functionName  ObjectType>  properties  ObjectType>  currentProperties  ObjectType  interfaceType  	projects/Closure2/src/com/google/javascript/jscomp/TypeCheck.java	0.24253562503633297	1574	1574	1	replace	currentPropertyNames  =  n.getPropertyNames();	  currentPropertyNames    =    implicitProto.getPropertyNames();    	non-compiled	[CE]  orphaned  case	5	None	replace
21	[BUG]  [BUGGY]  currentPropertyNames  =  this.implicitProto.getPropertyNames();  [CE]  orphaned  case  [FE]                    NullPointerException    [CONTEXT]      [BUGGY]  currentPropertyNames  =  this.implicitProto.getPropertyNames();  [BUGGY]    for  (String  name  :  currentPropertyNames)  {  ObjectType  oType  =  properties.get(name);  if  (oType  !=  null)  {  if  (!interfaceType.getPropertyType(name).isEquivalentTo(  oType.getPropertyType(name)))  {  compiler.report(  t.makeError(n,  INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,  functionName,  name,  oType.toString(),  interfaceType.toString()));  }  [CLASS]  TypeCheck  [METHOD]  checkInterfaceConflictProperties  [RETURN_TYPE]  void  NodeTraversal  t  Node  n  String  functionName  ObjectType>  properties  ObjectType>  currentProperties  ObjectType  interfaceType  	projects/Closure2/src/com/google/javascript/jscomp/TypeCheck.java	0.24253562503633297	1574	1574	1	replace	currentPropertyNames  =  this.implicitProto.getPropertyNames();	  currentPropertyNames    =    implicitProto.getPropertyNames();    	non-compiled	[CE]  orphaned  case	5	None	replace
22	[BUG]  [BUGGY]  if(implicitProto!=  null)  {  currentPropertyNames  =  implicitProto.getPropertyNames();  }  else  {  throw  new  IllegalArgumentException( " ");  }  [CE]  orphaned  case  [FE]                      NullPointerException    [CONTEXT]      [BUGGY]  if(implicitProto!=  null)  {  currentPropertyNames  =  implicitProto.getPropertyNames();  }  else  {  throw  new  IllegalArgumentException( " ");  }  [BUGGY]    for  (String  name  :  currentPropertyNames)  {  ObjectType  oType  =  properties.get(name);  if  (oType  !=  null)  {  if  (!interfaceType.getPropertyType(name).isEquivalentTo(  oType.getPropertyType(name)))  {  compiler.report(  t.makeError(n,  INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,  functionName,  name,  oType.toString(),  interfaceType.toString()));  }  [CLASS]  TypeCheck  [METHOD]  checkInterfaceConflictProperties  [RETURN_TYPE]  void  NodeTraversal  t  Node  n  String  functionName  ObjectType>  properties  ObjectType>  currentProperties  ObjectType  interfaceType  	projects/Closure2/src/com/google/javascript/jscomp/TypeCheck.java	0.24253562503633297	1574	1574	1	replace	if(implicitProto!=  null)  {  currentPropertyNames  =  implicitProto.getPropertyNames();  }  else  {  throw  new  IllegalArgumentException( " ");  }	  currentPropertyNames    =    implicitProto.getPropertyNames();    	non-compiled	[CE]  orphaned  case	5	None	replace
23	[BUG]  [BUGGY]  if(implicitProto!=  null)  {  currentPropertyNames  =  implicitProto.getPropertyNames();  }  else  {  return;  }  [CE]  orphaned  case  [FE]                        NullPointerException    [CONTEXT]      [BUGGY]  if(implicitProto!=  null)  {  currentPropertyNames  =  implicitProto.getPropertyNames();  }  else  {  return;  }  [BUGGY]    for  (String  name  :  currentPropertyNames)  {  ObjectType  oType  =  properties.get(name);  if  (oType  !=  null)  {  if  (!interfaceType.getPropertyType(name).isEquivalentTo(  oType.getPropertyType(name)))  {  compiler.report(  t.makeError(n,  INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,  functionName,  name,  oType.toString(),  interfaceType.toString()));  }  [CLASS]  TypeCheck  [METHOD]  checkInterfaceConflictProperties  [RETURN_TYPE]  void  NodeTraversal  t  Node  n  String  functionName  ObjectType>  properties  ObjectType>  currentProperties  ObjectType  interfaceType  	projects/Closure2/src/com/google/javascript/jscomp/TypeCheck.java	0.24253562503633297	1574	1574	1	replace	if(implicitProto!=  null)  {  currentPropertyNames  =  implicitProto.getPropertyNames();  }  else  {  return;  }	  currentPropertyNames    =    implicitProto.getPropertyNames();    	non-compiled	[CE]  orphaned  case	5	None	replace
24	[BUG]  [BUGGY]  currentPropertyNames  =  properties.get(implicitProto.getPropertyName());  [CE]  orphaned  case  [FE]                          NullPointerException    [CONTEXT]      [BUGGY]  currentPropertyNames  =  properties.get(implicitProto.getPropertyName());  [BUGGY]    for  (String  name  :  currentPropertyNames)  {  ObjectType  oType  =  properties.get(name);  if  (oType  !=  null)  {  if  (!interfaceType.getPropertyType(name).isEquivalentTo(  oType.getPropertyType(name)))  {  compiler.report(  t.makeError(n,  INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,  functionName,  name,  oType.toString(),  interfaceType.toString()));  }  [CLASS]  TypeCheck  [METHOD]  checkInterfaceConflictProperties  [RETURN_TYPE]  void  NodeTraversal  t  Node  n  String  functionName  ObjectType>  properties  ObjectType>  currentProperties  ObjectType  interfaceType  	projects/Closure2/src/com/google/javascript/jscomp/TypeCheck.java	0.24253562503633297	1574	1574	1	replace	currentPropertyNames  =  properties.get(implicitProto.getPropertyName());	  currentPropertyNames    =    implicitProto.getPropertyNames();    	non-compiled	[CE]  orphaned  case	5	None	replace
25	[BUG]  [BUGGY]  NodeTraversal.traverse(compiler,  n,  new  TypeCheck());  [CE]  orphaned  case  [FE]                    NullPointerException    [CONTEXT]      [BUGGY]  NodeTraversal.traverse(compiler,  n,  new  TypeCheck());  [BUGGY]    for  (String  name  :  currentPropertyNames)  {  ObjectType  oType  =  properties.get(name);  if  (oType  !=  null)  {  if  (!interfaceType.getPropertyType(name).isEquivalentTo(  oType.getPropertyType(name)))  {  compiler.report(  t.makeError(n,  INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,  functionName,  name,  oType.toString(),  interfaceType.toString()));  }  [CLASS]  TypeCheck  [METHOD]  checkInterfaceConflictProperties  [RETURN_TYPE]  void  NodeTraversal  t  Node  n  String  functionName  ObjectType>  properties  ObjectType>  currentProperties  ObjectType  interfaceType  	projects/Closure2/src/com/google/javascript/jscomp/TypeCheck.java	0.24253562503633297	1574	1574	1	replace	NodeTraversal.traverse(compiler,  n,  new  TypeCheck());	      	non-compiled	[CE]  orphaned  case	7	None	replace
26	[BUG]  [BUGGY]  NodeTraversal.traverse(compiler,  n,  this);  [CE]  orphaned  case  [FE]                      NullPointerException    [CONTEXT]      [BUGGY]  NodeTraversal.traverse(compiler,  n,  this);  [BUGGY]    for  (String  name  :  currentPropertyNames)  {  ObjectType  oType  =  properties.get(name);  if  (oType  !=  null)  {  if  (!interfaceType.getPropertyType(name).isEquivalentTo(  oType.getPropertyType(name)))  {  compiler.report(  t.makeError(n,  INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,  functionName,  name,  oType.toString(),  interfaceType.toString()));  }  [CLASS]  TypeCheck  [METHOD]  checkInterfaceConflictProperties  [RETURN_TYPE]  void  NodeTraversal  t  Node  n  String  functionName  ObjectType>  properties  ObjectType>  currentProperties  ObjectType  interfaceType  	projects/Closure2/src/com/google/javascript/jscomp/TypeCheck.java	0.24253562503633297	1574	1574	1	replace	NodeTraversal.traverse(compiler,  n,  this);	      	non-compiled	[CE]  orphaned  case	7	None	replace
27	[BUG]  [BUGGY]  NodeTraversal.traverse(compiler,  n,  currentProperties);  [CE]  orphaned  case  [FE]                        NullPointerException    [CONTEXT]      [BUGGY]  NodeTraversal.traverse(compiler,  n,  currentProperties);  [BUGGY]    for  (String  name  :  currentPropertyNames)  {  ObjectType  oType  =  properties.get(name);  if  (oType  !=  null)  {  if  (!interfaceType.getPropertyType(name).isEquivalentTo(  oType.getPropertyType(name)))  {  compiler.report(  t.makeError(n,  INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,  functionName,  name,  oType.toString(),  interfaceType.toString()));  }  [CLASS]  TypeCheck  [METHOD]  checkInterfaceConflictProperties  [RETURN_TYPE]  void  NodeTraversal  t  Node  n  String  functionName  ObjectType>  properties  ObjectType>  currentProperties  ObjectType  interfaceType  	projects/Closure2/src/com/google/javascript/jscomp/TypeCheck.java	0.24253562503633297	1574	1574	1	replace	NodeTraversal.traverse(compiler,  n,  currentProperties);	      	non-compiled	[CE]  orphaned  case	7	None	replace
28	[BUG]  [BUGGY]  t.makeError(n,  INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,  functionName,  null,  interfaceType.toString());  [CE]  orphaned  case  [FE]                          NullPointerException    [CONTEXT]      [BUGGY]  t.makeError(n,  INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,  functionName,  null,  interfaceType.toString());  [BUGGY]    for  (String  name  :  currentPropertyNames)  {  ObjectType  oType  =  properties.get(name);  if  (oType  !=  null)  {  if  (!interfaceType.getPropertyType(name).isEquivalentTo(  oType.getPropertyType(name)))  {  compiler.report(  t.makeError(n,  INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,  functionName,  name,  oType.toString(),  interfaceType.toString()));  }  [CLASS]  TypeCheck  [METHOD]  checkInterfaceConflictProperties  [RETURN_TYPE]  void  NodeTraversal  t  Node  n  String  functionName  ObjectType>  properties  ObjectType>  currentProperties  ObjectType  interfaceType  	projects/Closure2/src/com/google/javascript/jscomp/TypeCheck.java	0.24253562503633297	1574	1574	1	replace	t.makeError(n,  INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,  functionName,  null,  interfaceType.toString());	      	non-compiled	[CE]  orphaned  case	7	None	replace
29	[BUG]  [BUGGY]  t.makeError(n,  INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,  functionName,  null);  [CE]  orphaned  case  [FE]                            NullPointerException    [CONTEXT]      [BUGGY]  t.makeError(n,  INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,  functionName,  null);  [BUGGY]    for  (String  name  :  currentPropertyNames)  {  ObjectType  oType  =  properties.get(name);  if  (oType  !=  null)  {  if  (!interfaceType.getPropertyType(name).isEquivalentTo(  oType.getPropertyType(name)))  {  compiler.report(  t.makeError(n,  INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,  functionName,  name,  oType.toString(),  interfaceType.toString()));  }  [CLASS]  TypeCheck  [METHOD]  checkInterfaceConflictProperties  [RETURN_TYPE]  void  NodeTraversal  t  Node  n  String  functionName  ObjectType>  properties  ObjectType>  currentProperties  ObjectType  interfaceType  	projects/Closure2/src/com/google/javascript/jscomp/TypeCheck.java	0.24253562503633297	1574	1574	1	replace	t.makeError(n,  INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,  functionName,  null);	      	non-compiled	[CE]  orphaned  case	7	None	replace
30	[BUG]  [BUGGY]  t.makeError(n,  INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,  functionName,  null,  interfaceType.toString()));  [CE]  orphaned  case  [FE]                              NullPointerException    [CONTEXT]      [BUGGY]  t.makeError(n,  INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,  functionName,  null,  interfaceType.toString()));  [BUGGY]    for  (String  name  :  currentPropertyNames)  {  ObjectType  oType  =  properties.get(name);  if  (oType  !=  null)  {  if  (!interfaceType.getPropertyType(name).isEquivalentTo(  oType.getPropertyType(name)))  {  compiler.report(  t.makeError(n,  INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,  functionName,  name,  oType.toString(),  interfaceType.toString()));  }  [CLASS]  TypeCheck  [METHOD]  checkInterfaceConflictProperties  [RETURN_TYPE]  void  NodeTraversal  t  Node  n  String  functionName  ObjectType>  properties  ObjectType>  currentProperties  ObjectType  interfaceType  	projects/Closure2/src/com/google/javascript/jscomp/TypeCheck.java	0.24253562503633297	1574	1574	1	replace	t.makeError(n,  INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,  functionName,  null,  interfaceType.toString()));	      	non-compiled	[CE]  orphaned  case	7	None	replace
31	[BUG]  [BUGGY]  NodeTraversal.traverse(compiler,  n,  new  TypeChangeEvent(this));  [CE]  orphaned  case  [FE]                                NullPointerException    [CONTEXT]      [BUGGY]  NodeTraversal.traverse(compiler,  n,  new  TypeChangeEvent(this));  [BUGGY]    for  (String  name  :  currentPropertyNames)  {  ObjectType  oType  =  properties.get(name);  if  (oType  !=  null)  {  if  (!interfaceType.getPropertyType(name).isEquivalentTo(  oType.getPropertyType(name)))  {  compiler.report(  t.makeError(n,  INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,  functionName,  name,  oType.toString(),  interfaceType.toString()));  }  [CLASS]  TypeCheck  [METHOD]  checkInterfaceConflictProperties  [RETURN_TYPE]  void  NodeTraversal  t  Node  n  String  functionName  ObjectType>  properties  ObjectType>  currentProperties  ObjectType  interfaceType  	projects/Closure2/src/com/google/javascript/jscomp/TypeCheck.java	0.24253562503633297	1574	1574	1	replace	NodeTraversal.traverse(compiler,  n,  new  TypeChangeEvent(this));	      	non-compiled	[CE]  orphaned  case	7	None	replace
32	[BUG]  [BUGGY]  currentPropertyNames  =  properties.get(n.getOwnPropertyNames());  [CE]  orphaned  case  [FE]              NullPointerException    [CONTEXT]      [BUGGY]  currentPropertyNames  =  properties.get(n.getOwnPropertyNames());  [BUGGY]    for  (String  name  :  currentPropertyNames)  {  ObjectType  oType  =  properties.get(name);  if  (oType  !=  null)  {  if  (!interfaceType.getPropertyType(name).isEquivalentTo(  oType.getPropertyType(name)))  {  compiler.report(  t.makeError(n,  INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,  functionName,  name,  oType.toString(),  interfaceType.toString()));  }  [CLASS]  TypeCheck  [METHOD]  checkInterfaceConflictProperties  [RETURN_TYPE]  void  NodeTraversal  t  Node  n  String  functionName  ObjectType>  properties  ObjectType>  currentProperties  ObjectType  interfaceType  	projects/Closure2/src/com/google/javascript/jscomp/TypeCheck.java	0.24253562503633297	1574	1574	1	replace	currentPropertyNames  =  properties.get(n.getOwnPropertyNames());	  currentPropertyNames    =    properties.get(implicitProto.getOwnPropertyNames());    	non-compiled	[CE]  orphaned  case	4	None	replace
33	[BUG]  [BUGGY]  currentPropertyNames  =  properties.get(properties.get(0).getOwnPropertyNames());  [CE]  orphaned  case  [FE]                NullPointerException    [CONTEXT]      [BUGGY]  currentPropertyNames  =  properties.get(properties.get(0).getOwnPropertyNames());  [BUGGY]    for  (String  name  :  currentPropertyNames)  {  ObjectType  oType  =  properties.get(name);  if  (oType  !=  null)  {  if  (!interfaceType.getPropertyType(name).isEquivalentTo(  oType.getPropertyType(name)))  {  compiler.report(  t.makeError(n,  INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,  functionName,  name,  oType.toString(),  interfaceType.toString()));  }  [CLASS]  TypeCheck  [METHOD]  checkInterfaceConflictProperties  [RETURN_TYPE]  void  NodeTraversal  t  Node  n  String  functionName  ObjectType>  properties  ObjectType>  currentProperties  ObjectType  interfaceType  	projects/Closure2/src/com/google/javascript/jscomp/TypeCheck.java	0.24253562503633297	1574	1574	1	replace	currentPropertyNames  =  properties.get(properties.get(0).getOwnPropertyNames());	  currentPropertyNames    =    properties.get(implicitProto.getOwnPropertyNames());    	non-compiled	[CE]  orphaned  case	4	None	replace
34	[BUG]  [BUGGY]  currentPropertyNames  =  properties.get(implicitProto.getOwnPropertyNames(),  null);  [CE]  orphaned  case  [FE]                  NullPointerException    [CONTEXT]      [BUGGY]  currentPropertyNames  =  properties.get(implicitProto.getOwnPropertyNames(),  null);  [BUGGY]    for  (String  name  :  currentPropertyNames)  {  ObjectType  oType  =  properties.get(name);  if  (oType  !=  null)  {  if  (!interfaceType.getPropertyType(name).isEquivalentTo(  oType.getPropertyType(name)))  {  compiler.report(  t.makeError(n,  INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,  functionName,  name,  oType.toString(),  interfaceType.toString()));  }  [CLASS]  TypeCheck  [METHOD]  checkInterfaceConflictProperties  [RETURN_TYPE]  void  NodeTraversal  t  Node  n  String  functionName  ObjectType>  properties  ObjectType>  currentProperties  ObjectType  interfaceType  	projects/Closure2/src/com/google/javascript/jscomp/TypeCheck.java	0.24253562503633297	1574	1574	1	replace	currentPropertyNames  =  properties.get(implicitProto.getOwnPropertyNames(),  null);	  currentPropertyNames    =    properties.get(implicitProto.getOwnPropertyNames());    	non-compiled	[CE]  orphaned  case	4	None	replace
35	[BUG]  [BUGGY]  ObjectType  currentPropertyNames  =  properties.get(implicitProto.getOwnPropertyNames());  [CE]  orphaned  case  [FE]                    NullPointerException    [CONTEXT]      [BUGGY]  ObjectType  currentPropertyNames  =  properties.get(implicitProto.getOwnPropertyNames());  [BUGGY]    for  (String  name  :  currentPropertyNames)  {  ObjectType  oType  =  properties.get(name);  if  (oType  !=  null)  {  if  (!interfaceType.getPropertyType(name).isEquivalentTo(  oType.getPropertyType(name)))  {  compiler.report(  t.makeError(n,  INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,  functionName,  name,  oType.toString(),  interfaceType.toString()));  }  [CLASS]  TypeCheck  [METHOD]  checkInterfaceConflictProperties  [RETURN_TYPE]  void  NodeTraversal  t  Node  n  String  functionName  ObjectType>  properties  ObjectType>  currentProperties  ObjectType  interfaceType  	projects/Closure2/src/com/google/javascript/jscomp/TypeCheck.java	0.24253562503633297	1574	1574	1	replace	ObjectType  currentPropertyNames  =  properties.get(implicitProto.getOwnPropertyNames());	  currentPropertyNames    =    properties.get(implicitProto.getOwnPropertyNames());    	non-compiled	[CE]  orphaned  case	4	None	replace
36	[BUG]  [BUGGY]  currentPropertyNames  =  properties.get(implicitProto.getOwnPropertyNames(),  true);  [CE]  orphaned  case  [FE]                      NullPointerException    [CONTEXT]      [BUGGY]  currentPropertyNames  =  properties.get(implicitProto.getOwnPropertyNames(),  true);  [BUGGY]    for  (String  name  :  currentPropertyNames)  {  ObjectType  oType  =  properties.get(name);  if  (oType  !=  null)  {  if  (!interfaceType.getPropertyType(name).isEquivalentTo(  oType.getPropertyType(name)))  {  compiler.report(  t.makeError(n,  INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,  functionName,  name,  oType.toString(),  interfaceType.toString()));  }  [CLASS]  TypeCheck  [METHOD]  checkInterfaceConflictProperties  [RETURN_TYPE]  void  NodeTraversal  t  Node  n  String  functionName  ObjectType>  properties  ObjectType>  currentProperties  ObjectType  interfaceType  	projects/Closure2/src/com/google/javascript/jscomp/TypeCheck.java	0.24253562503633297	1574	1574	1	replace	currentPropertyNames  =  properties.get(implicitProto.getOwnPropertyNames(),  true);	  currentPropertyNames    =    properties.get(implicitProto.getOwnPropertyNames());    	non-compiled	[CE]  orphaned  case	4	None	replace
37	[BUG]  [BUGGY]  currentPropertyNames  =  properties.get(properties.get(implicitProto.getOwnPropertyNames()));  [CE]  orphaned  case  [FE]                        NullPointerException    [CONTEXT]      [BUGGY]  currentPropertyNames  =  properties.get(properties.get(implicitProto.getOwnPropertyNames()));  [BUGGY]    for  (String  name  :  currentPropertyNames)  {  ObjectType  oType  =  properties.get(name);  if  (oType  !=  null)  {  if  (!interfaceType.getPropertyType(name).isEquivalentTo(  oType.getPropertyType(name)))  {  compiler.report(  t.makeError(n,  INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,  functionName,  name,  oType.toString(),  interfaceType.toString()));  }  [CLASS]  TypeCheck  [METHOD]  checkInterfaceConflictProperties  [RETURN_TYPE]  void  NodeTraversal  t  Node  n  String  functionName  ObjectType>  properties  ObjectType>  currentProperties  ObjectType  interfaceType  	projects/Closure2/src/com/google/javascript/jscomp/TypeCheck.java	0.24253562503633297	1574	1574	1	replace	currentPropertyNames  =  properties.get(properties.get(implicitProto.getOwnPropertyNames()));	  currentPropertyNames    =    properties.get(implicitProto.getOwnPropertyNames());    	non-compiled	[CE]  orphaned  case	4	None	replace
38	[BUG]  [BUGGY]  currentPropertyNames  =  properties.get(this.implicitProto.getOwnPropertyNames());  [CE]  orphaned  case  [FE]        NullPointerException    [CONTEXT]      [BUGGY]  currentPropertyNames  =  properties.get(this.implicitProto.getOwnPropertyNames());  [BUGGY]    for  (String  name  :  currentPropertyNames)  {  ObjectType  oType  =  properties.get(name);  if  (oType  !=  null)  {  if  (!interfaceType.getPropertyType(name).isEquivalentTo(  oType.getPropertyType(name)))  {  compiler.report(  t.makeError(n,  INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,  functionName,  name,  oType.toString(),  interfaceType.toString()));  }  [CLASS]  TypeCheck  [METHOD]  checkInterfaceConflictProperties  [RETURN_TYPE]  void  NodeTraversal  t  Node  n  String  functionName  ObjectType>  properties  ObjectType>  currentProperties  ObjectType  interfaceType  	projects/Closure2/src/com/google/javascript/jscomp/TypeCheck.java	0.24253562503633297	1574	1574	1	replace	currentPropertyNames  =  properties.get(this.implicitProto.getOwnPropertyNames());	  currentPropertyNames    =    this.implicitProto.getOwnPropertyNames();    	non-compiled	[CE]  orphaned  case	1	None	replace
39	[BUG]  [BUGGY]  if(this.implicitProto!=  null)  {  currentPropertyNames  =  this.implicitProto.getOwnPropertyNames();  }  [CE]  orphaned  case  [FE]          NullPointerException    [CONTEXT]      [BUGGY]  if(this.implicitProto!=  null)  {  currentPropertyNames  =  this.implicitProto.getOwnPropertyNames();  }  [BUGGY]    for  (String  name  :  currentPropertyNames)  {  ObjectType  oType  =  properties.get(name);  if  (oType  !=  null)  {  if  (!interfaceType.getPropertyType(name).isEquivalentTo(  oType.getPropertyType(name)))  {  compiler.report(  t.makeError(n,  INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,  functionName,  name,  oType.toString(),  interfaceType.toString()));  }  [CLASS]  TypeCheck  [METHOD]  checkInterfaceConflictProperties  [RETURN_TYPE]  void  NodeTraversal  t  Node  n  String  functionName  ObjectType>  properties  ObjectType>  currentProperties  ObjectType  interfaceType  	projects/Closure2/src/com/google/javascript/jscomp/TypeCheck.java	0.24253562503633297	1574	1574	1	replace	if(this.implicitProto!=  null)  {  currentPropertyNames  =  this.implicitProto.getOwnPropertyNames();  }	  currentPropertyNames    =    this.implicitProto.getOwnPropertyNames();    	non-compiled	[CE]  orphaned  case	1	None	replace
40	[BUG]  [BUGGY]  CurrentPropertyNames  currentPropertyNames  =  this.implicitProto.getOwnPropertyNames();  [CE]  orphaned  case  [FE]            NullPointerException    [CONTEXT]      [BUGGY]  CurrentPropertyNames  currentPropertyNames  =  this.implicitProto.getOwnPropertyNames();  [BUGGY]    for  (String  name  :  currentPropertyNames)  {  ObjectType  oType  =  properties.get(name);  if  (oType  !=  null)  {  if  (!interfaceType.getPropertyType(name).isEquivalentTo(  oType.getPropertyType(name)))  {  compiler.report(  t.makeError(n,  INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,  functionName,  name,  oType.toString(),  interfaceType.toString()));  }  [CLASS]  TypeCheck  [METHOD]  checkInterfaceConflictProperties  [RETURN_TYPE]  void  NodeTraversal  t  Node  n  String  functionName  ObjectType>  properties  ObjectType>  currentProperties  ObjectType  interfaceType  	projects/Closure2/src/com/google/javascript/jscomp/TypeCheck.java	0.24253562503633297	1574	1574	1	replace	CurrentPropertyNames  currentPropertyNames  =  this.implicitProto.getOwnPropertyNames();	  currentPropertyNames    =    this.implicitProto.getOwnPropertyNames();    	non-compiled	[CE]  orphaned  case	1	None	replace
41	[BUG]  [BUGGY]  if(this.implicitProto!=  null)  {  currentPropertyNames  =  this.implicitProto.getOwnPropertyNames();  }  else  {  throw  new  IllegalArgumentException( " ");  }  [CE]  orphaned  case  [FE]              NullPointerException    [CONTEXT]      [BUGGY]  if(this.implicitProto!=  null)  {  currentPropertyNames  =  this.implicitProto.getOwnPropertyNames();  }  else  {  throw  new  IllegalArgumentException( " ");  }  [BUGGY]    for  (String  name  :  currentPropertyNames)  {  ObjectType  oType  =  properties.get(name);  if  (oType  !=  null)  {  if  (!interfaceType.getPropertyType(name).isEquivalentTo(  oType.getPropertyType(name)))  {  compiler.report(  t.makeError(n,  INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,  functionName,  name,  oType.toString(),  interfaceType.toString()));  }  [CLASS]  TypeCheck  [METHOD]  checkInterfaceConflictProperties  [RETURN_TYPE]  void  NodeTraversal  t  Node  n  String  functionName  ObjectType>  properties  ObjectType>  currentProperties  ObjectType  interfaceType  	projects/Closure2/src/com/google/javascript/jscomp/TypeCheck.java	0.24253562503633297	1574	1574	1	replace	if(this.implicitProto!=  null)  {  currentPropertyNames  =  this.implicitProto.getOwnPropertyNames();  }  else  {  throw  new  IllegalArgumentException( " ");  }	  currentPropertyNames    =    this.implicitProto.getOwnPropertyNames();    	non-compiled	[CE]  orphaned  case	1	None	replace
42	[BUG]  [BUGGY]  CurrentPropertyNames  n  =  currentProperties.getOwnPropertyNames();  [CE]  orphaned  case  [FE]          NullPointerException    [CONTEXT]      [BUGGY]  CurrentPropertyNames  n  =  currentProperties.getOwnPropertyNames();  [BUGGY]    for  (String  name  :  currentPropertyNames)  {  ObjectType  oType  =  properties.get(name);  if  (oType  !=  null)  {  if  (!interfaceType.getPropertyType(name).isEquivalentTo(  oType.getPropertyType(name)))  {  compiler.report(  t.makeError(n,  INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,  functionName,  name,  oType.toString(),  interfaceType.toString()));  }  [CLASS]  TypeCheck  [METHOD]  checkInterfaceConflictProperties  [RETURN_TYPE]  void  NodeTraversal  t  Node  n  String  functionName  ObjectType>  properties  ObjectType>  currentProperties  ObjectType  interfaceType  	projects/Closure2/src/com/google/javascript/jscomp/TypeCheck.java	0.24253562503633297	1574	1574	1	replace	CurrentPropertyNames  n  =  currentProperties.getOwnPropertyNames();	  currentPropertyNames    =    n.getOwnPropertyNames();    	non-compiled	[CE]  orphaned  case	2	None	replace
43	[BUG]  [BUGGY]  currentPropertyNames  =  properties.get(n.getType());  [CE]  orphaned  case  [FE]            NullPointerException    [CONTEXT]      [BUGGY]  currentPropertyNames  =  properties.get(n.getType());  [BUGGY]    for  (String  name  :  currentPropertyNames)  {  ObjectType  oType  =  properties.get(name);  if  (oType  !=  null)  {  if  (!interfaceType.getPropertyType(name).isEquivalentTo(  oType.getPropertyType(name)))  {  compiler.report(  t.makeError(n,  INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,  functionName,  name,  oType.toString(),  interfaceType.toString()));  }  [CLASS]  TypeCheck  [METHOD]  checkInterfaceConflictProperties  [RETURN_TYPE]  void  NodeTraversal  t  Node  n  String  functionName  ObjectType>  properties  ObjectType>  currentProperties  ObjectType  interfaceType  	projects/Closure2/src/com/google/javascript/jscomp/TypeCheck.java	0.24253562503633297	1574	1574	1	replace	currentPropertyNames  =  properties.get(n.getType());	  currentPropertyNames    =    n.getOwnPropertyNames();    	non-compiled	[CE]  orphaned  case	2	None	replace
44	[BUG]  [BUGGY]  currentPropertyNames  =  properties.get(n);  [CE]  orphaned  case  [FE]              NullPointerException    [CONTEXT]      [BUGGY]  currentPropertyNames  =  properties.get(n);  [BUGGY]    for  (String  name  :  currentPropertyNames)  {  ObjectType  oType  =  properties.get(name);  if  (oType  !=  null)  {  if  (!interfaceType.getPropertyType(name).isEquivalentTo(  oType.getPropertyType(name)))  {  compiler.report(  t.makeError(n,  INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,  functionName,  name,  oType.toString(),  interfaceType.toString()));  }  [CLASS]  TypeCheck  [METHOD]  checkInterfaceConflictProperties  [RETURN_TYPE]  void  NodeTraversal  t  Node  n  String  functionName  ObjectType>  properties  ObjectType>  currentProperties  ObjectType  interfaceType  	projects/Closure2/src/com/google/javascript/jscomp/TypeCheck.java	0.24253562503633297	1574	1574	1	replace	currentPropertyNames  =  properties.get(n);	  currentPropertyNames    =    n.getOwnPropertyNames();    	non-compiled	[CE]  orphaned  case	2	None	replace
45	[BUG]  [BUGGY]  currentPropertyNames  =  getImplicitPrototype().getOwnPropertyNames(properties);  [CE]  orphaned  case  [FE]            NullPointerException    [CONTEXT]      [BUGGY]  currentPropertyNames  =  getImplicitPrototype().getOwnPropertyNames(properties);  [BUGGY]    for  (String  name  :  currentPropertyNames)  {  ObjectType  oType  =  properties.get(name);  if  (oType  !=  null)  {  if  (!interfaceType.getPropertyType(name).isEquivalentTo(  oType.getPropertyType(name)))  {  compiler.report(  t.makeError(n,  INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,  functionName,  name,  oType.toString(),  interfaceType.toString()));  }  [CLASS]  TypeCheck  [METHOD]  checkInterfaceConflictProperties  [RETURN_TYPE]  void  NodeTraversal  t  Node  n  String  functionName  ObjectType>  properties  ObjectType>  currentProperties  ObjectType  interfaceType  	projects/Closure2/src/com/google/javascript/jscomp/TypeCheck.java	0.24253562503633297	1574	1574	1	replace	currentPropertyNames  =  getImplicitPrototype().getOwnPropertyNames(properties);	  currentPropertyNames    =    getImplicitPrototype().getOwnPropertyNames();    	non-compiled	[CE]  orphaned  case	3	None	replace
46	[BUG]  [BUGGY]  CurrentPropertyNames  currentPropertyNames  =  getImplicitPrototype().getPropertyNames();  [CE]  orphaned  case  [FE]              NullPointerException    [CONTEXT]      [BUGGY]  CurrentPropertyNames  currentPropertyNames  =  getImplicitPrototype().getPropertyNames();  [BUGGY]    for  (String  name  :  currentPropertyNames)  {  ObjectType  oType  =  properties.get(name);  if  (oType  !=  null)  {  if  (!interfaceType.getPropertyType(name).isEquivalentTo(  oType.getPropertyType(name)))  {  compiler.report(  t.makeError(n,  INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,  functionName,  name,  oType.toString(),  interfaceType.toString()));  }  [CLASS]  TypeCheck  [METHOD]  checkInterfaceConflictProperties  [RETURN_TYPE]  void  NodeTraversal  t  Node  n  String  functionName  ObjectType>  properties  ObjectType>  currentProperties  ObjectType  interfaceType  	projects/Closure2/src/com/google/javascript/jscomp/TypeCheck.java	0.24253562503633297	1574	1574	1	replace	CurrentPropertyNames  currentPropertyNames  =  getImplicitPrototype().getPropertyNames();	  currentPropertyNames    =    getImplicitPrototype().getOwnPropertyNames();    	non-compiled	[CE]  orphaned  case	3	None	replace
47	[BUG]  [BUGGY]  currentPropertyNames  =  getImplicitPrototype().getReferenceNames();  [CE]  orphaned  case  [FE]                NullPointerException    [CONTEXT]      [BUGGY]  currentPropertyNames  =  getImplicitPrototype().getReferenceNames();  [BUGGY]    for  (String  name  :  currentPropertyNames)  {  ObjectType  oType  =  properties.get(name);  if  (oType  !=  null)  {  if  (!interfaceType.getPropertyType(name).isEquivalentTo(  oType.getPropertyType(name)))  {  compiler.report(  t.makeError(n,  INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,  functionName,  name,  oType.toString(),  interfaceType.toString()));  }  [CLASS]  TypeCheck  [METHOD]  checkInterfaceConflictProperties  [RETURN_TYPE]  void  NodeTraversal  t  Node  n  String  functionName  ObjectType>  properties  ObjectType>  currentProperties  ObjectType  interfaceType  	projects/Closure2/src/com/google/javascript/jscomp/TypeCheck.java	0.24253562503633297	1574	1574	1	replace	currentPropertyNames  =  getImplicitPrototype().getReferenceNames();	  currentPropertyNames    =    getImplicitPrototype().getOwnPropertyNames();    	non-compiled	[CE]  orphaned  case	3	None	replace
48	[BUG]  [BUGGY]  currentPropertyNames  =  properties.get(implicitProto.getReferenceName());  [CE]  orphaned  case  [FE]                  NullPointerException    [CONTEXT]      [BUGGY]  currentPropertyNames  =  properties.get(implicitProto.getReferenceName());  [BUGGY]    for  (String  name  :  currentPropertyNames)  {  ObjectType  oType  =  properties.get(name);  if  (oType  !=  null)  {  if  (!interfaceType.getPropertyType(name).isEquivalentTo(  oType.getPropertyType(name)))  {  compiler.report(  t.makeError(n,  INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,  functionName,  name,  oType.toString(),  interfaceType.toString()));  }  [CLASS]  TypeCheck  [METHOD]  checkInterfaceConflictProperties  [RETURN_TYPE]  void  NodeTraversal  t  Node  n  String  functionName  ObjectType>  properties  ObjectType>  currentProperties  ObjectType  interfaceType  	projects/Closure2/src/com/google/javascript/jscomp/TypeCheck.java	0.24253562503633297	1574	1574	1	replace	currentPropertyNames  =  properties.get(implicitProto.getReferenceName());	  currentPropertyNames    =    properties.get(implicitProto.getOwnPropertyName());    	non-compiled	[CE]  orphaned  case	6	None	replace
49	[BUG]  [BUGGY]  currentPropertyNames  =  properties.get(implicitProto.getConstructor());  [CE]  orphaned  case  [FE]                    NullPointerException    [CONTEXT]      [BUGGY]  currentPropertyNames  =  properties.get(implicitProto.getConstructor());  [BUGGY]    for  (String  name  :  currentPropertyNames)  {  ObjectType  oType  =  properties.get(name);  if  (oType  !=  null)  {  if  (!interfaceType.getPropertyType(name).isEquivalentTo(  oType.getPropertyType(name)))  {  compiler.report(  t.makeError(n,  INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,  functionName,  name,  oType.toString(),  interfaceType.toString()));  }  [CLASS]  TypeCheck  [METHOD]  checkInterfaceConflictProperties  [RETURN_TYPE]  void  NodeTraversal  t  Node  n  String  functionName  ObjectType>  properties  ObjectType>  currentProperties  ObjectType  interfaceType  	projects/Closure2/src/com/google/javascript/jscomp/TypeCheck.java	0.24253562503633297	1574	1574	1	replace	currentPropertyNames  =  properties.get(implicitProto.getConstructor());	  currentPropertyNames    =    properties.get(implicitProto.getOwnPropertyName());    	non-compiled	[CE]  orphaned  case	6	None	replace
50	[BUG]  [BUGGY]  currentPropertyNames  =  properties.get(implicitProto.getOwnPropertyName(),  interfaceType);  [CE]  orphaned  case  [FE]                      NullPointerException    [CONTEXT]      [BUGGY]  currentPropertyNames  =  properties.get(implicitProto.getOwnPropertyName(),  interfaceType);  [BUGGY]    for  (String  name  :  currentPropertyNames)  {  ObjectType  oType  =  properties.get(name);  if  (oType  !=  null)  {  if  (!interfaceType.getPropertyType(name).isEquivalentTo(  oType.getPropertyType(name)))  {  compiler.report(  t.makeError(n,  INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,  functionName,  name,  oType.toString(),  interfaceType.toString()));  }  [CLASS]  TypeCheck  [METHOD]  checkInterfaceConflictProperties  [RETURN_TYPE]  void  NodeTraversal  t  Node  n  String  functionName  ObjectType>  properties  ObjectType>  currentProperties  ObjectType  interfaceType  	projects/Closure2/src/com/google/javascript/jscomp/TypeCheck.java	0.24253562503633297	1574	1574	1	replace	currentPropertyNames  =  properties.get(implicitProto.getOwnPropertyName(),  interfaceType);	  currentPropertyNames    =    properties.get(implicitProto.getOwnPropertyName());    	non-compiled	[CE]  orphaned  case	6	None	replace
51	[BUG]  [BUGGY]  t.makeError(n,  INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,  functionName,  interfaceType.toString());  [CE]  orphaned  case  [FE]                    NullPointerException    [CONTEXT]      [BUGGY]  t.makeError(n,  INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,  functionName,  interfaceType.toString());  [BUGGY]    for  (String  name  :  currentPropertyNames)  {  ObjectType  oType  =  properties.get(name);  if  (oType  !=  null)  {  if  (!interfaceType.getPropertyType(name).isEquivalentTo(  oType.getPropertyType(name)))  {  compiler.report(  t.makeError(n,  INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,  functionName,  name,  oType.toString(),  interfaceType.toString()));  }  [CLASS]  TypeCheck  [METHOD]  checkInterfaceConflictProperties  [RETURN_TYPE]  void  NodeTraversal  t  Node  n  String  functionName  ObjectType>  properties  ObjectType>  currentProperties  ObjectType  interfaceType  	projects/Closure2/src/com/google/javascript/jscomp/TypeCheck.java	0.24253562503633297	1574	1574	1	replace	t.makeError(n,  INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,  functionName,  interfaceType.toString());	      	non-compiled	[CE]  orphaned  case	7	None	replace
52	[BUG]  [BUGGY]  currentPropertyNames  =  propertyNames.getOwnPropertyNames();  [CE]  orphaned  case  [FE]          NullPointerException    [CONTEXT]      [BUGGY]  currentPropertyNames  =  propertyNames.getOwnPropertyNames();  [BUGGY]    for  (String  name  :  currentPropertyNames)  {  ObjectType  oType  =  properties.get(name);  if  (oType  !=  null)  {  if  (!interfaceType.getPropertyType(name).isEquivalentTo(  oType.getPropertyType(name)))  {  compiler.report(  t.makeError(n,  INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,  functionName,  name,  oType.toString(),  interfaceType.toString()));  }  [CLASS]  TypeCheck  [METHOD]  checkInterfaceConflictProperties  [RETURN_TYPE]  void  NodeTraversal  t  Node  n  String  functionName  ObjectType>  properties  ObjectType>  currentProperties  ObjectType  interfaceType  	projects/Closure2/src/com/google/javascript/jscomp/TypeCheck.java	0.24253562503633297	1574	1574	1	replace	currentPropertyNames  =  propertyNames.getOwnPropertyNames();	  currentPropertyNames    =    n.getOwnPropertyNames();    	non-compiled	[CE]  orphaned  case	2	None	replace
53	[BUG]  [BUGGY]  CurrentPropertyNames  currentPropertyNames  =  n.getOwnPropertyNames();  [CE]  orphaned  case  [FE]            NullPointerException    [CONTEXT]      [BUGGY]  CurrentPropertyNames  currentPropertyNames  =  n.getOwnPropertyNames();  [BUGGY]    for  (String  name  :  currentPropertyNames)  {  ObjectType  oType  =  properties.get(name);  if  (oType  !=  null)  {  if  (!interfaceType.getPropertyType(name).isEquivalentTo(  oType.getPropertyType(name)))  {  compiler.report(  t.makeError(n,  INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,  functionName,  name,  oType.toString(),  interfaceType.toString()));  }  [CLASS]  TypeCheck  [METHOD]  checkInterfaceConflictProperties  [RETURN_TYPE]  void  NodeTraversal  t  Node  n  String  functionName  ObjectType>  properties  ObjectType>  currentProperties  ObjectType  interfaceType  	projects/Closure2/src/com/google/javascript/jscomp/TypeCheck.java	0.24253562503633297	1574	1574	1	replace	CurrentPropertyNames  currentPropertyNames  =  n.getOwnPropertyNames();	  currentPropertyNames    =    n.getOwnPropertyNames();    	non-compiled	[CE]  orphaned  case	2	None	replace
54	[BUG]  [BUGGY]  currentPropertyNames  =(this.implicitProto!=  null)?  this.implicitProto.getOwnPropertyNames()  :  null;  [CE]  orphaned  case  [FE]        NullPointerException    [CONTEXT]      [BUGGY]  currentPropertyNames  =(this.implicitProto!=  null)?  this.implicitProto.getOwnPropertyNames()  :  null;  [BUGGY]    for  (String  name  :  currentPropertyNames)  {  ObjectType  oType  =  properties.get(name);  if  (oType  !=  null)  {  if  (!interfaceType.getPropertyType(name).isEquivalentTo(  oType.getPropertyType(name)))  {  compiler.report(  t.makeError(n,  INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,  functionName,  name,  oType.toString(),  interfaceType.toString()));  }  [CLASS]  TypeCheck  [METHOD]  checkInterfaceConflictProperties  [RETURN_TYPE]  void  NodeTraversal  t  Node  n  String  functionName  ObjectType>  properties  ObjectType>  currentProperties  ObjectType  interfaceType  	projects/Closure2/src/com/google/javascript/jscomp/TypeCheck.java	0.24253562503633297	1574	1574	1	replace	currentPropertyNames  =(this.implicitProto!=  null)?  this.implicitProto.getOwnPropertyNames()  :  null;	  currentPropertyNames    =    this.implicitProto.getOwnPropertyNames();    	non-compiled	[CE]  orphaned  case	1	None	replace
55	[BUG]  [BUGGY]  currentPropertyNames  =(this.implicitProto!=  null)?  this.implicitProto.getOwnPropertyNames()  :  properties;  [CE]  orphaned  case  [FE]          NullPointerException    [CONTEXT]      [BUGGY]  currentPropertyNames  =(this.implicitProto!=  null)?  this.implicitProto.getOwnPropertyNames()  :  properties;  [BUGGY]    for  (String  name  :  currentPropertyNames)  {  ObjectType  oType  =  properties.get(name);  if  (oType  !=  null)  {  if  (!interfaceType.getPropertyType(name).isEquivalentTo(  oType.getPropertyType(name)))  {  compiler.report(  t.makeError(n,  INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,  functionName,  name,  oType.toString(),  interfaceType.toString()));  }  [CLASS]  TypeCheck  [METHOD]  checkInterfaceConflictProperties  [RETURN_TYPE]  void  NodeTraversal  t  Node  n  String  functionName  ObjectType>  properties  ObjectType>  currentProperties  ObjectType  interfaceType  	projects/Closure2/src/com/google/javascript/jscomp/TypeCheck.java	0.24253562503633297	1574	1574	1	replace	currentPropertyNames  =(this.implicitProto!=  null)?  this.implicitProto.getOwnPropertyNames()  :  properties;	  currentPropertyNames    =    this.implicitProto.getOwnPropertyNames();    	non-compiled	[CE]  orphaned  case	1	None	replace
56	[BUG]  [BUGGY]  currentPropertyNames  =  this.properties.getOwnPropertyNames();  [CE]  orphaned  case  [FE]            NullPointerException    [CONTEXT]      [BUGGY]  currentPropertyNames  =  this.properties.getOwnPropertyNames();  [BUGGY]    for  (String  name  :  currentPropertyNames)  {  ObjectType  oType  =  properties.get(name);  if  (oType  !=  null)  {  if  (!interfaceType.getPropertyType(name).isEquivalentTo(  oType.getPropertyType(name)))  {  compiler.report(  t.makeError(n,  INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,  functionName,  name,  oType.toString(),  interfaceType.toString()));  }  [CLASS]  TypeCheck  [METHOD]  checkInterfaceConflictProperties  [RETURN_TYPE]  void  NodeTraversal  t  Node  n  String  functionName  ObjectType>  properties  ObjectType>  currentProperties  ObjectType  interfaceType  	projects/Closure2/src/com/google/javascript/jscomp/TypeCheck.java	0.24253562503633297	1574	1574	1	replace	currentPropertyNames  =  this.properties.getOwnPropertyNames();	  currentPropertyNames    =    this.implicitProto.getOwnPropertyNames();    	non-compiled	[CE]  orphaned  case	1	None	replace
57	[BUG]  [BUGGY]  CurrentPropertyNames  currentPropertyNames  =  properties.get(implicitProto).getOwnPropertyNames();  [CE]  orphaned  case  [FE]        NullPointerException    [CONTEXT]      [BUGGY]  CurrentPropertyNames  currentPropertyNames  =  properties.get(implicitProto).getOwnPropertyNames();  [BUGGY]    for  (String  name  :  currentPropertyNames)  {  ObjectType  oType  =  properties.get(name);  if  (oType  !=  null)  {  if  (!interfaceType.getPropertyType(name).isEquivalentTo(  oType.getPropertyType(name)))  {  compiler.report(  t.makeError(n,  INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,  functionName,  name,  oType.toString(),  interfaceType.toString()));  }  [CLASS]  TypeCheck  [METHOD]  checkInterfaceConflictProperties  [RETURN_TYPE]  void  NodeTraversal  t  Node  n  String  functionName  ObjectType>  properties  ObjectType>  currentProperties  ObjectType  interfaceType  	projects/Closure2/src/com/google/javascript/jscomp/TypeCheck.java	0.24253562503633297	1574	1574	1	replace	CurrentPropertyNames  currentPropertyNames  =  properties.get(implicitProto).getOwnPropertyNames();	  currentPropertyNames    =    properties.get(implicitProto).getOwnPropertyNames();    	non-compiled	[CE]  orphaned  case	8	None	replace
58	[BUG]  [BUGGY]  NodeTraversal.traverse(compiler,  n,  currentPropertyNames);  [CE]  orphaned  case  [FE]          NullPointerException    [CONTEXT]      [BUGGY]  NodeTraversal.traverse(compiler,  n,  currentPropertyNames);  [BUGGY]    for  (String  name  :  currentPropertyNames)  {  ObjectType  oType  =  properties.get(name);  if  (oType  !=  null)  {  if  (!interfaceType.getPropertyType(name).isEquivalentTo(  oType.getPropertyType(name)))  {  compiler.report(  t.makeError(n,  INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,  functionName,  name,  oType.toString(),  interfaceType.toString()));  }  [CLASS]  TypeCheck  [METHOD]  checkInterfaceConflictProperties  [RETURN_TYPE]  void  NodeTraversal  t  Node  n  String  functionName  ObjectType>  properties  ObjectType>  currentProperties  ObjectType  interfaceType  	projects/Closure2/src/com/google/javascript/jscomp/TypeCheck.java	0.24253562503633297	1574	1574	1	replace	NodeTraversal.traverse(compiler,  n,  currentPropertyNames);	  currentPropertyNames    =    properties.get(implicitProto).getOwnPropertyNames();    	non-compiled	[CE]  orphaned  case	8	None	replace
59	[BUG]  [BUGGY]  currentPropertyNames  =  properties.get(implicitProto.getOwnPropertyNames()  -  1);  [CE]  orphaned  case  [FE]              NullPointerException    [CONTEXT]      [BUGGY]  currentPropertyNames  =  properties.get(implicitProto.getOwnPropertyNames()  -  1);  [BUGGY]    for  (String  name  :  currentPropertyNames)  {  ObjectType  oType  =  properties.get(name);  if  (oType  !=  null)  {  if  (!interfaceType.getPropertyType(name).isEquivalentTo(  oType.getPropertyType(name)))  {  compiler.report(  t.makeError(n,  INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,  functionName,  name,  oType.toString(),  interfaceType.toString()));  }  [CLASS]  TypeCheck  [METHOD]  checkInterfaceConflictProperties  [RETURN_TYPE]  void  NodeTraversal  t  Node  n  String  functionName  ObjectType>  properties  ObjectType>  currentProperties  ObjectType  interfaceType  	projects/Closure2/src/com/google/javascript/jscomp/TypeCheck.java	0.24253562503633297	1574	1574	1	replace	currentPropertyNames  =  properties.get(implicitProto.getOwnPropertyNames()  -  1);	  currentPropertyNames    =    properties.get(implicitProto.getOwnPropertyNames());    	non-compiled	[CE]  orphaned  case	4	None	replace
60	[BUG]  [BUGGY]  currentPropertyNames  =  properties.get(implicitProto.getPropertyNames());  [CE]  orphaned  case  [FE]                NullPointerException    [CONTEXT]      [BUGGY]  currentPropertyNames  =  properties.get(implicitProto.getPropertyNames());  [BUGGY]    for  (String  name  :  currentPropertyNames)  {  ObjectType  oType  =  properties.get(name);  if  (oType  !=  null)  {  if  (!interfaceType.getPropertyType(name).isEquivalentTo(  oType.getPropertyType(name)))  {  compiler.report(  t.makeError(n,  INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,  functionName,  name,  oType.toString(),  interfaceType.toString()));  }  [CLASS]  TypeCheck  [METHOD]  checkInterfaceConflictProperties  [RETURN_TYPE]  void  NodeTraversal  t  Node  n  String  functionName  ObjectType>  properties  ObjectType>  currentProperties  ObjectType  interfaceType  	projects/Closure2/src/com/google/javascript/jscomp/TypeCheck.java	0.24253562503633297	1574	1574	1	replace	currentPropertyNames  =  properties.get(implicitProto.getPropertyNames());	  currentPropertyNames    =    implicitProto.getPropertyNames();    	non-compiled	[CE]  orphaned  case	5	None	replace
61	[BUG]  [BUGGY]  currentPropertyNames  =  properties.get(0).getPropertyNames();  [CE]  orphaned  case  [FE]                NullPointerException    [CONTEXT]      [BUGGY]  currentPropertyNames  =  properties.get(0).getPropertyNames();  [BUGGY]    for  (String  name  :  currentPropertyNames)  {  ObjectType  oType  =  properties.get(name);  if  (oType  !=  null)  {  if  (!interfaceType.getPropertyType(name).isEquivalentTo(  oType.getPropertyType(name)))  {  compiler.report(  t.makeError(n,  INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,  functionName,  name,  oType.toString(),  interfaceType.toString()));  }  [CLASS]  TypeCheck  [METHOD]  checkInterfaceConflictProperties  [RETURN_TYPE]  void  NodeTraversal  t  Node  n  String  functionName  ObjectType>  properties  ObjectType>  currentProperties  ObjectType  interfaceType  	projects/Closure2/src/com/google/javascript/jscomp/TypeCheck.java	0.24253562503633297	1574	1574	1	replace	currentPropertyNames  =  properties.get(0).getPropertyNames();	  currentPropertyNames    =    implicitProto.getPropertyNames();    	non-compiled	[CE]  orphaned  case	5	None	replace
62	[BUG]  [BUGGY]  currentPropertyNames  =  getImplicitPrototype().getOwnerPropertyNames();  [CE]  orphaned  case  [FE]            NullPointerException    [CONTEXT]      [BUGGY]  currentPropertyNames  =  getImplicitPrototype().getOwnerPropertyNames();  [BUGGY]    for  (String  name  :  currentPropertyNames)  {  ObjectType  oType  =  properties.get(name);  if  (oType  !=  null)  {  if  (!interfaceType.getPropertyType(name).isEquivalentTo(  oType.getPropertyType(name)))  {  compiler.report(  t.makeError(n,  INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,  functionName,  name,  oType.toString(),  interfaceType.toString()));  }  [CLASS]  TypeCheck  [METHOD]  checkInterfaceConflictProperties  [RETURN_TYPE]  void  NodeTraversal  t  Node  n  String  functionName  ObjectType>  properties  ObjectType>  currentProperties  ObjectType  interfaceType  	projects/Closure2/src/com/google/javascript/jscomp/TypeCheck.java	0.24253562503633297	1574	1574	1	replace	currentPropertyNames  =  getImplicitPrototype().getOwnerPropertyNames();	  currentPropertyNames    =    getImplicitPrototype().getOwnPropertyNames();    	non-compiled	[CE]  orphaned  case	3	None	replace
63	[BUG]  [BUGGY]  CurrentPropertyNames  =  getImplicitPrototype().getOwnPropertyNames();  [CE]  orphaned  case  [FE]              NullPointerException    [CONTEXT]      [BUGGY]  CurrentPropertyNames  =  getImplicitPrototype().getOwnPropertyNames();  [BUGGY]    for  (String  name  :  currentPropertyNames)  {  ObjectType  oType  =  properties.get(name);  if  (oType  !=  null)  {  if  (!interfaceType.getPropertyType(name).isEquivalentTo(  oType.getPropertyType(name)))  {  compiler.report(  t.makeError(n,  INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,  functionName,  name,  oType.toString(),  interfaceType.toString()));  }  [CLASS]  TypeCheck  [METHOD]  checkInterfaceConflictProperties  [RETURN_TYPE]  void  NodeTraversal  t  Node  n  String  functionName  ObjectType>  properties  ObjectType>  currentProperties  ObjectType  interfaceType  	projects/Closure2/src/com/google/javascript/jscomp/TypeCheck.java	0.24253562503633297	1574	1574	1	replace	CurrentPropertyNames  =  getImplicitPrototype().getOwnPropertyNames();	  currentPropertyNames    =    getImplicitPrototype().getOwnPropertyNames();    	non-compiled	[CE]  orphaned  case	3	None	replace
64	[BUG]  [BUGGY]  currentPropertyNames  =  getImplicitPrototype().getProperties();  [CE]  orphaned  case  [FE]                NullPointerException    [CONTEXT]      [BUGGY]  currentPropertyNames  =  getImplicitPrototype().getProperties();  [BUGGY]    for  (String  name  :  currentPropertyNames)  {  ObjectType  oType  =  properties.get(name);  if  (oType  !=  null)  {  if  (!interfaceType.getPropertyType(name).isEquivalentTo(  oType.getPropertyType(name)))  {  compiler.report(  t.makeError(n,  INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,  functionName,  name,  oType.toString(),  interfaceType.toString()));  }  [CLASS]  TypeCheck  [METHOD]  checkInterfaceConflictProperties  [RETURN_TYPE]  void  NodeTraversal  t  Node  n  String  functionName  ObjectType>  properties  ObjectType>  currentProperties  ObjectType  interfaceType  	projects/Closure2/src/com/google/javascript/jscomp/TypeCheck.java	0.24253562503633297	1574	1574	1	replace	currentPropertyNames  =  getImplicitPrototype().getProperties();	  currentPropertyNames    =    getImplicitPrototype().getOwnPropertyNames();    	non-compiled	[CE]  orphaned  case	3	None	replace
65	[BUG]  [BUGGY]  currentPropertyNames  =  properties.get(implicitProto.getImplicitPropertyNames());  [CE]  orphaned  case  [FE]              NullPointerException    [CONTEXT]      [BUGGY]  currentPropertyNames  =  properties.get(implicitProto.getImplicitPropertyNames());  [BUGGY]    for  (String  name  :  currentPropertyNames)  {  ObjectType  oType  =  properties.get(name);  if  (oType  !=  null)  {  if  (!interfaceType.getPropertyType(name).isEquivalentTo(  oType.getPropertyType(name)))  {  compiler.report(  t.makeError(n,  INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,  functionName,  name,  oType.toString(),  interfaceType.toString()));  }  [CLASS]  TypeCheck  [METHOD]  checkInterfaceConflictProperties  [RETURN_TYPE]  void  NodeTraversal  t  Node  n  String  functionName  ObjectType>  properties  ObjectType>  currentProperties  ObjectType  interfaceType  	projects/Closure2/src/com/google/javascript/jscomp/TypeCheck.java	0.24253562503633297	1574	1574	1	replace	currentPropertyNames  =  properties.get(implicitProto.getImplicitPropertyNames());	  currentPropertyNames    =    properties.get(implicitProto.getOwnPropertyNames());    	non-compiled	[CE]  orphaned  case	4	None	replace
66	[BUG]  [BUGGY]  currentPropertyNames  =  properties.get(implicitProto.getImmediateParentNode());  [CE]  orphaned  case  [FE]                  NullPointerException    [CONTEXT]      [BUGGY]  currentPropertyNames  =  properties.get(implicitProto.getImmediateParentNode());  [BUGGY]    for  (String  name  :  currentPropertyNames)  {  ObjectType  oType  =  properties.get(name);  if  (oType  !=  null)  {  if  (!interfaceType.getPropertyType(name).isEquivalentTo(  oType.getPropertyType(name)))  {  compiler.report(  t.makeError(n,  INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,  functionName,  name,  oType.toString(),  interfaceType.toString()));  }  [CLASS]  TypeCheck  [METHOD]  checkInterfaceConflictProperties  [RETURN_TYPE]  void  NodeTraversal  t  Node  n  String  functionName  ObjectType>  properties  ObjectType>  currentProperties  ObjectType  interfaceType  	projects/Closure2/src/com/google/javascript/jscomp/TypeCheck.java	0.24253562503633297	1574	1574	1	replace	currentPropertyNames  =  properties.get(implicitProto.getImmediateParentNode());	  currentPropertyNames    =    properties.get(implicitProto.getOwnPropertyName());    	non-compiled	[CE]  orphaned  case	6	None	replace
67	[BUG]  [BUGGY]  ObjectType  currentPropertyNames  =  properties.get(implicitProto.getOwnPropertyName());  [CE]  orphaned  case  [FE]                    NullPointerException    [CONTEXT]      [BUGGY]  ObjectType  currentPropertyNames  =  properties.get(implicitProto.getOwnPropertyName());  [BUGGY]    for  (String  name  :  currentPropertyNames)  {  ObjectType  oType  =  properties.get(name);  if  (oType  !=  null)  {  if  (!interfaceType.getPropertyType(name).isEquivalentTo(  oType.getPropertyType(name)))  {  compiler.report(  t.makeError(n,  INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,  functionName,  name,  oType.toString(),  interfaceType.toString()));  }  [CLASS]  TypeCheck  [METHOD]  checkInterfaceConflictProperties  [RETURN_TYPE]  void  NodeTraversal  t  Node  n  String  functionName  ObjectType>  properties  ObjectType>  currentProperties  ObjectType  interfaceType  	projects/Closure2/src/com/google/javascript/jscomp/TypeCheck.java	0.24253562503633297	1574	1574	1	replace	ObjectType  currentPropertyNames  =  properties.get(implicitProto.getOwnPropertyName());	  currentPropertyNames    =    properties.get(implicitProto.getOwnPropertyName());    	non-compiled	[CE]  orphaned  case	6	None	replace
68	[BUG]  [BUGGY]  CurrentPropertyNames  =  properties.get(implicitProto).getOwnPropertyNames();  [CE]  orphaned  case  [FE]        NullPointerException    [CONTEXT]      [BUGGY]  CurrentPropertyNames  =  properties.get(implicitProto).getOwnPropertyNames();  [BUGGY]    for  (String  name  :  currentPropertyNames)  {  ObjectType  oType  =  properties.get(name);  if  (oType  !=  null)  {  if  (!interfaceType.getPropertyType(name).isEquivalentTo(  oType.getPropertyType(name)))  {  compiler.report(  t.makeError(n,  INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,  functionName,  name,  oType.toString(),  interfaceType.toString()));  }  [CLASS]  TypeCheck  [METHOD]  checkInterfaceConflictProperties  [RETURN_TYPE]  void  NodeTraversal  t  Node  n  String  functionName  ObjectType>  properties  ObjectType>  currentProperties  ObjectType  interfaceType  	projects/Closure2/src/com/google/javascript/jscomp/TypeCheck.java	0.24253562503633297	1574	1574	1	replace	CurrentPropertyNames  =  properties.get(implicitProto).getOwnPropertyNames();	  currentPropertyNames    =    properties.get(implicitProto).getOwnPropertyNames();    	non-compiled	[CE]  orphaned  case	8	None	replace
69	[BUG]  [BUGGY]  ObjectType  implicitProto  =  properties.get(implicitProto).getImplicitPrototype();  [CE]  orphaned  case  [FE]          NullPointerException    [CONTEXT]      [BUGGY]  ObjectType  implicitProto  =  properties.get(implicitProto).getImplicitPrototype();  [BUGGY]    for  (String  name  :  currentPropertyNames)  {  ObjectType  oType  =  properties.get(name);  if  (oType  !=  null)  {  if  (!interfaceType.getPropertyType(name).isEquivalentTo(  oType.getPropertyType(name)))  {  compiler.report(  t.makeError(n,  INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,  functionName,  name,  oType.toString(),  interfaceType.toString()));  }  [CLASS]  TypeCheck  [METHOD]  checkInterfaceConflictProperties  [RETURN_TYPE]  void  NodeTraversal  t  Node  n  String  functionName  ObjectType>  properties  ObjectType>  currentProperties  ObjectType  interfaceType  	projects/Closure2/src/com/google/javascript/jscomp/TypeCheck.java	0.24253562503633297	1574	1574	1	replace	ObjectType  implicitProto  =  properties.get(implicitProto).getImplicitPrototype();	  currentPropertyNames    =    properties.get(implicitProto).getOwnPropertyNames();    	non-compiled	[CE]  orphaned  case	8	None	replace
70	[BUG]  [BUGGY]  NodeTraversal.traverse(compiler,  n,  new  TypeChecker());  [CE]  orphaned  case  [FE]                    NullPointerException    [CONTEXT]      [BUGGY]  NodeTraversal.traverse(compiler,  n,  new  TypeChecker());  [BUGGY]    for  (String  name  :  currentPropertyNames)  {  ObjectType  oType  =  properties.get(name);  if  (oType  !=  null)  {  if  (!interfaceType.getPropertyType(name).isEquivalentTo(  oType.getPropertyType(name)))  {  compiler.report(  t.makeError(n,  INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,  functionName,  name,  oType.toString(),  interfaceType.toString()));  }  [CLASS]  TypeCheck  [METHOD]  checkInterfaceConflictProperties  [RETURN_TYPE]  void  NodeTraversal  t  Node  n  String  functionName  ObjectType>  properties  ObjectType>  currentProperties  ObjectType  interfaceType  	projects/Closure2/src/com/google/javascript/jscomp/TypeCheck.java	0.24253562503633297	1574	1574	1	replace	NodeTraversal.traverse(compiler,  n,  new  TypeChecker());	      	non-compiled	[CE]  orphaned  case	7	None	replace
71	[BUG]  [BUGGY]  NodeTraversal.traverse(compiler,  n,  new  TypeVisibleProperties());  [CE]  orphaned  case  [FE]                      NullPointerException    [CONTEXT]      [BUGGY]  NodeTraversal.traverse(compiler,  n,  new  TypeVisibleProperties());  [BUGGY]    for  (String  name  :  currentPropertyNames)  {  ObjectType  oType  =  properties.get(name);  if  (oType  !=  null)  {  if  (!interfaceType.getPropertyType(name).isEquivalentTo(  oType.getPropertyType(name)))  {  compiler.report(  t.makeError(n,  INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,  functionName,  name,  oType.toString(),  interfaceType.toString()));  }  [CLASS]  TypeCheck  [METHOD]  checkInterfaceConflictProperties  [RETURN_TYPE]  void  NodeTraversal  t  Node  n  String  functionName  ObjectType>  properties  ObjectType>  currentProperties  ObjectType  interfaceType  	projects/Closure2/src/com/google/javascript/jscomp/TypeCheck.java	0.24253562503633297	1574	1574	1	replace	NodeTraversal.traverse(compiler,  n,  new  TypeVisibleProperties());	      	non-compiled	[CE]  orphaned  case	7	None	replace
72	[BUG]  [BUGGY]  ObjectType  currentProperties  =  properties.get(functionName);  [CE]  orphaned  case  [FE]                        NullPointerException    [CONTEXT]      [BUGGY]  ObjectType  currentProperties  =  properties.get(functionName);  [BUGGY]    for  (String  name  :  currentPropertyNames)  {  ObjectType  oType  =  properties.get(name);  if  (oType  !=  null)  {  if  (!interfaceType.getPropertyType(name).isEquivalentTo(  oType.getPropertyType(name)))  {  compiler.report(  t.makeError(n,  INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,  functionName,  name,  oType.toString(),  interfaceType.toString()));  }  [CLASS]  TypeCheck  [METHOD]  checkInterfaceConflictProperties  [RETURN_TYPE]  void  NodeTraversal  t  Node  n  String  functionName  ObjectType>  properties  ObjectType>  currentProperties  ObjectType  interfaceType  	projects/Closure2/src/com/google/javascript/jscomp/TypeCheck.java	0.24253562503633297	1574	1574	1	replace	ObjectType  currentProperties  =  properties.get(functionName);	      	non-compiled	[CE]  orphaned  case	7	None	replace
73	[BUG]  [BUGGY]  currentPropertyNames  =  properties.get(this.implicitProto).getOwnPropertyNames();  [CE]  orphaned  case  [FE]        NullPointerException    [CONTEXT]      [BUGGY]  currentPropertyNames  =  properties.get(this.implicitProto).getOwnPropertyNames();  [BUGGY]    for  (String  name  :  currentPropertyNames)  {  ObjectType  oType  =  properties.get(name);  if  (oType  !=  null)  {  if  (!interfaceType.getPropertyType(name).isEquivalentTo(  oType.getPropertyType(name)))  {  compiler.report(  t.makeError(n,  INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,  functionName,  name,  oType.toString(),  interfaceType.toString()));  }  [CLASS]  TypeCheck  [METHOD]  checkInterfaceConflictProperties  [RETURN_TYPE]  void  NodeTraversal  t  Node  n  String  functionName  ObjectType>  properties  ObjectType>  currentProperties  ObjectType  interfaceType  	projects/Closure2/src/com/google/javascript/jscomp/TypeCheck.java	0.24253562503633297	1574	1574	1	replace	currentPropertyNames  =  properties.get(this.implicitProto).getOwnPropertyNames();	  currentPropertyNames    =    this.implicitProto.getOwnPropertyNames();    	non-compiled	[CE]  orphaned  case	1	None	replace
74	[BUG]  [BUGGY]  currentPropertyNames  =  properties.get(this.implicitProto);  [CE]  orphaned  case  [FE]          NullPointerException    [CONTEXT]      [BUGGY]  currentPropertyNames  =  properties.get(this.implicitProto);  [BUGGY]    for  (String  name  :  currentPropertyNames)  {  ObjectType  oType  =  properties.get(name);  if  (oType  !=  null)  {  if  (!interfaceType.getPropertyType(name).isEquivalentTo(  oType.getPropertyType(name)))  {  compiler.report(  t.makeError(n,  INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,  functionName,  name,  oType.toString(),  interfaceType.toString()));  }  [CLASS]  TypeCheck  [METHOD]  checkInterfaceConflictProperties  [RETURN_TYPE]  void  NodeTraversal  t  Node  n  String  functionName  ObjectType>  properties  ObjectType>  currentProperties  ObjectType  interfaceType  	projects/Closure2/src/com/google/javascript/jscomp/TypeCheck.java	0.24253562503633297	1574	1574	1	replace	currentPropertyNames  =  properties.get(this.implicitProto);	  currentPropertyNames    =    this.implicitProto.getOwnPropertyNames();    	non-compiled	[CE]  orphaned  case	1	None	replace
75	[BUG]  [BUGGY]  currentPropertyNames  =  this.implicitProto.getOwnerPropertyNames();  [CE]  orphaned  case  [FE]            NullPointerException    [CONTEXT]      [BUGGY]  currentPropertyNames  =  this.implicitProto.getOwnerPropertyNames();  [BUGGY]    for  (String  name  :  currentPropertyNames)  {  ObjectType  oType  =  properties.get(name);  if  (oType  !=  null)  {  if  (!interfaceType.getPropertyType(name).isEquivalentTo(  oType.getPropertyType(name)))  {  compiler.report(  t.makeError(n,  INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,  functionName,  name,  oType.toString(),  interfaceType.toString()));  }  [CLASS]  TypeCheck  [METHOD]  checkInterfaceConflictProperties  [RETURN_TYPE]  void  NodeTraversal  t  Node  n  String  functionName  ObjectType>  properties  ObjectType>  currentProperties  ObjectType  interfaceType  	projects/Closure2/src/com/google/javascript/jscomp/TypeCheck.java	0.24253562503633297	1574	1574	1	replace	currentPropertyNames  =  this.implicitProto.getOwnerPropertyNames();	  currentPropertyNames    =    this.implicitProto.getOwnPropertyNames();    	non-compiled	[CE]  orphaned  case	1	None	replace
