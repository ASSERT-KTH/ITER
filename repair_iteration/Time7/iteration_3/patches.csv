bugid	buggy	buggy_class	suspiciousness	buggy_line	endbuggycode	original_failing_test_number	action	patch	original_buggy	execution_result	diagnosis	previous_bug_id	new_failing_test_number	this_action12	[BUG]  [BUGGY]  long  instantMillis  =  instant.getMillis()  /  position  +  1L;  [timeout]  [CONTEXT]        public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(       "Instant  must  not  be  null       ");  }        [BUGGY]  long  instantMillis  =  instant.getMillis()  /  position  +  1L;  [BUGGY]        Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  int  defaultYear  =  chrono.year().get(instantLocal);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  defaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	706	706	2	replace	long  instantMillis  =  instant.getMillis()  /  position  +  1L;	  long    instantMillis    =    instant.getMillis()    /    position    +    1;    [timeout]    [CONTEXT]            public    int    parseInto(ReadWritableInstant    instant,    String    text,    int    position)    {    DateTimeParser    parser    =    requireParser();    if    (instant    ==    null)    {    throw    new    IllegalArgumentException(           "Instant    must    not    be    null           ");    }            	non-compiled	[timeout]	121	None	replace
14	[BUG]  [BUGGY]  long  instantMillis  =  instant.getMillis()  /  position  +  2;  [timeout]  [CONTEXT]        public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(       "Instant  must  not  be  null       ");  }        [BUGGY]  long  instantMillis  =  instant.getMillis()  /  position  +  2;  [BUGGY]        Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  int  defaultYear  =  chrono.year().get(instantLocal);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  defaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	706	706	2	replace	long  instantMillis  =  instant.getMillis()  /  position  +  2;	  long    instantMillis    =    instant.getMillis()    /    position    +    1;    [timeout]    [CONTEXT]            public    int    parseInto(ReadWritableInstant    instant,    String    text,    int    position)    {    DateTimeParser    parser    =    requireParser();    if    (instant    ==    null)    {    throw    new    IllegalArgumentException(           "Instant    must    not    be    null           ");    }            	non-compiled	[timeout]	121	None	replace
51	[BUG]  [BUGGY]  long  instantMillis  =  instant.getMillis()  /  position  -  1;  [timeout]  [CONTEXT]        public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(       "Instant  must  not  be  null       ");  }        [BUGGY]  long  instantMillis  =  instant.getMillis()  /  position  -  1;  [BUGGY]        Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  int  defaultYear  =  chrono.year().get(instantLocal);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  defaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	706	706	2	replace	long  instantMillis  =  instant.getMillis()  /  position  -  1;	  long    instantMillis    =    instant.getMillis()    /    position    *    2;    [timeout]    [CONTEXT]            public    int    parseInto(ReadWritableInstant    instant,    String    text,    int    position)    {    DateTimeParser    parser    =    requireParser();    if    (instant    ==    null)    {    throw    new    IllegalArgumentException(           "Instant    must    not    be    null           ");    }            	non-compiled	[timeout]	304	None	replace
54	[BUG]  [BUGGY]  long  instantMillis  =  instant.getMillis()  *  position  /  2;  [timeout]  [CONTEXT]        public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(       "Instant  must  not  be  null       ");  }        [BUGGY]  long  instantMillis  =  instant.getMillis()  *  position  /  2;  [BUGGY]        Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  int  defaultYear  =  chrono.year().get(instantLocal);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  defaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	706	706	2	replace	long  instantMillis  =  instant.getMillis()  *  position  /  2;	  long    instantMillis    =    instant.getMillis()    /    position    *    2;    [timeout]    [CONTEXT]            public    int    parseInto(ReadWritableInstant    instant,    String    text,    int    position)    {    DateTimeParser    parser    =    requireParser();    if    (instant    ==    null)    {    throw    new    IllegalArgumentException(           "Instant    must    not    be    null           ");    }            	non-compiled	[timeout]	304	None	replace
72	[BUG]  [BUGGY]  if(parser!=  null  &&  instant.getMillis()!=  text.length())  {  [timeout]  [CONTEXT]        public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();        [BUGGY]  if(parser!=  null  &&  instant.getMillis()!=  text.length())  {  [BUGGY]        throw  new  IllegalArgumentException(       "Instant  must  not  be  null       ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  int  defaultYear  =  chrono.year().get(instantLocal);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	702	702	2	replace	if(parser!=  null  &&  instant.getMillis()!=  text.length())  {	  if(parser!=    null    ||    instant.getMillis()!=    text.length())    {    [timeout]    [CONTEXT]            public    int    parseInto(ReadWritableInstant    instant,    String    text,    int    position)    {    DateTimeParser    parser    =    requireParser();            	non-compiled	[timeout]	214	None	replace
73	[BUG]  [BUGGY]  if(instant!=  null  ||  parser.getMillis()!=  text.length())  {  [timeout]  [CONTEXT]        public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();        [BUGGY]  if(instant!=  null  ||  parser.getMillis()!=  text.length())  {  [BUGGY]        throw  new  IllegalArgumentException(       "Instant  must  not  be  null       ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  int  defaultYear  =  chrono.year().get(instantLocal);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	702	702	2	replace	if(instant!=  null  ||  parser.getMillis()!=  text.length())  {	  if(parser!=    null    ||    instant.getMillis()!=    text.length())    {    [timeout]    [CONTEXT]            public    int    parseInto(ReadWritableInstant    instant,    String    text,    int    position)    {    DateTimeParser    parser    =    requireParser();            	non-compiled	[timeout]	214	None	replace
111	[BUG]  [BUGGY]                  chrono        =        selectChronology(chrono);        chrono    =    selectChronology(chrono);    chrono  =  selectChronology(chrono);  if(iParser!=  null)  {  throw  new  IllegalArgumentException( " ");  }  [timeout]  [CONTEXT]        public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(       "Instant  must  not  be  null       ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();        [BUGGY]                  chrono        =        selectChronology(chrono);        chrono    =    selectChronology(chrono);    chrono  =  selectChronology(chrono);  if(iParser!=  null)  {  throw  new  IllegalArgumentException( " ");  }  [BUGGY]        long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  int  defaultYear  =  chrono.year().get(instantLocal);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  defaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	708	708	2	replace	                                chrono                =                selectChronology(chrono);                chrono        =        selectChronology(chrono);        chrono    =    selectChronology(chrono);    if(iParser!=  null)  {  throw  new  IllegalArgumentException( " ");  }	  	non-compiled	[timeout]	441	None	add
112	[BUG]  [BUGGY]                  chrono        =        selectChronology(chrono);        chrono    =    selectChronology(chrono);    chrono  =  selectChronology(chrono);  if(iParser!=  null)  {  throw  new  IllegalArgumentException( " ");  }  else  {  DateTimeParser  parser  =  parser.parseInto(instantMillis,  text,  position);  }  [timeout]  [CONTEXT]        public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(       "Instant  must  not  be  null       ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();        [BUGGY]                  chrono        =        selectChronology(chrono);        chrono    =    selectChronology(chrono);    chrono  =  selectChronology(chrono);  if(iParser!=  null)  {  throw  new  IllegalArgumentException( " ");  }  else  {  DateTimeParser  parser  =  parser.parseInto(instantMillis,  text,  position);  }  [BUGGY]        long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  int  defaultYear  =  chrono.year().get(instantLocal);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  defaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	708	708	2	replace	                                chrono                =                selectChronology(chrono);                chrono        =        selectChronology(chrono);        chrono    =    selectChronology(chrono);    if(iParser!=  null)  {  throw  new  IllegalArgumentException( " ");  }  else  {  DateTimeParser  parser  =  parser.parseInto(instantMillis,  text,  position);  }	  	non-compiled	[timeout]	441	None	add
173	[BUG]  [BUGGY]  if(parser!=  null  &&  instant.getMillis()  <  text.length())  {  [timeout]  [CONTEXT]        public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();        [BUGGY]  if(parser!=  null  &&  instant.getMillis()  <  text.length())  {  [BUGGY]        throw  new  IllegalArgumentException(       "Instant  must  not  be  null       ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  int  defaultYear  =  chrono.year().get(instantLocal);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	702	702	2	replace	if(parser!=  null  &&  instant.getMillis()  <  text.length())  {	  if(instant!=    null    ||    instant.getMillis()    <    text.length())    {    [timeout]    [CONTEXT]            public    int    parseInto(ReadWritableInstant    instant,    String    text,    int    position)    {    DateTimeParser    parser    =    requireParser();            	non-compiled	[timeout]	43	None	replace
174	[BUG]  [BUGGY]  if(instant!=  null  &&  instant.getMillis()  <  text.length())  {  [timeout]  [CONTEXT]        public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();        [BUGGY]  if(instant!=  null  &&  instant.getMillis()  <  text.length())  {  [BUGGY]        throw  new  IllegalArgumentException(       "Instant  must  not  be  null       ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  int  defaultYear  =  chrono.year().get(instantLocal);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	702	702	2	replace	if(instant!=  null  &&  instant.getMillis()  <  text.length())  {	  if(instant!=    null    ||    instant.getMillis()    <    text.length())    {    [timeout]    [CONTEXT]            public    int    parseInto(ReadWritableInstant    instant,    String    text,    int    position)    {    DateTimeParser    parser    =    requireParser();            	non-compiled	[timeout]	43	None	replace
233	[BUG]  [BUGGY]  instantLocal  =  instantMillis  /  chrono.getZone().getOffset(instantMillis  +  1);  [timeout]  [CONTEXT]        public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(       "Instant  must  not  be  null       ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);        [BUGGY]  instantLocal  =  instantMillis  /  chrono.getZone().getOffset(instantMillis  +  1);  [BUGGY]        chrono  =  selectChronology(chrono);  int  defaultYear  =  chrono.year().get(instantLocal);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  defaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	709	709	2	replace	instantLocal  =  instantMillis  /  chrono.getZone().getOffset(instantMillis  +  1);	  instantLocal    =    instantMillis    /    chrono.getZone().getOffset(instantMillis);    [timeout]    [CONTEXT]            public    int    parseInto(ReadWritableInstant    instant,    String    text,    int    position)    {    DateTimeParser    parser    =    requireParser();    if    (instant    ==    null)    {    throw    new    IllegalArgumentException(           "Instant    must    not    be    null           ");    }    long    instantMillis    =    instant.getMillis();    Chronology    chrono    =    instant.getChronology();    long    instantLocal    =    instantMillis    +    chrono.getZone().getOffset(instantMillis);            	non-compiled	[timeout]	23	None	replace
23	[BUG]  [BUGGY]  if(instant!=  null  ||  instant.getMillis()  ==  text.length())  {  [timeout]  [CONTEXT]        public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();        [BUGGY]  if(instant!=  null  ||  instant.getMillis()  ==  text.length())  {  [BUGGY]        throw  new  IllegalArgumentException(       "Instant  must  not  be  null       ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  int  defaultYear  =  chrono.year().get(instantLocal);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	702	702	2	replace	if(instant!=  null  ||  instant.getMillis()  ==  text.length())  {	  if(instant!=    null    ||    instant.getMillis()!=    text.length())    {    [timeout]    [CONTEXT]            public    int    parseInto(ReadWritableInstant    instant,    String    text,    int    position)    {    DateTimeParser    parser    =    requireParser();            	non-compiled	[timeout]	663	None	replace
24	[BUG]  [BUGGY]  if(instant!=  null  &&  instant.getMillis()!=  text.length())  {  [timeout]  [CONTEXT]        public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();        [BUGGY]  if(instant!=  null  &&  instant.getMillis()!=  text.length())  {  [BUGGY]        throw  new  IllegalArgumentException(       "Instant  must  not  be  null       ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  int  defaultYear  =  chrono.year().get(instantLocal);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	702	702	2	replace	if(instant!=  null  &&  instant.getMillis()!=  text.length())  {	  if(instant!=    null    ||    instant.getMillis()!=    text.length())    {    [timeout]    [CONTEXT]            public    int    parseInto(ReadWritableInstant    instant,    String    text,    int    position)    {    DateTimeParser    parser    =    requireParser();            	non-compiled	[timeout]	663	None	replace
342	[BUG]  [BUGGY]  long  instantMillis  =  instant.getMillis()  /  position  *  2  +  1;  [timeout]  [CONTEXT]        public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(       "Instant  must  not  be  null       ");  }        [BUGGY]  long  instantMillis  =  instant.getMillis()  /  position  *  2  +  1;  [BUGGY]        Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  int  defaultYear  =  chrono.year().get(instantLocal);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  defaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	706	706	2	replace	long  instantMillis  =  instant.getMillis()  /  position  *  2  +  1;	  long    instantMillis    =    instant.getMillis()    /    position    *    2;    [timeout]    [CONTEXT]            public    int    parseInto(ReadWritableInstant    instant,    String    text,    int    position)    {    DateTimeParser    parser    =    requireParser();    if    (instant    ==    null)    {    throw    new    IllegalArgumentException(           "Instant    must    not    be    null           ");    }            	non-compiled	[timeout]	304	None	replace
344	[BUG]  [BUGGY]  long  instantMillis  =  instant.getMillis()  /  position  *  1;  [timeout]  [CONTEXT]        public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(       "Instant  must  not  be  null       ");  }        [BUGGY]  long  instantMillis  =  instant.getMillis()  /  position  *  1;  [BUGGY]        Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  int  defaultYear  =  chrono.year().get(instantLocal);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  defaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	706	706	2	replace	long  instantMillis  =  instant.getMillis()  /  position  *  1;	  long    instantMillis    =    instant.getMillis()    /    position    *    2;    [timeout]    [CONTEXT]            public    int    parseInto(ReadWritableInstant    instant,    String    text,    int    position)    {    DateTimeParser    parser    =    requireParser();    if    (instant    ==    null)    {    throw    new    IllegalArgumentException(           "Instant    must    not    be    null           ");    }            	non-compiled	[timeout]	304	None	replace
64	[BUG]  [BUGGY]  instantLocal  =  instantMillis  /  chrono.getZone().getOffsetFromLocal(instantMillis);  [timeout]  [CONTEXT]        public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(       "Instant  must  not  be  null       ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);        [BUGGY]  instantLocal  =  instantMillis  /  chrono.getZone().getOffsetFromLocal(instantMillis);  [BUGGY]        chrono  =  selectChronology(chrono);  int  defaultYear  =  chrono.year().get(instantLocal);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  defaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	709	709	2	replace	instantLocal  =  instantMillis  /  chrono.getZone().getOffsetFromLocal(instantMillis);	  instantLocal    =    instantMillis    /    chrono.getZone().getOffset(instantMillis);    [timeout]    [CONTEXT]            public    int    parseInto(ReadWritableInstant    instant,    String    text,    int    position)    {    DateTimeParser    parser    =    requireParser();    if    (instant    ==    null)    {    throw    new    IllegalArgumentException(           "Instant    must    not    be    null           ");    }    long    instantMillis    =    instant.getMillis();    Chronology    chrono    =    instant.getChronology();    long    instantLocal    =    instantMillis    +    chrono.getZone().getOffset(instantMillis);            	non-compiled	[timeout]	23	None	replace
184	[BUG]  [BUGGY]  long  instantMillis  =  instant.getMillis()  /  position  +  3;  [timeout]  [CONTEXT]        public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(       "Instant  must  not  be  null       ");  }        [BUGGY]  long  instantMillis  =  instant.getMillis()  /  position  +  3;  [BUGGY]        Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  int  defaultYear  =  chrono.year().get(instantLocal);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  defaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	706	706	2	replace	long  instantMillis  =  instant.getMillis()  /  position  +  3;	  long    instantMillis    =    instant.getMillis()    /    position    +    1;    [timeout]    [CONTEXT]            public    int    parseInto(ReadWritableInstant    instant,    String    text,    int    position)    {    DateTimeParser    parser    =    requireParser();    if    (instant    ==    null)    {    throw    new    IllegalArgumentException(           "Instant    must    not    be    null           ");    }            	non-compiled	[timeout]	121	None	replace
213	[BUG]  [BUGGY]  long  instantMillis  =  instant.getMillis()  /  position  *  4;  [timeout]  [CONTEXT]        public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(       "Instant  must  not  be  null       ");  }        [BUGGY]  long  instantMillis  =  instant.getMillis()  /  position  *  4;  [BUGGY]        Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  int  defaultYear  =  chrono.year().get(instantLocal);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  defaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	706	706	2	replace	long  instantMillis  =  instant.getMillis()  /  position  *  4;	  long    instantMillis    =    instant.getMillis()    /    position    *    2;    [timeout]    [CONTEXT]            public    int    parseInto(ReadWritableInstant    instant,    String    text,    int    position)    {    DateTimeParser    parser    =    requireParser();    if    (instant    ==    null)    {    throw    new    IllegalArgumentException(           "Instant    must    not    be    null           ");    }            	non-compiled	[timeout]	304	None	replace
214	[BUG]  [BUGGY]  long  instantMillis  =  instant.getMillis()  /  position  *  3;  [timeout]  [CONTEXT]        public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(       "Instant  must  not  be  null       ");  }        [BUGGY]  long  instantMillis  =  instant.getMillis()  /  position  *  3;  [BUGGY]        Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  int  defaultYear  =  chrono.year().get(instantLocal);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  defaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	706	706	2	replace	long  instantMillis  =  instant.getMillis()  /  position  *  3;	  long    instantMillis    =    instant.getMillis()    /    position    *    2;    [timeout]    [CONTEXT]            public    int    parseInto(ReadWritableInstant    instant,    String    text,    int    position)    {    DateTimeParser    parser    =    requireParser();    if    (instant    ==    null)    {    throw    new    IllegalArgumentException(           "Instant    must    not    be    null           ");    }            	non-compiled	[timeout]	304	None	replace
332	[BUG]  [BUGGY]  if(instant.getMillis()!=  text.length()  &&  position!=  0)  {  [timeout]  [CONTEXT]        public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();        [BUGGY]  if(instant.getMillis()!=  text.length()  &&  position!=  0)  {  [BUGGY]        throw  new  IllegalArgumentException(       "Instant  must  not  be  null       ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  int  defaultYear  =  chrono.year().get(instantLocal);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	702	702	2	replace	if(instant.getMillis()!=  text.length()  &&  position!=  0)  {	  if(instant.getMillis()!=    text.length())    {    [timeout]    [CONTEXT]            public    int    parseInto(ReadWritableInstant    instant,    String    text,    int    position)    {    DateTimeParser    parser    =    requireParser();            	non-compiled	[timeout]	662	None	replace
333	[BUG]  [BUGGY]  if(instant.getMillis()!=  text.length()  ||  instant.getChronology()  ==  DateTimeUtils.getInstantMillis(instant,  text,  position))  {  [timeout]  [CONTEXT]        public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();        [BUGGY]  if(instant.getMillis()!=  text.length()  ||  instant.getChronology()  ==  DateTimeUtils.getInstantMillis(instant,  text,  position))  {  [BUGGY]        throw  new  IllegalArgumentException(       "Instant  must  not  be  null       ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  int  defaultYear  =  chrono.year().get(instantLocal);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	702	702	2	replace	if(instant.getMillis()!=  text.length()  ||  instant.getChronology()  ==  DateTimeUtils.getInstantMillis(instant,  text,  position))  {	  if(instant.getMillis()!=    text.length())    {    [timeout]    [CONTEXT]            public    int    parseInto(ReadWritableInstant    instant,    String    text,    int    position)    {    DateTimeParser    parser    =    requireParser();            	non-compiled	[timeout]	662	None	replace
363	[BUG]  [BUGGY]  long  instantMillis  =  instant.getMillis()  *  position  -  2;  [timeout]  [CONTEXT]        public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(       "Instant  must  not  be  null       ");  }        [BUGGY]  long  instantMillis  =  instant.getMillis()  *  position  -  2;  [BUGGY]        Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  int  defaultYear  =  chrono.year().get(instantLocal);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  defaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	706	706	2	replace	long  instantMillis  =  instant.getMillis()  *  position  -  2;	  long    instantMillis    =    instant.getMillis()    *    position    -    1;    [timeout]    [CONTEXT]            public    int    parseInto(ReadWritableInstant    instant,    String    text,    int    position)    {    DateTimeParser    parser    =    requireParser();    if    (instant    ==    null)    {    throw    new    IllegalArgumentException(           "Instant    must    not    be    null           ");    }            	non-compiled	[timeout]	403	None	replace
483	[BUG]  [BUGGY]  instantLocal  =  instantLocal  /  chrono.getZone().getOffset(instantLocal  +  1);  [timeout]  [CONTEXT]        public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(       "Instant  must  not  be  null       ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);        [BUGGY]  instantLocal  =  instantLocal  /  chrono.getZone().getOffset(instantLocal  +  1);  [BUGGY]        chrono  =  selectChronology(chrono);  int  defaultYear  =  chrono.year().get(instantLocal);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  defaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	709	709	2	replace	instantLocal  =  instantLocal  /  chrono.getZone().getOffset(instantLocal  +  1);	  instantLocal    =    instantLocal    /    chrono.getZone().getOffset(instantLocal);    [timeout]    [CONTEXT]            public    int    parseInto(ReadWritableInstant    instant,    String    text,    int    position)    {    DateTimeParser    parser    =    requireParser();    if    (instant    ==    null)    {    throw    new    IllegalArgumentException(           "Instant    must    not    be    null           ");    }    long    instantMillis    =    instant.getMillis();    Chronology    chrono    =    instant.getChronology();    long    instantLocal    =    instantMillis    +    chrono.getZone().getOffset(instantMillis);            	non-compiled	[timeout]	223	None	replace
484	[BUG]  [BUGGY]  instantLocal  =  instantLocal  /  chrono.getZone().getOffsetFromLocal(instantLocal);  [timeout]  [CONTEXT]        public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(       "Instant  must  not  be  null       ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);        [BUGGY]  instantLocal  =  instantLocal  /  chrono.getZone().getOffsetFromLocal(instantLocal);  [BUGGY]        chrono  =  selectChronology(chrono);  int  defaultYear  =  chrono.year().get(instantLocal);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  defaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	709	709	2	replace	instantLocal  =  instantLocal  /  chrono.getZone().getOffsetFromLocal(instantLocal);	  instantLocal    =    instantLocal    /    chrono.getZone().getOffset(instantLocal);    [timeout]    [CONTEXT]            public    int    parseInto(ReadWritableInstant    instant,    String    text,    int    position)    {    DateTimeParser    parser    =    requireParser();    if    (instant    ==    null)    {    throw    new    IllegalArgumentException(           "Instant    must    not    be    null           ");    }    long    instantMillis    =    instant.getMillis();    Chronology    chrono    =    instant.getChronology();    long    instantLocal    =    instantMillis    +    chrono.getZone().getOffset(instantMillis);            	non-compiled	[timeout]	223	None	replace
694	[BUG]  [BUGGY]  if(instant!=  null  ||  instant.getMillis()  <=  text.length())  {  [timeout]  [CONTEXT]        public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();        [BUGGY]  if(instant!=  null  ||  instant.getMillis()  <=  text.length())  {  [BUGGY]        throw  new  IllegalArgumentException(       "Instant  must  not  be  null       ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  int  defaultYear  =  chrono.year().get(instantLocal);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	702	702	2	replace	if(instant!=  null  ||  instant.getMillis()  <=  text.length())  {	  if(instant    ==    null    ||    instant.getMillis()    <=    text.length())    {    [timeout]    [CONTEXT]            public    int    parseInto(ReadWritableInstant    instant,    String    text,    int    position)    {    DateTimeParser    parser    =    requireParser();            	non-compiled	[timeout]	73	None	replace
