bugid	buggy	buggy_class	suspiciousness	buggy_line	endbuggycode	failing_test_number	action	patch
1	[BUG] [BUGGY] if (locale == getLocale() || (locale != null && locale.equals(getLocale()))) { [FE] org.joda.time.IllegalFieldValueException: Cannot parse "2 29": Value 29 for dayOfMonth must be in the range [1 testParseInto_monthDay_feb29_newYork_startOfYear [CONTEXT] public DateTimeFormatter withLocale(Locale locale) { [BUGGY] if (locale == getLocale() || (locale != null && locale.equals(getLocale()))) { [BUGGY] return this; } return new DateTimeFormatter(iPrinter, iParser, locale, iOffsetParsed, iChrono, iZone, iPivotYear, iDefaultYear); } [CLASS] DateTimeFormatter [METHOD] withLocale [RETURN_TYPE] DateTimeFormatter  Locale locale [VARIABLES] Locale iLocale locale Integer iPivotYear pivotYear DateTimeParser iParser parser boolean iOffsetParsed offsetParsed Chronology chrono iChrono DateTimePrinter iPrinter printer DateTimeZone iZone zone int defaultYear iDefaultYear  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.30151134457776363	190	190	2	replace	
2	[BUG] [BUGGY] [FE] org.joda.time.IllegalFieldValueException: Cannot parse "2 29": Value 29 for dayOfMonth must be in the range [1 testParseInto_monthDay_feb29_newYork_startOfYear [CONTEXT] public DateTimeFormatter withLocale(Locale locale) { [BUGGY] [BUGGY] if (locale == getLocale() || (locale != null && locale.equals(getLocale()))) { return this; } return new DateTimeFormatter(iPrinter, iParser, locale, iOffsetParsed, iChrono, iZone, iPivotYear, iDefaultYear); } [CLASS] DateTimeFormatter [METHOD] withLocale [RETURN_TYPE] DateTimeFormatter  Locale locale [VARIABLES] Locale iLocale locale Integer iPivotYear pivotYear DateTimeParser iParser parser boolean iOffsetParsed offsetParsed Chronology chrono iChrono DateTimePrinter iPrinter printer DateTimeZone iZone zone int defaultYear iDefaultYear  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.30151134457776363	190	190	2	add	
3	[BUG] [BUGGY] return new DateTimeFormatter(iPrinter, iParser, locale, iOffsetParsed, iChrono, iZone, iPivotYear, iDefaultYear); [FE] org.joda.time.IllegalFieldValueException: Cannot parse "2 29": Value 29 for dayOfMonth must be in the range [1 testParseInto_monthDay_feb29_newYork_startOfYear [CONTEXT] public DateTimeFormatter withLocale(Locale locale) { if (locale == getLocale() || (locale != null && locale.equals(getLocale()))) { return this; } [BUGGY] return new DateTimeFormatter(iPrinter, iParser, locale,    iOffsetParsed, iChrono, iZone, iPivotYear, iDefaultYear); [BUGGY] iOffsetParsed, iChrono, iZone, iPivotYear, iDefaultYear); } [CLASS] DateTimeFormatter [METHOD] withLocale [RETURN_TYPE] DateTimeFormatter  Locale locale [VARIABLES] Locale iLocale locale Integer iPivotYear pivotYear DateTimeParser iParser parser boolean iOffsetParsed offsetParsed Chronology chrono iChrono DateTimePrinter iPrinter printer DateTimeZone iZone zone int defaultYear iDefaultYear  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.30151134457776363	193	194	2	replace	
4	[BUG] [BUGGY] [FE] org.joda.time.IllegalFieldValueException: Cannot parse "2 29": Value 29 for dayOfMonth must be in the range [1 testParseInto_monthDay_feb29_newYork_startOfYear [CONTEXT] public DateTimeFormatter withLocale(Locale locale) { if (locale == getLocale() || (locale != null && locale.equals(getLocale()))) { return this; } [BUGGY] [BUGGY] return new DateTimeFormatter(iPrinter, iParser, locale,    iOffsetParsed, iChrono, iZone, iPivotYear, iDefaultYear); iOffsetParsed, iChrono, iZone, iPivotYear, iDefaultYear); } [CLASS] DateTimeFormatter [METHOD] withLocale [RETURN_TYPE] DateTimeFormatter  Locale locale [VARIABLES] Locale iLocale locale Integer iPivotYear pivotYear DateTimeParser iParser parser boolean iOffsetParsed offsetParsed Chronology chrono iChrono DateTimePrinter iPrinter printer DateTimeZone iZone zone int defaultYear iDefaultYear  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.30151134457776363	193	194	2	add	
5	[BUG] [BUGGY] return iLocale; [FE] org.joda.time.IllegalFieldValueException: Cannot parse "2 29": Value 29 for dayOfMonth must be in the range [1 testParseInto_monthDay_feb29_newYork_startOfYear [CONTEXT] public Locale getLocale() { [BUGGY] return iLocale; [BUGGY] } [CLASS] DateTimeFormatter [METHOD] getLocale [RETURN_TYPE] Locale  [VARIABLES] Locale iLocale locale Integer iPivotYear pivotYear DateTimeParser iParser parser boolean iOffsetParsed offsetParsed Chronology chrono iChrono DateTimePrinter iPrinter printer DateTimeZone iZone zone int defaultYear iDefaultYear  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.30151134457776363	204	204	2	replace	
6	[BUG] [BUGGY] [FE] org.joda.time.IllegalFieldValueException: Cannot parse "2 29": Value 29 for dayOfMonth must be in the range [1 testParseInto_monthDay_feb29_newYork_startOfYear [CONTEXT] public Locale getLocale() { [BUGGY] [BUGGY] return iLocale; } [CLASS] DateTimeFormatter [METHOD] getLocale [RETURN_TYPE] Locale  [VARIABLES] Locale iLocale locale Integer iPivotYear pivotYear DateTimeParser iParser parser boolean iOffsetParsed offsetParsed Chronology chrono iChrono DateTimePrinter iPrinter printer DateTimeZone iZone zone int defaultYear iDefaultYear  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.30151134457776363	204	204	2	add	
7	[BUG] [BUGGY] DateTimeParser parser = requireParser(); [FE] org.joda.time.IllegalFieldValueException: Cannot parse "2 29": Value 29 for dayOfMonth must be in the range [1 testParseInto_monthDay_feb29_newYork_startOfYear [CONTEXT] public int parseInto(ReadWritableInstant instant, String text, int position) { [BUGGY] DateTimeParser parser = requireParser(); [BUGGY] if (instant == null) { throw new IllegalArgumentException("Instant must not be null"); } long instantMillis = instant.getMillis(); Chronology chrono = instant.getChronology(); long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis); chrono = selectChronology(chrono); int defaultYear = chrono.year().get(instantLocal);  [CLASS] DateTimeFormatter [METHOD] parseInto [RETURN_TYPE] int  ReadWritableInstant instant String text int position [VARIABLES] Locale iLocale locale Integer iPivotYear pivotYear DateTimeParser iParser parser boolean iOffsetParsed offsetParsed DateTimeParserBucket bucket ReadWritableInstant instant Chronology chrono iChrono String text DateTimePrinter iPrinter printer DateTimeZone iZone parsedZone zone int defaultYear iDefaultYear newPos offset parsedOffset pivotYear position long instantLocal instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	701	701	2	replace	
8	[BUG] [BUGGY] [FE] org.joda.time.IllegalFieldValueException: Cannot parse "2 29": Value 29 for dayOfMonth must be in the range [1 testParseInto_monthDay_feb29_newYork_startOfYear [CONTEXT] public int parseInto(ReadWritableInstant instant, String text, int position) { [BUGGY] [BUGGY] DateTimeParser parser = requireParser(); if (instant == null) { throw new IllegalArgumentException("Instant must not be null"); } long instantMillis = instant.getMillis(); Chronology chrono = instant.getChronology(); long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis); chrono = selectChronology(chrono); int defaultYear = chrono.year().get(instantLocal);  [CLASS] DateTimeFormatter [METHOD] parseInto [RETURN_TYPE] int  ReadWritableInstant instant String text int position [VARIABLES] Locale iLocale locale Integer iPivotYear pivotYear DateTimeParser iParser parser boolean iOffsetParsed offsetParsed DateTimeParserBucket bucket ReadWritableInstant instant Chronology chrono iChrono String text DateTimePrinter iPrinter printer DateTimeZone iZone parsedZone zone int defaultYear iDefaultYear newPos offset parsedOffset pivotYear position long instantLocal instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	701	701	2	add	
9	[BUG] [BUGGY] if (instant == null) { [FE] org.joda.time.IllegalFieldValueException: Cannot parse "2 29": Value 29 for dayOfMonth must be in the range [1 testParseInto_monthDay_feb29_newYork_startOfYear [CONTEXT] public int parseInto(ReadWritableInstant instant, String text, int position) { DateTimeParser parser = requireParser(); [BUGGY] if (instant == null) { [BUGGY] throw new IllegalArgumentException("Instant must not be null"); } long instantMillis = instant.getMillis(); Chronology chrono = instant.getChronology(); long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis); chrono = selectChronology(chrono); int defaultYear = chrono.year().get(instantLocal); DateTimeParserBucket bucket = new DateTimeParserBucket( [CLASS] DateTimeFormatter [METHOD] parseInto [RETURN_TYPE] int  ReadWritableInstant instant String text int position [VARIABLES] Locale iLocale locale Integer iPivotYear pivotYear DateTimeParser iParser parser boolean iOffsetParsed offsetParsed DateTimeParserBucket bucket ReadWritableInstant instant Chronology chrono iChrono String text DateTimePrinter iPrinter printer DateTimeZone iZone parsedZone zone int defaultYear iDefaultYear newPos offset parsedOffset pivotYear position long instantLocal instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	702	702	2	replace	
10	[BUG] [BUGGY] [FE] org.joda.time.IllegalFieldValueException: Cannot parse "2 29": Value 29 for dayOfMonth must be in the range [1 testParseInto_monthDay_feb29_newYork_startOfYear [CONTEXT] public int parseInto(ReadWritableInstant instant, String text, int position) { DateTimeParser parser = requireParser(); [BUGGY] [BUGGY] if (instant == null) { throw new IllegalArgumentException("Instant must not be null"); } long instantMillis = instant.getMillis(); Chronology chrono = instant.getChronology(); long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis); chrono = selectChronology(chrono); int defaultYear = chrono.year().get(instantLocal); DateTimeParserBucket bucket = new DateTimeParserBucket( [CLASS] DateTimeFormatter [METHOD] parseInto [RETURN_TYPE] int  ReadWritableInstant instant String text int position [VARIABLES] Locale iLocale locale Integer iPivotYear pivotYear DateTimeParser iParser parser boolean iOffsetParsed offsetParsed DateTimeParserBucket bucket ReadWritableInstant instant Chronology chrono iChrono String text DateTimePrinter iPrinter printer DateTimeZone iZone parsedZone zone int defaultYear iDefaultYear newPos offset parsedOffset pivotYear position long instantLocal instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	702	702	2	add	
11	[BUG] [BUGGY] long instantMillis = instant.getMillis(); [FE] org.joda.time.IllegalFieldValueException: Cannot parse "2 29": Value 29 for dayOfMonth must be in the range [1 testParseInto_monthDay_feb29_newYork_startOfYear [CONTEXT] public int parseInto(ReadWritableInstant instant, String text, int position) { DateTimeParser parser = requireParser(); if (instant == null) { throw new IllegalArgumentException("Instant must not be null"); } [BUGGY] long instantMillis = instant.getMillis(); [BUGGY] Chronology chrono = instant.getChronology(); long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis); chrono = selectChronology(chrono); int defaultYear = chrono.year().get(instantLocal); DateTimeParserBucket bucket = new DateTimeParserBucket( instantLocal, chrono, iLocale, iPivotYear, defaultYear); int newPos = parser.parseInto(bucket, text, position); instant.setMillis(bucket.computeMillis(false, text)); if (iOffsetParsed && bucket.getOffsetInteger() != null) { [CLASS] DateTimeFormatter [METHOD] parseInto [RETURN_TYPE] int  ReadWritableInstant instant String text int position [VARIABLES] Locale iLocale locale Integer iPivotYear pivotYear DateTimeParser iParser parser boolean iOffsetParsed offsetParsed DateTimeParserBucket bucket ReadWritableInstant instant Chronology chrono iChrono String text DateTimePrinter iPrinter printer DateTimeZone iZone parsedZone zone int defaultYear iDefaultYear newPos offset parsedOffset pivotYear position long instantLocal instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	706	706	2	replace	
12	[BUG] [BUGGY] [FE] org.joda.time.IllegalFieldValueException: Cannot parse "2 29": Value 29 for dayOfMonth must be in the range [1 testParseInto_monthDay_feb29_newYork_startOfYear [CONTEXT] public int parseInto(ReadWritableInstant instant, String text, int position) { DateTimeParser parser = requireParser(); if (instant == null) { throw new IllegalArgumentException("Instant must not be null"); } [BUGGY] [BUGGY] long instantMillis = instant.getMillis(); Chronology chrono = instant.getChronology(); long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis); chrono = selectChronology(chrono); int defaultYear = chrono.year().get(instantLocal); DateTimeParserBucket bucket = new DateTimeParserBucket( instantLocal, chrono, iLocale, iPivotYear, defaultYear); int newPos = parser.parseInto(bucket, text, position); instant.setMillis(bucket.computeMillis(false, text)); if (iOffsetParsed && bucket.getOffsetInteger() != null) { [CLASS] DateTimeFormatter [METHOD] parseInto [RETURN_TYPE] int  ReadWritableInstant instant String text int position [VARIABLES] Locale iLocale locale Integer iPivotYear pivotYear DateTimeParser iParser parser boolean iOffsetParsed offsetParsed DateTimeParserBucket bucket ReadWritableInstant instant Chronology chrono iChrono String text DateTimePrinter iPrinter printer DateTimeZone iZone parsedZone zone int defaultYear iDefaultYear newPos offset parsedOffset pivotYear position long instantLocal instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	706	706	2	add	
13	[BUG] [BUGGY] Chronology chrono = instant.getChronology(); [FE] org.joda.time.IllegalFieldValueException: Cannot parse "2 29": Value 29 for dayOfMonth must be in the range [1 testParseInto_monthDay_feb29_newYork_startOfYear [CONTEXT] public int parseInto(ReadWritableInstant instant, String text, int position) { DateTimeParser parser = requireParser(); if (instant == null) { throw new IllegalArgumentException("Instant must not be null"); } long instantMillis = instant.getMillis(); [BUGGY] Chronology chrono = instant.getChronology(); [BUGGY] long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis); chrono = selectChronology(chrono); int defaultYear = chrono.year().get(instantLocal); DateTimeParserBucket bucket = new DateTimeParserBucket( instantLocal, chrono, iLocale, iPivotYear, defaultYear); int newPos = parser.parseInto(bucket, text, position); instant.setMillis(bucket.computeMillis(false, text)); if (iOffsetParsed && bucket.getOffsetInteger() != null) { int parsedOffset = bucket.getOffsetInteger(); [CLASS] DateTimeFormatter [METHOD] parseInto [RETURN_TYPE] int  ReadWritableInstant instant String text int position [VARIABLES] Locale iLocale locale Integer iPivotYear pivotYear DateTimeParser iParser parser boolean iOffsetParsed offsetParsed DateTimeParserBucket bucket ReadWritableInstant instant Chronology chrono iChrono String text DateTimePrinter iPrinter printer DateTimeZone iZone parsedZone zone int defaultYear iDefaultYear newPos offset parsedOffset pivotYear position long instantLocal instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	707	707	2	replace	
14	[BUG] [BUGGY] [FE] org.joda.time.IllegalFieldValueException: Cannot parse "2 29": Value 29 for dayOfMonth must be in the range [1 testParseInto_monthDay_feb29_newYork_startOfYear [CONTEXT] public int parseInto(ReadWritableInstant instant, String text, int position) { DateTimeParser parser = requireParser(); if (instant == null) { throw new IllegalArgumentException("Instant must not be null"); } long instantMillis = instant.getMillis(); [BUGGY] [BUGGY] Chronology chrono = instant.getChronology(); long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis); chrono = selectChronology(chrono); int defaultYear = chrono.year().get(instantLocal); DateTimeParserBucket bucket = new DateTimeParserBucket( instantLocal, chrono, iLocale, iPivotYear, defaultYear); int newPos = parser.parseInto(bucket, text, position); instant.setMillis(bucket.computeMillis(false, text)); if (iOffsetParsed && bucket.getOffsetInteger() != null) { int parsedOffset = bucket.getOffsetInteger(); [CLASS] DateTimeFormatter [METHOD] parseInto [RETURN_TYPE] int  ReadWritableInstant instant String text int position [VARIABLES] Locale iLocale locale Integer iPivotYear pivotYear DateTimeParser iParser parser boolean iOffsetParsed offsetParsed DateTimeParserBucket bucket ReadWritableInstant instant Chronology chrono iChrono String text DateTimePrinter iPrinter printer DateTimeZone iZone parsedZone zone int defaultYear iDefaultYear newPos offset parsedOffset pivotYear position long instantLocal instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	707	707	2	add	
15	[BUG] [BUGGY] long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis); [FE] org.joda.time.IllegalFieldValueException: Cannot parse "2 29": Value 29 for dayOfMonth must be in the range [1 testParseInto_monthDay_feb29_newYork_startOfYear [CONTEXT] public int parseInto(ReadWritableInstant instant, String text, int position) { DateTimeParser parser = requireParser(); if (instant == null) { throw new IllegalArgumentException("Instant must not be null"); } long instantMillis = instant.getMillis(); Chronology chrono = instant.getChronology(); [BUGGY] long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis); [BUGGY] chrono = selectChronology(chrono); int defaultYear = chrono.year().get(instantLocal); DateTimeParserBucket bucket = new DateTimeParserBucket( instantLocal, chrono, iLocale, iPivotYear, defaultYear); int newPos = parser.parseInto(bucket, text, position); instant.setMillis(bucket.computeMillis(false, text)); if (iOffsetParsed && bucket.getOffsetInteger() != null) { int parsedOffset = bucket.getOffsetInteger(); DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset); [CLASS] DateTimeFormatter [METHOD] parseInto [RETURN_TYPE] int  ReadWritableInstant instant String text int position [VARIABLES] Locale iLocale locale Integer iPivotYear pivotYear DateTimeParser iParser parser boolean iOffsetParsed offsetParsed DateTimeParserBucket bucket ReadWritableInstant instant Chronology chrono iChrono String text DateTimePrinter iPrinter printer DateTimeZone iZone parsedZone zone int defaultYear iDefaultYear newPos offset parsedOffset pivotYear position long instantLocal instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	708	708	2	replace	
16	[BUG] [BUGGY] [FE] org.joda.time.IllegalFieldValueException: Cannot parse "2 29": Value 29 for dayOfMonth must be in the range [1 testParseInto_monthDay_feb29_newYork_startOfYear [CONTEXT] public int parseInto(ReadWritableInstant instant, String text, int position) { DateTimeParser parser = requireParser(); if (instant == null) { throw new IllegalArgumentException("Instant must not be null"); } long instantMillis = instant.getMillis(); Chronology chrono = instant.getChronology(); [BUGGY] [BUGGY] long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis); chrono = selectChronology(chrono); int defaultYear = chrono.year().get(instantLocal); DateTimeParserBucket bucket = new DateTimeParserBucket( instantLocal, chrono, iLocale, iPivotYear, defaultYear); int newPos = parser.parseInto(bucket, text, position); instant.setMillis(bucket.computeMillis(false, text)); if (iOffsetParsed && bucket.getOffsetInteger() != null) { int parsedOffset = bucket.getOffsetInteger(); DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset); [CLASS] DateTimeFormatter [METHOD] parseInto [RETURN_TYPE] int  ReadWritableInstant instant String text int position [VARIABLES] Locale iLocale locale Integer iPivotYear pivotYear DateTimeParser iParser parser boolean iOffsetParsed offsetParsed DateTimeParserBucket bucket ReadWritableInstant instant Chronology chrono iChrono String text DateTimePrinter iPrinter printer DateTimeZone iZone parsedZone zone int defaultYear iDefaultYear newPos offset parsedOffset pivotYear position long instantLocal instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	708	708	2	add	
17	[BUG] [BUGGY] chrono = selectChronology(chrono); [FE] org.joda.time.IllegalFieldValueException: Cannot parse "2 29": Value 29 for dayOfMonth must be in the range [1 testParseInto_monthDay_feb29_newYork_startOfYear [CONTEXT] public int parseInto(ReadWritableInstant instant, String text, int position) { DateTimeParser parser = requireParser(); if (instant == null) { throw new IllegalArgumentException("Instant must not be null"); } long instantMillis = instant.getMillis(); Chronology chrono = instant.getChronology(); long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis); [BUGGY] chrono = selectChronology(chrono); [BUGGY] int defaultYear = chrono.year().get(instantLocal); DateTimeParserBucket bucket = new DateTimeParserBucket( instantLocal, chrono, iLocale, iPivotYear, defaultYear); int newPos = parser.parseInto(bucket, text, position); instant.setMillis(bucket.computeMillis(false, text)); if (iOffsetParsed && bucket.getOffsetInteger() != null) { int parsedOffset = bucket.getOffsetInteger(); DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset); chrono = chrono.withZone(parsedZone); [CLASS] DateTimeFormatter [METHOD] parseInto [RETURN_TYPE] int  ReadWritableInstant instant String text int position [VARIABLES] Locale iLocale locale Integer iPivotYear pivotYear DateTimeParser iParser parser boolean iOffsetParsed offsetParsed DateTimeParserBucket bucket ReadWritableInstant instant Chronology chrono iChrono String text DateTimePrinter iPrinter printer DateTimeZone iZone parsedZone zone int defaultYear iDefaultYear newPos offset parsedOffset pivotYear position long instantLocal instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	709	709	2	replace	
18	[BUG] [BUGGY] [FE] org.joda.time.IllegalFieldValueException: Cannot parse "2 29": Value 29 for dayOfMonth must be in the range [1 testParseInto_monthDay_feb29_newYork_startOfYear [CONTEXT] public int parseInto(ReadWritableInstant instant, String text, int position) { DateTimeParser parser = requireParser(); if (instant == null) { throw new IllegalArgumentException("Instant must not be null"); } long instantMillis = instant.getMillis(); Chronology chrono = instant.getChronology(); long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis); [BUGGY] [BUGGY] chrono = selectChronology(chrono); int defaultYear = chrono.year().get(instantLocal); DateTimeParserBucket bucket = new DateTimeParserBucket( instantLocal, chrono, iLocale, iPivotYear, defaultYear); int newPos = parser.parseInto(bucket, text, position); instant.setMillis(bucket.computeMillis(false, text)); if (iOffsetParsed && bucket.getOffsetInteger() != null) { int parsedOffset = bucket.getOffsetInteger(); DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset); chrono = chrono.withZone(parsedZone); [CLASS] DateTimeFormatter [METHOD] parseInto [RETURN_TYPE] int  ReadWritableInstant instant String text int position [VARIABLES] Locale iLocale locale Integer iPivotYear pivotYear DateTimeParser iParser parser boolean iOffsetParsed offsetParsed DateTimeParserBucket bucket ReadWritableInstant instant Chronology chrono iChrono String text DateTimePrinter iPrinter printer DateTimeZone iZone parsedZone zone int defaultYear iDefaultYear newPos offset parsedOffset pivotYear position long instantLocal instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	709	709	2	add	
19	[BUG] [BUGGY] int defaultYear = chrono.year().get(instantLocal); [FE] org.joda.time.IllegalFieldValueException: Cannot parse "2 29": Value 29 for dayOfMonth must be in the range [1 testParseInto_monthDay_feb29_newYork_startOfYear [CONTEXT] public int parseInto(ReadWritableInstant instant, String text, int position) { DateTimeParser parser = requireParser(); if (instant == null) { throw new IllegalArgumentException("Instant must not be null"); } long instantMillis = instant.getMillis(); Chronology chrono = instant.getChronology(); long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis); chrono = selectChronology(chrono); [BUGGY] int defaultYear = chrono.year().get(instantLocal); [BUGGY]  DateTimeParserBucket bucket = new DateTimeParserBucket( instantLocal, chrono, iLocale, iPivotYear, defaultYear); int newPos = parser.parseInto(bucket, text, position); instant.setMillis(bucket.computeMillis(false, text)); if (iOffsetParsed && bucket.getOffsetInteger() != null) { int parsedOffset = bucket.getOffsetInteger(); DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset); chrono = chrono.withZone(parsedZone); } else if (bucket.getZone() != null) { [CLASS] DateTimeFormatter [METHOD] parseInto [RETURN_TYPE] int  ReadWritableInstant instant String text int position [VARIABLES] Locale iLocale locale Integer iPivotYear pivotYear DateTimeParser iParser parser boolean iOffsetParsed offsetParsed DateTimeParserBucket bucket ReadWritableInstant instant Chronology chrono iChrono String text DateTimePrinter iPrinter printer DateTimeZone iZone parsedZone zone int defaultYear iDefaultYear newPos offset parsedOffset pivotYear position long instantLocal instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	710	710	2	replace	
20	[BUG] [BUGGY] [FE] org.joda.time.IllegalFieldValueException: Cannot parse "2 29": Value 29 for dayOfMonth must be in the range [1 testParseInto_monthDay_feb29_newYork_startOfYear [CONTEXT] public int parseInto(ReadWritableInstant instant, String text, int position) { DateTimeParser parser = requireParser(); if (instant == null) { throw new IllegalArgumentException("Instant must not be null"); } long instantMillis = instant.getMillis(); Chronology chrono = instant.getChronology(); long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis); chrono = selectChronology(chrono); [BUGGY] [BUGGY] int defaultYear = chrono.year().get(instantLocal); DateTimeParserBucket bucket = new DateTimeParserBucket( instantLocal, chrono, iLocale, iPivotYear, defaultYear); int newPos = parser.parseInto(bucket, text, position); instant.setMillis(bucket.computeMillis(false, text)); if (iOffsetParsed && bucket.getOffsetInteger() != null) { int parsedOffset = bucket.getOffsetInteger(); DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset); chrono = chrono.withZone(parsedZone); } else if (bucket.getZone() != null) { [CLASS] DateTimeFormatter [METHOD] parseInto [RETURN_TYPE] int  ReadWritableInstant instant String text int position [VARIABLES] Locale iLocale locale Integer iPivotYear pivotYear DateTimeParser iParser parser boolean iOffsetParsed offsetParsed DateTimeParserBucket bucket ReadWritableInstant instant Chronology chrono iChrono String text DateTimePrinter iPrinter printer DateTimeZone iZone parsedZone zone int defaultYear iDefaultYear newPos offset parsedOffset pivotYear position long instantLocal instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	710	710	2	add	
