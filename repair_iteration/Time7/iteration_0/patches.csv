bugid	buggy	buggy_class	suspiciousness	buggy_line	endbuggycode	original_failing_test_number	action	patch	original_buggy	execution_result	diagnosis	previous_bug_id	new_failing_test_number	this_action122	[BUG]  [BUGGY]  [FE]  org.joda.time.IllegalFieldValueException:  Cannot  parse   "2  29 ":  Value  29  for  dayOfMonth  must  be  in  the  range  [1  testParseInto_monthDay_feb29_newYork_startOfYear  [CONTEXT]  public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException( "Instant  must  not  be  null ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  [BUGGY]    instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantLocal);  [BUGGY]  chrono  =  selectChronology(chrono);  int  defaultYear  =  chrono.year().get(instantLocal);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  defaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	709	709	2	add	    instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantLocal);		compilable	  [FE]  org.joda.time.IllegalFieldValueException:  Cannot  parse   "2  29 ":  Value  29  for  dayOfMonth  must  be  in  the  range  [1  testParseInto_monthDay_feb29_newYork_startOfYear	18	2	add
123	[BUG]  [BUGGY]    instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantLocal);  [FE]  org.joda.time.IllegalFieldValueException:  Cannot  parse   "2  29 ":  Value  29  for  dayOfMonth  must  be  in  the  range  [1  testParseInto_monthDay_feb29_newYork_startOfYear  [CONTEXT]  public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException( "Instant  must  not  be  null ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  [BUGGY]    instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantLocal);  [BUGGY]  chrono  =  selectChronology(chrono);  int  defaultYear  =  chrono.year().get(instantLocal);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  defaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	709	709	2	replace	    instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantLocal);		compilable	  [FE]  org.joda.time.IllegalFieldValueException:  Cannot  parse   "2  29 ":  Value  29  for  dayOfMonth  must  be  in  the  range  [1  testParseInto_monthDay_feb29_newYork_startOfYear	18	2	add
172	[BUG]  [BUGGY]  long  instantLocal  =  instantMillis  /  chrono.getZone().getOffset(instantMillis);  [timeout]  [CONTEXT]  public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException( "Instant  must  not  be  null ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  [BUGGY]  long  instantLocal  =  instantMillis  /  chrono.getZone().getOffset(instantMillis);  [BUGGY]  chrono  =  selectChronology(chrono);  int  defaultYear  =  chrono.year().get(instantLocal);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  defaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	708	708	2	replace	long  instantLocal  =  instantMillis  /  chrono.getZone().getOffset(instantMillis);	long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  	non-compiled	[timeout]	15	None	replace
173	[BUG]  [BUGGY]  long  instantLocal  =  instantMillis  +  chrono.getZone().setUTC(instantMillis);  [timeout]  [CONTEXT]  public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException( "Instant  must  not  be  null ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  [BUGGY]  long  instantLocal  =  instantMillis  +  chrono.getZone().setUTC(instantMillis);  [BUGGY]  chrono  =  selectChronology(chrono);  int  defaultYear  =  chrono.year().get(instantLocal);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  defaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	708	708	2	replace	long  instantLocal  =  instantMillis  +  chrono.getZone().setUTC(instantMillis);	long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  	non-compiled	[timeout]	15	None	replace
191	[BUG]  [BUGGY]  [FE]  org.joda.time.IllegalFieldValueException:  Cannot  parse   "2  29 ":  Value  29  for  dayOfMonth  must  be  in  the  range  [1  testParseInto_monthDay_feb29_newYork_startOfYear  [CONTEXT]  public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException( "Instant  must  not  be  null ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  [BUGGY]    instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantLocal);  [BUGGY]  int  defaultYear  =  chrono.year().get(instantLocal);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  defaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	710	710	2	add	    instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantLocal);		compilable	  [FE]  org.joda.time.IllegalFieldValueException:  Cannot  parse   "2  29 ":  Value  29  for  dayOfMonth  must  be  in  the  range  [1  testParseInto_monthDay_feb29_newYork_startOfYear	20	2	add
192	[BUG]  [BUGGY]    instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantLocal);  [FE]  org.joda.time.IllegalFieldValueException:  Cannot  parse   "2  29 ":  Value  29  for  dayOfMonth  must  be  in  the  range  [1  testParseInto_monthDay_feb29_newYork_startOfYear  [CONTEXT]  public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException( "Instant  must  not  be  null ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  [BUGGY]    instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantLocal);  [BUGGY]  int  defaultYear  =  chrono.year().get(instantLocal);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  defaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	710	710	2	replace	    instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantLocal);		compilable	  [FE]  org.joda.time.IllegalFieldValueException:  Cannot  parse   "2  29 ":  Value  29  for  dayOfMonth  must  be  in  the  range  [1  testParseInto_monthDay_feb29_newYork_startOfYear	20	2	add
193	[BUG]  [BUGGY]  [FE]  org.joda.time.IllegalFieldValueException:  Cannot  parse   "2  29 ":  Value  29  for  dayOfMonth  must  be  in  the  range  [1  testParseInto_monthDay_feb29_newYork_startOfYear  [CONTEXT]  public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException( "Instant  must  not  be  null ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  [BUGGY]    int  year  =  chrono.year().get(instantLocal);  [BUGGY]  int  defaultYear  =  chrono.year().get(instantLocal);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  defaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	710	710	2	add	    int  year  =  chrono.year().get(instantLocal);		compilable	  [FE]  org.joda.time.IllegalFieldValueException:  Cannot  parse   "2  29 ":  Value  29  for  dayOfMonth  must  be  in  the  range  [1  testParseInto_monthDay_feb29_newYork_startOfYear	20	2	add
194	[BUG]  [BUGGY]    int  year  =  chrono.year().get(instantLocal);  [FE]  org.joda.time.IllegalFieldValueException:  Cannot  parse   "2  29 ":  Value  29  for  dayOfMonth  must  be  in  the  range  [1  testParseInto_monthDay_feb29_newYork_startOfYear  [CONTEXT]  public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException( "Instant  must  not  be  null ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  [BUGGY]    int  year  =  chrono.year().get(instantLocal);  [BUGGY]  int  defaultYear  =  chrono.year().get(instantLocal);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  defaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	710	710	2	replace	    int  year  =  chrono.year().get(instantLocal);		compilable	  [FE]  org.joda.time.IllegalFieldValueException:  Cannot  parse   "2  29 ":  Value  29  for  dayOfMonth  must  be  in  the  range  [1  testParseInto_monthDay_feb29_newYork_startOfYear	20	2	add
194	[BUG]  [BUGGY]  [FE]  org.joda.time.IllegalFieldValueException:  Cannot  parse   "2  29 ":  Value  29  for  dayOfMonth  must  be  in  the  range  [1  testParseInto_monthDay_feb29_newYork_startOfYear  [CONTEXT]  public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException( "Instant  must  not  be  null ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  [BUGGY]    int  iLocal  =  chrono.monthOfYear().get(instantLocal);  [BUGGY]  int  defaultYear  =  chrono.year().get(instantLocal);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  defaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	710	710	2	add	    int  iLocal  =  chrono.monthOfYear().get(instantLocal);		compilable	  [FE]  org.joda.time.IllegalFieldValueException:  Cannot  parse   "2  29 ":  Value  29  for  dayOfMonth  must  be  in  the  range  [1  testParseInto_monthDay_feb29_newYork_startOfYear	20	2	add
195	[BUG]  [BUGGY]    int  iLocal  =  chrono.monthOfYear().get(instantLocal);  [FE]  org.joda.time.IllegalFieldValueException:  Cannot  parse   "2  29 ":  Value  29  for  dayOfMonth  must  be  in  the  range  [1  testParseInto_monthDay_feb29_newYork_startOfYear  [CONTEXT]  public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException( "Instant  must  not  be  null ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  [BUGGY]    int  iLocal  =  chrono.monthOfYear().get(instantLocal);  [BUGGY]  int  defaultYear  =  chrono.year().get(instantLocal);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  defaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	710	710	2	replace	    int  iLocal  =  chrono.monthOfYear().get(instantLocal);		compilable	  [FE]  org.joda.time.IllegalFieldValueException:  Cannot  parse   "2  29 ":  Value  29  for  dayOfMonth  must  be  in  the  range  [1  testParseInto_monthDay_feb29_newYork_startOfYear	20	2	add
195	[BUG]  [BUGGY]  [FE]  org.joda.time.IllegalFieldValueException:  Cannot  parse   "2  29 ":  Value  29  for  dayOfMonth  must  be  in  the  range  [1  testParseInto_monthDay_feb29_newYork_startOfYear  [CONTEXT]  public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException( "Instant  must  not  be  null ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  [BUGGY]    chrono  =  selectChronology(chrono);  [BUGGY]  int  defaultYear  =  chrono.year().get(instantLocal);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  defaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	710	710	2	add	    chrono  =  selectChronology(chrono);		compilable	  [FE]  org.joda.time.IllegalFieldValueException:  Cannot  parse   "2  29 ":  Value  29  for  dayOfMonth  must  be  in  the  range  [1  testParseInto_monthDay_feb29_newYork_startOfYear	20	2	add
196	[BUG]  [BUGGY]    chrono  =  selectChronology(chrono);  [FE]  org.joda.time.IllegalFieldValueException:  Cannot  parse   "2  29 ":  Value  29  for  dayOfMonth  must  be  in  the  range  [1  testParseInto_monthDay_feb29_newYork_startOfYear  [CONTEXT]  public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException( "Instant  must  not  be  null ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  [BUGGY]    chrono  =  selectChronology(chrono);  [BUGGY]  int  defaultYear  =  chrono.year().get(instantLocal);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  defaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	710	710	2	replace	    chrono  =  selectChronology(chrono);		compilable	  [FE]  org.joda.time.IllegalFieldValueException:  Cannot  parse   "2  29 ":  Value  29  for  dayOfMonth  must  be  in  the  range  [1  testParseInto_monthDay_feb29_newYork_startOfYear	20	2	add
24	[BUG]  [BUGGY]  [FE]  org.joda.time.IllegalFieldValueException:  Cannot  parse   "2  29 ":  Value  29  for  dayOfMonth  must  be  in  the  range  [1  testParseInto_monthDay_feb29_newYork_startOfYear  [CONTEXT]  public  DateTimeFormatter  withLocale(Locale  locale)  {  [BUGGY]  if(locale  ==  getLocale()  ||  locale!=  null  &&  locale.equals(getLocale()))  {  [BUGGY]  return  this;  }  return  new  DateTimeFormatter(iPrinter,  iParser,  locale,  iOffsetParsed,  iChrono,  iZone,  iPivotYear,  iDefaultYear);  }  [CLASS]  DateTimeFormatter  [METHOD]  withLocale  [RETURN_TYPE]  DateTimeFormatter  Locale  locale  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  Chronology  chrono  iChrono  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  zone  int  defaultYear  iDefaultYear  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.30151134457776363	190	190	2	add	if(locale  ==  getLocale()  ||  locale!=  null  &&  locale.equals(getLocale()))  {	if  (locale  ==  getLocale()  ||  (locale  !=  null  &&  locale.equals(getLocale())))  {  	compilable	  [FE]  org.joda.time.IllegalFieldValueException:  Cannot  parse   "2  29 ":  Value  29  for  dayOfMonth  must  be  in  the  range  [1  testParseInto_monthDay_feb29_newYork_startOfYear	1	2	replace
25	[BUG]  [BUGGY]  if(locale  ==  getLocale()  ||  locale!=  null  &&  locale.equals(getLocale()))  {  [FE]  org.joda.time.IllegalFieldValueException:  Cannot  parse   "2  29 ":  Value  29  for  dayOfMonth  must  be  in  the  range  [1  testParseInto_monthDay_feb29_newYork_startOfYear  [CONTEXT]  public  DateTimeFormatter  withLocale(Locale  locale)  {  [BUGGY]  if(locale  ==  getLocale()  ||  locale!=  null  &&  locale.equals(getLocale()))  {  [BUGGY]  return  this;  }  return  new  DateTimeFormatter(iPrinter,  iParser,  locale,  iOffsetParsed,  iChrono,  iZone,  iPivotYear,  iDefaultYear);  }  [CLASS]  DateTimeFormatter  [METHOD]  withLocale  [RETURN_TYPE]  DateTimeFormatter  Locale  locale  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  Chronology  chrono  iChrono  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  zone  int  defaultYear  iDefaultYear  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.30151134457776363	190	190	2	replace	if(locale  ==  getLocale()  ||  locale!=  null  &&  locale.equals(getLocale()))  {	if  (locale  ==  getLocale()  ||  (locale  !=  null  &&  locale.equals(getLocale())))  {  	compilable	  [FE]  org.joda.time.IllegalFieldValueException:  Cannot  parse   "2  29 ":  Value  29  for  dayOfMonth  must  be  in  the  range  [1  testParseInto_monthDay_feb29_newYork_startOfYear	1	2	replace
102	[BUG]  [BUGGY]  [FE]  org.joda.time.IllegalFieldValueException:  Cannot  parse   "2  29 ":  Value  29  for  dayOfMonth  must  be  in  the  range  [1  testParseInto_monthDay_feb29_newYork_startOfYear  [CONTEXT]  public  Locale  getLocale()  {  [BUGGY]  return  this.iLocale;  [BUGGY]  }  [CLASS]  DateTimeFormatter  [METHOD]  getLocale  [RETURN_TYPE]  Locale  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  Chronology  chrono  iChrono  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  zone  int  defaultYear  iDefaultYear  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.30151134457776363	204	204	2	add	return  this.iLocale;	return  iLocale;  	compilable	  [FE]  org.joda.time.IllegalFieldValueException:  Cannot  parse   "2  29 ":  Value  29  for  dayOfMonth  must  be  in  the  range  [1  testParseInto_monthDay_feb29_newYork_startOfYear	5	2	replace
103	[BUG]  [BUGGY]  return  this.iLocale;  [FE]  org.joda.time.IllegalFieldValueException:  Cannot  parse   "2  29 ":  Value  29  for  dayOfMonth  must  be  in  the  range  [1  testParseInto_monthDay_feb29_newYork_startOfYear  [CONTEXT]  public  Locale  getLocale()  {  [BUGGY]  return  this.iLocale;  [BUGGY]  }  [CLASS]  DateTimeFormatter  [METHOD]  getLocale  [RETURN_TYPE]  Locale  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  Chronology  chrono  iChrono  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  zone  int  defaultYear  iDefaultYear  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.30151134457776363	204	204	2	replace	return  this.iLocale;	return  iLocale;  	compilable	  [FE]  org.joda.time.IllegalFieldValueException:  Cannot  parse   "2  29 ":  Value  29  for  dayOfMonth  must  be  in  the  range  [1  testParseInto_monthDay_feb29_newYork_startOfYear	5	2	replace
262	[BUG]  [BUGGY]  [FE]  org.joda.time.IllegalFieldValueException:  Cannot  parse   "2  29 ":  Value  29  for  dayOfMonth  must  be  in  the  range  [1  testParseInto_monthDay_feb29_newYork_startOfYear  [CONTEXT]  public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  [BUGGY]  DateTimeParser  parser  =  getParser();  [BUGGY]  if  (instant  ==  null)  {  throw  new  IllegalArgumentException( "Instant  must  not  be  null ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  int  defaultYear  =  chrono.year().get(instantLocal);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	701	701	2	add	DateTimeParser  parser  =  getParser();	DateTimeParser  parser  =  requireParser();  	compilable	  [FE]  org.joda.time.IllegalFieldValueException:  Cannot  parse   "2  29 ":  Value  29  for  dayOfMonth  must  be  in  the  range  [1  testParseInto_monthDay_feb29_newYork_startOfYear	7	2	replace
263	[BUG]  [BUGGY]  DateTimeParser  parser  =  getParser();  [FE]  org.joda.time.IllegalFieldValueException:  Cannot  parse   "2  29 ":  Value  29  for  dayOfMonth  must  be  in  the  range  [1  testParseInto_monthDay_feb29_newYork_startOfYear  [CONTEXT]  public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  [BUGGY]  DateTimeParser  parser  =  getParser();  [BUGGY]  if  (instant  ==  null)  {  throw  new  IllegalArgumentException( "Instant  must  not  be  null ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  int  defaultYear  =  chrono.year().get(instantLocal);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	701	701	2	replace	DateTimeParser  parser  =  getParser();	DateTimeParser  parser  =  requireParser();  	compilable	  [FE]  org.joda.time.IllegalFieldValueException:  Cannot  parse   "2  29 ":  Value  29  for  dayOfMonth  must  be  in  the  range  [1  testParseInto_monthDay_feb29_newYork_startOfYear	7	2	replace
281	[BUG]  [BUGGY]  [FE]  org.joda.time.IllegalFieldValueException:  Cannot  parse   "2  29 ":  Value  29  for  dayOfMonth  must  be  in  the  range  [1  testParseInto_monthDay_feb29_newYork_startOfYear  [CONTEXT]  public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException( "Instant  must  not  be  null ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  [BUGGY]    chrono  =  selectChronology(chrono);  [BUGGY]  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  int  defaultYear  =  chrono.year().get(instantLocal);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  defaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	708	708	2	add	    chrono  =  selectChronology(chrono);		compilable	  [FE]  org.joda.time.IllegalFieldValueException:  Cannot  parse   "2  29 ":  Value  29  for  dayOfMonth  must  be  in  the  range  [1  testParseInto_monthDay_feb29_newYork_startOfYear	16	2	add
282	[BUG]  [BUGGY]    chrono  =  selectChronology(chrono);  [FE]  org.joda.time.IllegalFieldValueException:  Cannot  parse   "2  29 ":  Value  29  for  dayOfMonth  must  be  in  the  range  [1  testParseInto_monthDay_feb29_newYork_startOfYear  [CONTEXT]  public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException( "Instant  must  not  be  null ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  [BUGGY]    chrono  =  selectChronology(chrono);  [BUGGY]  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  int  defaultYear  =  chrono.year().get(instantLocal);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  defaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	708	708	2	replace	    chrono  =  selectChronology(chrono);		compilable	  [FE]  org.joda.time.IllegalFieldValueException:  Cannot  parse   "2  29 ":  Value  29  for  dayOfMonth  must  be  in  the  range  [1  testParseInto_monthDay_feb29_newYork_startOfYear	16	2	add
321	[BUG]  [BUGGY]  [FE]  org.joda.time.IllegalFieldValueException:  Cannot  parse   "2  29 ":  Value  29  for  dayOfMonth  must  be  in  the  range  [1  testParseInto_monthDay_feb29_newYork_startOfYear  [CONTEXT]  public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException( "Instant  must  not  be  null ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  [BUGGY]    int  pivotYear  =  chrono.year().get(instantLocal);  [BUGGY]  int  defaultYear  =  chrono.year().get(instantLocal);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  defaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	710	710	2	add	    int  pivotYear  =  chrono.year().get(instantLocal);		compilable	  [FE]  org.joda.time.IllegalFieldValueException:  Cannot  parse   "2  29 ":  Value  29  for  dayOfMonth  must  be  in  the  range  [1  testParseInto_monthDay_feb29_newYork_startOfYear	20	2	add
322	[BUG]  [BUGGY]    int  pivotYear  =  chrono.year().get(instantLocal);  [FE]  org.joda.time.IllegalFieldValueException:  Cannot  parse   "2  29 ":  Value  29  for  dayOfMonth  must  be  in  the  range  [1  testParseInto_monthDay_feb29_newYork_startOfYear  [CONTEXT]  public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException( "Instant  must  not  be  null ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  [BUGGY]    int  pivotYear  =  chrono.year().get(instantLocal);  [BUGGY]  int  defaultYear  =  chrono.year().get(instantLocal);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  defaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	710	710	2	replace	    int  pivotYear  =  chrono.year().get(instantLocal);		compilable	  [FE]  org.joda.time.IllegalFieldValueException:  Cannot  parse   "2  29 ":  Value  29  for  dayOfMonth  must  be  in  the  range  [1  testParseInto_monthDay_feb29_newYork_startOfYear	20	2	add
322	[BUG]  [BUGGY]  [FE]  org.joda.time.IllegalFieldValueException:  Cannot  parse   "2  29 ":  Value  29  for  dayOfMonth  must  be  in  the  range  [1  testParseInto_monthDay_feb29_newYork_startOfYear  [CONTEXT]  public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException( "Instant  must  not  be  null ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  [BUGGY]    int  parsedYear  =  chrono.year().get(instantLocal);  [BUGGY]  int  defaultYear  =  chrono.year().get(instantLocal);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  defaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	710	710	2	add	    int  parsedYear  =  chrono.year().get(instantLocal);		compilable	  [FE]  org.joda.time.IllegalFieldValueException:  Cannot  parse   "2  29 ":  Value  29  for  dayOfMonth  must  be  in  the  range  [1  testParseInto_monthDay_feb29_newYork_startOfYear	20	2	add
323	[BUG]  [BUGGY]    int  parsedYear  =  chrono.year().get(instantLocal);  [FE]  org.joda.time.IllegalFieldValueException:  Cannot  parse   "2  29 ":  Value  29  for  dayOfMonth  must  be  in  the  range  [1  testParseInto_monthDay_feb29_newYork_startOfYear  [CONTEXT]  public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException( "Instant  must  not  be  null ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  [BUGGY]    int  parsedYear  =  chrono.year().get(instantLocal);  [BUGGY]  int  defaultYear  =  chrono.year().get(instantLocal);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  defaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	710	710	2	replace	    int  parsedYear  =  chrono.year().get(instantLocal);		compilable	  [FE]  org.joda.time.IllegalFieldValueException:  Cannot  parse   "2  29 ":  Value  29  for  dayOfMonth  must  be  in  the  range  [1  testParseInto_monthDay_feb29_newYork_startOfYear	20	2	add
383	[BUG]  [BUGGY]  long  instantMillis  =  instant.getMillis()  -  1;  [timeout]  [CONTEXT]  public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException( "Instant  must  not  be  null ");  }  [BUGGY]  long  instantMillis  =  instant.getMillis()  -  1;  [BUGGY]  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  int  defaultYear  =  chrono.year().get(instantLocal);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  defaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	706	706	2	replace	long  instantMillis  =  instant.getMillis()  -  1;	long  instantMillis  =  instant.getMillis();  	non-compiled	[timeout]	11	None	replace
384	[BUG]  [BUGGY]  long  instantMillis  =  instant.getMillis()  -  position;  [timeout]  [CONTEXT]  public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException( "Instant  must  not  be  null ");  }  [BUGGY]  long  instantMillis  =  instant.getMillis()  -  position;  [BUGGY]  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  int  defaultYear  =  chrono.year().get(instantLocal);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  defaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	706	706	2	replace	long  instantMillis  =  instant.getMillis()  -  position;	long  instantMillis  =  instant.getMillis();  	non-compiled	[timeout]	11	None	replace
151	[BUG]  [BUGGY]    instantMillis  =  DateTimeUtils.currentTimeMillis();  [timeout]  [CONTEXT]  public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException( "Instant  must  not  be  null ");  }  long  instantMillis  =  instant.getMillis();  [BUGGY]    instantMillis  =  DateTimeUtils.currentTimeMillis();  [BUGGY]  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  int  defaultYear  =  chrono.year().get(instantLocal);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  defaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	707	707	2	replace	    instantMillis  =  DateTimeUtils.currentTimeMillis();		non-compiled	[timeout]	14	None	add
152	[BUG]  [BUGGY]    instantMillis  +=  DateTimeUtils.currentTimeMillis();  [timeout]  [CONTEXT]  public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException( "Instant  must  not  be  null ");  }  long  instantMillis  =  instant.getMillis();  [BUGGY]    instantMillis  +=  DateTimeUtils.currentTimeMillis();  [BUGGY]  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  int  defaultYear  =  chrono.year().get(instantLocal);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  defaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	707	707	2	replace	    instantMillis  +=  DateTimeUtils.currentTimeMillis();		non-compiled	[timeout]	14	None	add
241	[BUG]  [BUGGY]  if(instant  ==  null  ||  instant.getMillis()!=  text.length())  {  [timeout]  [CONTEXT]  public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  [BUGGY]  if(instant  ==  null  ||  instant.getMillis()!=  text.length())  {  [BUGGY]  throw  new  IllegalArgumentException( "Instant  must  not  be  null ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  int  defaultYear  =  chrono.year().get(instantLocal);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	702	702	2	replace	if(instant  ==  null  ||  instant.getMillis()!=  text.length())  {	if  (instant  ==  null)  {  	non-compiled	[timeout]	9	None	replace
242	[BUG]  [BUGGY]  if(instant  ==  null  ||  instant.getLocalMillis()!=  text.length())  {  [timeout]  [CONTEXT]  public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  [BUGGY]  if(instant  ==  null  ||  instant.getLocalMillis()!=  text.length())  {  [BUGGY]  throw  new  IllegalArgumentException( "Instant  must  not  be  null ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  int  defaultYear  =  chrono.year().get(instantLocal);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	702	702	2	replace	if(instant  ==  null  ||  instant.getLocalMillis()!=  text.length())  {	if  (instant  ==  null)  {  	non-compiled	[timeout]	9	None	replace
392	[BUG]  [BUGGY]  [FE]  org.joda.time.IllegalFieldValueException:  Cannot  parse   "2  29 ":  Value  29  for  dayOfMonth  must  be  in  the  range  [1  testParseInto_monthDay_feb29_newYork_startOfYear  [CONTEXT]  public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException( "Instant  must  not  be  null ");  }  long  instantMillis  =  instant.getMillis();  [BUGGY]  Chronology  chrono  =(instant  ==  null)?  instant.getChronology()  :  instant.getChronology();  [BUGGY]  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  int  defaultYear  =  chrono.year().get(instantLocal);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  defaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	707	707	2	add	Chronology  chrono  =(instant  ==  null)?  instant.getChronology()  :  instant.getChronology();	Chronology  chrono  =  instant.getChronology();  	compilable	  [FE]  org.joda.time.IllegalFieldValueException:  Cannot  parse   "2  29 ":  Value  29  for  dayOfMonth  must  be  in  the  range  [1  testParseInto_monthDay_feb29_newYork_startOfYear	13	2	replace
393	[BUG]  [BUGGY]  Chronology  chrono  =(instant  ==  null)?  instant.getChronology()  :  instant.getChronology();  [FE]  org.joda.time.IllegalFieldValueException:  Cannot  parse   "2  29 ":  Value  29  for  dayOfMonth  must  be  in  the  range  [1  testParseInto_monthDay_feb29_newYork_startOfYear  [CONTEXT]  public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException( "Instant  must  not  be  null ");  }  long  instantMillis  =  instant.getMillis();  [BUGGY]  Chronology  chrono  =(instant  ==  null)?  instant.getChronology()  :  instant.getChronology();  [BUGGY]  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  int  defaultYear  =  chrono.year().get(instantLocal);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  defaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	707	707	2	replace	Chronology  chrono  =(instant  ==  null)?  instant.getChronology()  :  instant.getChronology();	Chronology  chrono  =  instant.getChronology();  	compilable	  [FE]  org.joda.time.IllegalFieldValueException:  Cannot  parse   "2  29 ":  Value  29  for  dayOfMonth  must  be  in  the  range  [1  testParseInto_monthDay_feb29_newYork_startOfYear	13	2	replace
393	[BUG]  [BUGGY]  [FE]  org.joda.time.IllegalFieldValueException:  Cannot  parse   "2  29 ":  Value  29  for  dayOfMonth  must  be  in  the  range  [1  testParseInto_monthDay_feb29_newYork_startOfYear  [CONTEXT]  public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException( "Instant  must  not  be  null ");  }  long  instantMillis  =  instant.getMillis();  [BUGGY]  Chronology  chrono  =(instant  ==  null)?  instant.getChronology()  :  DateTimeUtils.getInstantChronology(instant);  [BUGGY]  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  int  defaultYear  =  chrono.year().get(instantLocal);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  defaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	707	707	2	add	Chronology  chrono  =(instant  ==  null)?  instant.getChronology()  :  DateTimeUtils.getInstantChronology(instant);	Chronology  chrono  =  instant.getChronology();  	compilable	  [FE]  org.joda.time.IllegalFieldValueException:  Cannot  parse   "2  29 ":  Value  29  for  dayOfMonth  must  be  in  the  range  [1  testParseInto_monthDay_feb29_newYork_startOfYear	13	2	replace
394	[BUG]  [BUGGY]  Chronology  chrono  =(instant  ==  null)?  instant.getChronology()  :  DateTimeUtils.getInstantChronology(instant);  [FE]  org.joda.time.IllegalFieldValueException:  Cannot  parse   "2  29 ":  Value  29  for  dayOfMonth  must  be  in  the  range  [1  testParseInto_monthDay_feb29_newYork_startOfYear  [CONTEXT]  public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException( "Instant  must  not  be  null ");  }  long  instantMillis  =  instant.getMillis();  [BUGGY]  Chronology  chrono  =(instant  ==  null)?  instant.getChronology()  :  DateTimeUtils.getInstantChronology(instant);  [BUGGY]  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  int  defaultYear  =  chrono.year().get(instantLocal);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  defaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	707	707	2	replace	Chronology  chrono  =(instant  ==  null)?  instant.getChronology()  :  DateTimeUtils.getInstantChronology(instant);	Chronology  chrono  =  instant.getChronology();  	compilable	  [FE]  org.joda.time.IllegalFieldValueException:  Cannot  parse   "2  29 ":  Value  29  for  dayOfMonth  must  be  in  the  range  [1  testParseInto_monthDay_feb29_newYork_startOfYear	13	2	replace
451	[BUG]  [BUGGY]    instantMillis  =  DateTimeUtils.currentTimeMillis();  [timeout]  [CONTEXT]  public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException( "Instant  must  not  be  null ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  [BUGGY]    instantMillis  =  DateTimeUtils.currentTimeMillis();  [BUGGY]  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  int  defaultYear  =  chrono.year().get(instantLocal);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  defaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	708	708	2	replace	    instantMillis  =  DateTimeUtils.currentTimeMillis();		non-compiled	[timeout]	16	None	add
452	[BUG]  [BUGGY]    DateTimeParser  parser  =  requireParser();  [timeout]  [CONTEXT]  public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException( "Instant  must  not  be  null ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  [BUGGY]    DateTimeParser  parser  =  requireParser();  [BUGGY]  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  int  defaultYear  =  chrono.year().get(instantLocal);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  defaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	708	708	2	replace	    DateTimeParser  parser  =  requireParser();		non-compiled	[timeout]	16	None	add
