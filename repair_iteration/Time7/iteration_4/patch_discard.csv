increase failing tests,702,replace, [FE] org.joda.time.IllegalFieldValueException: Cannot parse "2 29": Value 29 for dayOfMonth must be in the range [1 testParseInto_monthDay_feb29_newYork_startOfYear, if(parser!=  null  &&  instant.getMillis()!=  text.length())  {  [timeout]  [CONTEXT]        public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();        ,if(parser!= null && instant.getMillis() == text.length()) {
compilation error,702,replace,[CE] cannot find symbol, if(parser!=  null  &&  instant.getMillis()!=  text.length())  {  [timeout]  [CONTEXT]        public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();        ,if(instant!= null && parser.getMillis()!= text.length()) {
compilation error,706,replace,[CE] bad operand types for binary operator '*', long  instantMillis  =  instant.getMillis()  *  position  -  2;  [timeout]  [CONTEXT]        public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(       "Instant  must  not  be  null       ");  }        ,long instantMillis = instant.getMillis() * text - position - 2;
compilation error,702,replace,[CE] cannot find symbol, if(instant.getMillis()!=  text.length()  ||  instant.getChronology()  ==  DateTimeUtils.getInstantMillis(instant,  text,  position))  {  [timeout]  [CONTEXT]        public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();        ,if(parser.getMillis()!= text.length() || instant.getChronology() == DateTimeUtils.getInstantMillis(instant, text, position)) {
increase failing tests,702,replace, [FE] IllegalArgumentException testParseInto_monthOnly_baseStartYear, if(instant!=  null  &&  instant.getMillis()  <  text.length())  {  [timeout]  [CONTEXT]        public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();        ,if(instant!= null && instant.getMillis() > text.length()) {
increase failing tests,702,replace, [FE] org.joda.time.IllegalFieldValueException: Cannot parse "2 29": Value 29 for dayOfMonth must be in the range [1 testParseInto_monthDay_feb29_newYork_startOfYear, if(instant!=  null  &&  instant.getMillis()  <  text.length())  {  [timeout]  [CONTEXT]        public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();        ,if(parser == null && instant.getMillis() < text.length()) {
compilation error,702,replace,[CE] cannot find symbol, if(instant!=  null  ||  parser.getMillis()!=  text.length())  {  [timeout]  [CONTEXT]        public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();        ,if(parser == null && parser.getMillis()!= text.length()) {
increase failing tests,702,replace, [FE] org.joda.time.IllegalFieldValueException: Cannot parse "2 29": Value 29 for dayOfMonth must be in the range [1 testParseInto_monthDay_feb29_newYork_startOfYear, if(instant!=  null  &&  instant.getMillis()!=  text.length())  {  [timeout]  [CONTEXT]        public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();        ,if(instant!= null && instant.getMillis() == text.length()) {
increase failing tests,709,replace, [FE] AssertionFailedError testParseInto_monthOnly_baseStartYear, instantLocal  =  instantLocal  /  chrono.getZone().getOffsetFromLocal(instantLocal);  [timeout]  [CONTEXT]        public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(       "Instant  must  not  be  null       ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);        ,instantLocal = instantLocal - chrono.getZone().getOffsetFromLocal(instantLocal);
increase failing tests,706,replace, [FE] AssertionFailedError testParseInto_monthOnly_baseStartYear, long  instantMillis  =  instant.getMillis()  /  position  *  4;  [timeout]  [CONTEXT]        public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(       "Instant  must  not  be  null       ");  }        ,long instantMillis = instant.getMillis() * position * 4;
increase failing tests,709,replace, [FE] AssertionFailedError testParseInto_monthOnly_baseStartYear, instantLocal  =  instantMillis  /  chrono.getZone().getOffset(instantMillis  +  1);  [timeout]  [CONTEXT]        public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(       "Instant  must  not  be  null       ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);        ,instantLocal = instantMillis - chrono.getZone().getOffset(instantMillis + 1);
compilation error,702,replace,[CE] cannot find symbol, if(instant.getMillis()!=  text.length()  &&  position!=  0)  {  [timeout]  [CONTEXT]        public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();        ,if(parser.getMillis()!= text.length() && position == 0) {
compilation error,708,replace,[CE] ,                 chrono        =        selectChronology(chrono);        chrono    =    selectChronology(chrono);    chrono  =  selectChronology(chrono);  if(iParser!=  null)  {  throw  new  IllegalArgumentException( " ");  }  else  {  DateTimeParser  parser  =  parser.parseInto(instantMillis,  text,  position);  }  [timeout]  [CONTEXT]        public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(       "Instant  must  not  be  null       ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();        ,chrono = selectChronology(chrono); chrono = selectChronology(chrono); if(iParser!= null) { throw new IllegalArgumentException(""); } else { DateTimeParser parser = parser.parseInto(instantMillis, text
increase failing tests,709,replace, [FE] AssertionFailedError testParseInto_monthOnly_baseStartYear, instantLocal  =  instantMillis  /  chrono.getZone().getOffsetFromLocal(instantMillis);  [timeout]  [CONTEXT]        public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(       "Instant  must  not  be  null       ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);        ,instantLocal = instantMillis - chrono.getZone().getOffsetFromLocal(instantMillis);
increase failing tests,709,replace, [FE] org.joda.time.IllegalFieldValueException: Cannot parse "2 29": Value 29 for dayOfMonth must be in the range [1 testParseInto_monthDay_feb29_newYork_startOfYear, instantLocal  =  instantMillis  /  chrono.getZone().getOffsetFromLocal(instantMillis);  [timeout]  [CONTEXT]        public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(       "Instant  must  not  be  null       ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);        ,instantLocal = instantMillis + chrono.getZone().getOffsetFromLocal(instantMillis);
increase failing tests,706,replace, [FE] ComparisonFailure testPrint_bufferMethods, long  instantMillis  =  instant.getMillis()  /  position  +  2;  [timeout]  [CONTEXT]        public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(       "Instant  must  not  be  null       ");  }        ,long instantMillis = instant.getMillis() * position + 2;
increase failing tests,709,replace, [FE] AssertionFailedError testParseInto_monthOnly_baseStartYear, instantLocal  =  instantLocal  /  chrono.getZone().getOffset(instantLocal  +  1);  [timeout]  [CONTEXT]        public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(       "Instant  must  not  be  null       ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);        ,instantLocal = instantLocal - chrono.getZone().getOffset(instantLocal + 1);
compilation error,706,replace,[CE] bad operand types for binary operator '*', long  instantMillis  =  instant.getMillis()  *  position  /  2;  [timeout]  [CONTEXT]        public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(       "Instant  must  not  be  null       ");  }        ,long instantMillis = instant.getMillis() * text / 2;
increase failing tests,702,replace, [FE] IllegalArgumentException testParseInto_monthOnly_baseStartYear, if(parser!=  null  &&  instant.getMillis()  <  text.length())  {  [timeout]  [CONTEXT]        public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();        ,if(parser!= null && instant.getMillis() >= text.length()) {
compilation error,702,replace,[CE] cannot find symbol, if(parser!=  null  &&  instant.getMillis()  <  text.length())  {  [timeout]  [CONTEXT]        public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();        ,if(instant!= null && parser.getMillis() < text.length()) {
compilation error,706,replace,[CE] bad operand types for binary operator '/', long  instantMillis  =  instant.getMillis()  /  position  -  1;  [timeout]  [CONTEXT]        public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(       "Instant  must  not  be  null       ");  }        ,long instantMillis = instant.getMillis() / text - position - 1;
increase failing tests,706,replace, [FE] AssertionFailedError testParseInto_monthOnly_baseStartYear, long  instantMillis  =  instant.getMillis()  /  position  *  1;  [timeout]  [CONTEXT]        public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(       "Instant  must  not  be  null       ");  }        ,long instantMillis = instant.getMillis() * position * 1;
increase failing tests,706,replace, [FE] ComparisonFailure testPrint_bufferMethods, long  instantMillis  =  instant.getMillis()  /  position  +  3;  [timeout]  [CONTEXT]        public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(       "Instant  must  not  be  null       ");  }        ,long instantMillis = instant.getMillis() * position + 3;
compilation error,702,replace,[CE] method getInstantMillis in class DateTimeUtils cannot be applied to given types;, if(instant.getMillis()!=  text.length()  ||  instant.getChronology()  ==  DateTimeUtils.getInstantMillis(instant,  text,  position))  {  [timeout]  [CONTEXT]        public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();        ,if(instant.getMillis() == text.length() || instant.getChronology() == DateTimeUtils.getInstantMillis(instant, text, position)) {
increase failing tests,702,replace, [FE] org.joda.time.IllegalFieldValueException: Cannot parse "2 29": Value 29 for dayOfMonth must be in the range [1 testParseInto_monthDay_feb29_newYork_startOfYear, if(instant!=  null  &&  instant.getMillis()!=  text.length())  {  [timeout]  [CONTEXT]        public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();        ,if(instant == null && instant.getMillis()!= text.length()) {
compilation error,702,replace,[CE] bad operand types for binary operator '<', if(instant!=  null  &&  instant.getMillis()!=  text.length())  {  [timeout]  [CONTEXT]        public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();        ,if(instant < null && instant.getMillis()!= text.length()) {
increase failing tests,702,replace, [FE] org.joda.time.IllegalFieldValueException: Cannot parse "2 29": Value 29 for dayOfMonth must be in the range [1 testParseInto_monthDay_feb29_newYork_startOfYear, if(instant!=  null  &&  instant.getMillis()  <  text.length())  {  [timeout]  [CONTEXT]        public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();        ,if(instant == null && instant.getMillis() < text.length()) {
compilation error,702,replace,[CE] cannot find symbol bucket, if(parser!=  null  &&  instant.getMillis()  <  text.length())  {  [timeout]  [CONTEXT]        public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();        ,if(instant == null && parser.parseInto(bucket, text, position)) {
compilation error,702,replace,[CE] bad operand types for binary operator '<', if(instant!=  null  ||  parser.getMillis()!=  text.length())  {  [timeout]  [CONTEXT]        public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();        ,if(instant < null || parser.getMillis()!= text.length()) {
compilation error,709,replace,[CE] method getOffsetFromLocal in class DateTimeZone cannot be applied to given types;, instantLocal  =  instantMillis  /  chrono.getZone().getOffsetFromLocal(instantMillis);  [timeout]  [CONTEXT]        public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(       "Instant  must  not  be  null       ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);        ,instantLocal = instantMillis / chrono.getZone().getOffsetFromLocal(instantMillis, chrono);
increase failing tests,702,replace, [FE] org.joda.time.IllegalFieldValueException: Cannot parse "2 29": Value 29 for dayOfMonth must be in the range [1 testParseInto_monthDay_feb29_newYork_startOfYear, if(instant.getMillis()!=  text.length()  &&  position!=  0)  {  [timeout]  [CONTEXT]        public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();        ,if(instant.getMillis() == text.length() && position == 0) {
increase failing tests,702,replace, [FE] org.joda.time.IllegalFieldValueException: Cannot parse "2 29": Value 29 for dayOfMonth must be in the range [1 testParseInto_monthDay_feb29_newYork_startOfYear, if(instant.getMillis()!=  text.length()  &&  position!=  0)  {  [timeout]  [CONTEXT]        public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();        ,if(instant.getMillis() == text.length() && position!= 0) {
increase failing tests,706,replace, [FE] ComparisonFailure testPrint_bufferMethods, long  instantMillis  =  instant.getMillis()  *  position  /  2;  [timeout]  [CONTEXT]        public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(       "Instant  must  not  be  null       ");  }        ,long instantMillis = instant.getMillis() * position / 2 + 1;
compilation error,702,replace,[CE] cannot find symbol bucket, if(parser!=  null  &&  instant.getMillis()!=  text.length())  {  [timeout]  [CONTEXT]        public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();        ,if(instant!= null && parser.parseInto(bucket, text, position)) {
compilation error,702,replace,[CE] method getInstantMillis in class DateTimeUtils cannot be applied to given types;, if(instant.getMillis()!=  text.length()  ||  instant.getChronology()  ==  DateTimeUtils.getInstantMillis(instant,  text,  position))  {  [timeout]  [CONTEXT]        public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();        ,if(instant.getMillis()!= text.length() && instant.getChronology() == DateTimeUtils.getInstantMillis(instant, text, position)) {
compilation error,702,replace,[CE] cannot find symbol, if(instant!=  null  ||  parser.getMillis()!=  text.length())  {  [timeout]  [CONTEXT]        public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();        ,if(instant == null || parser.getMethod()!= text.length()) {
compilation error,702,replace,[CE] bad operand types for binary operator '<', if(parser!=  null  &&  instant.getMillis()  <  text.length())  {  [timeout]  [CONTEXT]        public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();        ,if(instant < null && instant.getMillis() < text.length()) {
