bugid	buggy	buggy_class	suspiciousness	buggy_line	endbuggycode	original_failing_test_number	action	patch	original_buggy	execution_result	diagnosis	previous_bug_id	new_failing_test_number	this_action83	[BUG]  [BUGGY]  instantLocal  =  instantMillis  /  chrono.getZone().getOffsetFromLocal(instantLocal);  [timeout]  [CONTEXT]          public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(         "Instant  must  not  be  null         ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);          [BUGGY]  instantLocal  =  instantMillis  /  chrono.getZone().getOffsetFromLocal(instantLocal);  [BUGGY]          chrono  =  selectChronology(chrono);  int  defaultYear  =  chrono.year().get(instantLocal);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  defaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	709	709	2	replace	instantLocal  =  instantMillis  /  chrono.getZone().getOffsetFromLocal(instantLocal);	  instantLocal    =    instantLocal    /    chrono.getZone().getOffsetFromLocal(instantLocal);    [timeout]    [CONTEXT]                public    int    parseInto(ReadWritableInstant    instant,    String    text,    int    position)    {    DateTimeParser    parser    =    requireParser();    if    (instant    ==    null)    {    throw    new    IllegalArgumentException(               "Instant    must    not    be    null               ");    }    long    instantMillis    =    instant.getMillis();    Chronology    chrono    =    instant.getChronology();    long    instantLocal    =    instantMillis    +    chrono.getZone().getOffset(instantMillis);                	non-compiled	[timeout]	484	None	replace
123	[BUG]  [BUGGY]  instantLocal  =  instantMillis  /  chrono.getZone().getOffset(instantMillis  +  2);  [timeout]  [CONTEXT]          public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(         "Instant  must  not  be  null         ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);          [BUGGY]  instantLocal  =  instantMillis  /  chrono.getZone().getOffset(instantMillis  +  2);  [BUGGY]          chrono  =  selectChronology(chrono);  int  defaultYear  =  chrono.year().get(instantLocal);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  defaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	709	709	2	replace	instantLocal  =  instantMillis  /  chrono.getZone().getOffset(instantMillis  +  2);	  instantLocal    =    instantMillis    /    chrono.getZone().getOffset(instantMillis    +    1);    [timeout]    [CONTEXT]                public    int    parseInto(ReadWritableInstant    instant,    String    text,    int    position)    {    DateTimeParser    parser    =    requireParser();    if    (instant    ==    null)    {    throw    new    IllegalArgumentException(               "Instant    must    not    be    null               ");    }    long    instantMillis    =    instant.getMillis();    Chronology    chrono    =    instant.getChronology();    long    instantLocal    =    instantMillis    +    chrono.getZone().getOffset(instantMillis);                	non-compiled	[timeout]	233	None	replace
124	[BUG]  [BUGGY]  instantLocal  =  instantMillis  *  chrono.getZone().getOffset(instantMillis  +  1);  [timeout]  [CONTEXT]          public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(         "Instant  must  not  be  null         ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);          [BUGGY]  instantLocal  =  instantMillis  *  chrono.getZone().getOffset(instantMillis  +  1);  [BUGGY]          chrono  =  selectChronology(chrono);  int  defaultYear  =  chrono.year().get(instantLocal);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  defaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	709	709	2	replace	instantLocal  =  instantMillis  *  chrono.getZone().getOffset(instantMillis  +  1);	  instantLocal    =    instantMillis    /    chrono.getZone().getOffset(instantMillis    +    1);    [timeout]    [CONTEXT]                public    int    parseInto(ReadWritableInstant    instant,    String    text,    int    position)    {    DateTimeParser    parser    =    requireParser();    if    (instant    ==    null)    {    throw    new    IllegalArgumentException(               "Instant    must    not    be    null               ");    }    long    instantMillis    =    instant.getMillis();    Chronology    chrono    =    instant.getChronology();    long    instantLocal    =    instantMillis    +    chrono.getZone().getOffset(instantMillis);                	non-compiled	[timeout]	233	None	replace
183	[BUG]  [BUGGY]  instantLocal  =  instantMillis  /  chrono.getZone().getOffset(instantLocal  +  1);  [timeout]  [CONTEXT]          public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(         "Instant  must  not  be  null         ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);          [BUGGY]  instantLocal  =  instantMillis  /  chrono.getZone().getOffset(instantLocal  +  1);  [BUGGY]          chrono  =  selectChronology(chrono);  int  defaultYear  =  chrono.year().get(instantLocal);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  defaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	709	709	2	replace	instantLocal  =  instantMillis  /  chrono.getZone().getOffset(instantLocal  +  1);	  instantLocal    =    instantLocal    /    chrono.getZone().getOffset(instantLocal    +    1);    [timeout]    [CONTEXT]                public    int    parseInto(ReadWritableInstant    instant,    String    text,    int    position)    {    DateTimeParser    parser    =    requireParser();    if    (instant    ==    null)    {    throw    new    IllegalArgumentException(               "Instant    must    not    be    null               ");    }    long    instantMillis    =    instant.getMillis();    Chronology    chrono    =    instant.getChronology();    long    instantLocal    =    instantMillis    +    chrono.getZone().getOffset(instantMillis);                	non-compiled	[timeout]	483	None	replace
184	[BUG]  [BUGGY]  instantLocal  =  instantLocal  +  chrono.getZone().getOffset(instantLocal  +  1);  [timeout]  [CONTEXT]          public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(         "Instant  must  not  be  null         ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);          [BUGGY]  instantLocal  =  instantLocal  +  chrono.getZone().getOffset(instantLocal  +  1);  [BUGGY]          chrono  =  selectChronology(chrono);  int  defaultYear  =  chrono.year().get(instantLocal);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  defaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	709	709	2	replace	instantLocal  =  instantLocal  +  chrono.getZone().getOffset(instantLocal  +  1);	  instantLocal    =    instantLocal    /    chrono.getZone().getOffset(instantLocal    +    1);    [timeout]    [CONTEXT]                public    int    parseInto(ReadWritableInstant    instant,    String    text,    int    position)    {    DateTimeParser    parser    =    requireParser();    if    (instant    ==    null)    {    throw    new    IllegalArgumentException(               "Instant    must    not    be    null               ");    }    long    instantMillis    =    instant.getMillis();    Chronology    chrono    =    instant.getChronology();    long    instantLocal    =    instantMillis    +    chrono.getZone().getOffset(instantMillis);                	non-compiled	[timeout]	483	None	replace
244	[BUG]  [BUGGY]  instantLocal  =  instantLocal  /  chrono.getZone().getOffset(instantMillis  +  1);  [timeout]  [CONTEXT]          public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(         "Instant  must  not  be  null         ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);          [BUGGY]  instantLocal  =  instantLocal  /  chrono.getZone().getOffset(instantMillis  +  1);  [BUGGY]          chrono  =  selectChronology(chrono);  int  defaultYear  =  chrono.year().get(instantLocal);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  defaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	709	709	2	replace	instantLocal  =  instantLocal  /  chrono.getZone().getOffset(instantMillis  +  1);	  instantLocal    =    instantLocal    /    chrono.getZone().getOffset(instantLocal    +    1);    [timeout]    [CONTEXT]                public    int    parseInto(ReadWritableInstant    instant,    String    text,    int    position)    {    DateTimeParser    parser    =    requireParser();    if    (instant    ==    null)    {    throw    new    IllegalArgumentException(               "Instant    must    not    be    null               ");    }    long    instantMillis    =    instant.getMillis();    Chronology    chrono    =    instant.getChronology();    long    instantLocal    =    instantMillis    +    chrono.getZone().getOffset(instantMillis);                	non-compiled	[timeout]	483	None	replace
283	[BUG]  [BUGGY]  long  instantMillis  =  instant.getMillis()  /  position  *  4  +  1;  [timeout]  [CONTEXT]          public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(         "Instant  must  not  be  null         ");  }          [BUGGY]  long  instantMillis  =  instant.getMillis()  /  position  *  4  +  1;  [BUGGY]          Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  int  defaultYear  =  chrono.year().get(instantLocal);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  defaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	706	706	2	replace	long  instantMillis  =  instant.getMillis()  /  position  *  4  +  1;	  long    instantMillis    =    instant.getMillis()    /    position    *    2    +    1;    [timeout]    [CONTEXT]                public    int    parseInto(ReadWritableInstant    instant,    String    text,    int    position)    {    DateTimeParser    parser    =    requireParser();    if    (instant    ==    null)    {    throw    new    IllegalArgumentException(               "Instant    must    not    be    null               ");    }                	non-compiled	[timeout]	342	None	replace
284	[BUG]  [BUGGY]  long  instantMillis  =  instant.getMillis()  /  position  *  3  +  1;  [timeout]  [CONTEXT]          public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(         "Instant  must  not  be  null         ");  }          [BUGGY]  long  instantMillis  =  instant.getMillis()  /  position  *  3  +  1;  [BUGGY]          Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  int  defaultYear  =  chrono.year().get(instantLocal);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  defaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	706	706	2	replace	long  instantMillis  =  instant.getMillis()  /  position  *  3  +  1;	  long    instantMillis    =    instant.getMillis()    /    position    *    2    +    1;    [timeout]    [CONTEXT]                public    int    parseInto(ReadWritableInstant    instant,    String    text,    int    position)    {    DateTimeParser    parser    =    requireParser();    if    (instant    ==    null)    {    throw    new    IllegalArgumentException(               "Instant    must    not    be    null               ");    }                	non-compiled	[timeout]	342	None	replace
302	[BUG]  [BUGGY]  if(instant.getMillis()!=  text.length()  ||  position  ==  0)  {  [timeout]  [CONTEXT]          public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();          [BUGGY]  if(instant.getMillis()!=  text.length()  ||  position  ==  0)  {  [BUGGY]          throw  new  IllegalArgumentException(         "Instant  must  not  be  null         ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  int  defaultYear  =  chrono.year().get(instantLocal);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	702	702	2	replace	if(instant.getMillis()!=  text.length()  ||  position  ==  0)  {	  if(instant.getMillis()!=    text.length()    &&    position!=    0)    {    [timeout]    [CONTEXT]                public    int    parseInto(ReadWritableInstant    instant,    String    text,    int    position)    {    DateTimeParser    parser    =    requireParser();                	non-compiled	[timeout]	332	None	replace
303	[BUG]  [BUGGY]  if(instant.getMillis()!=  text.length()  &&  position  ==  0)  {  [timeout]  [CONTEXT]          public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();          [BUGGY]  if(instant.getMillis()!=  text.length()  &&  position  ==  0)  {  [BUGGY]          throw  new  IllegalArgumentException(         "Instant  must  not  be  null         ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  int  defaultYear  =  chrono.year().get(instantLocal);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	702	702	2	replace	if(instant.getMillis()!=  text.length()  &&  position  ==  0)  {	  if(instant.getMillis()!=    text.length()    &&    position!=    0)    {    [timeout]    [CONTEXT]                public    int    parseInto(ReadWritableInstant    instant,    String    text,    int    position)    {    DateTimeParser    parser    =    requireParser();                	non-compiled	[timeout]	332	None	replace
382	[BUG]  [BUGGY]  long  instantMillis  =  instant.getMillis()  *  position  /  2  -  1;  [timeout]  [CONTEXT]          public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(         "Instant  must  not  be  null         ");  }          [BUGGY]  long  instantMillis  =  instant.getMillis()  *  position  /  2  -  1;  [BUGGY]          Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  int  defaultYear  =  chrono.year().get(instantLocal);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  defaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	706	706	2	replace	long  instantMillis  =  instant.getMillis()  *  position  /  2  -  1;	  long    instantMillis    =    instant.getMillis()    *    position    /    2;    [timeout]    [CONTEXT]                public    int    parseInto(ReadWritableInstant    instant,    String    text,    int    position)    {    DateTimeParser    parser    =    requireParser();    if    (instant    ==    null)    {    throw    new    IllegalArgumentException(               "Instant    must    not    be    null               ");    }                	non-compiled	[timeout]	54	None	replace
384	[BUG]  [BUGGY]  long  instantMillis  =  instant.getMillis()  *  position  /  3;  [timeout]  [CONTEXT]          public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(         "Instant  must  not  be  null         ");  }          [BUGGY]  long  instantMillis  =  instant.getMillis()  *  position  /  3;  [BUGGY]          Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  int  defaultYear  =  chrono.year().get(instantLocal);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  defaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	706	706	2	replace	long  instantMillis  =  instant.getMillis()  *  position  /  3;	  long    instantMillis    =    instant.getMillis()    *    position    /    2;    [timeout]    [CONTEXT]                public    int    parseInto(ReadWritableInstant    instant,    String    text,    int    position)    {    DateTimeParser    parser    =    requireParser();    if    (instant    ==    null)    {    throw    new    IllegalArgumentException(               "Instant    must    not    be    null               ");    }                	non-compiled	[timeout]	54	None	replace
403	[BUG]  [BUGGY]  long  instantMillis  =  instant.getMillis()  /  position  -  2;  [timeout]  [CONTEXT]          public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(         "Instant  must  not  be  null         ");  }          [BUGGY]  long  instantMillis  =  instant.getMillis()  /  position  -  2;  [BUGGY]          Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  int  defaultYear  =  chrono.year().get(instantLocal);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  defaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	706	706	2	replace	long  instantMillis  =  instant.getMillis()  /  position  -  2;	  long    instantMillis    =    instant.getMillis()    *    position    -    2;    [timeout]    [CONTEXT]                public    int    parseInto(ReadWritableInstant    instant,    String    text,    int    position)    {    DateTimeParser    parser    =    requireParser();    if    (instant    ==    null)    {    throw    new    IllegalArgumentException(               "Instant    must    not    be    null               ");    }                	non-compiled	[timeout]	363	None	replace
64	[BUG]  [BUGGY]  instantLocal  =  instantLocal  /  chrono.getZone().getOffsetFromLocal(instantLocal  +  1);  [timeout]  [CONTEXT]          public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(         "Instant  must  not  be  null         ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);          [BUGGY]  instantLocal  =  instantLocal  /  chrono.getZone().getOffsetFromLocal(instantLocal  +  1);  [BUGGY]          chrono  =  selectChronology(chrono);  int  defaultYear  =  chrono.year().get(instantLocal);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  defaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	709	709	2	replace	instantLocal  =  instantLocal  /  chrono.getZone().getOffsetFromLocal(instantLocal  +  1);	  instantLocal    =    instantLocal    /    chrono.getZone().getOffsetFromLocal(instantLocal);    [timeout]    [CONTEXT]                public    int    parseInto(ReadWritableInstant    instant,    String    text,    int    position)    {    DateTimeParser    parser    =    requireParser();    if    (instant    ==    null)    {    throw    new    IllegalArgumentException(               "Instant    must    not    be    null               ");    }    long    instantMillis    =    instant.getMillis();    Chronology    chrono    =    instant.getChronology();    long    instantLocal    =    instantMillis    +    chrono.getZone().getOffset(instantMillis);                	non-compiled	[timeout]	484	None	replace
154	[BUG]  [BUGGY]  if(text.length()!=  0  ||  instant.getMillis()!=  text.length())  {  [timeout]  [CONTEXT]          public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();          [BUGGY]  if(text.length()!=  0  ||  instant.getMillis()!=  text.length())  {  [BUGGY]          throw  new  IllegalArgumentException(         "Instant  must  not  be  null         ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  int  defaultYear  =  chrono.year().get(instantLocal);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	702	702	2	replace	if(text.length()!=  0  ||  instant.getMillis()!=  text.length())  {	  if(instant.getMillis()!=    text.length()    &&    position!=    0)    {    [timeout]    [CONTEXT]                public    int    parseInto(ReadWritableInstant    instant,    String    text,    int    position)    {    DateTimeParser    parser    =    requireParser();                	non-compiled	[timeout]	332	None	replace
214	[BUG]  [BUGGY]  instantLocal  =  instantMillis  /  chrono.getZone().getOffset(instantMillis  +  3);  [timeout]  [CONTEXT]          public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(         "Instant  must  not  be  null         ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);          [BUGGY]  instantLocal  =  instantMillis  /  chrono.getZone().getOffset(instantMillis  +  3);  [BUGGY]          chrono  =  selectChronology(chrono);  int  defaultYear  =  chrono.year().get(instantLocal);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  defaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	709	709	2	replace	instantLocal  =  instantMillis  /  chrono.getZone().getOffset(instantMillis  +  3);	  instantLocal    =    instantMillis    /    chrono.getZone().getOffset(instantMillis    +    1);    [timeout]    [CONTEXT]                public    int    parseInto(ReadWritableInstant    instant,    String    text,    int    position)    {    DateTimeParser    parser    =    requireParser();    if    (instant    ==    null)    {    throw    new    IllegalArgumentException(               "Instant    must    not    be    null               ");    }    long    instantMillis    =    instant.getMillis();    Chronology    chrono    =    instant.getChronology();    long    instantLocal    =    instantMillis    +    chrono.getZone().getOffset(instantMillis);                	non-compiled	[timeout]	233	None	replace
242	[BUG]  [BUGGY]  instantLocal  =  instantLocal  /  chrono.getZone().getOffset(instantLocal  +  2);  [timeout]  [CONTEXT]          public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(         "Instant  must  not  be  null         ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);          [BUGGY]  instantLocal  =  instantLocal  /  chrono.getZone().getOffset(instantLocal  +  2);  [BUGGY]          chrono  =  selectChronology(chrono);  int  defaultYear  =  chrono.year().get(instantLocal);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  defaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	709	709	2	replace	instantLocal  =  instantLocal  /  chrono.getZone().getOffset(instantLocal  +  2);	  instantLocal    =    instantLocal    /    chrono.getZone().getOffset(instantLocal    +    1);    [timeout]    [CONTEXT]                public    int    parseInto(ReadWritableInstant    instant,    String    text,    int    position)    {    DateTimeParser    parser    =    requireParser();    if    (instant    ==    null)    {    throw    new    IllegalArgumentException(               "Instant    must    not    be    null               ");    }    long    instantMillis    =    instant.getMillis();    Chronology    chrono    =    instant.getChronology();    long    instantLocal    =    instantMillis    +    chrono.getZone().getOffset(instantMillis);                	non-compiled	[timeout]	483	None	replace
243	[BUG]  [BUGGY]  instantLocal  =  instantLocal  /  chrono.getZone().getOffset(instantLocal  +  3);  [timeout]  [CONTEXT]          public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(         "Instant  must  not  be  null         ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);          [BUGGY]  instantLocal  =  instantLocal  /  chrono.getZone().getOffset(instantLocal  +  3);  [BUGGY]          chrono  =  selectChronology(chrono);  int  defaultYear  =  chrono.year().get(instantLocal);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  defaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	709	709	2	replace	instantLocal  =  instantLocal  /  chrono.getZone().getOffset(instantLocal  +  3);	  instantLocal    =    instantLocal    /    chrono.getZone().getOffset(instantLocal    +    1);    [timeout]    [CONTEXT]                public    int    parseInto(ReadWritableInstant    instant,    String    text,    int    position)    {    DateTimeParser    parser    =    requireParser();    if    (instant    ==    null)    {    throw    new    IllegalArgumentException(               "Instant    must    not    be    null               ");    }    long    instantMillis    =    instant.getMillis();    Chronology    chrono    =    instant.getChronology();    long    instantLocal    =    instantMillis    +    chrono.getZone().getOffset(instantMillis);                	non-compiled	[timeout]	483	None	replace
244	[BUG]  [BUGGY]  instantLocal  =  instantLocal  /  chrono.getZone().getOffset(instantLocal  +  6);  [timeout]  [CONTEXT]          public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(         "Instant  must  not  be  null         ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);          [BUGGY]  instantLocal  =  instantLocal  /  chrono.getZone().getOffset(instantLocal  +  6);  [BUGGY]          chrono  =  selectChronology(chrono);  int  defaultYear  =  chrono.year().get(instantLocal);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  defaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	709	709	2	replace	instantLocal  =  instantLocal  /  chrono.getZone().getOffset(instantLocal  +  6);	  instantLocal    =    instantLocal    /    chrono.getZone().getOffset(instantLocal    +    1);    [timeout]    [CONTEXT]                public    int    parseInto(ReadWritableInstant    instant,    String    text,    int    position)    {    DateTimeParser    parser    =    requireParser();    if    (instant    ==    null)    {    throw    new    IllegalArgumentException(               "Instant    must    not    be    null               ");    }    long    instantMillis    =    instant.getMillis();    Chronology    chrono    =    instant.getChronology();    long    instantLocal    =    instantMillis    +    chrono.getZone().getOffset(instantMillis);                	non-compiled	[timeout]	483	None	replace
274	[BUG]  [BUGGY]  long  instantMillis  =  instant.getMillis()  /  position  +  4;  [timeout]  [CONTEXT]          public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(         "Instant  must  not  be  null         ");  }          [BUGGY]  long  instantMillis  =  instant.getMillis()  /  position  +  4;  [BUGGY]          Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  int  defaultYear  =  chrono.year().get(instantLocal);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  defaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	706	706	2	replace	long  instantMillis  =  instant.getMillis()  /  position  +  4;	  long    instantMillis    =    instant.getMillis()    /    position    +    2;    [timeout]    [CONTEXT]                public    int    parseInto(ReadWritableInstant    instant,    String    text,    int    position)    {    DateTimeParser    parser    =    requireParser();    if    (instant    ==    null)    {    throw    new    IllegalArgumentException(               "Instant    must    not    be    null               ");    }                	non-compiled	[timeout]	14	None	replace
304	[BUG]  [BUGGY]  long  instantMillis  =  instant.getMillis()  /  position  *  6;  [timeout]  [CONTEXT]          public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(         "Instant  must  not  be  null         ");  }          [BUGGY]  long  instantMillis  =  instant.getMillis()  /  position  *  6;  [BUGGY]          Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  int  defaultYear  =  chrono.year().get(instantLocal);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  defaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	706	706	2	replace	long  instantMillis  =  instant.getMillis()  /  position  *  6;	  long    instantMillis    =    instant.getMillis()    /    position    *    4;    [timeout]    [CONTEXT]                public    int    parseInto(ReadWritableInstant    instant,    String    text,    int    position)    {    DateTimeParser    parser    =    requireParser();    if    (instant    ==    null)    {    throw    new    IllegalArgumentException(               "Instant    must    not    be    null               ");    }                	non-compiled	[timeout]	213	None	replace
574	[BUG]  [BUGGY]  [FE]  org.joda.time.IllegalFieldValueException:  Cannot  parse   "2  29 ":  Value  29  for  dayOfMonth  must  be  in  the  range  [1  testParseInto_monthDay_feb29_newYork_startOfYear  [CONTEXT]          public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(         "Instant  must  not  be  null         ");  }          [BUGGY]  long  instantMillis  =  instant.getMillis()  +  position  /  2;  [BUGGY]          Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  int  defaultYear  =  chrono.year().get(instantLocal);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  defaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	706	706	2	add	long  instantMillis  =  instant.getMillis()  +  position  /  2;	  long    instantMillis    =    instant.getMillis()    *    position    /    2;    [timeout]    [CONTEXT]                public    int    parseInto(ReadWritableInstant    instant,    String    text,    int    position)    {    DateTimeParser    parser    =    requireParser();    if    (instant    ==    null)    {    throw    new    IllegalArgumentException(               "Instant    must    not    be    null               ");    }                	compilable	  [FE]  org.joda.time.IllegalFieldValueException:  Cannot  parse   "2  29 ":  Value  29  for  dayOfMonth  must  be  in  the  range  [1  testParseInto_monthDay_feb29_newYork_startOfYear	54	2	replace
575	[BUG]  [BUGGY]  long  instantMillis  =  instant.getMillis()  +  position  /  2;  [FE]  org.joda.time.IllegalFieldValueException:  Cannot  parse   "2  29 ":  Value  29  for  dayOfMonth  must  be  in  the  range  [1  testParseInto_monthDay_feb29_newYork_startOfYear  [CONTEXT]          public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(         "Instant  must  not  be  null         ");  }          [BUGGY]  long  instantMillis  =  instant.getMillis()  +  position  /  2;  [BUGGY]          Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  int  defaultYear  =  chrono.year().get(instantLocal);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  defaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	706	706	2	replace	long  instantMillis  =  instant.getMillis()  +  position  /  2;	  long    instantMillis    =    instant.getMillis()    *    position    /    2;    [timeout]    [CONTEXT]                public    int    parseInto(ReadWritableInstant    instant,    String    text,    int    position)    {    DateTimeParser    parser    =    requireParser();    if    (instant    ==    null)    {    throw    new    IllegalArgumentException(               "Instant    must    not    be    null               ");    }                	compilable	  [FE]  org.joda.time.IllegalFieldValueException:  Cannot  parse   "2  29 ":  Value  29  for  dayOfMonth  must  be  in  the  range  [1  testParseInto_monthDay_feb29_newYork_startOfYear	54	2	replace
