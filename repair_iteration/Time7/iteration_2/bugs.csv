bugid	buggy	buggy_class	suspiciousness	buggy_line	endbuggycode	original_failing_test_number	action	patch	original_buggy	execution_result	diagnosis	previous_bug_id	new_failing_test_number	this_action31	[BUG]  [BUGGY]  [FE]  org.joda.time.IllegalFieldValueException:  Cannot  parse   "2  29 ":  Value  29  for  dayOfMonth  must  be  in  the  range  [1  testParseInto_monthDay_feb29_newYork_startOfYear  [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]      instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantLocal);  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantLocal);  [BUGGY]    int  defaultYear  =  chrono.year().get(instantLocal);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  defaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	710	710	2	add	        instantLocal    =    instantMillis    +    chrono.getZone().getOffset(instantLocal);    instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantLocal);	  	compilable	  [FE]  org.joda.time.IllegalFieldValueException:  Cannot  parse   "2  29 ":  Value  29  for  dayOfMonth  must  be  in  the  range  [1  testParseInto_monthDay_feb29_newYork_startOfYear	191	2	add
32	[BUG]  [BUGGY]      instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantLocal);  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantLocal);  [FE]  org.joda.time.IllegalFieldValueException:  Cannot  parse   "2  29 ":  Value  29  for  dayOfMonth  must  be  in  the  range  [1  testParseInto_monthDay_feb29_newYork_startOfYear  [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]      instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantLocal);  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantLocal);  [BUGGY]    int  defaultYear  =  chrono.year().get(instantLocal);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  defaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	710	710	2	replace	        instantLocal    =    instantMillis    +    chrono.getZone().getOffset(instantLocal);    instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantLocal);	  	compilable	  [FE]  org.joda.time.IllegalFieldValueException:  Cannot  parse   "2  29 ":  Value  29  for  dayOfMonth  must  be  in  the  range  [1  testParseInto_monthDay_feb29_newYork_startOfYear	191	2	add
91	[BUG]  [BUGGY]  [FE]  org.joda.time.IllegalFieldValueException:  Cannot  parse   "2  29 ":  Value  29  for  dayOfMonth  must  be  in  the  range  [1  testParseInto_monthDay_feb29_newYork_startOfYear  [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();    [BUGGY]  Chronology  chrono  =(instant!=  null)?  instant.getChronology()  :  DateTimeUtils.getInstantChronology(instant);  [BUGGY]    long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  int  defaultYear  =  chrono.year().get(instantLocal);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  defaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	707	707	2	add	Chronology  chrono  =(instant!=  null)?  instant.getChronology()  :  DateTimeUtils.getInstantChronology(instant);	  Chronology    chrono    =(instant    ==    null)?    instant.getChronology()    :    DateTimeUtils.getInstantChronology(instant);    	compilable	  [FE]  org.joda.time.IllegalFieldValueException:  Cannot  parse   "2  29 ":  Value  29  for  dayOfMonth  must  be  in  the  range  [1  testParseInto_monthDay_feb29_newYork_startOfYear	394	2	replace
92	[BUG]  [BUGGY]  Chronology  chrono  =(instant!=  null)?  instant.getChronology()  :  DateTimeUtils.getInstantChronology(instant);  [FE]  org.joda.time.IllegalFieldValueException:  Cannot  parse   "2  29 ":  Value  29  for  dayOfMonth  must  be  in  the  range  [1  testParseInto_monthDay_feb29_newYork_startOfYear  [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();    [BUGGY]  Chronology  chrono  =(instant!=  null)?  instant.getChronology()  :  DateTimeUtils.getInstantChronology(instant);  [BUGGY]    long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  int  defaultYear  =  chrono.year().get(instantLocal);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  defaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	707	707	2	replace	Chronology  chrono  =(instant!=  null)?  instant.getChronology()  :  DateTimeUtils.getInstantChronology(instant);	  Chronology    chrono    =(instant    ==    null)?    instant.getChronology()    :    DateTimeUtils.getInstantChronology(instant);    	compilable	  [FE]  org.joda.time.IllegalFieldValueException:  Cannot  parse   "2  29 ":  Value  29  for  dayOfMonth  must  be  in  the  range  [1  testParseInto_monthDay_feb29_newYork_startOfYear	394	2	replace
112	[BUG]  [BUGGY]  instantLocal  =  instantMillis  /  chrono.getZone().getOffset(instantLocal);  [timeout]  [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  instantLocal  =  instantMillis  /  chrono.getZone().getOffset(instantLocal);  [BUGGY]    chrono  =  selectChronology(chrono);  int  defaultYear  =  chrono.year().get(instantLocal);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  defaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	709	709	2	replace	instantLocal  =  instantMillis  /  chrono.getZone().getOffset(instantLocal);	      instantLocal    =    instantMillis    +    chrono.getZone().getOffset(instantLocal);    	non-compiled	[timeout]	123	None	replace
114	[BUG]  [BUGGY]  instantLocal  =  instantLocal  +  chrono.getZone().getOffset(instantMillis);  [timeout]  [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  instantLocal  =  instantLocal  +  chrono.getZone().getOffset(instantMillis);  [BUGGY]    chrono  =  selectChronology(chrono);  int  defaultYear  =  chrono.year().get(instantLocal);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  defaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	709	709	2	replace	instantLocal  =  instantLocal  +  chrono.getZone().getOffset(instantMillis);	      instantLocal    =    instantMillis    +    chrono.getZone().getOffset(instantLocal);    	non-compiled	[timeout]	123	None	replace
211	[BUG]  [BUGGY]  [FE]  org.joda.time.IllegalFieldValueException:  Cannot  parse   "2  29 ":  Value  29  for  dayOfMonth  must  be  in  the  range  [1  testParseInto_monthDay_feb29_newYork_startOfYear  [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();    [BUGGY]      chrono  =  selectChronology(chrono);  chrono  =  selectChronology(chrono);  [BUGGY]    long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  int  defaultYear  =  chrono.year().get(instantLocal);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  defaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	708	708	2	add	        chrono    =    selectChronology(chrono);    chrono  =  selectChronology(chrono);	  	compilable	  [FE]  org.joda.time.IllegalFieldValueException:  Cannot  parse   "2  29 ":  Value  29  for  dayOfMonth  must  be  in  the  range  [1  testParseInto_monthDay_feb29_newYork_startOfYear	281	2	add
212	[BUG]  [BUGGY]      chrono  =  selectChronology(chrono);  chrono  =  selectChronology(chrono);  [FE]  org.joda.time.IllegalFieldValueException:  Cannot  parse   "2  29 ":  Value  29  for  dayOfMonth  must  be  in  the  range  [1  testParseInto_monthDay_feb29_newYork_startOfYear  [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();    [BUGGY]      chrono  =  selectChronology(chrono);  chrono  =  selectChronology(chrono);  [BUGGY]    long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  int  defaultYear  =  chrono.year().get(instantLocal);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  defaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	708	708	2	replace	        chrono    =    selectChronology(chrono);    chrono  =  selectChronology(chrono);	  	compilable	  [FE]  org.joda.time.IllegalFieldValueException:  Cannot  parse   "2  29 ":  Value  29  for  dayOfMonth  must  be  in  the  range  [1  testParseInto_monthDay_feb29_newYork_startOfYear	281	2	add
242	[BUG]  [BUGGY]  if(instant  ==  null  ||  instant.getMillis()  <  text.length())  {  [timeout]  [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();    [BUGGY]  if(instant  ==  null  ||  instant.getMillis()  <  text.length())  {  [BUGGY]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  int  defaultYear  =  chrono.year().get(instantLocal);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	702	702	2	replace	if(instant  ==  null  ||  instant.getMillis()  <  text.length())  {	  if(instant    ==    null    ||    instant.getMillis()!=    text.length())    {    [timeout]    [CONTEXT]    public    int    parseInto(ReadWritableInstant    instant,    String    text,    int    position)    {    DateTimeParser    parser    =    requireParser();    	non-compiled	[timeout]	241	None	replace
243	[BUG]  [BUGGY]  if(parser  ==  null  ||  instant.getMillis()!=  text.length())  {  [timeout]  [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();    [BUGGY]  if(parser  ==  null  ||  instant.getMillis()!=  text.length())  {  [BUGGY]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  int  defaultYear  =  chrono.year().get(instantLocal);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	702	702	2	replace	if(parser  ==  null  ||  instant.getMillis()!=  text.length())  {	  if(instant    ==    null    ||    instant.getMillis()!=    text.length())    {    [timeout]    [CONTEXT]    public    int    parseInto(ReadWritableInstant    instant,    String    text,    int    position)    {    DateTimeParser    parser    =    requireParser();    	non-compiled	[timeout]	241	None	replace
312	[BUG]  [BUGGY]  [FE]  org.joda.time.IllegalFieldValueException:  Cannot  parse   "2  29 ":  Value  29  for  dayOfMonth  must  be  in  the  range  [1  testParseInto_monthDay_feb29_newYork_startOfYear  [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();    [BUGGY]  Chronology  chrono  =(instant!=  null)?  instant.getChronology()  :  instant.getChronology();  [BUGGY]    long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  int  defaultYear  =  chrono.year().get(instantLocal);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  defaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	707	707	2	add	Chronology  chrono  =(instant!=  null)?  instant.getChronology()  :  instant.getChronology();	  Chronology    chrono    =(instant    ==    null)?    instant.getChronology()    :    instant.getChronology();    	compilable	  [FE]  org.joda.time.IllegalFieldValueException:  Cannot  parse   "2  29 ":  Value  29  for  dayOfMonth  must  be  in  the  range  [1  testParseInto_monthDay_feb29_newYork_startOfYear	393	2	replace
313	[BUG]  [BUGGY]  Chronology  chrono  =(instant!=  null)?  instant.getChronology()  :  instant.getChronology();  [FE]  org.joda.time.IllegalFieldValueException:  Cannot  parse   "2  29 ":  Value  29  for  dayOfMonth  must  be  in  the  range  [1  testParseInto_monthDay_feb29_newYork_startOfYear  [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();    [BUGGY]  Chronology  chrono  =(instant!=  null)?  instant.getChronology()  :  instant.getChronology();  [BUGGY]    long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  int  defaultYear  =  chrono.year().get(instantLocal);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  defaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	707	707	2	replace	Chronology  chrono  =(instant!=  null)?  instant.getChronology()  :  instant.getChronology();	  Chronology    chrono    =(instant    ==    null)?    instant.getChronology()    :    instant.getChronology();    	compilable	  [FE]  org.joda.time.IllegalFieldValueException:  Cannot  parse   "2  29 ":  Value  29  for  dayOfMonth  must  be  in  the  range  [1  testParseInto_monthDay_feb29_newYork_startOfYear	393	2	replace
162	[BUG]  [BUGGY]  [FE]  org.joda.time.IllegalFieldValueException:  Cannot  parse   "2  29 ":  Value  29  for  dayOfMonth  must  be  in  the  range  [1  testParseInto_monthDay_feb29_newYork_startOfYear  [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]      int  year  =  chrono.year().get(instantLocal);  int  month  =  chrono.monthOfYear().get(instantLocal);  [BUGGY]    int  defaultYear  =  chrono.year().get(instantLocal);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  defaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	710	710	2	add	        int    year    =    chrono.year().get(instantLocal);    int  month  =  chrono.monthOfYear().get(instantLocal);	  	compilable	  [FE]  org.joda.time.IllegalFieldValueException:  Cannot  parse   "2  29 ":  Value  29  for  dayOfMonth  must  be  in  the  range  [1  testParseInto_monthDay_feb29_newYork_startOfYear	193	2	add
163	[BUG]  [BUGGY]      int  year  =  chrono.year().get(instantLocal);  int  month  =  chrono.monthOfYear().get(instantLocal);  [FE]  org.joda.time.IllegalFieldValueException:  Cannot  parse   "2  29 ":  Value  29  for  dayOfMonth  must  be  in  the  range  [1  testParseInto_monthDay_feb29_newYork_startOfYear  [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]      int  year  =  chrono.year().get(instantLocal);  int  month  =  chrono.monthOfYear().get(instantLocal);  [BUGGY]    int  defaultYear  =  chrono.year().get(instantLocal);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  defaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	710	710	2	replace	        int    year    =    chrono.year().get(instantLocal);    int  month  =  chrono.monthOfYear().get(instantLocal);	  	compilable	  [FE]  org.joda.time.IllegalFieldValueException:  Cannot  parse   "2  29 ":  Value  29  for  dayOfMonth  must  be  in  the  range  [1  testParseInto_monthDay_feb29_newYork_startOfYear	193	2	add
302	[BUG]  [BUGGY]  long  instantMillis  =  instant.getMillis()  /  position;  [timeout]  [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }    [BUGGY]  long  instantMillis  =  instant.getMillis()  /  position;  [BUGGY]    Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  int  defaultYear  =  chrono.year().get(instantLocal);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  defaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	706	706	2	replace	long  instantMillis  =  instant.getMillis()  /  position;	  long    instantMillis    =    instant.getMillis()    -    position;    [timeout]    [CONTEXT]    public    int    parseInto(ReadWritableInstant    instant,    String    text,    int    position)    {    DateTimeParser    parser    =    requireParser();    if    (instant    ==    null)    {    throw    new    IllegalArgumentException(   "Instant    must    not    be    null   ");    }    	non-compiled	[timeout]	384	None	replace
303	[BUG]  [BUGGY]  long  instantMillis  =  instant.getMillis()  *  position;  [timeout]  [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }    [BUGGY]  long  instantMillis  =  instant.getMillis()  *  position;  [BUGGY]    Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  int  defaultYear  =  chrono.year().get(instantLocal);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  defaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	706	706	2	replace	long  instantMillis  =  instant.getMillis()  *  position;	  long    instantMillis    =    instant.getMillis()    -    position;    [timeout]    [CONTEXT]    public    int    parseInto(ReadWritableInstant    instant,    String    text,    int    position)    {    DateTimeParser    parser    =    requireParser();    if    (instant    ==    null)    {    throw    new    IllegalArgumentException(   "Instant    must    not    be    null   ");    }    	non-compiled	[timeout]	384	None	replace
382	[BUG]  [BUGGY]  [FE]  org.joda.time.IllegalFieldValueException:  Cannot  parse   "2  29 ":  Value  29  for  dayOfMonth  must  be  in  the  range  [1  testParseInto_monthDay_feb29_newYork_startOfYear  [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();    [BUGGY]  if(instant  ==  null  ||  instant.getMillis()  ==  text.length())  {  [BUGGY]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  int  defaultYear  =  chrono.year().get(instantLocal);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	702	702	2	add	if(instant  ==  null  ||  instant.getMillis()  ==  text.length())  {	  if(instant    ==    null    ||    instant.getMillis()!=    text.length())    {    [timeout]    [CONTEXT]    public    int    parseInto(ReadWritableInstant    instant,    String    text,    int    position)    {    DateTimeParser    parser    =    requireParser();    	compilable	  [FE]  org.joda.time.IllegalFieldValueException:  Cannot  parse   "2  29 ":  Value  29  for  dayOfMonth  must  be  in  the  range  [1  testParseInto_monthDay_feb29_newYork_startOfYear	241	2	replace
383	[BUG]  [BUGGY]  if(instant  ==  null  ||  instant.getMillis()  ==  text.length())  {  [FE]  org.joda.time.IllegalFieldValueException:  Cannot  parse   "2  29 ":  Value  29  for  dayOfMonth  must  be  in  the  range  [1  testParseInto_monthDay_feb29_newYork_startOfYear  [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();    [BUGGY]  if(instant  ==  null  ||  instant.getMillis()  ==  text.length())  {  [BUGGY]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  int  defaultYear  =  chrono.year().get(instantLocal);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	702	702	2	replace	if(instant  ==  null  ||  instant.getMillis()  ==  text.length())  {	  if(instant    ==    null    ||    instant.getMillis()!=    text.length())    {    [timeout]    [CONTEXT]    public    int    parseInto(ReadWritableInstant    instant,    String    text,    int    position)    {    DateTimeParser    parser    =    requireParser();    	compilable	  [FE]  org.joda.time.IllegalFieldValueException:  Cannot  parse   "2  29 ":  Value  29  for  dayOfMonth  must  be  in  the  range  [1  testParseInto_monthDay_feb29_newYork_startOfYear	241	2	replace
602	[BUG]  [BUGGY]  [FE]  org.joda.time.IllegalFieldValueException:  Cannot  parse   "2  29 ":  Value  29  for  dayOfMonth  must  be  in  the  range  [1  testParseInto_monthDay_feb29_newYork_startOfYear  [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]      instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantLocal);  chrono  =  selectChronology(chrono);  [BUGGY]    int  defaultYear  =  chrono.year().get(instantLocal);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  defaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	710	710	2	add	        instantLocal    =    instantMillis    +    chrono.getZone().getOffset(instantLocal);    chrono  =  selectChronology(chrono);	  	compilable	  [FE]  org.joda.time.IllegalFieldValueException:  Cannot  parse   "2  29 ":  Value  29  for  dayOfMonth  must  be  in  the  range  [1  testParseInto_monthDay_feb29_newYork_startOfYear	191	2	add
603	[BUG]  [BUGGY]      instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantLocal);  chrono  =  selectChronology(chrono);  [FE]  org.joda.time.IllegalFieldValueException:  Cannot  parse   "2  29 ":  Value  29  for  dayOfMonth  must  be  in  the  range  [1  testParseInto_monthDay_feb29_newYork_startOfYear  [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]      instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantLocal);  chrono  =  selectChronology(chrono);  [BUGGY]    int  defaultYear  =  chrono.year().get(instantLocal);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  defaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	710	710	2	replace	        instantLocal    =    instantMillis    +    chrono.getZone().getOffset(instantLocal);    chrono  =  selectChronology(chrono);	  	compilable	  [FE]  org.joda.time.IllegalFieldValueException:  Cannot  parse   "2  29 ":  Value  29  for  dayOfMonth  must  be  in  the  range  [1  testParseInto_monthDay_feb29_newYork_startOfYear	191	2	add
3	[BUG]  [BUGGY]  long  instantLocal  =  instantMillis  /  position  -  chrono.getZone().getOffset(instantMillis);  [timeout]  [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();    [BUGGY]  long  instantLocal  =  instantMillis  /  position  -  chrono.getZone().getOffset(instantMillis);  [BUGGY]    chrono  =  selectChronology(chrono);  int  defaultYear  =  chrono.year().get(instantLocal);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  defaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	708	708	2	replace	long  instantLocal  =  instantMillis  /  position  -  chrono.getZone().getOffset(instantMillis);	  long    instantLocal    =    instantMillis    /    chrono.getZone().getOffset(instantMillis);    [timeout]    [CONTEXT]    public    int    parseInto(ReadWritableInstant    instant,    String    text,    int    position)    {    DateTimeParser    parser    =    requireParser();    if    (instant    ==    null)    {    throw    new    IllegalArgumentException(   "Instant    must    not    be    null   ");    }    long    instantMillis    =    instant.getMillis();    Chronology    chrono    =    instant.getChronology();    	non-compiled	[timeout]	172	None	replace
4	[BUG]  [BUGGY]  long  instantLocal  =  instantMillis  /  chrono.getZone().setOffset(instantMillis);  [timeout]  [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();    [BUGGY]  long  instantLocal  =  instantMillis  /  chrono.getZone().setOffset(instantMillis);  [BUGGY]    chrono  =  selectChronology(chrono);  int  defaultYear  =  chrono.year().get(instantLocal);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  defaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	708	708	2	replace	long  instantLocal  =  instantMillis  /  chrono.getZone().setOffset(instantMillis);	  long    instantLocal    =    instantMillis    /    chrono.getZone().getOffset(instantMillis);    [timeout]    [CONTEXT]    public    int    parseInto(ReadWritableInstant    instant,    String    text,    int    position)    {    DateTimeParser    parser    =    requireParser();    if    (instant    ==    null)    {    throw    new    IllegalArgumentException(   "Instant    must    not    be    null   ");    }    long    instantMillis    =    instant.getMillis();    Chronology    chrono    =    instant.getChronology();    	non-compiled	[timeout]	172	None	replace
151	[BUG]  [BUGGY]  [FE]  org.joda.time.IllegalFieldValueException:  Cannot  parse   "2  29 ":  Value  29  for  dayOfMonth  must  be  in  the  range  [1  testParseInto_monthDay_feb29_newYork_startOfYear  [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]      int  pivotYear  =  chrono.year().get(instantLocal);  int  year  =  chrono.year().get(instantLocal);  [BUGGY]    int  defaultYear  =  chrono.year().get(instantLocal);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  defaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	710	710	2	add	        int    pivotYear    =    chrono.year().get(instantLocal);    int  year  =  chrono.year().get(instantLocal);	  	compilable	  [FE]  org.joda.time.IllegalFieldValueException:  Cannot  parse   "2  29 ":  Value  29  for  dayOfMonth  must  be  in  the  range  [1  testParseInto_monthDay_feb29_newYork_startOfYear	321	2	add
152	[BUG]  [BUGGY]      int  pivotYear  =  chrono.year().get(instantLocal);  int  year  =  chrono.year().get(instantLocal);  [FE]  org.joda.time.IllegalFieldValueException:  Cannot  parse   "2  29 ":  Value  29  for  dayOfMonth  must  be  in  the  range  [1  testParseInto_monthDay_feb29_newYork_startOfYear  [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]      int  pivotYear  =  chrono.year().get(instantLocal);  int  year  =  chrono.year().get(instantLocal);  [BUGGY]    int  defaultYear  =  chrono.year().get(instantLocal);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  defaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	710	710	2	replace	        int    pivotYear    =    chrono.year().get(instantLocal);    int  year  =  chrono.year().get(instantLocal);	  	compilable	  [FE]  org.joda.time.IllegalFieldValueException:  Cannot  parse   "2  29 ":  Value  29  for  dayOfMonth  must  be  in  the  range  [1  testParseInto_monthDay_feb29_newYork_startOfYear	321	2	add
