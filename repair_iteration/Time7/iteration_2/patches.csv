bugid	buggy	buggy_class	suspiciousness	buggy_line	endbuggycode	original_failing_test_number	action	patch	original_buggy	execution_result	diagnosis	previous_bug_id	new_failing_test_number	this_action1	[BUG]  [BUGGY]          chrono    =    selectChronology(chrono);    chrono  =  selectChronology(chrono);  if(iParser!=  null)  {  throw  new  IllegalArgumentException( " ");  }  [timeout]  [CONTEXT]      public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(     "Instant  must  not  be  null     ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();      [BUGGY]          chrono    =    selectChronology(chrono);    chrono  =  selectChronology(chrono);  if(iParser!=  null)  {  throw  new  IllegalArgumentException( " ");  }  [BUGGY]      long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  int  defaultYear  =  chrono.year().get(instantLocal);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  defaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	708	708	2	replace	                chrono        =        selectChronology(chrono);        chrono    =    selectChronology(chrono);    if(iParser!=  null)  {  throw  new  IllegalArgumentException( " ");  }	  	non-compiled	[timeout]	211	None	add
2	[BUG]  [BUGGY]          chrono    =    selectChronology(chrono);    chrono  =  selectChronology(chrono);  if(instantMillis  >=  0)  {  throw  new  IllegalArgumentException( " ");  }  [timeout]  [CONTEXT]      public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(     "Instant  must  not  be  null     ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();      [BUGGY]          chrono    =    selectChronology(chrono);    chrono  =  selectChronology(chrono);  if(instantMillis  >=  0)  {  throw  new  IllegalArgumentException( " ");  }  [BUGGY]      long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  int  defaultYear  =  chrono.year().get(instantLocal);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  defaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	708	708	2	replace	                chrono        =        selectChronology(chrono);        chrono    =    selectChronology(chrono);    if(instantMillis  >=  0)  {  throw  new  IllegalArgumentException( " ");  }	  	non-compiled	[timeout]	211	None	add
23	[BUG]  [BUGGY]  instantLocal  =  instantMillis  /  chrono.getZone().getOffset(instantMillis);  [timeout]  [CONTEXT]      public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(     "Instant  must  not  be  null     ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);      [BUGGY]  instantLocal  =  instantMillis  /  chrono.getZone().getOffset(instantMillis);  [BUGGY]      chrono  =  selectChronology(chrono);  int  defaultYear  =  chrono.year().get(instantLocal);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  defaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	709	709	2	replace	instantLocal  =  instantMillis  /  chrono.getZone().getOffset(instantMillis);	  instantLocal    =    instantLocal    +    chrono.getZone().getOffset(instantMillis);    [timeout]    [CONTEXT]        public    int    parseInto(ReadWritableInstant    instant,    String    text,    int    position)    {    DateTimeParser    parser    =    requireParser();    if    (instant    ==    null)    {    throw    new    IllegalArgumentException(       "Instant    must    not    be    null       ");    }    long    instantMillis    =    instant.getMillis();    Chronology    chrono    =    instant.getChronology();    long    instantLocal    =    instantMillis    +    chrono.getZone().getOffset(instantMillis);        	non-compiled	[timeout]	114	None	replace
24	[BUG]  [BUGGY]  instantLocal  =  instantMillis  +  iChrono.getZone().getOffset(instantMillis);  [timeout]  [CONTEXT]      public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(     "Instant  must  not  be  null     ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);      [BUGGY]  instantLocal  =  instantMillis  +  iChrono.getZone().getOffset(instantMillis);  [BUGGY]      chrono  =  selectChronology(chrono);  int  defaultYear  =  chrono.year().get(instantLocal);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  defaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	709	709	2	replace	instantLocal  =  instantMillis  +  iChrono.getZone().getOffset(instantMillis);	  instantLocal    =    instantLocal    +    chrono.getZone().getOffset(instantMillis);    [timeout]    [CONTEXT]        public    int    parseInto(ReadWritableInstant    instant,    String    text,    int    position)    {    DateTimeParser    parser    =    requireParser();    if    (instant    ==    null)    {    throw    new    IllegalArgumentException(       "Instant    must    not    be    null       ");    }    long    instantMillis    =    instant.getMillis();    Chronology    chrono    =    instant.getChronology();    long    instantLocal    =    instantMillis    +    chrono.getZone().getOffset(instantMillis);        	non-compiled	[timeout]	114	None	replace
42	[BUG]  [BUGGY]  if(parser  ==  null  ||  instant.getMillis()  <  text.length())  {  [timeout]  [CONTEXT]      public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();      [BUGGY]  if(parser  ==  null  ||  instant.getMillis()  <  text.length())  {  [BUGGY]      throw  new  IllegalArgumentException(     "Instant  must  not  be  null     ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  int  defaultYear  =  chrono.year().get(instantLocal);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	702	702	2	replace	if(parser  ==  null  ||  instant.getMillis()  <  text.length())  {	  if(instant    ==    null    ||    instant.getMillis()    <    text.length())    {    [timeout]    [CONTEXT]        public    int    parseInto(ReadWritableInstant    instant,    String    text,    int    position)    {    DateTimeParser    parser    =    requireParser();        	non-compiled	[timeout]	242	None	replace
43	[BUG]  [BUGGY]  if(instant!=  null  ||  instant.getMillis()  <  text.length())  {  [timeout]  [CONTEXT]      public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();      [BUGGY]  if(instant!=  null  ||  instant.getMillis()  <  text.length())  {  [BUGGY]      throw  new  IllegalArgumentException(     "Instant  must  not  be  null     ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  int  defaultYear  =  chrono.year().get(instantLocal);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	702	702	2	replace	if(instant!=  null  ||  instant.getMillis()  <  text.length())  {	  if(instant    ==    null    ||    instant.getMillis()    <    text.length())    {    [timeout]    [CONTEXT]        public    int    parseInto(ReadWritableInstant    instant,    String    text,    int    position)    {    DateTimeParser    parser    =    requireParser();        	non-compiled	[timeout]	242	None	replace
73	[BUG]  [BUGGY]  if(instant  ==  null  ||  instant.getMillis()  <=  text.length())  {  [timeout]  [CONTEXT]      public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();      [BUGGY]  if(instant  ==  null  ||  instant.getMillis()  <=  text.length())  {  [BUGGY]      throw  new  IllegalArgumentException(     "Instant  must  not  be  null     ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  int  defaultYear  =  chrono.year().get(instantLocal);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	702	702	2	replace	if(instant  ==  null  ||  instant.getMillis()  <=  text.length())  {	  if(instant    ==    null    ||    instant.getMillis()    ==    text.length())    {    	non-compiled	[timeout]	383	None	replace
121	[BUG]  [BUGGY]  long  instantMillis  =  instant.getMillis()  /  position  +  1;  [timeout]  [CONTEXT]      public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(     "Instant  must  not  be  null     ");  }      [BUGGY]  long  instantMillis  =  instant.getMillis()  /  position  +  1;  [BUGGY]      Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  int  defaultYear  =  chrono.year().get(instantLocal);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  defaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	706	706	2	replace	long  instantMillis  =  instant.getMillis()  /  position  +  1;	  long    instantMillis    =    instant.getMillis()    /    position;    [timeout]    [CONTEXT]        public    int    parseInto(ReadWritableInstant    instant,    String    text,    int    position)    {    DateTimeParser    parser    =    requireParser();    if    (instant    ==    null)    {    throw    new    IllegalArgumentException(       "Instant    must    not    be    null       ");    }        	non-compiled	[timeout]	302	None	replace
122	[BUG]  [BUGGY]  long  instantMillis  =  instant.getMillis()  /  text;  [timeout]  [CONTEXT]      public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(     "Instant  must  not  be  null     ");  }      [BUGGY]  long  instantMillis  =  instant.getMillis()  /  text;  [BUGGY]      Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  int  defaultYear  =  chrono.year().get(instantLocal);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  defaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	706	706	2	replace	long  instantMillis  =  instant.getMillis()  /  text;	  long    instantMillis    =    instant.getMillis()    /    position;    [timeout]    [CONTEXT]        public    int    parseInto(ReadWritableInstant    instant,    String    text,    int    position)    {    DateTimeParser    parser    =    requireParser();    if    (instant    ==    null)    {    throw    new    IllegalArgumentException(       "Instant    must    not    be    null       ");    }        	non-compiled	[timeout]	302	None	replace
214	[BUG]  [BUGGY]  if(parser!=  null  ||  instant.getMillis()!=  text.length())  {  [timeout]  [CONTEXT]      public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();      [BUGGY]  if(parser!=  null  ||  instant.getMillis()!=  text.length())  {  [BUGGY]      throw  new  IllegalArgumentException(     "Instant  must  not  be  null     ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  int  defaultYear  =  chrono.year().get(instantLocal);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	702	702	2	replace	if(parser!=  null  ||  instant.getMillis()!=  text.length())  {	  if(parser    ==    null    ||    instant.getMillis()!=    text.length())    {    [timeout]    [CONTEXT]        public    int    parseInto(ReadWritableInstant    instant,    String    text,    int    position)    {    DateTimeParser    parser    =    requireParser();        	non-compiled	[timeout]	243	None	replace
223	[BUG]  [BUGGY]  instantLocal  =  instantLocal  /  chrono.getZone().getOffset(instantLocal);  [timeout]  [CONTEXT]      public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(     "Instant  must  not  be  null     ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);      [BUGGY]  instantLocal  =  instantLocal  /  chrono.getZone().getOffset(instantLocal);  [BUGGY]      chrono  =  selectChronology(chrono);  int  defaultYear  =  chrono.year().get(instantLocal);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  defaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	709	709	2	replace	instantLocal  =  instantLocal  /  chrono.getZone().getOffset(instantLocal);	  instantLocal    =    instantMillis    /    chrono.getZone().getOffset(instantLocal);    [timeout]    [CONTEXT]        public    int    parseInto(ReadWritableInstant    instant,    String    text,    int    position)    {    DateTimeParser    parser    =    requireParser();    if    (instant    ==    null)    {    throw    new    IllegalArgumentException(       "Instant    must    not    be    null       ");    }    long    instantMillis    =    instant.getMillis();    Chronology    chrono    =    instant.getChronology();    long    instantLocal    =    instantMillis    +    chrono.getZone().getOffset(instantMillis);        	non-compiled	[timeout]	112	None	replace
224	[BUG]  [BUGGY]  instantLocal  =  instantLocal  /  chrono.getZone().getOffset(instantMillis);  [timeout]  [CONTEXT]      public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(     "Instant  must  not  be  null     ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);      [BUGGY]  instantLocal  =  instantLocal  /  chrono.getZone().getOffset(instantMillis);  [BUGGY]      chrono  =  selectChronology(chrono);  int  defaultYear  =  chrono.year().get(instantLocal);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  defaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	709	709	2	replace	instantLocal  =  instantLocal  /  chrono.getZone().getOffset(instantMillis);	  instantLocal    =    instantMillis    /    chrono.getZone().getOffset(instantLocal);    [timeout]    [CONTEXT]        public    int    parseInto(ReadWritableInstant    instant,    String    text,    int    position)    {    DateTimeParser    parser    =    requireParser();    if    (instant    ==    null)    {    throw    new    IllegalArgumentException(       "Instant    must    not    be    null       ");    }    long    instantMillis    =    instant.getMillis();    Chronology    chrono    =    instant.getChronology();    long    instantLocal    =    instantMillis    +    chrono.getZone().getOffset(instantMillis);        	non-compiled	[timeout]	112	None	replace
304	[BUG]  [BUGGY]  long  instantMillis  =  instant.getMillis()  /  position  *  2;  [timeout]  [CONTEXT]      public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(     "Instant  must  not  be  null     ");  }      [BUGGY]  long  instantMillis  =  instant.getMillis()  /  position  *  2;  [BUGGY]      Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  int  defaultYear  =  chrono.year().get(instantLocal);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  defaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	706	706	2	replace	long  instantMillis  =  instant.getMillis()  /  position  *  2;	  long    instantMillis    =    instant.getMillis()    /    position;    [timeout]    [CONTEXT]        public    int    parseInto(ReadWritableInstant    instant,    String    text,    int    position)    {    DateTimeParser    parser    =    requireParser();    if    (instant    ==    null)    {    throw    new    IllegalArgumentException(       "Instant    must    not    be    null       ");    }        	non-compiled	[timeout]	302	None	replace
363	[BUG]  [BUGGY]  long  instantLocal  =  instantMillis  /  position  *  chrono.getZone().getOffset(instantMillis);  [timeout]  [CONTEXT]      public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(     "Instant  must  not  be  null     ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();      [BUGGY]  long  instantLocal  =  instantMillis  /  position  *  chrono.getZone().getOffset(instantMillis);  [BUGGY]      chrono  =  selectChronology(chrono);  int  defaultYear  =  chrono.year().get(instantLocal);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  defaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	708	708	2	replace	long  instantLocal  =  instantMillis  /  position  *  chrono.getZone().getOffset(instantMillis);	  long    instantLocal    =    instantMillis    /    position    -    chrono.getZone().getOffset(instantMillis);    [timeout]    [CONTEXT]        public    int    parseInto(ReadWritableInstant    instant,    String    text,    int    position)    {    DateTimeParser    parser    =    requireParser();    if    (instant    ==    null)    {    throw    new    IllegalArgumentException(       "Instant    must    not    be    null       ");    }    long    instantMillis    =    instant.getMillis();    Chronology    chrono    =    instant.getChronology();        	non-compiled	[timeout]	3	None	replace
364	[BUG]  [BUGGY]  long  instantLocal  =  instantMillis  /  position  -  chrono.getZone().getOffset(instantMillis,  chrono);  [timeout]  [CONTEXT]      public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(     "Instant  must  not  be  null     ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();      [BUGGY]  long  instantLocal  =  instantMillis  /  position  -  chrono.getZone().getOffset(instantMillis,  chrono);  [BUGGY]      chrono  =  selectChronology(chrono);  int  defaultYear  =  chrono.year().get(instantLocal);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  defaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	708	708	2	replace	long  instantLocal  =  instantMillis  /  position  -  chrono.getZone().getOffset(instantMillis,  chrono);	  long    instantLocal    =    instantMillis    /    position    -    chrono.getZone().getOffset(instantMillis);    [timeout]    [CONTEXT]        public    int    parseInto(ReadWritableInstant    instant,    String    text,    int    position)    {    DateTimeParser    parser    =    requireParser();    if    (instant    ==    null)    {    throw    new    IllegalArgumentException(       "Instant    must    not    be    null       ");    }    long    instantMillis    =    instant.getMillis();    Chronology    chrono    =    instant.getChronology();        	non-compiled	[timeout]	3	None	replace
403	[BUG]  [BUGGY]  long  instantMillis  =  instant.getMillis()  *  position  -  1;  [timeout]  [CONTEXT]      public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(     "Instant  must  not  be  null     ");  }      [BUGGY]  long  instantMillis  =  instant.getMillis()  *  position  -  1;  [BUGGY]      Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  int  defaultYear  =  chrono.year().get(instantLocal);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  defaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	706	706	2	replace	long  instantMillis  =  instant.getMillis()  *  position  -  1;	  long    instantMillis    =    instant.getMillis()    *    position;    [timeout]    [CONTEXT]        public    int    parseInto(ReadWritableInstant    instant,    String    text,    int    position)    {    DateTimeParser    parser    =    requireParser();    if    (instant    ==    null)    {    throw    new    IllegalArgumentException(       "Instant    must    not    be    null       ");    }        	non-compiled	[timeout]	303	None	replace
441	[BUG]  [BUGGY]  [FE]  org.joda.time.IllegalFieldValueException:  Cannot  parse   "2  29 ":  Value  29  for  dayOfMonth  must  be  in  the  range  [1  testParseInto_monthDay_feb29_newYork_startOfYear  [CONTEXT]      public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(     "Instant  must  not  be  null     ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();      [BUGGY]          chrono    =    selectChronology(chrono);    chrono  =  selectChronology(chrono);  chrono  =  selectChronology(chrono);  [BUGGY]      long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  int  defaultYear  =  chrono.year().get(instantLocal);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  defaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	708	708	2	add	                chrono        =        selectChronology(chrono);        chrono    =    selectChronology(chrono);    chrono  =  selectChronology(chrono);	  	compilable	  [FE]  org.joda.time.IllegalFieldValueException:  Cannot  parse   "2  29 ":  Value  29  for  dayOfMonth  must  be  in  the  range  [1  testParseInto_monthDay_feb29_newYork_startOfYear	211	2	add
442	[BUG]  [BUGGY]          chrono    =    selectChronology(chrono);    chrono  =  selectChronology(chrono);  chrono  =  selectChronology(chrono);  [FE]  org.joda.time.IllegalFieldValueException:  Cannot  parse   "2  29 ":  Value  29  for  dayOfMonth  must  be  in  the  range  [1  testParseInto_monthDay_feb29_newYork_startOfYear  [CONTEXT]      public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(     "Instant  must  not  be  null     ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();      [BUGGY]          chrono    =    selectChronology(chrono);    chrono  =  selectChronology(chrono);  chrono  =  selectChronology(chrono);  [BUGGY]      long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  int  defaultYear  =  chrono.year().get(instantLocal);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  defaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	708	708	2	replace	                chrono        =        selectChronology(chrono);        chrono    =    selectChronology(chrono);    chrono  =  selectChronology(chrono);	  	compilable	  [FE]  org.joda.time.IllegalFieldValueException:  Cannot  parse   "2  29 ":  Value  29  for  dayOfMonth  must  be  in  the  range  [1  testParseInto_monthDay_feb29_newYork_startOfYear	211	2	add
1	[BUG]  [BUGGY]  [FE]  org.joda.time.IllegalFieldValueException:  Cannot  parse   "2  29 ":  Value  29  for  dayOfMonth  must  be  in  the  range  [1  testParseInto_monthDay_feb29_newYork_startOfYear  [CONTEXT]      public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(     "Instant  must  not  be  null     ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);      [BUGGY]          int    year    =    chrono.year().get(instantLocal);    int  month  =  chrono.monthOfYear().get(instantLocal);  int  dayOfMonth  =  chrono.dayOfMonth().get(instantLocal);  [BUGGY]      int  defaultYear  =  chrono.year().get(instantLocal);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  defaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	710	710	2	add	                int        year        =        chrono.year().get(instantLocal);        int    month    =    chrono.monthOfYear().get(instantLocal);    int  dayOfMonth  =  chrono.dayOfMonth().get(instantLocal);	  	compilable	  [FE]  org.joda.time.IllegalFieldValueException:  Cannot  parse   "2  29 ":  Value  29  for  dayOfMonth  must  be  in  the  range  [1  testParseInto_monthDay_feb29_newYork_startOfYear	162	2	add
2	[BUG]  [BUGGY]          int    year    =    chrono.year().get(instantLocal);    int  month  =  chrono.monthOfYear().get(instantLocal);  int  dayOfMonth  =  chrono.dayOfMonth().get(instantLocal);  [FE]  org.joda.time.IllegalFieldValueException:  Cannot  parse   "2  29 ":  Value  29  for  dayOfMonth  must  be  in  the  range  [1  testParseInto_monthDay_feb29_newYork_startOfYear  [CONTEXT]      public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(     "Instant  must  not  be  null     ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);      [BUGGY]          int    year    =    chrono.year().get(instantLocal);    int  month  =  chrono.monthOfYear().get(instantLocal);  int  dayOfMonth  =  chrono.dayOfMonth().get(instantLocal);  [BUGGY]      int  defaultYear  =  chrono.year().get(instantLocal);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  defaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	710	710	2	replace	                int        year        =        chrono.year().get(instantLocal);        int    month    =    chrono.monthOfYear().get(instantLocal);    int  dayOfMonth  =  chrono.dayOfMonth().get(instantLocal);	  	compilable	  [FE]  org.joda.time.IllegalFieldValueException:  Cannot  parse   "2  29 ":  Value  29  for  dayOfMonth  must  be  in  the  range  [1  testParseInto_monthDay_feb29_newYork_startOfYear	162	2	add
2	[BUG]  [BUGGY]  [FE]  org.joda.time.IllegalFieldValueException:  Cannot  parse   "2  29 ":  Value  29  for  dayOfMonth  must  be  in  the  range  [1  testParseInto_monthDay_feb29_newYork_startOfYear  [CONTEXT]      public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(     "Instant  must  not  be  null     ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);      [BUGGY]          int    year    =    chrono.year().get(instantLocal);    int  month  =  chrono.monthOfYear().get(instantLocal);  int  day  =  chrono.dayOfMonth().get(instantLocal);  [BUGGY]      int  defaultYear  =  chrono.year().get(instantLocal);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  defaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	710	710	2	add	                int        year        =        chrono.year().get(instantLocal);        int    month    =    chrono.monthOfYear().get(instantLocal);    int  day  =  chrono.dayOfMonth().get(instantLocal);	  	compilable	  [FE]  org.joda.time.IllegalFieldValueException:  Cannot  parse   "2  29 ":  Value  29  for  dayOfMonth  must  be  in  the  range  [1  testParseInto_monthDay_feb29_newYork_startOfYear	162	2	add
3	[BUG]  [BUGGY]          int    year    =    chrono.year().get(instantLocal);    int  month  =  chrono.monthOfYear().get(instantLocal);  int  day  =  chrono.dayOfMonth().get(instantLocal);  [FE]  org.joda.time.IllegalFieldValueException:  Cannot  parse   "2  29 ":  Value  29  for  dayOfMonth  must  be  in  the  range  [1  testParseInto_monthDay_feb29_newYork_startOfYear  [CONTEXT]      public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(     "Instant  must  not  be  null     ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);      [BUGGY]          int    year    =    chrono.year().get(instantLocal);    int  month  =  chrono.monthOfYear().get(instantLocal);  int  day  =  chrono.dayOfMonth().get(instantLocal);  [BUGGY]      int  defaultYear  =  chrono.year().get(instantLocal);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  defaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	710	710	2	replace	                int        year        =        chrono.year().get(instantLocal);        int    month    =    chrono.monthOfYear().get(instantLocal);    int  day  =  chrono.dayOfMonth().get(instantLocal);	  	compilable	  [FE]  org.joda.time.IllegalFieldValueException:  Cannot  parse   "2  29 ":  Value  29  for  dayOfMonth  must  be  in  the  range  [1  testParseInto_monthDay_feb29_newYork_startOfYear	162	2	add
542	[BUG]  [BUGGY]  long  instantLocal  =  instantMillis  /  position  -  chrono.getZone().getOffsetFromLocal(instantMillis);  [timeout]  [CONTEXT]      public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(     "Instant  must  not  be  null     ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();      [BUGGY]  long  instantLocal  =  instantMillis  /  position  -  chrono.getZone().getOffsetFromLocal(instantMillis);  [BUGGY]      chrono  =  selectChronology(chrono);  int  defaultYear  =  chrono.year().get(instantLocal);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  defaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	708	708	2	replace	long  instantLocal  =  instantMillis  /  position  -  chrono.getZone().getOffsetFromLocal(instantMillis);	  long    instantLocal    =    instantMillis    /    position    -    chrono.getZone().getOffset(instantMillis);    [timeout]    [CONTEXT]        public    int    parseInto(ReadWritableInstant    instant,    String    text,    int    position)    {    DateTimeParser    parser    =    requireParser();    if    (instant    ==    null)    {    throw    new    IllegalArgumentException(       "Instant    must    not    be    null       ");    }    long    instantMillis    =    instant.getMillis();    Chronology    chrono    =    instant.getChronology();        	non-compiled	[timeout]	3	None	replace
662	[BUG]  [BUGGY]  if(instant.getMillis()!=  text.length())  {  [timeout]  [CONTEXT]      public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();      [BUGGY]  if(instant.getMillis()!=  text.length())  {  [BUGGY]      throw  new  IllegalArgumentException(     "Instant  must  not  be  null     ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  int  defaultYear  =  chrono.year().get(instantLocal);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	702	702	2	replace	if(instant.getMillis()!=  text.length())  {	  if(parser    ==    null    ||    instant.getMillis()!=    text.length())    {    [timeout]    [CONTEXT]        public    int    parseInto(ReadWritableInstant    instant,    String    text,    int    position)    {    DateTimeParser    parser    =    requireParser();        	non-compiled	[timeout]	243	None	replace
663	[BUG]  [BUGGY]  if(instant!=  null  ||  instant.getMillis()!=  text.length())  {  [timeout]  [CONTEXT]      public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();      [BUGGY]  if(instant!=  null  ||  instant.getMillis()!=  text.length())  {  [BUGGY]      throw  new  IllegalArgumentException(     "Instant  must  not  be  null     ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  int  defaultYear  =  chrono.year().get(instantLocal);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time7/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.2886751345948129	702	702	2	replace	if(instant!=  null  ||  instant.getMillis()!=  text.length())  {	  if(parser    ==    null    ||    instant.getMillis()!=    text.length())    {    [timeout]    [CONTEXT]        public    int    parseInto(ReadWritableInstant    instant,    String    text,    int    position)    {    DateTimeParser    parser    =    requireParser();        	non-compiled	[timeout]	243	None	replace
