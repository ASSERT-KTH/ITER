bugid	buggy	buggy_class	suspiciousness	buggy_line	endbuggycode	original_failing_test_number	action	patch	original_buggy	execution_result	diagnosis	previous_bug_id	new_failing_test_number	this_action
1	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "java.util.ArrayBuilders   ");  Node  emptyStringNode  =  Node.newString( "java.util.ArrayBuilders   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "java.util.ArrayBuilders   ");  Node  emptyStringNode  =  Node.newString( "java.util.ArrayBuilders   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "java.util.ArrayBuilders   ");    Node  emptyStringNode  =  Node.newString( "java.util.ArrayBuilders   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	169	None	add
2	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "java.util.ArrayBuilders   ");  Node  emptyStringNode  =  Node.newString( ".java.util.ArrayBuilders   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]      AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "java.util.ArrayBuilders   ");  Node  emptyStringNode  =  Node.newString( ".java.util.ArrayBuilders   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "java.util.ArrayBuilders   ");    Node  emptyStringNode  =  Node.newString( ".java.util.ArrayBuilders   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	169	None	add
3	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "java.util.ArrayBuilders   ");  Node  emptyStringNode  =  Node.newString( ",java.util.ArrayBuilders   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]        AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "java.util.ArrayBuilders   ");  Node  emptyStringNode  =  Node.newString( ",java.util.ArrayBuilders   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "java.util.ArrayBuilders   ");    Node  emptyStringNode  =  Node.newString( ",java.util.ArrayBuilders   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	169	None	add
4	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "java.util.ArrayBuilders   ");  Node  emptyStringNode  =  Node.newString( "java.util.ArrayBuilders ",);  [CE]  illegal  start  of  expression  [FE]          AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "java.util.ArrayBuilders   ");  Node  emptyStringNode  =  Node.newString( "java.util.ArrayBuilders ",);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "java.util.ArrayBuilders   ");    Node  emptyStringNode  =  Node.newString( "java.util.ArrayBuilders ",);	  	non-compiled	[CE]  illegal  start  of  expression	169	None	add
5	[BUG]  [BUGGY]  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]              AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ".[ ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( ".[ ");	  Node    emptyStringNode    =    Node.newString(       "[       ");    Node    emptyStringNode    =    Node.newString(.   "[       ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	98	3	replace
6	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( ".[ ");  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]              AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ".[ ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( ".[ ");	  Node    emptyStringNode    =    Node.newString(       "[       ");    Node    emptyStringNode    =    Node.newString(.   "[       ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	98	3	replace
7	[BUG]  [BUGGY]  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]              AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ",- ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( ",- ");	  Node    emptyStringNode    =    Node.newString(       "-       ");    Node    emptyStringNode    =    Node.newString(   ",-       ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	114	3	replace
8	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( ",- ");  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]              AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ",- ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( ",- ");	  Node    emptyStringNode    =    Node.newString(       "-       ");    Node    emptyStringNode    =    Node.newString(   ",-       ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	114	3	replace
9	[BUG]  [BUGGY]  [FE]  junit.framework.AssertionFailedError:  Expected:  x= " "  Result:  x= "  [FE]                AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ", ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( ", ");	  Node    emptyStringNode    =    Node.newString(       "-       ");    Node    emptyStringNode    =    Node.newString(   ",-       ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x= " "  Result:  x= "  	114	3	replace
10	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( ", ");  [FE]  junit.framework.AssertionFailedError:  Expected:  x= " "  Result:  x= "  [FE]                AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ", ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( ", ");	  Node    emptyStringNode    =    Node.newString(       "-       ");    Node    emptyStringNode    =    Node.newString(   ",-       ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x= " "  Result:  x= "  	114	3	replace
11	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( ",- ",  foldedSize);  [CE]  no  suitable  method  found  for  newString(String,int)  [FE]                  AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ",- ",  foldedSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( ",- ",  foldedSize);	  Node    emptyStringNode    =    Node.newString(       "-       ");    Node    emptyStringNode    =    Node.newString(   ",-       ");    	non-compiled	[CE]  no  suitable  method  found  for  newString(String,int)	114	None	replace
12	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "- ",  originalSize);  [CE]  no  suitable  method  found  for  newString(String,int)  [FE]                    AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "- ",  originalSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "- ",  originalSize);	  Node    emptyStringNode    =    Node.newString(       "-       ");    Node    emptyStringNode    =    Node.newString(   ",-       ");    	non-compiled	[CE]  no  suitable  method  found  for  newString(String,int)	114	None	replace
13	[BUG]  [BUGGY]  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]                      AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ";- ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( ";- ");	  Node    emptyStringNode    =    Node.newString(       "-       ");    Node    emptyStringNode    =    Node.newString(   ",-       ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	114	3	replace
14	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( ";- ");  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]                      AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ";- ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( ";- ");	  Node    emptyStringNode    =    Node.newString(       "-       ");    Node    emptyStringNode    =    Node.newString(   ",-       ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	114	3	replace
15	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "n ",  originalSize);  [CE]  no  suitable  method  found  for  newString(String,int)  [FE]                        AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "n ",  originalSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "n ",  originalSize);	  Node    emptyStringNode    =    Node.newString(       "-       ");    Node    emptyStringNode    =    Node.newString(   ",-       ");    	non-compiled	[CE]  no  suitable  method  found  for  newString(String,int)	114	None	replace
16	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList( "  +  originalSize  + "),  arrayFoldedChildren);  [CE]  unclosed  string  literal  [FE]          junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList( "  +  originalSize  + "),  arrayFoldedChildren);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList( "  +  originalSize  + "),  arrayFoldedChildren);	  Node    emptyStringNode    =    Node.newString(   "java.util.Arrays.asList(   "),    arrayFoldedChildren);    	non-compiled	[CE]  unclosed  string  literal	152	None	replace
17	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "Arrays.asList( "  +  originalSize  + "),  arrayFoldedChildren);  [CE]  unclosed  string  literal  [FE]            junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "Arrays.asList( "  +  originalSize  + "),  arrayFoldedChildren);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "Arrays.asList( "  +  originalSize  + "),  arrayFoldedChildren);	  Node    emptyStringNode    =    Node.newString(   "java.util.Arrays.asList(   "),    arrayFoldedChildren);    	non-compiled	[CE]  unclosed  string  literal	152	None	replace
18	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList( "  +  x  + "),  arrayFoldedChildren);  [CE]  unclosed  string  literal  [FE]              junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList( "  +  x  + "),  arrayFoldedChildren);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList( "  +  x  + "),  arrayFoldedChildren);	  Node    emptyStringNode    =    Node.newString(   "java.util.Arrays.asList(   "),    arrayFoldedChildren);    	non-compiled	[CE]  unclosed  string  literal	152	None	replace
19	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList( ",  arrayFoldedChildren.size()  -  1));  [CE]  [FE]                junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList( ",  arrayFoldedChildren.size()  -  1));  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList( ",  arrayFoldedChildren.size()  -  1));	  Node    emptyStringNode    =    Node.newString(   "java.util.Arrays.asList(   "),    arrayFoldedChildren);    	non-compiled	[CE]  	152	None	replace
20	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList( "  +  arrayFoldedChildren.size()  +  1));  [CE]  [FE]                  junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList( "  +  arrayFoldedChildren.size()  +  1));  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList( "  +  arrayFoldedChildren.size()  +  1));	  Node    emptyStringNode    =    Node.newString(   "java.util.Arrays.asList(   "),    arrayFoldedChildren);    	non-compiled	[CE]  	152	None	replace
21	[BUG]  [BUGGY]  Node  emptyStringNode  =  arrayFoldedChildren.getLastChild();  [CE]  cannot  find  symbol  [FE]                          junit.framework.AssertionFailedError:  Expected:  x=[     "a     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  arrayFoldedChildren.getLastChild();  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  arrayFoldedChildren.getLastChild();	  Node    emptyStringNode    =    arrayFoldedChildren.getFirstChild();    	non-compiled	[CE]  cannot  find  symbol	147	None	replace
22	[BUG]  [BUGGY]  Node  emptyStringNode  =  arrayFoldedChildren,  n.getFirstChild();  [CE]  ';'  expected  [FE]                            junit.framework.AssertionFailedError:  Expected:  x=[     "a     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  arrayFoldedChildren,  n.getFirstChild();  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  arrayFoldedChildren,  n.getFirstChild();	  Node    emptyStringNode    =    arrayFoldedChildren.getFirstChild();    	non-compiled	[CE]  ';'  expected	147	None	replace
23	[BUG]  [BUGGY]  Node  emptyStringNode  =  arrayFoldedChildren.removeFirstChild();  [CE]  cannot  find  symbol  [FE]                              junit.framework.AssertionFailedError:  Expected:  x=[     "a     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  arrayFoldedChildren.removeFirstChild();  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  arrayFoldedChildren.removeFirstChild();	  Node    emptyStringNode    =    arrayFoldedChildren.getFirstChild();    	non-compiled	[CE]  cannot  find  symbol	147	None	replace
24	[BUG]  [BUGGY]  Node  emptyStringNode  =  arrayFoldedParent.getFirstChild();  [CE]  cannot  find  symbol  arrayFoldedParent  [FE]                                junit.framework.AssertionFailedError:  Expected:  x=[     "a     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  arrayFoldedParent.getFirstChild();  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  arrayFoldedParent.getFirstChild();	  Node    emptyStringNode    =    arrayFoldedChildren.getFirstChild();    	non-compiled	[CE]  cannot  find  symbol  arrayFoldedParent	147	None	replace
25	[BUG]  [BUGGY]  [FE]  junit.framework.AssertionFailedError:  Expected:  x= " "  Result:  x= "  [FE]          AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ",Array ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( ",Array ");	  Node    emptyStringNode    =    Node.newString(       "Array       ");    Node    emptyStringNode    =    Node.newString(   ",Array       ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x= " "  Result:  x= "  	31	3	replace
26	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( ",Array ");  [FE]  junit.framework.AssertionFailedError:  Expected:  x= " "  Result:  x= "  [FE]          AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ",Array ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( ",Array ");	  Node    emptyStringNode    =    Node.newString(       "Array       ");    Node    emptyStringNode    =    Node.newString(   ",Array       ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x= " "  Result:  x= "  	31	3	replace
27	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "Array ",  originalSize);  [CE]  no  suitable  method  found  for  newString(String,int)  [FE]            AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "Array ",  originalSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "Array ",  originalSize);	  Node    emptyStringNode    =    Node.newString(       "Array       ");    Node    emptyStringNode    =    Node.newString(   ",Array       ");    	non-compiled	[CE]  no  suitable  method  found  for  newString(String,int)	31	None	replace
28	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]              AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ";Array ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( ";Array ");	  Node    emptyStringNode    =    Node.newString(       "Array       ");    Node    emptyStringNode    =    Node.newString(   ",Array       ");    	compilable	  [FE]  AssertionFailedError  	31	3	replace
29	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( ";Array ");  [FE]  AssertionFailedError  [FE]              AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ";Array ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( ";Array ");	  Node    emptyStringNode    =    Node.newString(       "Array       ");    Node    emptyStringNode    =    Node.newString(   ",Array       ");    	compilable	  [FE]  AssertionFailedError  	31	3	replace
30	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "Array ",  null);  [CE]  no  suitable  method  found  for  newString(String,<null>)  [FE]                AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "Array ",  null);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "Array ",  null);	  Node    emptyStringNode    =    Node.newString(       "Array       ");    Node    emptyStringNode    =    Node.newString(   ",Array       ");    	non-compiled	[CE]  no  suitable  method  found  for  newString(String,<null>)	31	None	replace
31	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( ",Array ",  foldedSize);  [CE]  no  suitable  method  found  for  newString(String,int)  [FE]                  AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ",Array ",  foldedSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( ",Array ",  foldedSize);	  Node    emptyStringNode    =    Node.newString(       "Array       ");    Node    emptyStringNode    =    Node.newString(   ",Array       ");    	non-compiled	[CE]  no  suitable  method  found  for  newString(String,int)	31	None	replace
32	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "[Array] ",  null);  [CE]  no  suitable  method  found  for  newString(String,<null>)  [FE]                    AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[Array] ",  null);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "[Array] ",  null);	  Node    emptyStringNode    =    Node.newString(       "Array       ");    Node    emptyStringNode    =    Node.newString(   ",Array       ");    	non-compiled	[CE]  no  suitable  method  found  for  newString(String,<null>)	31	None	replace
33	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "- ",  n);  [CE]  no  suitable  method  found  for  newString(String,Node)  [FE]        AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "- ",  n);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "- ",  n);	  Node    emptyStringNode    =    Node.newString(       "-       ");    Node    emptyStringNode    =    Node.newString(   "-       ");    	non-compiled	[CE]  no  suitable  method  found  for  newString(String,Node)	111	None	replace
34	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "- ").replaceChild(n,  foldedStringNode);  [CE]  cannot  find  symbol  foldedStringNode  [FE]          AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "- ").replaceChild(n,  foldedStringNode);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "- ").replaceChild(n,  foldedStringNode);	  Node    emptyStringNode    =    Node.newString(       "-       ");    Node    emptyStringNode    =    Node.newString(   "-       ");    	non-compiled	[CE]  cannot  find  symbol  foldedStringNode	111	None	replace
35	[BUG]  [BUGGY]  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('  [FE]            AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "- ").removeFirstChild();  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "- ").removeFirstChild();	  Node    emptyStringNode    =    Node.newString(       "-       ");    Node    emptyStringNode    =    Node.newString(   "-       ");    	compilable	  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('  	111	3	replace
36	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "- ").removeFirstChild();  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('  [FE]            AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "- ").removeFirstChild();  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "- ").removeFirstChild();	  Node    emptyStringNode    =    Node.newString(       "-       ");    Node    emptyStringNode    =    Node.newString(   "-       ");    	compilable	  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('  	111	3	replace
37	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]            AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "Array. ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "Array. ");	  Node    emptyStringNode    =    Node.newString(       "Array       ");    Node    emptyStringNode    =    Node.newString(   ".Array       ");    	compilable	  [FE]  AssertionFailedError  	32	3	replace
38	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "Array. ");  [FE]  AssertionFailedError  [FE]            AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "Array. ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "Array. ");	  Node    emptyStringNode    =    Node.newString(       "Array       ");    Node    emptyStringNode    =    Node.newString(   ".Array       ");    	compilable	  [FE]  AssertionFailedError  	32	3	replace
39	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "Array ".getBytes());  [CE]  no  suitable  method  found  for  newString(byte[])  [FE]              AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "Array ".getBytes());  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "Array ".getBytes());	  Node    emptyStringNode    =    Node.newString(       "Array       ");    Node    emptyStringNode    =    Node.newString(   ".Array       ");    	non-compiled	[CE]  no  suitable  method  found  for  newString(byte[])	32	None	replace
40	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]                AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[Array] ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "[Array] ");	  Node    emptyStringNode    =    Node.newString(       "Array       ");    Node    emptyStringNode    =    Node.newString(   ".Array       ");    	compilable	  [FE]  AssertionFailedError  	32	3	replace
41	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "[Array] ");  [FE]  AssertionFailedError  [FE]                AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[Array] ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "[Array] ");	  Node    emptyStringNode    =    Node.newString(       "Array       ");    Node    emptyStringNode    =    Node.newString(   ".Array       ");    	compilable	  [FE]  AssertionFailedError  	32	3	replace
42	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "[n   ");  Node  emptyStringNode  =  Node.newString(   "[n   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "[n   ");  Node  emptyStringNode  =  Node.newString(   "[n   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "[n   ");    Node  emptyStringNode  =  Node.newString(   "[n   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	132	None	add
43	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "[n   ");  Node  emptyStringNode  =  Node.newString( ".[n   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]      AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "[n   ");  Node  emptyStringNode  =  Node.newString( ".[n   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "[n   ");    Node  emptyStringNode  =  Node.newString( ".[n   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	132	None	add
44	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "[n   ");  Node  emptyStringNode  =  Node.newString( ",[n   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]        AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "[n   ");  Node  emptyStringNode  =  Node.newString( ",[n   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "[n   ");    Node  emptyStringNode  =  Node.newString( ",[n   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	132	None	add
45	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "[n   ");  Node  emptyStringNode  =  Node.newString(. "[n   ");  [CE]  illegal  start  of  expression  [FE]          AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "[n   ");  Node  emptyStringNode  =  Node.newString(. "[n   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "[n   ");    Node  emptyStringNode  =  Node.newString(. "[n   ");	  	non-compiled	[CE]  illegal  start  of  expression	132	None	add
46	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "[n   ");  Node  emptyStringNode  =  Node.newString(, "[n   ");  [CE]  illegal  start  of  expression  [FE]            AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "[n   ");  Node  emptyStringNode  =  Node.newString(, "[n   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "[n   ");    Node  emptyStringNode  =  Node.newString(, "[n   ");	  	non-compiled	[CE]  illegal  start  of  expression	132	None	add
47	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "[n   ");  Node  emptyStringNode  =  Node.newString( ")[n   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]              AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "[n   ");  Node  emptyStringNode  =  Node.newString( ")[n   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "[n   ");    Node  emptyStringNode  =  Node.newString( ")[n   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	132	None	add
48	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "[]   ");  Node  emptyStringNode  =  Node.newString(   "[]   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "[]   ");  Node  emptyStringNode  =  Node.newString(   "[]   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "[]   ");    Node  emptyStringNode  =  Node.newString(   "[]   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	57	None	add
49	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "[]   ");  Node  emptyStringNode  =  Node.newString( ".[]   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]      AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "[]   ");  Node  emptyStringNode  =  Node.newString( ".[]   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "[]   ");    Node  emptyStringNode  =  Node.newString( ".[]   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	57	None	add
50	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "[]   ");  Node  emptyStringNode  =  Node.newString( ",[]   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]        AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "[]   ");  Node  emptyStringNode  =  Node.newString( ",[]   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "[]   ");    Node  emptyStringNode  =  Node.newString( ",[]   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	57	None	add
51	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "[]   ");  Node  emptyStringNode  =  Node.newString(   "[] "));  [CE]  [FE]          AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "[]   ");  Node  emptyStringNode  =  Node.newString(   "[] "));  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "[]   ");    Node  emptyStringNode  =  Node.newString(   "[] "));	  	non-compiled	[CE]  	57	None	add
52	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "[]   ");  Node  emptyStringNode  =  Node.newString(. "[]   ");  [CE]  illegal  start  of  expression  [FE]            AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "[]   ");  Node  emptyStringNode  =  Node.newString(. "[]   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "[]   ");    Node  emptyStringNode  =  Node.newString(. "[]   ");	  	non-compiled	[CE]  illegal  start  of  expression	57	None	add
53	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(sb.toString()).toString();  [CE]  incompatible  types  [FE]            AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(sb.toString()).toString();  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(sb.toString()).toString();	  Node    emptyStringNode    =    Node.newString(   "]   ").toString();    	non-compiled	[CE]  incompatible  types	60	None	replace
54	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "] ",  sb.toString());  [CE]  no  suitable  method  found  for  newString(String,String)  [FE]              AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "] ",  sb.toString());  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "] ",  sb.toString());	  Node    emptyStringNode    =    Node.newString(   "]   ").toString();    	non-compiled	[CE]  no  suitable  method  found  for  newString(String,String)	60	None	replace
55	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.STRING,  foldedSize).toString();  [CE]  no  suitable  method  found  for  newString(int,int)  [FE]                AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.STRING,  foldedSize).toString();  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(Token.STRING,  foldedSize).toString();	  Node    emptyStringNode    =    Node.newString(   "]   ").toString();    	non-compiled	[CE]  no  suitable  method  found  for  newString(int,int)	60	None	replace
56	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "[] ").toString();  [CE]  incompatible  types  [FE]                  AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[] ").toString();  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "[] ").toString();	  Node    emptyStringNode    =    Node.newString(   "]   ").toString();    	non-compiled	[CE]  incompatible  types	60	None	replace
57	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.STRING,  originalSize).toString();  [CE]  no  suitable  method  found  for  newString(int,int)  [FE]                    AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.STRING,  originalSize).toString();  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(Token.STRING,  originalSize).toString();	  Node    emptyStringNode    =    Node.newString(   "]   ").toString();    	non-compiled	[CE]  no  suitable  method  found  for  newString(int,int)	60	None	replace
58	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "Array "  +  foldedSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "Array "  +  foldedSize);	  Node    emptyStringNode    =    Node.newString(   "Array   "    +    originalSize);    	compilable	  [FE]  AssertionFailedError  	118	3	replace
59	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "Array "  +  foldedSize);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "Array "  +  foldedSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "Array "  +  foldedSize);	  Node    emptyStringNode    =    Node.newString(   "Array   "    +    originalSize);    	compilable	  [FE]  AssertionFailedError  	118	3	replace
60	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "Array "  +  originalSize  +  1);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "Array "  +  originalSize  +  1);	  Node    emptyStringNode    =    Node.newString(   "Array   "    +    originalSize);    	compilable	  [FE]  AssertionFailedError  	118	3	replace
61	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "Array "  +  originalSize  +  1);  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "Array "  +  originalSize  +  1);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "Array "  +  originalSize  +  1);	  Node    emptyStringNode    =    Node.newString(   "Array   "    +    originalSize);    	compilable	  [FE]  AssertionFailedError  	118	3	replace
62	[BUG]  [BUGGY]  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('  [FE]        AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "Array "  +  sb.length());  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "Array "  +  sb.length());	  Node    emptyStringNode    =    Node.newString(   "Array   "    +    originalSize);    	compilable	  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('  	118	3	replace
63	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "Array "  +  sb.length());  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('  [FE]        AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "Array "  +  sb.length());  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "Array "  +  sb.length());	  Node    emptyStringNode    =    Node.newString(   "Array   "    +    originalSize);    	compilable	  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('  	118	3	replace
64	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.EXPR_RESULT,  foldedSize);  [CE]  no  suitable  method  found  for  newString(int,int)  [FE]              junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.EXPR_RESULT,  foldedSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(Token.EXPR_RESULT,  foldedSize);	  Node    emptyStringNode    =    Node.newString(Token.EXPR_RESULT);    	non-compiled	[CE]  no  suitable  method  found  for  newString(int,int)	41	None	replace
65	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.EXPR_RESULT,  x);  [CE]  cannot  find  symbol  x  [FE]                junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.EXPR_RESULT,  x);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(Token.EXPR_RESULT,  x);	  Node    emptyStringNode    =    Node.newString(Token.EXPR_RESULT);    	non-compiled	[CE]  cannot  find  symbol  x	41	None	replace
66	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.EXPR_RESULT,  n);  [CE]  no  suitable  method  found  for  newString(int,Node)  [FE]                  junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.EXPR_RESULT,  n);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(Token.EXPR_RESULT,  n);	  Node    emptyStringNode    =    Node.newString(Token.EXPR_RESULT);    	non-compiled	[CE]  no  suitable  method  found  for  newString(int,Node)	41	None	replace
67	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.EXPR_RESULT,  originalSize);  [CE]  no  suitable  method  found  for  newString(int,int)  [FE]                    junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.EXPR_RESULT,  originalSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(Token.EXPR_RESULT,  originalSize);	  Node    emptyStringNode    =    Node.newString(Token.EXPR_RESULT);    	non-compiled	[CE]  no  suitable  method  found  for  newString(int,int)	41	None	replace
68	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.EXPR_RESULT,  left);  [CE]  cannot  find  symbol  left  [FE]                      junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.EXPR_RESULT,  left);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(Token.EXPR_RESULT,  left);	  Node    emptyStringNode    =    Node.newString(Token.EXPR_RESULT);    	non-compiled	[CE]  cannot  find  symbol  left	41	None	replace
69	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.EXPR_RESULT,  sb);  [CE]  no  suitable  method  found  for  newString(int,StringBuilder)  [FE]                        junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.EXPR_RESULT,  sb);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(Token.EXPR_RESULT,  sb);	  Node    emptyStringNode    =    Node.newString(Token.EXPR_RESULT);    	non-compiled	[CE]  no  suitable  method  found  for  newString(int,StringBuilder)	41	None	replace
70	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[1] ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "[1] ");	  Node    emptyStringNode    =    Node.newString(       "[       ");    Node    emptyStringNode    =    Node.newString(   "[       ");    	compilable	  [FE]  AssertionFailedError  	95	3	replace
71	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "[1] ");  [FE]  AssertionFailedError  [FE]        AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[1] ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "[1] ");	  Node    emptyStringNode    =    Node.newString(       "[       ");    Node    emptyStringNode    =    Node.newString(   "[       ");    	compilable	  [FE]  AssertionFailedError  	95	3	replace
72	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList( ").join(x,   "  [CE]  unclosed  string  literal  [FE]            junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList( ").join(x,   "  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList( ").join(x,   "	  Node    emptyStringNode    =    Node.newString(   "java.util.Arrays.asList(   ").join(   "    	non-compiled	[CE]  unclosed  string  literal	183	None	replace
73	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList(x).join( "  [CE]  [FE]              junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList(x).join( "  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList(x).join( "	  Node    emptyStringNode    =    Node.newString(   "java.util.Arrays.asList(   ").join(   "    	non-compiled	[CE]  	183	None	replace
74	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList( ").join(x)  [CE]  [FE]                junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList( ").join(x)  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList( ").join(x)	  Node    emptyStringNode    =    Node.newString(   "java.util.Arrays.asList(   ").join(   "    	non-compiled	[CE]  	183	None	replace
75	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList( ").join(x),   "  [CE]  unclosed  string  literal  [FE]                  junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList( ").join(x),   "  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList( ").join(x),   "	  Node    emptyStringNode    =    Node.newString(   "java.util.Arrays.asList(   ").join(   "    	non-compiled	[CE]  unclosed  string  literal	183	None	replace
76	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "Arrays.asList( ").join(x,   "  [CE]  unclosed  string  literal  [FE]                    junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "Arrays.asList( ").join(x,   "  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "Arrays.asList( ").join(x,   "	  Node    emptyStringNode    =    Node.newString(   "java.util.Arrays.asList(   ").join(   "    	non-compiled	[CE]  unclosed  string  literal	183	None	replace
77	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]                junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList( "  +  arrayFoldedChildren.size());  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList( "  +  arrayFoldedChildren.size());	  Node    emptyStringNode    =    Node.newString(   "java.util.Arrays.asList(   "    +    arrayFoldedChildren.size()    -    1);    	compilable	  [FE]  AssertionFailedError  	56	3	replace
78	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList( "  +  arrayFoldedChildren.size());  [FE]  AssertionFailedError  [FE]                junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList( "  +  arrayFoldedChildren.size());  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList( "  +  arrayFoldedChildren.size());	  Node    emptyStringNode    =    Node.newString(   "java.util.Arrays.asList(   "    +    arrayFoldedChildren.size()    -    1);    	compilable	  [FE]  AssertionFailedError  	56	3	replace
79	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]                  junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList( "  +  arrayFoldedChildren.size()  +  1);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList( "  +  arrayFoldedChildren.size()  +  1);	  Node    emptyStringNode    =    Node.newString(   "java.util.Arrays.asList(   "    +    arrayFoldedChildren.size()    -    1);    	compilable	  [FE]  AssertionFailedError  	56	3	replace
80	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList( "  +  arrayFoldedChildren.size()  +  1);  [FE]  AssertionFailedError  [FE]                  junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList( "  +  arrayFoldedChildren.size()  +  1);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList( "  +  arrayFoldedChildren.size()  +  1);	  Node    emptyStringNode    =    Node.newString(   "java.util.Arrays.asList(   "    +    arrayFoldedChildren.size()    -    1);    	compilable	  [FE]  AssertionFailedError  	56	3	replace
81	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]                    junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "Arrays.asList( "  +  arrayFoldedChildren.size());  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "Arrays.asList( "  +  arrayFoldedChildren.size());	  Node    emptyStringNode    =    Node.newString(   "java.util.Arrays.asList(   "    +    arrayFoldedChildren.size()    -    1);    	compilable	  [FE]  AssertionFailedError  	56	3	replace
82	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "Arrays.asList( "  +  arrayFoldedChildren.size());  [FE]  AssertionFailedError  [FE]                    junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "Arrays.asList( "  +  arrayFoldedChildren.size());  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "Arrays.asList( "  +  arrayFoldedChildren.size());	  Node    emptyStringNode    =    Node.newString(   "java.util.Arrays.asList(   "    +    arrayFoldedChildren.size()    -    1);    	compilable	  [FE]  AssertionFailedError  	56	3	replace
83	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "string ").replaceChild(n,  foldedSize,  arrayFoldedChildren);  [CE]  method  replaceChild  in  class  Node  cannot  be  applied  to  given  types;  [FE]          AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "string ").replaceChild(n,  foldedSize,  arrayFoldedChildren);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "string ").replaceChild(n,  foldedSize,  arrayFoldedChildren);	  Node    emptyStringNode    =    Node.newString(   "string   ").replaceChild(n,    arrayFoldedChildren);    	non-compiled	[CE]  method  replaceChild  in  class  Node  cannot  be  applied  to  given  types;	142	None	replace
84	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "string ").replaceChild(n,  arrayFoldedChildren,  foldedSize);  [CE]  method  replaceChild  in  class  Node  cannot  be  applied  to  given  types;  [FE]            AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "string ").replaceChild(n,  arrayFoldedChildren,  foldedSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "string ").replaceChild(n,  arrayFoldedChildren,  foldedSize);	  Node    emptyStringNode    =    Node.newString(   "string   ").replaceChild(n,    arrayFoldedChildren);    	non-compiled	[CE]  method  replaceChild  in  class  Node  cannot  be  applied  to  given  types;	142	None	replace
85	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "string ").replaceChild(n,  originalSize,  arrayFoldedChildren);  [CE]  method  replaceChild  in  class  Node  cannot  be  applied  to  given  types;  [FE]              AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "string ").replaceChild(n,  originalSize,  arrayFoldedChildren);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "string ").replaceChild(n,  originalSize,  arrayFoldedChildren);	  Node    emptyStringNode    =    Node.newString(   "string   ").replaceChild(n,    arrayFoldedChildren);    	non-compiled	[CE]  method  replaceChild  in  class  Node  cannot  be  applied  to  given  types;	142	None	replace
86	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "string ").replaceChild(n,  prev,  arrayFoldedChildren);  [CE]  method  replaceChild  in  class  Node  cannot  be  applied  to  given  types;  [FE]                AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "string ").replaceChild(n,  prev,  arrayFoldedChildren);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "string ").replaceChild(n,  prev,  arrayFoldedChildren);	  Node    emptyStringNode    =    Node.newString(   "string   ").replaceChild(n,    arrayFoldedChildren);    	non-compiled	[CE]  method  replaceChild  in  class  Node  cannot  be  applied  to  given  types;	142	None	replace
87	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "string "),  arrayFoldedChildren.replaceChild(n,  emptyStringNode);  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "string "),  arrayFoldedChildren.replaceChild(n,  emptyStringNode);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "string "),  arrayFoldedChildren.replaceChild(n,  emptyStringNode);	  Node    emptyStringNode    =    Node.newString(   "string   ").replaceChild(n,    arrayFoldedChildren);    	non-compiled	[CE]  	142	None	replace
88	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "string ").replaceChild(arrayNode,  n);  [CE]  incompatible  types  [FE]                    AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "string ").replaceChild(arrayNode,  n);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "string ").replaceChild(arrayNode,  n);	  Node    emptyStringNode    =    Node.newString(   "string   ").replaceChild(n,    arrayFoldedChildren);    	non-compiled	[CE]  incompatible  types	142	None	replace
89	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "string ").replaceChild(n,  oldStringNode,  arrayFoldedChildren);  [CE]  cannot  find  symbol  oldStringNode  [FE]                      AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "string ").replaceChild(n,  oldStringNode,  arrayFoldedChildren);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "string ").replaceChild(n,  oldStringNode,  arrayFoldedChildren);	  Node    emptyStringNode    =    Node.newString(   "string   ").replaceChild(n,    arrayFoldedChildren);    	non-compiled	[CE]  cannot  find  symbol  oldStringNode	142	None	replace
90	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME,   "]   ");  Node  emptyStringNode  =  Node.newString(Token.NAME,   "] ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]    junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME,   "]   ");  Node  emptyStringNode  =  Node.newString(Token.NAME,   "] ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(Token.NAME,   "]   ");    Node  emptyStringNode  =  Node.newString(Token.NAME,   "] ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	156	None	add
91	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME,   "]   ");  Node  emptyStringNode  =  Node.newString(Token.NAME,   "]. ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]      junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME,   "]   ");  Node  emptyStringNode  =  Node.newString(Token.NAME,   "]. ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(Token.NAME,   "]   ");    Node  emptyStringNode  =  Node.newString(Token.NAME,   "]. ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	156	None	add
92	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME,   "]   ");  Node  emptyStringNode  =  Node.newString(Token.NAME, ",] ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]        junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME,   "]   ");  Node  emptyStringNode  =  Node.newString(Token.NAME, ",] ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(Token.NAME,   "]   ");    Node  emptyStringNode  =  Node.newString(Token.NAME, ",] ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	156	None	add
93	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME,   "]   ");  Node  emptyStringNode  =  Node.newString(Token.NAME,   "] ",  n);  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]          junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME,   "]   ");  Node  emptyStringNode  =  Node.newString(Token.NAME,   "] ",  n);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(Token.NAME,   "]   ");    Node  emptyStringNode  =  Node.newString(Token.NAME,   "] ",  n);	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	156	None	add
94	[BUG]  [BUGGY]  Node  emptyStringNode  =  arrayFoldedChildren.get(n);  [CE]  method  get  in  interface  List<E>  cannot  be  applied  to  given  types;  [FE]    java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  Index:  12    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  arrayFoldedChildren.get(n);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  arrayFoldedChildren.get(n);	  Node    emptyStringNode    =    arrayFoldedChildren.get(originalSize);    	non-compiled	[CE]  method  get  in  interface  List<E>  cannot  be  applied  to  given  types;	10	None	replace
95	[BUG]  [BUGGY]  Node  emptyStringNode  =  arrayFoldedChildren.get(paddingSize);  [CE]  cannot  find  symbol  paddingSize  [FE]      java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  Index:  12    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  arrayFoldedChildren.get(paddingSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  arrayFoldedChildren.get(paddingSize);	  Node    emptyStringNode    =    arrayFoldedChildren.get(originalSize);    	non-compiled	[CE]  cannot  find  symbol  paddingSize	10	None	replace
96	[BUG]  [BUGGY]  Node  emptyStringNode  =  arrayFoldedChildren.get(parent);  [CE]  cannot  find  symbol  parent  [FE]        java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  Index:  12    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  arrayFoldedChildren.get(parent);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  arrayFoldedChildren.get(parent);	  Node    emptyStringNode    =    arrayFoldedChildren.get(originalSize);    	non-compiled	[CE]  cannot  find  symbol  parent	10	None	replace
97	[BUG]  [BUGGY]  Node  emptyStringNode  =  arrayFoldedChildren.get(false);  [CE]  method  get  in  interface  List<E>  cannot  be  applied  to  given  types;  [FE]          java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  Index:  12    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  arrayFoldedChildren.get(false);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  arrayFoldedChildren.get(false);	  Node    emptyStringNode    =    arrayFoldedChildren.get(originalSize);    	non-compiled	[CE]  method  get  in  interface  List<E>  cannot  be  applied  to  given  types;	10	None	replace
98	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "Arrays.asList( "));  [CE]  [FE]            junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "Arrays.asList( "));  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "Arrays.asList( "));	  Node    emptyStringNode    =    Node.newString(   "java.util.Arrays.asList(   "));    	non-compiled	[CE]  	54	None	replace
99	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList(n "));  [CE]  [FE]              junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList(n "));  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList(n "));	  Node    emptyStringNode    =    Node.newString(   "java.util.Arrays.asList(   "));    	non-compiled	[CE]  	54	None	replace
100	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList() "));  [CE]  [FE]                junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList() "));  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList() "));	  Node    emptyStringNode    =    Node.newString(   "java.util.Arrays.asList(   "));    	non-compiled	[CE]  	54	None	replace
101	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList(x,  y));  [CE]  unclosed  string  literal  [FE]                  junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList(x,  y));  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList(x,  y));	  Node    emptyStringNode    =    Node.newString(   "java.util.Arrays.asList(   "));    	non-compiled	[CE]  unclosed  string  literal	54	None	replace
102	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "Arrays.asList() "));  [CE]  [FE]                    junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "Arrays.asList() "));  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "Arrays.asList() "));	  Node    emptyStringNode    =    Node.newString(   "java.util.Arrays.asList(   "));    	non-compiled	[CE]  	54	None	replace
103	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "Arrays.asList(n "));  [CE]  [FE]                      junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "Arrays.asList(n "));  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "Arrays.asList(n "));	  Node    emptyStringNode    =    Node.newString(   "java.util.Arrays.asList(   "));    	non-compiled	[CE]  	54	None	replace
104	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "string ",  originalSize);  [CE]  no  suitable  method  found  for  newString(String,int)  [FE]        AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "string ",  originalSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "string ",  originalSize);	  Node    emptyStringNode    =    Node.newString(       "string       ");    Node    emptyStringNode    =    Node.newString(   "string       ");    	non-compiled	[CE]  no  suitable  method  found  for  newString(String,int)	87	None	replace
105	[BUG]  [BUGGY]  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]          AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "null ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "null ");	  Node    emptyStringNode    =    Node.newString(       "string       ");    Node    emptyStringNode    =    Node.newString(   "string       ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	87	3	replace
106	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "null ");  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]          AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "null ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "null ");	  Node    emptyStringNode    =    Node.newString(       "string       ");    Node    emptyStringNode    =    Node.newString(   "string       ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	87	3	replace
107	[BUG]  [BUGGY]  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]            AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "void ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "void ");	  Node    emptyStringNode    =    Node.newString(       "string       ");    Node    emptyStringNode    =    Node.newString(   "string       ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	87	3	replace
108	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "void ");  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]            AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "void ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "void ");	  Node    emptyStringNode    =    Node.newString(       "string       ");    Node    emptyStringNode    =    Node.newString(   "string       ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	87	3	replace
109	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "string "  +  foldedSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "string "  +  foldedSize);	  Node    emptyStringNode    =    Node.newString(   "string   "    +    originalSize);    	compilable	  [FE]  AssertionFailedError  	107	3	replace
110	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "string "  +  foldedSize);  [FE]  AssertionFailedError  [FE]    junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "string "  +  foldedSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "string "  +  foldedSize);	  Node    emptyStringNode    =    Node.newString(   "string   "    +    originalSize);    	compilable	  [FE]  AssertionFailedError  	107	3	replace
111	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "string "  +  originalSize  +  1);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "string "  +  originalSize  +  1);	  Node    emptyStringNode    =    Node.newString(   "string   "    +    originalSize);    	compilable	  [FE]  AssertionFailedError  	107	3	replace
112	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "string "  +  originalSize  +  1);  [FE]  AssertionFailedError  [FE]      junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "string "  +  originalSize  +  1);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "string "  +  originalSize  +  1);	  Node    emptyStringNode    =    Node.newString(   "string   "    +    originalSize);    	compilable	  [FE]  AssertionFailedError  	107	3	replace
113	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "string "  +  kJoinOverhead);  [CE]  cannot  find  symbol  kJoinOverhead  [FE]        junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "string "  +  kJoinOverhead);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "string "  +  kJoinOverhead);	  Node    emptyStringNode    =    Node.newString(   "string   "    +    originalSize);    	non-compiled	[CE]  cannot  find  symbol  kJoinOverhead	107	None	replace
114	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "string "  +  n);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "string "  +  n);	  Node    emptyStringNode    =    Node.newString(   "string   "    +    originalSize);    	compilable	  [FE]  AssertionFailedError  	107	3	replace
115	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "string "  +  n);  [FE]  AssertionFailedError  [FE]          junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "string "  +  n);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "string "  +  n);	  Node    emptyStringNode    =    Node.newString(   "string   "    +    originalSize);    	compilable	  [FE]  AssertionFailedError  	107	3	replace
116	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "Join.ArrayBuilder   ");  Node  emptyStringNode  =  Node.newString( "Join.ArrayBuilder   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]    junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "Join.ArrayBuilder   ");  Node  emptyStringNode  =  Node.newString( "Join.ArrayBuilder   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "Join.ArrayBuilder   ");    Node  emptyStringNode  =  Node.newString( "Join.ArrayBuilder   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	104	None	add
117	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "Join.ArrayBuilder   ");  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [CE]  not  a  statement  [FE]      junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "Join.ArrayBuilder   ");  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "Join.ArrayBuilder   ");    junit.framework.AssertionFailedError:  Expected:  x=[].join( "	  	non-compiled	[CE]  not  a  statement	104	None	add
118	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "Join.ArrayBuilder   ");  Node  emptyStringNode  =  Node.newString( ".Join.ArrayBuilder   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]        junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "Join.ArrayBuilder   ");  Node  emptyStringNode  =  Node.newString( ".Join.ArrayBuilder   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "Join.ArrayBuilder   ");    Node  emptyStringNode  =  Node.newString( ".Join.ArrayBuilder   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	104	None	add
119	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "Join.ArrayBuilder   ");  junit.framework.AssertionFailedError:  Expected:  x=[0].join( "  [CE]  not  a  statement  [FE]          junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "Join.ArrayBuilder   ");  junit.framework.AssertionFailedError:  Expected:  x=[0].join( "  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "Join.ArrayBuilder   ");    junit.framework.AssertionFailedError:  Expected:  x=[0].join( "	  	non-compiled	[CE]  not  a  statement	104	None	add
120	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "arrayJoin   ");  Node  emptyStringNode  =  Node.newString( "arrayJoin   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "arrayJoin   ");  Node  emptyStringNode  =  Node.newString( "arrayJoin   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "arrayJoin   ");    Node  emptyStringNode  =  Node.newString( "arrayJoin   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	70	None	add
121	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "arrayJoin   ");  Node  emptyStringNode  =  Node.newString( ".arrayJoin   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]      AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "arrayJoin   ");  Node  emptyStringNode  =  Node.newString( ".arrayJoin   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "arrayJoin   ");    Node  emptyStringNode  =  Node.newString( ".arrayJoin   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	70	None	add
122	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "arrayJoin   ");  Node  emptyStringNode  =  Node.newString( ",arrayJoin   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]        AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "arrayJoin   ");  Node  emptyStringNode  =  Node.newString( ",arrayJoin   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "arrayJoin   ");    Node  emptyStringNode  =  Node.newString( ",arrayJoin   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	70	None	add
123	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "arrayJoin   ");  Node  emptyStringNode  =  Node.newString( "arrayJoin "));  [CE]  [FE]          AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "arrayJoin   ");  Node  emptyStringNode  =  Node.newString( "arrayJoin "));  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "arrayJoin   ");    Node  emptyStringNode  =  Node.newString( "arrayJoin "));	  	non-compiled	[CE]  	70	None	add
124	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "arrayJoin   ");  Node  emptyStringNode  =  Node.newString( "arrayJoin ",);  [CE]  illegal  start  of  expression  [FE]            AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "arrayJoin   ");  Node  emptyStringNode  =  Node.newString( "arrayJoin ",);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "arrayJoin   ");    Node  emptyStringNode  =  Node.newString( "arrayJoin ",);	  	non-compiled	[CE]  illegal  start  of  expression	70	None	add
125	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "[node] ").replaceChild(n,  foldedSize);  [CE]  method  replaceChild  in  class  Node  cannot  be  applied  to  given  types;  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[node] ").replaceChild(n,  foldedSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "[node] ").replaceChild(n,  foldedSize);	  Node    emptyStringNode    =    Node.newString(   "[node]   ");    	non-compiled	[CE]  method  replaceChild  in  class  Node  cannot  be  applied  to  given  types;	176	None	replace
126	[BUG]  [BUGGY]  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('  [FE]      AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[node] "  +  sb.toString());  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "[node] "  +  sb.toString());	  Node    emptyStringNode    =    Node.newString(   "[node]   ");    	compilable	  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('  	176	3	replace
127	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "[node] "  +  sb.toString());  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('  [FE]      AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[node] "  +  sb.toString());  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "[node] "  +  sb.toString());	  Node    emptyStringNode    =    Node.newString(   "[node]   ");    	compilable	  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('  	176	3	replace
128	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[node] "  +  originalSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "[node] "  +  originalSize);	  Node    emptyStringNode    =    Node.newString(   "[node]   ");    	compilable	  [FE]  AssertionFailedError  	176	3	replace
129	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "[node] "  +  originalSize);  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[node] "  +  originalSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "[node] "  +  originalSize);	  Node    emptyStringNode    =    Node.newString(   "[node]   ");    	compilable	  [FE]  AssertionFailedError  	176	3	replace
130	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "[node] ",  foldedSize);  [CE]  no  suitable  method  found  for  newString(String,int)  [FE]          AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[node] ",  foldedSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "[node] ",  foldedSize);	  Node    emptyStringNode    =    Node.newString(   "[node]   ");    	non-compiled	[CE]  no  suitable  method  found  for  newString(String,int)	176	None	replace
131	[BUG]  [BUGGY]  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]            AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[node] "  +  Token.FUNCTION);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "[node] "  +  Token.FUNCTION);	  Node    emptyStringNode    =    Node.newString(   "[node]   ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	176	3	replace
132	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "[node] "  +  Token.FUNCTION);  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]            AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[node] "  +  Token.FUNCTION);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "[node] "  +  Token.FUNCTION);	  Node    emptyStringNode    =    Node.newString(   "[node]   ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	176	3	replace
133	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]              AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[node] "  +  functionName);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "[node] "  +  functionName);	  Node    emptyStringNode    =    Node.newString(   "[node]   ");    	compilable	  [FE]  AssertionFailedError  	176	3	replace
134	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "[node] "  +  functionName);  [FE]  AssertionFailedError  [FE]              AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[node] "  +  functionName);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "[node] "  +  functionName);	  Node    emptyStringNode    =    Node.newString(   "[node]   ");    	compilable	  [FE]  AssertionFailedError  	176	3	replace
135	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(1);  [CE]  no  suitable  method  found  for  newString(int)  [FE]        AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(1);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(1);	  Node    emptyStringNode    =    Node.newString(       "Array       ");    Node    emptyStringNode    =    Node.newString(   ")Array       ");    	non-compiled	[CE]  no  suitable  method  found  for  newString(int)	144	None	replace
136	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "Array "));  [CE]  [FE]          AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "Array "));  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "Array "));	  Node    emptyStringNode    =    Node.newString(       "Array       ");    Node    emptyStringNode    =    Node.newString(   ")Array       ");    	non-compiled	[CE]  	144	None	replace
137	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]            AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ")Array ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( ")Array ");	  Node    emptyStringNode    =    Node.newString(       "Array       ");    Node    emptyStringNode    =    Node.newString(   ")Array       ");    	compilable	  [FE]  AssertionFailedError  	144	3	replace
138	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( ")Array ");  [FE]  AssertionFailedError  [FE]            AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ")Array ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( ")Array ");	  Node    emptyStringNode    =    Node.newString(       "Array       ");    Node    emptyStringNode    =    Node.newString(   ")Array       ");    	compilable	  [FE]  AssertionFailedError  	144	3	replace
139	[BUG]  [BUGGY]  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]          AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ".node ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( ".node ");	  Node    emptyStringNode    =    Node.newString(       "n       ");    Node    emptyStringNode    =    Node.newString(   ".n       ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	17	3	replace
140	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( ".node ");  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]          AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ".node ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( ".node ");	  Node    emptyStringNode    =    Node.newString(       "n       ");    Node    emptyStringNode    =    Node.newString(   ".n       ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	17	3	replace
141	[BUG]  [BUGGY]  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]            AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ".js ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( ".js ");	  Node    emptyStringNode    =    Node.newString(       "n       ");    Node    emptyStringNode    =    Node.newString(   ".n       ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	17	3	replace
142	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( ".js ");  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]            AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ".js ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( ".js ");	  Node    emptyStringNode    =    Node.newString(       "n       ");    Node    emptyStringNode    =    Node.newString(   ".n       ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	17	3	replace
143	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]              AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ".no_string ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( ".no_string ");	  Node    emptyStringNode    =    Node.newString(       "n       ");    Node    emptyStringNode    =    Node.newString(   ".n       ");    	compilable	  [FE]  AssertionFailedError  	17	3	replace
144	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( ".no_string ");  [FE]  AssertionFailedError  [FE]              AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ".no_string ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( ".no_string ");	  Node    emptyStringNode    =    Node.newString(       "n       ");    Node    emptyStringNode    =    Node.newString(   ".n       ");    	compilable	  [FE]  AssertionFailedError  	17	3	replace
145	[BUG]  [BUGGY]  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]                AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ".nodes ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( ".nodes ");	  Node    emptyStringNode    =    Node.newString(       "n       ");    Node    emptyStringNode    =    Node.newString(   ".n       ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	17	3	replace
146	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( ".nodes ");  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]                AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ".nodes ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( ".nodes ");	  Node    emptyStringNode    =    Node.newString(       "n       ");    Node    emptyStringNode    =    Node.newString(   ".n       ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	17	3	replace
147	[BUG]  [BUGGY]  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  The  new  child  node  already  has  a  parent.  Node(CALL):  testcode:1:11  x  =  [].join('  [FE]    java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  The  new  child  node  has  siblings.  Node(CALL):  testcode:1:11  x  =  [].join('    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  n.getLastChild();  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  n.getLastChild();	  Node    emptyStringNode    =    n.getFirstChild();    	compilable	  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  The  new  child  node  already  has  a  parent.  Node(CALL):  testcode:1:11  x  =  [].join('  	8	3	replace
148	[BUG]  [BUGGY]  Node  emptyStringNode  =  n.getLastChild();  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  The  new  child  node  already  has  a  parent.  Node(CALL):  testcode:1:11  x  =  [].join('  [FE]    java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  The  new  child  node  has  siblings.  Node(CALL):  testcode:1:11  x  =  [].join('    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  n.getLastChild();  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  n.getLastChild();	  Node    emptyStringNode    =    n.getFirstChild();    	compilable	  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  The  new  child  node  already  has  a  parent.  Node(CALL):  testcode:1:11  x  =  [].join('  	8	3	replace
149	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  The  new  child  node  has  siblings.  Node(CALL):  testcode:1:11  x  =  [].join('    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  n.removeFirstChild();  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  n.removeFirstChild();	  Node    emptyStringNode    =    n.getFirstChild();    	compilable	  [FE]  AssertionFailedError  	8	3	replace
150	[BUG]  [BUGGY]  Node  emptyStringNode  =  n.removeFirstChild();  [FE]  AssertionFailedError  [FE]      java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  The  new  child  node  has  siblings.  Node(CALL):  testcode:1:11  x  =  [].join('    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  n.removeFirstChild();  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  n.removeFirstChild();	  Node    emptyStringNode    =    n.getFirstChild();    	compilable	  [FE]  AssertionFailedError  	8	3	replace
151	[BUG]  [BUGGY]  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('  [FE]        java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  The  new  child  node  has  siblings.  Node(CALL):  testcode:1:11  x  =  [].join('    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  n.getNext();  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  n.getNext();	  Node    emptyStringNode    =    n.getFirstChild();    	compilable	  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('  	8	3	replace
152	[BUG]  [BUGGY]  Node  emptyStringNode  =  n.getNext();  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('  [FE]        java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  The  new  child  node  has  siblings.  Node(CALL):  testcode:1:11  x  =  [].join('    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  n.getNext();  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  n.getNext();	  Node    emptyStringNode    =    n.getFirstChild();    	compilable	  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('  	8	3	replace
153	[BUG]  [BUGGY]  Node  emptyStringNode  =  arrayFoldedChildren.size();  [CE]  incompatible  types  [FE]          java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  The  new  child  node  has  siblings.  Node(CALL):  testcode:1:11  x  =  [].join('    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  arrayFoldedChildren.size();  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  arrayFoldedChildren.size();	  Node    emptyStringNode    =    n.getFirstChild();    	non-compiled	[CE]  incompatible  types	8	None	replace
154	[BUG]  [BUGGY]  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "array-foo.js. ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "array-foo.js. ");	  Node    emptyStringNode    =    Node.newString(   "array-foo.   ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	205	3	replace
155	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "array-foo.js. ");  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "array-foo.js. ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "array-foo.js. ");	  Node    emptyStringNode    =    Node.newString(   "array-foo.   ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	205	3	replace
156	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "array-foo.js ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "array-foo.js ");	  Node    emptyStringNode    =    Node.newString(   "array-foo.   ");    	compilable	  [FE]  AssertionFailedError  	205	3	replace
157	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "array-foo.js ");  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "array-foo.js ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "array-foo.js ");	  Node    emptyStringNode    =    Node.newString(   "array-foo.   ");    	compilable	  [FE]  AssertionFailedError  	205	3	replace
158	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "array-foo.1 ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "array-foo.1 ");	  Node    emptyStringNode    =    Node.newString(   "array-foo.   ");    	compilable	  [FE]  AssertionFailedError  	205	3	replace
159	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "array-foo.1 ");  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "array-foo.1 ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "array-foo.1 ");	  Node    emptyStringNode    =    Node.newString(   "array-foo.   ");    	compilable	  [FE]  AssertionFailedError  	205	3	replace
160	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "array-foo.void ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "array-foo.void ");	  Node    emptyStringNode    =    Node.newString(   "array-foo.   ");    	compilable	  [FE]  AssertionFailedError  	205	3	replace
161	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "array-foo.void ");  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "array-foo.void ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "array-foo.void ");	  Node    emptyStringNode    =    Node.newString(   "array-foo.   ");    	compilable	  [FE]  AssertionFailedError  	205	3	replace
162	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "array-foo.txt ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "array-foo.txt ");	  Node    emptyStringNode    =    Node.newString(   "array-foo.   ");    	compilable	  [FE]  AssertionFailedError  	205	3	replace
163	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "array-foo.txt ");  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "array-foo.txt ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "array-foo.txt ");	  Node    emptyStringNode    =    Node.newString(   "array-foo.   ");    	compilable	  [FE]  AssertionFailedError  	205	3	replace
164	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(']',  foldedSize);  [CE]  no  suitable  method  found  for  newString(char,int)  [FE]        AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(']',  foldedSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(']',  foldedSize);	  Node    emptyStringNode    =    Node.newString(       "]       ");    Node    emptyStringNode    =    Node.newString(    ']');    	non-compiled	[CE]  no  suitable  method  found  for  newString(char,int)	149	None	replace
165	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(']');  [CE]  no  suitable  method  found  for  newString(char)  [FE]          AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(']');  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(']');	  Node    emptyStringNode    =    Node.newString(       "]       ");    Node    emptyStringNode    =    Node.newString(    ']');    	non-compiled	[CE]  no  suitable  method  found  for  newString(char)	149	None	replace
166	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(originalSize);  [CE]  no  suitable  method  found  for  newString(int)  [FE]            AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(originalSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(originalSize);	  Node    emptyStringNode    =    Node.newString(       "]       ");    Node    emptyStringNode    =    Node.newString(    ']');    	non-compiled	[CE]  no  suitable  method  found  for  newString(int)	149	None	replace
167	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "array_name   ");  Node  emptyStringNode  =  Node.newString( "array_name   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "array_name   ");  Node  emptyStringNode  =  Node.newString( "array_name   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "array_name   ");    Node  emptyStringNode  =  Node.newString( "array_name   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	72	None	add
168	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "array_name   ");  Node  emptyStringNode  =  Node.newString( ".array_name   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]      AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "array_name   ");  Node  emptyStringNode  =  Node.newString( ".array_name   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "array_name   ");    Node  emptyStringNode  =  Node.newString( ".array_name   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	72	None	add
169	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "array_name   ");  Node  emptyStringNode  =  Node.newString( ",array_name   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]        AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "array_name   ");  Node  emptyStringNode  =  Node.newString( ",array_name   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "array_name   ");    Node  emptyStringNode  =  Node.newString( ",array_name   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	72	None	add
170	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "array_name   ");  Node  emptyStringNode  =  Node.newString(. "array_name   ");  [CE]  illegal  start  of  expression  [FE]          AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "array_name   ");  Node  emptyStringNode  =  Node.newString(. "array_name   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "array_name   ");    Node  emptyStringNode  =  Node.newString(. "array_name   ");	  	non-compiled	[CE]  illegal  start  of  expression	72	None	add
171	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "array_name   ");  Node  emptyStringNode  =  Node.newString( "array_name "));  [CE]  [FE]            AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "array_name   ");  Node  emptyStringNode  =  Node.newString( "array_name "));  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "array_name   ");    Node  emptyStringNode  =  Node.newString( "array_name "));	  	non-compiled	[CE]  	72	None	add
172	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "array_name   ");  Node  emptyStringNode  =  Node.newString( "array_name ",);  [CE]  illegal  start  of  expression  [FE]              AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "array_name   ");  Node  emptyStringNode  =  Node.newString( "array_name ",);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "array_name   ");    Node  emptyStringNode  =  Node.newString( "array_name ",);	  	non-compiled	[CE]  illegal  start  of  expression	72	None	add
173	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "[Locale.US]   ");  Node  emptyStringNode  =  Node.newString( "[Locale.US]   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "[Locale.US]   ");  Node  emptyStringNode  =  Node.newString( "[Locale.US]   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "[Locale.US]   ");    Node  emptyStringNode  =  Node.newString( "[Locale.US]   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	64	None	add
174	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "[Locale.US]   ");  Node  emptyStringNode  =  Node.newString( "[Locale.US] ",);  [CE]  illegal  start  of  expression  [FE]      AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "[Locale.US]   ");  Node  emptyStringNode  =  Node.newString( "[Locale.US] ",);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "[Locale.US]   ");    Node  emptyStringNode  =  Node.newString( "[Locale.US] ",);	  	non-compiled	[CE]  illegal  start  of  expression	64	None	add
175	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "[Locale.US]   ");  Node  emptyStringNode  =  Node.newString( ",[Locale.US]   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]        AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "[Locale.US]   ");  Node  emptyStringNode  =  Node.newString( ",[Locale.US]   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "[Locale.US]   ");    Node  emptyStringNode  =  Node.newString( ",[Locale.US]   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	64	None	add
176	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "[Locale.US]   ");  Node  emptyStringNode  =  Node.newString( ".[Locale.US]   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]          AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "[Locale.US]   ");  Node  emptyStringNode  =  Node.newString( ".[Locale.US]   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "[Locale.US]   ");    Node  emptyStringNode  =  Node.newString( ".[Locale.US]   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	64	None	add
177	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "array. ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "array. ");	  Node    emptyStringNode    =    Node.newString(       "array       ");    Node    emptyStringNode    =    Node.newString(   ".array   ");    	compilable	  [FE]  AssertionFailedError  	13	3	replace
178	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "array. ");  [FE]  AssertionFailedError  [FE]          junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "array. ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "array. ");	  Node    emptyStringNode    =    Node.newString(       "array       ");    Node    emptyStringNode    =    Node.newString(   ".array   ");    	compilable	  [FE]  AssertionFailedError  	13	3	replace
179	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]            junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ".array ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( ".array ");	  Node    emptyStringNode    =    Node.newString(       "array       ");    Node    emptyStringNode    =    Node.newString(   ".array   ");    	compilable	  [FE]  AssertionFailedError  	13	3	replace
180	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( ".array ");  [FE]  AssertionFailedError  [FE]            junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ".array ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( ".array ");	  Node    emptyStringNode    =    Node.newString(       "array       ");    Node    emptyStringNode    =    Node.newString(   ".array   ");    	compilable	  [FE]  AssertionFailedError  	13	3	replace
181	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "array ",  originalSize);  [CE]  no  suitable  method  found  for  newString(String,int)  [FE]              junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "array ",  originalSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "array ",  originalSize);	  Node    emptyStringNode    =    Node.newString(       "array       ");    Node    emptyStringNode    =    Node.newString(   ".array   ");    	non-compiled	[CE]  no  suitable  method  found  for  newString(String,int)	13	None	replace
182	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]                junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[array] ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "[array] ");	  Node    emptyStringNode    =    Node.newString(       "array       ");    Node    emptyStringNode    =    Node.newString(   ".array   ");    	compilable	  [FE]  AssertionFailedError  	13	3	replace
183	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "[array] ");  [FE]  AssertionFailedError  [FE]                junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[array] ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "[array] ");	  Node    emptyStringNode    =    Node.newString(       "array       ");    Node    emptyStringNode    =    Node.newString(   ".array   ");    	compilable	  [FE]  AssertionFailedError  	13	3	replace
184	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString('[',  foldedSize);  [CE]  no  suitable  method  found  for  newString(char,int)  [FE]          AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString('[',  foldedSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString('[',  foldedSize);	  Node    emptyStringNode    =    Node.newString(       "[       ");    Node    emptyStringNode    =    Node.newString('[');    	non-compiled	[CE]  no  suitable  method  found  for  newString(char,int)	140	None	replace
185	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "[A-Z] ").replaceChild(n,  foldedSize);  [CE]  method  replaceChild  in  class  Node  cannot  be  applied  to  given  types;  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[A-Z] ").replaceChild(n,  foldedSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "[A-Z] ").replaceChild(n,  foldedSize);	  Node    emptyStringNode    =    Node.newString(   "[A-Z]   ");    	non-compiled	[CE]  method  replaceChild  in  class  Node  cannot  be  applied  to  given  types;	67	None	replace
186	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "[A-Z] ",  foldedSize);  [CE]  no  suitable  method  found  for  newString(String,int)  [FE]      AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[A-Z] ",  foldedSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "[A-Z] ",  foldedSize);	  Node    emptyStringNode    =    Node.newString(   "[A-Z]   ");    	non-compiled	[CE]  no  suitable  method  found  for  newString(String,int)	67	None	replace
187	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[A-Z] "  +  originalSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "[A-Z] "  +  originalSize);	  Node    emptyStringNode    =    Node.newString(   "[A-Z]   ");    	compilable	  [FE]  AssertionFailedError  	67	3	replace
188	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "[A-Z] "  +  originalSize);  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[A-Z] "  +  originalSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "[A-Z] "  +  originalSize);	  Node    emptyStringNode    =    Node.newString(   "[A-Z]   ");    	compilable	  [FE]  AssertionFailedError  	67	3	replace
189	[BUG]  [BUGGY]  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('  [FE]          AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[A-Z] "  +  sb.toString());  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "[A-Z] "  +  sb.toString());	  Node    emptyStringNode    =    Node.newString(   "[A-Z]   ");    	compilable	  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('  	67	3	replace
190	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "[A-Z] "  +  sb.toString());  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('  [FE]          AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[A-Z] "  +  sb.toString());  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "[A-Z] "  +  sb.toString());	  Node    emptyStringNode    =    Node.newString(   "[A-Z]   ");    	compilable	  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('  	67	3	replace
191	[BUG]  [BUGGY]  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]            AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[A-Z] "  +  Token.name(originalSize));  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "[A-Z] "  +  Token.name(originalSize));	  Node    emptyStringNode    =    Node.newString(   "[A-Z]   ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	67	3	replace
192	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "[A-Z] "  +  Token.name(originalSize));  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]            AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[A-Z] "  +  Token.name(originalSize));  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "[A-Z] "  +  Token.name(originalSize));	  Node    emptyStringNode    =    Node.newString(   "[A-Z]   ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	67	3	replace
193	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "[A-Z] ",  sb.toString());  [CE]  no  suitable  method  found  for  newString(String,String)  [FE]              AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[A-Z] ",  sb.toString());  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "[A-Z] ",  sb.toString());	  Node    emptyStringNode    =    Node.newString(   "[A-Z]   ");    	non-compiled	[CE]  no  suitable  method  found  for  newString(String,String)	67	None	replace
194	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "JoinOverhead   ");  Node  emptyStringNode  =  Node.newString( "JoinOverhead   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "JoinOverhead   ");  Node  emptyStringNode  =  Node.newString( "JoinOverhead   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "JoinOverhead   ");    Node  emptyStringNode  =  Node.newString( "JoinOverhead   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	145	None	add
195	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "JoinOverhead   ");  Node  emptyStringNode  =  Node.newString( ",JoinOverhead   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]      AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "JoinOverhead   ");  Node  emptyStringNode  =  Node.newString( ",JoinOverhead   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "JoinOverhead   ");    Node  emptyStringNode  =  Node.newString( ",JoinOverhead   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	145	None	add
196	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "JoinOverhead   ");  Node  emptyStringNode  =  Node.newString( ".JoinOverhead   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]        AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "JoinOverhead   ");  Node  emptyStringNode  =  Node.newString( ".JoinOverhead   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "JoinOverhead   ");    Node  emptyStringNode  =  Node.newString( ".JoinOverhead   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	145	None	add
197	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "JoinOverhead   ");  Node  emptyStringNode  =  Node.newString(. "JoinOverhead   ");  [CE]  illegal  start  of  expression  [FE]          AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "JoinOverhead   ");  Node  emptyStringNode  =  Node.newString(. "JoinOverhead   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "JoinOverhead   ");    Node  emptyStringNode  =  Node.newString(. "JoinOverhead   ");	  	non-compiled	[CE]  illegal  start  of  expression	145	None	add
198	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "JoinOverhead   ");  Node  emptyStringNode  =  Node.newString(, "JoinOverhead   ");  [CE]  illegal  start  of  expression  [FE]            AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "JoinOverhead   ");  Node  emptyStringNode  =  Node.newString(, "JoinOverhead   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "JoinOverhead   ");    Node  emptyStringNode  =  Node.newString(, "JoinOverhead   ");	  	non-compiled	[CE]  illegal  start  of  expression	145	None	add
199	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "JoinOverhead   ");  Node  emptyStringNode  =  Node.newString(... "JoinOverhead   ");  [CE]  illegal  start  of  expression  [FE]              AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "JoinOverhead   ");  Node  emptyStringNode  =  Node.newString(... "JoinOverhead   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "JoinOverhead   ");    Node  emptyStringNode  =  Node.newString(... "JoinOverhead   ");	  	non-compiled	[CE]  illegal  start  of  expression	145	None	add
200	[BUG]  [BUGGY]  n.removeChild(prev,  arrayFoldedChildren);  [CE]  method  removeChild  in  class  Node  cannot  be  applied  to  given  types;  [FE]                          junit.framework.AssertionFailedError:  Expected:  x=[     "a     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  n.removeChild(prev,  arrayFoldedChildren);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	n.removeChild(prev,  arrayFoldedChildren);	  n.removeChild(arrayFoldedChildren);    	non-compiled	[CE]  method  removeChild  in  class  Node  cannot  be  applied  to  given  types;	186	None	replace
201	[BUG]  [BUGGY]  n.removeChild(arrayFoldedChildren,  prev);  [CE]  method  removeChild  in  class  Node  cannot  be  applied  to  given  types;  [FE]                            junit.framework.AssertionFailedError:  Expected:  x=[     "a     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  n.removeChild(arrayFoldedChildren,  prev);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	n.removeChild(arrayFoldedChildren,  prev);	  n.removeChild(arrayFoldedChildren);    	non-compiled	[CE]  method  removeChild  in  class  Node  cannot  be  applied  to  given  types;	186	None	replace
202	[BUG]  [BUGGY]  n.removeChild(oldStringNode,  arrayFoldedChildren);  [CE]  cannot  find  symbol  oldStringNode  [FE]                              junit.framework.AssertionFailedError:  Expected:  x=[     "a     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  n.removeChild(oldStringNode,  arrayFoldedChildren);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	n.removeChild(oldStringNode,  arrayFoldedChildren);	  n.removeChild(arrayFoldedChildren);    	non-compiled	[CE]  cannot  find  symbol  oldStringNode	186	None	replace
203	[BUG]  [BUGGY]  n.removeChild(sb,  arrayFoldedChildren);  [CE]  method  removeChild  in  class  Node  cannot  be  applied  to  given  types;  [FE]                                junit.framework.AssertionFailedError:  Expected:  x=[     "a     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  n.removeChild(sb,  arrayFoldedChildren);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	n.removeChild(sb,  arrayFoldedChildren);	  n.removeChild(arrayFoldedChildren);    	non-compiled	[CE]  method  removeChild  in  class  Node  cannot  be  applied  to  given  types;	186	None	replace
204	[BUG]  [BUGGY]  n.removeChild(arrayFoldedChildren.size()  -  1);  [CE]  method  removeChild  in  class  Node  cannot  be  applied  to  given  types;  [FE]                                  junit.framework.AssertionFailedError:  Expected:  x=[     "a     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  n.removeChild(arrayFoldedChildren.size()  -  1);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	n.removeChild(arrayFoldedChildren.size()  -  1);	  n.removeChild(arrayFoldedChildren);    	non-compiled	[CE]  method  removeChild  in  class  Node  cannot  be  applied  to  given  types;	186	None	replace
205	[BUG]  [BUGGY]  n.removeChild(arrayFoldedChildren,  originalSize);  [CE]  method  removeChild  in  class  Node  cannot  be  applied  to  given  types;  [FE]                                    junit.framework.AssertionFailedError:  Expected:  x=[     "a     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  n.removeChild(arrayFoldedChildren,  originalSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	n.removeChild(arrayFoldedChildren,  originalSize);	  n.removeChild(arrayFoldedChildren);    	non-compiled	[CE]  method  removeChild  in  class  Node  cannot  be  applied  to  given  types;	186	None	replace
206	[BUG]  [BUGGY]  n.removeChild(arrayFoldedChildren,  foldedSize);  [CE]  method  removeChild  in  class  Node  cannot  be  applied  to  given  types;  [FE]                                      junit.framework.AssertionFailedError:  Expected:  x=[     "a     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  n.removeChild(arrayFoldedChildren,  foldedSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	n.removeChild(arrayFoldedChildren,  foldedSize);	  n.removeChild(arrayFoldedChildren);    	non-compiled	[CE]  method  removeChild  in  class  Node  cannot  be  applied  to  given  types;	186	None	replace
207	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "[AssertionFailedError]   ");  Node  emptyStringNode  =  Node.newString( "[AssertionFailedError]   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "[AssertionFailedError]   ");  Node  emptyStringNode  =  Node.newString( "[AssertionFailedError]   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "[AssertionFailedError]   ");    Node  emptyStringNode  =  Node.newString( "[AssertionFailedError]   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	68	None	add
208	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "[AssertionFailedError]   ");  Node  emptyStringNode  =  Node.newString( ",[AssertionFailedError]   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]      AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "[AssertionFailedError]   ");  Node  emptyStringNode  =  Node.newString( ",[AssertionFailedError]   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "[AssertionFailedError]   ");    Node  emptyStringNode  =  Node.newString( ",[AssertionFailedError]   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	68	None	add
209	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "[AssertionFailedError]   ");  Node  emptyStringNode  =  Node.newString( "[AssertionFailedError] ",);  [CE]  illegal  start  of  expression  [FE]        AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "[AssertionFailedError]   ");  Node  emptyStringNode  =  Node.newString( "[AssertionFailedError] ",);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "[AssertionFailedError]   ");    Node  emptyStringNode  =  Node.newString( "[AssertionFailedError] ",);	  	non-compiled	[CE]  illegal  start  of  expression	68	None	add
210	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "[AssertionFailedError]   ");  Node  emptyStringNode  =  Node.newString( ".[AssertionFailedError]   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]          AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "[AssertionFailedError]   ");  Node  emptyStringNode  =  Node.newString( ".[AssertionFailedError]   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "[AssertionFailedError]   ");    Node  emptyStringNode  =  Node.newString( ".[AssertionFailedError]   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	68	None	add
211	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(ArrayElement.EMPTY_STRING);  [CE]  cannot  find  symbol  ArrayElement  [FE]        junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(ArrayElement.EMPTY_STRING);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(ArrayElement.EMPTY_STRING);	  Node    emptyStringNode    =    Node.newString(       "java.util.ArrayElement       ");    Node    emptyStringNode    =    Node.newString(java.util.ArrayElement       ");    	non-compiled	[CE]  cannot  find  symbol  ArrayElement	160	None	replace
212	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "FoldArrayJoin ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "FoldArrayJoin ");	  Node    emptyStringNode    =    Node.newString(   "ArrayElement   ");    	compilable	  [FE]  AssertionFailedError  	37	3	replace
213	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "FoldArrayJoin ");  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "FoldArrayJoin ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "FoldArrayJoin ");	  Node    emptyStringNode    =    Node.newString(   "ArrayElement   ");    	compilable	  [FE]  AssertionFailedError  	37	3	replace
214	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(? "- ");  [CE]  illegal  start  of  expression  [FE]                AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(? "- ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(? "- ");	  Node    emptyStringNode    =    Node.newString(       "-       ");    Node    emptyStringNode    =    Node.newString(?   "-       ");    	non-compiled	[CE]  illegal  start  of  expression	115	None	replace
215	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]                  AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "-1 ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "-1 ");	  Node    emptyStringNode    =    Node.newString(       "-       ");    Node    emptyStringNode    =    Node.newString(?   "-       ");    	compilable	  [FE]  AssertionFailedError  	115	3	replace
216	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "-1 ");  [FE]  AssertionFailedError  [FE]                  AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "-1 ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "-1 ");	  Node    emptyStringNode    =    Node.newString(       "-       ");    Node    emptyStringNode    =    Node.newString(?   "-       ");    	compilable	  [FE]  AssertionFailedError  	115	3	replace
217	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Arrays.asList(originalSize));  [CE]  cannot  find  symbol  Arrays  [FE]          junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Arrays.asList(originalSize));  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(Arrays.asList(originalSize));	  Node    emptyStringNode    =    Node.newString(       "java.util.Arrays.asList(       ");    Node    emptyStringNode    =    Node.newString(java.util.Arrays.asList(       ");    	non-compiled	[CE]  cannot  find  symbol  Arrays	77	None	replace
218	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Arrays.asList(x));  [CE]  cannot  find  symbol  x  [FE]            junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Arrays.asList(x));  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(Arrays.asList(x));	  Node    emptyStringNode    =    Node.newString(       "java.util.Arrays.asList(       ");    Node    emptyStringNode    =    Node.newString(java.util.Arrays.asList(       ");    	non-compiled	[CE]  cannot  find  symbol  x	77	None	replace
219	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Arrays.asList(new  String[]  {  x  }  ));  [CE]  cannot  find  symbol  x  [FE]              junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Arrays.asList(new  String[]  {  x  }  ));  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(Arrays.asList(new  String[]  {  x  }  ));	  Node    emptyStringNode    =    Node.newString(       "java.util.Arrays.asList(       ");    Node    emptyStringNode    =    Node.newString(java.util.Arrays.asList(       ");    	non-compiled	[CE]  cannot  find  symbol  x	77	None	replace
220	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Arrays.asList(n));  [CE]  cannot  find  symbol  Arrays  [FE]                junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Arrays.asList(n));  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(Arrays.asList(n));	  Node    emptyStringNode    =    Node.newString(       "java.util.Arrays.asList(       ");    Node    emptyStringNode    =    Node.newString(java.util.Arrays.asList(       ");    	non-compiled	[CE]  cannot  find  symbol  Arrays	77	None	replace
221	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Arrays.asList(x,  y));  [CE]  cannot  find  symbol  x  [FE]                  junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Arrays.asList(x,  y));  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(Arrays.asList(x,  y));	  Node    emptyStringNode    =    Node.newString(       "java.util.Arrays.asList(       ");    Node    emptyStringNode    =    Node.newString(java.util.Arrays.asList(       ");    	non-compiled	[CE]  cannot  find  symbol  x	77	None	replace
222	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Arrays.asList(0,  foldedSize));  [CE]  cannot  find  symbol  Arrays  [FE]                    junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Arrays.asList(0,  foldedSize));  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(Arrays.asList(0,  foldedSize));	  Node    emptyStringNode    =    Node.newString(       "java.util.Arrays.asList(       ");    Node    emptyStringNode    =    Node.newString(java.util.Arrays.asList(       ");    	non-compiled	[CE]  cannot  find  symbol  Arrays	77	None	replace
223	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Arrays.asList(0,  0));  [CE]  cannot  find  symbol  Arrays  [FE]                      junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Arrays.asList(0,  0));  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(Arrays.asList(0,  0));	  Node    emptyStringNode    =    Node.newString(       "java.util.Arrays.asList(       ");    Node    emptyStringNode    =    Node.newString(java.util.Arrays.asList(       ");    	non-compiled	[CE]  cannot  find  symbol  Arrays	77	None	replace
224	[BUG]  [BUGGY]  [FE]  junit.framework.AssertionFailedError:  Expected:  x= " "  Result:  x= "]  [FE]        AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "], ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "], ");	  Node    emptyStringNode    =    Node.newString(       "]       ");    Node    emptyStringNode    =    Node.newString(       "]   ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x= " "  Result:  x= "]  	91	3	replace
225	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "], ");  [FE]  junit.framework.AssertionFailedError:  Expected:  x= " "  Result:  x= "]  [FE]        AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "], ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "], ");	  Node    emptyStringNode    =    Node.newString(       "]       ");    Node    emptyStringNode    =    Node.newString(       "]   ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x= " "  Result:  x= "]  	91	3	replace
226	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "] ").replaceChild(n,  foldedStringNode);  [CE]  cannot  find  symbol  foldedStringNode  [FE]          AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "] ").replaceChild(n,  foldedStringNode);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "] ").replaceChild(n,  foldedStringNode);	  Node    emptyStringNode    =    Node.newString(       "]       ");    Node    emptyStringNode    =    Node.newString(       "]   ");    	non-compiled	[CE]  cannot  find  symbol  foldedStringNode	91	None	replace
227	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "] ").replaceChild(n,  foldedSize);  [CE]  method  replaceChild  in  class  Node  cannot  be  applied  to  given  types;  [FE]            AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "] ").replaceChild(n,  foldedSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "] ").replaceChild(n,  foldedSize);	  Node    emptyStringNode    =    Node.newString(       "]       ");    Node    emptyStringNode    =    Node.newString(       "]   ");    	non-compiled	[CE]  method  replaceChild  in  class  Node  cannot  be  applied  to  given  types;	91	None	replace
228	[BUG]  [BUGGY]  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]    junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "ArrayList: ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "ArrayList: ");	  Node    emptyStringNode    =    Node.newString(   "java.util.ArrayList:   ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	159	3	replace
229	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "ArrayList: ");  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]    junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "ArrayList: ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "ArrayList: ");	  Node    emptyStringNode    =    Node.newString(   "java.util.ArrayList:   ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	159	3	replace
230	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.ArrayList: "  +  originalSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "java.util.ArrayList: "  +  originalSize);	  Node    emptyStringNode    =    Node.newString(   "java.util.ArrayList:   ");    	compilable	  [FE]  AssertionFailedError  	159	3	replace
231	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.ArrayList: "  +  originalSize);  [FE]  AssertionFailedError  [FE]      junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.ArrayList: "  +  originalSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "java.util.ArrayList: "  +  originalSize);	  Node    emptyStringNode    =    Node.newString(   "java.util.ArrayList:   ");    	compilable	  [FE]  AssertionFailedError  	159	3	replace
232	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "JoinArrayList: ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "JoinArrayList: ");	  Node    emptyStringNode    =    Node.newString(   "java.util.ArrayList:   ");    	compilable	  [FE]  AssertionFailedError  	159	3	replace
233	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "JoinArrayList: ");  [FE]  AssertionFailedError  [FE]        junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "JoinArrayList: ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "JoinArrayList: ");	  Node    emptyStringNode    =    Node.newString(   "java.util.ArrayList:   ");    	compilable	  [FE]  AssertionFailedError  	159	3	replace
234	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(? "java.util.ArrayList ");  [CE]  illegal  start  of  expression  [FE]                AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(? "java.util.ArrayList ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(? "java.util.ArrayList ");	  Node    emptyStringNode    =    Node.newString(       "java.util.ArrayList       ");    Node    emptyStringNode    =    Node.newString(?   "java.util.ArrayList       ");    	non-compiled	[CE]  illegal  start  of  expression	28	None	replace
235	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(? "ArrayList ");  [CE]  illegal  start  of  expression  [FE]                  AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(? "ArrayList ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(? "ArrayList ");	  Node    emptyStringNode    =    Node.newString(       "java.util.ArrayList       ");    Node    emptyStringNode    =    Node.newString(?   "java.util.ArrayList       ");    	non-compiled	[CE]  illegal  start  of  expression	28	None	replace
236	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME,  foldedSize,  originalSize);  [CE]  no  suitable  method  found  for  newString(int,int,int)  [FE]              AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME,  foldedSize,  originalSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(Token.NAME,  foldedSize,  originalSize);	  Node    emptyStringNode    =    Node.newString(Token.NAME,    originalSize);    	non-compiled	[CE]  no  suitable  method  found  for  newString(int,int,int)	61	None	replace
237	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME,  n,  originalSize);  [CE]  no  suitable  method  found  for  newString(int,Node,int)  [FE]                AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME,  n,  originalSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(Token.NAME,  n,  originalSize);	  Node    emptyStringNode    =    Node.newString(Token.NAME,    originalSize);    	non-compiled	[CE]  no  suitable  method  found  for  newString(int,Node,int)	61	None	replace
238	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME,  originalSize,  kJoinOverhead);  [CE]  cannot  find  symbol  kJoinOverhead  [FE]                  AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME,  originalSize,  kJoinOverhead);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(Token.NAME,  originalSize,  kJoinOverhead);	  Node    emptyStringNode    =    Node.newString(Token.NAME,    originalSize);    	non-compiled	[CE]  cannot  find  symbol  kJoinOverhead	61	None	replace
239	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME,  originalSize,  foldedSize);  [CE]  no  suitable  method  found  for  newString(int,int,int)  [FE]                    AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME,  originalSize,  foldedSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(Token.NAME,  originalSize,  foldedSize);	  Node    emptyStringNode    =    Node.newString(Token.NAME,    originalSize);    	non-compiled	[CE]  no  suitable  method  found  for  newString(int,int,int)	61	None	replace
240	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME,  foldingSize,  originalSize);  [CE]  cannot  find  symbol  foldingSize  [FE]                      AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME,  foldingSize,  originalSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(Token.NAME,  foldingSize,  originalSize);	  Node    emptyStringNode    =    Node.newString(Token.NAME,    originalSize);    	non-compiled	[CE]  cannot  find  symbol  foldingSize	61	None	replace
241	[BUG]  [BUGGY]  Node  emptyStringNode  =  arrayFoldedChildren.remove(0);  Node  emptyStringNode  =  arrayFoldedChildren.remove(0);  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]    java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  Index:  0    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  arrayFoldedChildren.remove(0);  Node  emptyStringNode  =  arrayFoldedChildren.remove(0);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    arrayFoldedChildren.remove(0);    Node  emptyStringNode  =  arrayFoldedChildren.remove(0);	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	5	None	add
242	[BUG]  [BUGGY]  Node  emptyStringNode  =  arrayFoldedChildren.remove(0);  Node  emptyStringNode  =  arrayFoldedChildren.remove(1);  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]      java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  Index:  0    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  arrayFoldedChildren.remove(0);  Node  emptyStringNode  =  arrayFoldedChildren.remove(1);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    arrayFoldedChildren.remove(0);    Node  emptyStringNode  =  arrayFoldedChildren.remove(1);	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	5	None	add
243	[BUG]  [BUGGY]  Node  emptyStringNode  =  arrayFoldedChildren.remove(0);  Node  emptyStringNode  =  arrayFoldedChildren.remove(prev);  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]        java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  Index:  0    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  arrayFoldedChildren.remove(0);  Node  emptyStringNode  =  arrayFoldedChildren.remove(prev);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    arrayFoldedChildren.remove(0);    Node  emptyStringNode  =  arrayFoldedChildren.remove(prev);	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	5	None	add
244	[BUG]  [BUGGY]  Node  emptyStringNode  =  arrayFoldedChildren.remove(0);  Node  emptyStringNode  =  arrayFoldedChildren.remove(n);  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]          java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  Index:  0    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  arrayFoldedChildren.remove(0);  Node  emptyStringNode  =  arrayFoldedChildren.remove(n);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    arrayFoldedChildren.remove(0);    Node  emptyStringNode  =  arrayFoldedChildren.remove(n);	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	5	None	add
245	[BUG]  [BUGGY]  Node  emptyStringNode  =  arrayFoldedChildren.remove(0);  Node  emptyStringNode  =  arrayFoldedChildren.remove(2);  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]            java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  Index:  0    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  arrayFoldedChildren.remove(0);  Node  emptyStringNode  =  arrayFoldedChildren.remove(2);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    arrayFoldedChildren.remove(0);    Node  emptyStringNode  =  arrayFoldedChildren.remove(2);	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	5	None	add
246	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "string ").replaceChild(n,  prev,  foldedSize);  [CE]  method  replaceChild  in  class  Node  cannot  be  applied  to  given  types;  [FE]        AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "string ").replaceChild(n,  prev,  foldedSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "string ").replaceChild(n,  prev,  foldedSize);	  Node    emptyStringNode    =    Node.newString(   "string   ").replaceChild(n,    prev);    	non-compiled	[CE]  method  replaceChild  in  class  Node  cannot  be  applied  to  given  types;	141	None	replace
247	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "string ").replaceChild(n,  prev,  sb);  [CE]  method  replaceChild  in  class  Node  cannot  be  applied  to  given  types;  [FE]          AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "string ").replaceChild(n,  prev,  sb);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "string ").replaceChild(n,  prev,  sb);	  Node    emptyStringNode    =    Node.newString(   "string   ").replaceChild(n,    prev);    	non-compiled	[CE]  method  replaceChild  in  class  Node  cannot  be  applied  to  given  types;	141	None	replace
248	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "string ").replaceChild(n,  prev,  originalSize);  [CE]  method  replaceChild  in  class  Node  cannot  be  applied  to  given  types;  [FE]            AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "string ").replaceChild(n,  prev,  originalSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "string ").replaceChild(n,  prev,  originalSize);	  Node    emptyStringNode    =    Node.newString(   "string   ").replaceChild(n,    prev);    	non-compiled	[CE]  method  replaceChild  in  class  Node  cannot  be  applied  to  given  types;	141	None	replace
249	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "string ").replaceChild(n,  prev,  left);  [CE]  cannot  find  symbol  left  [FE]              AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "string ").replaceChild(n,  prev,  left);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "string ").replaceChild(n,  prev,  left);	  Node    emptyStringNode    =    Node.newString(   "string   ").replaceChild(n,    prev);    	non-compiled	[CE]  cannot  find  symbol  left	141	None	replace
250	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "string ").replaceChild(n,  prev,  type);  [CE]  cannot  find  symbol  type  [FE]                AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "string ").replaceChild(n,  prev,  type);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "string ").replaceChild(n,  prev,  type);	  Node    emptyStringNode    =    Node.newString(   "string   ").replaceChild(n,    prev);    	non-compiled	[CE]  cannot  find  symbol  type	141	None	replace
251	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "string ").replaceChild(prev,  n);  [CE]  incompatible  types  [FE]                  AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "string ").replaceChild(prev,  n);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "string ").replaceChild(prev,  n);	  Node    emptyStringNode    =    Node.newString(   "string   ").replaceChild(n,    prev);    	non-compiled	[CE]  incompatible  types	141	None	replace
252	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "string ").replaceChild(n,  prev,  oldName);  [CE]  cannot  find  symbol  oldName  [FE]                    AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "string ").replaceChild(n,  prev,  oldName);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "string ").replaceChild(n,  prev,  oldName);	  Node    emptyStringNode    =    Node.newString(   "string   ").replaceChild(n,    prev);    	non-compiled	[CE]  cannot  find  symbol  oldName	141	None	replace
253	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "[0]   ");  Node  emptyStringNode  =  Node.newString( "[0]   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "[0]   ");  Node  emptyStringNode  =  Node.newString( "[0]   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "[0]   ");    Node  emptyStringNode  =  Node.newString( "[0]   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	62	None	add
254	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "[0]   ");  Node  emptyStringNode  =  Node.newString( ".[0]   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]      AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "[0]   ");  Node  emptyStringNode  =  Node.newString( ".[0]   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "[0]   ");    Node  emptyStringNode  =  Node.newString( ".[0]   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	62	None	add
255	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "[0]   ");  Node  emptyStringNode  =  Node.newString( ",[0]   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]        AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "[0]   ");  Node  emptyStringNode  =  Node.newString( ",[0]   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "[0]   ");    Node  emptyStringNode  =  Node.newString( ",[0]   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	62	None	add
256	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "[0]   ");  Node  emptyStringNode  =  Node.newString(. "[0]   ");  [CE]  illegal  start  of  expression  [FE]          AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "[0]   ");  Node  emptyStringNode  =  Node.newString(. "[0]   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "[0]   ");    Node  emptyStringNode  =  Node.newString(. "[0]   ");	  	non-compiled	[CE]  illegal  start  of  expression	62	None	add
257	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]                  AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ".ArrayList ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( ".ArrayList ");	  Node    emptyStringNode    =    Node.newString(       "java.util.ArrayList       ");    Node    emptyStringNode    =    Node.newString(.   "java.util.ArrayList       ");    	compilable	  [FE]  AssertionFailedError  	29	3	replace
258	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( ".ArrayList ");  [FE]  AssertionFailedError  [FE]                  AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ".ArrayList ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( ".ArrayList ");	  Node    emptyStringNode    =    Node.newString(       "java.util.ArrayList       ");    Node    emptyStringNode    =    Node.newString(.   "java.util.ArrayList       ");    	compilable	  [FE]  AssertionFailedError  	29	3	replace
259	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(. "java.util.ArrayList ");  [CE]  illegal  start  of  expression  [FE]                    AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(. "java.util.ArrayList ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(. "java.util.ArrayList ");	  Node    emptyStringNode    =    Node.newString(       "java.util.ArrayList       ");    Node    emptyStringNode    =    Node.newString(.   "java.util.ArrayList       ");    	non-compiled	[CE]  illegal  start  of  expression	29	None	replace
260	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "array ",  arrayFoldedChildren.size()  -  1);  [CE]  no  suitable  method  found  for  newString(String,int)  [FE]        junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "array ",  arrayFoldedChildren.size()  -  1);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "array ",  arrayFoldedChildren.size()  -  1);	  Node    emptyStringNode    =    Node.newString(       "array       ");    Node    emptyStringNode    =    Node.newString(   "array       ");    	non-compiled	[CE]  no  suitable  method  found  for  newString(String,int)	12	None	replace
261	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "array ",  arrayFoldedChildren.size());  [CE]  no  suitable  method  found  for  newString(String,int)  [FE]          junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "array ",  arrayFoldedChildren.size());  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "array ",  arrayFoldedChildren.size());	  Node    emptyStringNode    =    Node.newString(       "array       ");    Node    emptyStringNode    =    Node.newString(   "array       ");    	non-compiled	[CE]  no  suitable  method  found  for  newString(String,int)	12	None	replace
262	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.ArrayElement ",  foldedSize);  [CE]  no  suitable  method  found  for  newString(String,int)  [FE]          junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.ArrayElement ",  foldedSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "java.util.ArrayElement ",  foldedSize);	  Node    emptyStringNode    =    Node.newString(       "java.util.ArrayElement       ");    Node    emptyStringNode    =    Node.newString(   ".java.util.ArrayElement       ");    	non-compiled	[CE]  no  suitable  method  found  for  newString(String,int)	21	None	replace
263	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]            junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "Join.ArrayElement ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "Join.ArrayElement ");	  Node    emptyStringNode    =    Node.newString(       "java.util.ArrayElement       ");    Node    emptyStringNode    =    Node.newString(   ".java.util.ArrayElement       ");    	compilable	  [FE]  AssertionFailedError  	21	3	replace
264	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "Join.ArrayElement ");  [FE]  AssertionFailedError  [FE]            junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "Join.ArrayElement ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "Join.ArrayElement ");	  Node    emptyStringNode    =    Node.newString(       "java.util.ArrayElement       ");    Node    emptyStringNode    =    Node.newString(   ".java.util.ArrayElement       ");    	compilable	  [FE]  AssertionFailedError  	21	3	replace
265	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]              junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.ArrayElement. ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "java.util.ArrayElement. ");	  Node    emptyStringNode    =    Node.newString(       "java.util.ArrayElement       ");    Node    emptyStringNode    =    Node.newString(   ".java.util.ArrayElement       ");    	compilable	  [FE]  AssertionFailedError  	21	3	replace
266	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.ArrayElement. ");  [FE]  AssertionFailedError  [FE]              junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.ArrayElement. ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "java.util.ArrayElement. ");	  Node    emptyStringNode    =    Node.newString(       "java.util.ArrayElement       ");    Node    emptyStringNode    =    Node.newString(   ".java.util.ArrayElement       ");    	compilable	  [FE]  AssertionFailedError  	21	3	replace
267	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "node()   ");  Node  emptyStringNode  =  Node.newString(   "node()   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "node()   ");  Node  emptyStringNode  =  Node.newString(   "node()   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "node()   ");    Node  emptyStringNode  =  Node.newString(   "node()   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	200	None	add
268	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "node()   ");  Node  emptyStringNode  =  Node.newString( ".node()   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]      AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "node()   ");  Node  emptyStringNode  =  Node.newString( ".node()   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "node()   ");    Node  emptyStringNode  =  Node.newString( ".node()   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	200	None	add
269	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "node()   ");  Node  emptyStringNode  =  Node.newString( ",node()   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]        AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "node()   ");  Node  emptyStringNode  =  Node.newString( ",node()   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "node()   ");    Node  emptyStringNode  =  Node.newString( ",node()   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	200	None	add
270	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "node()   ");  Node  emptyStringNode  =  Node.newString(. "node()   ");  [CE]  illegal  start  of  expression  [FE]          AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "node()   ");  Node  emptyStringNode  =  Node.newString(. "node()   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "node()   ");    Node  emptyStringNode  =  Node.newString(. "node()   ");	  	non-compiled	[CE]  illegal  start  of  expression	200	None	add
271	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "node()   ");  Node  emptyStringNode  =  Node.newString(? "node()   ");  [CE]  illegal  start  of  expression  [FE]            AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "node()   ");  Node  emptyStringNode  =  Node.newString(? "node()   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "node()   ");    Node  emptyStringNode  =  Node.newString(? "node()   ");	  	non-compiled	[CE]  illegal  start  of  expression	200	None	add
272	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "node()   ");  Node  emptyStringNode  =  Node.newString(... "node()   ");  [CE]  illegal  start  of  expression  [FE]              AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "node()   ");  Node  emptyStringNode  =  Node.newString(... "node()   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "node()   ");    Node  emptyStringNode  =  Node.newString(... "node()   ");	  	non-compiled	[CE]  illegal  start  of  expression	200	None	add
273	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "ArrayBuilders ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "ArrayBuilders ");	  Node    emptyStringNode    =    Node.newString(   "java.util.ArrayBuilders   ");    	compilable	  [FE]  AssertionFailedError  	170	3	replace
274	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "ArrayBuilders ");  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "ArrayBuilders ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "ArrayBuilders ");	  Node    emptyStringNode    =    Node.newString(   "java.util.ArrayBuilders   ");    	compilable	  [FE]  AssertionFailedError  	170	3	replace
275	[BUG]  [BUGGY]  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]      AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "org.join.ArrayBuilders ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "org.join.ArrayBuilders ");	  Node    emptyStringNode    =    Node.newString(   "java.util.ArrayBuilders   ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	170	3	replace
276	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "org.join.ArrayBuilders ");  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]      AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "org.join.ArrayBuilders ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "org.join.ArrayBuilders ");	  Node    emptyStringNode    =    Node.newString(   "java.util.ArrayBuilders   ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	170	3	replace
277	[BUG]  [BUGGY]  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]        AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "JoinArrayBuilders ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "JoinArrayBuilders ");	  Node    emptyStringNode    =    Node.newString(   "java.util.ArrayBuilders   ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	170	3	replace
278	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "JoinArrayBuilders ");  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]        AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "JoinArrayBuilders ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "JoinArrayBuilders ");	  Node    emptyStringNode    =    Node.newString(   "java.util.ArrayBuilders   ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	170	3	replace
279	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "Array   ").copyInformationFrom(prev);  Node  emptyStringNode  =  Node.newString(   "Array   ").copyInformationFrom(prev);  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]    java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "Array   ").copyInformationFrom(prev);  Node  emptyStringNode  =  Node.newString(   "Array   ").copyInformationFrom(prev);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "Array   ").copyInformationFrom(prev);    Node  emptyStringNode  =  Node.newString(   "Array   ").copyInformationFrom(prev);	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	165	None	add
280	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "Array   ").copyInformationFrom(prev);  Node  emptyStringNode  =  Node.newString( ".Array   ").copyInformationFrom(prev);  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]      java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "Array   ").copyInformationFrom(prev);  Node  emptyStringNode  =  Node.newString( ".Array   ").copyInformationFrom(prev);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "Array   ").copyInformationFrom(prev);    Node  emptyStringNode  =  Node.newString( ".Array   ").copyInformationFrom(prev);	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	165	None	add
281	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "Array   ").copyInformationFrom(prev);  Node  emptyStringNode  =  Node.newString( ",Array   ").copyInformationFrom(prev);  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]        java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "Array   ").copyInformationFrom(prev);  Node  emptyStringNode  =  Node.newString( ",Array   ").copyInformationFrom(prev);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "Array   ").copyInformationFrom(prev);    Node  emptyStringNode  =  Node.newString( ",Array   ").copyInformationFrom(prev);	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	165	None	add
282	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "Array   ").copyInformationFrom(prev);  Node  emptyStringNode  =  Node.newString(. "Array   ").copyInformationFrom(prev);  [CE]  illegal  start  of  expression  [FE]          java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "Array   ").copyInformationFrom(prev);  Node  emptyStringNode  =  Node.newString(. "Array   ").copyInformationFrom(prev);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "Array   ").copyInformationFrom(prev);    Node  emptyStringNode  =  Node.newString(. "Array   ").copyInformationFrom(prev);	  	non-compiled	[CE]  illegal  start  of  expression	165	None	add
283	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList( "),  arrayFoldedChildren.size());  [CE]  [FE]        junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList( "),  arrayFoldedChildren.size());  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList( "),  arrayFoldedChildren.size());	  Node    emptyStringNode    =    Node.newString(       "java.util.Arrays.asList(       ");    Node    emptyStringNode    =    Node.newString(   "java.util.Arrays.asList(       ");    	non-compiled	[CE]  	76	None	replace
284	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList( ", ");  [CE]  unclosed  string  literal  [FE]          junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList( ", ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList( ", ");	  Node    emptyStringNode    =    Node.newString(       "java.util.Arrays.asList(       ");    Node    emptyStringNode    =    Node.newString(   "java.util.Arrays.asList(       ");    	non-compiled	[CE]  unclosed  string  literal	76	None	replace
285	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "string ").replaceChild(n,  originalSize);  [CE]  method  replaceChild  in  class  Node  cannot  be  applied  to  given  types;  [FE]            AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "string ").replaceChild(n,  originalSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "string ").replaceChild(n,  originalSize);	  Node    emptyStringNode    =    Node.newString(   "string   ").replaceChild(n,    foldedSize);    	non-compiled	[CE]  method  replaceChild  in  class  Node  cannot  be  applied  to  given  types;	110	None	replace
286	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "string ").replaceChild(n,  foldedSize,  originalSize);  [CE]  method  replaceChild  in  class  Node  cannot  be  applied  to  given  types;  [FE]              AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "string ").replaceChild(n,  foldedSize,  originalSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "string ").replaceChild(n,  foldedSize,  originalSize);	  Node    emptyStringNode    =    Node.newString(   "string   ").replaceChild(n,    foldedSize);    	non-compiled	[CE]  method  replaceChild  in  class  Node  cannot  be  applied  to  given  types;	110	None	replace
287	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "string ").replaceChild(n,  leftStringNode);  [CE]  cannot  find  symbol  leftStringNode  [FE]                AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "string ").replaceChild(n,  leftStringNode);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "string ").replaceChild(n,  leftStringNode);	  Node    emptyStringNode    =    Node.newString(   "string   ").replaceChild(n,    foldedSize);    	non-compiled	[CE]  cannot  find  symbol  leftStringNode	110	None	replace
288	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "string ").replaceChild(n,  foldedSize,  prev);  [CE]  method  replaceChild  in  class  Node  cannot  be  applied  to  given  types;  [FE]                  AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "string ").replaceChild(n,  foldedSize,  prev);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "string ").replaceChild(n,  foldedSize,  prev);	  Node    emptyStringNode    =    Node.newString(   "string   ").replaceChild(n,    foldedSize);    	non-compiled	[CE]  method  replaceChild  in  class  Node  cannot  be  applied  to  given  types;	110	None	replace
289	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "]   "  +  Token.NAME);  Node  emptyStringNode  =  Node.newString(   "]   "  +  Token.NAME);  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "]   "  +  Token.NAME);  Node  emptyStringNode  =  Node.newString(   "]   "  +  Token.NAME);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "]   "    +    Token.NAME);    Node  emptyStringNode  =  Node.newString(   "]   "  +  Token.NAME);	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	153	None	add
290	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "]   "  +  Token.NAME);  Node  emptyStringNode  =  Node.newString( ".]   "  +  Token.NAME);  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]      AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "]   "  +  Token.NAME);  Node  emptyStringNode  =  Node.newString( ".]   "  +  Token.NAME);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "]   "    +    Token.NAME);    Node  emptyStringNode  =  Node.newString( ".]   "  +  Token.NAME);	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	153	None	add
291	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "]   "  +  Token.NAME);  Node  emptyStringNode  =  Node.newString( ",]   "  +  Token.NAME);  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]        AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "]   "  +  Token.NAME);  Node  emptyStringNode  =  Node.newString( ",]   "  +  Token.NAME);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "]   "    +    Token.NAME);    Node  emptyStringNode  =  Node.newString( ",]   "  +  Token.NAME);	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	153	None	add
292	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "]   "  +  Token.NAME);  Node  emptyStringNode  =  Node.newString(. "]   "  +  Token.NAME);  [CE]  illegal  start  of  expression  [FE]          AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "]   "  +  Token.NAME);  Node  emptyStringNode  =  Node.newString(. "]   "  +  Token.NAME);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "]   "    +    Token.NAME);    Node  emptyStringNode  =  Node.newString(. "]   "  +  Token.NAME);	  	non-compiled	[CE]  illegal  start  of  expression	153	None	add
293	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "]   "  +  Token.NAME);  Node  emptyStringNode  =  Node.newString(... "]   "  +  Token.NAME);  [CE]  illegal  start  of  expression  [FE]            AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "]   "  +  Token.NAME);  Node  emptyStringNode  =  Node.newString(... "]   "  +  Token.NAME);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "]   "    +    Token.NAME);    Node  emptyStringNode  =  Node.newString(... "]   "  +  Token.NAME);	  	non-compiled	[CE]  illegal  start  of  expression	153	None	add
294	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "]   "  +  Token.NAME);  Node  emptyStringNode  =  Node.newString(   "]   ")  +  Token.NAME);  [CE]  [FE]              AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "]   "  +  Token.NAME);  Node  emptyStringNode  =  Node.newString(   "]   ")  +  Token.NAME);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "]   "    +    Token.NAME);    Node  emptyStringNode  =  Node.newString(   "]   ")  +  Token.NAME);	  	non-compiled	[CE]  	153	None	add
295	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "Arrays.asList( ", ");  [CE]  unclosed  string  literal  [FE]                junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "Arrays.asList( ", ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "Arrays.asList( ", ");	  Node    emptyStringNode    =    Node.newString(       "java.util.Arrays.asList(       ");    Node    emptyStringNode    =    Node.newString(   "java.util.Arrays.asList(   ",);    	non-compiled	[CE]  unclosed  string  literal	80	None	replace
296	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "Arrays.asList( ",);  [CE]  illegal  start  of  expression  [FE]                  junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "Arrays.asList( ",);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "Arrays.asList( ",);	  Node    emptyStringNode    =    Node.newString(       "java.util.Arrays.asList(       ");    Node    emptyStringNode    =    Node.newString(   "java.util.Arrays.asList(   ",);    	non-compiled	[CE]  illegal  start  of  expression	80	None	replace
297	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "Arrays.asList( ",  originalSize);  [CE]  no  suitable  method  found  for  newString(String,int)  [FE]                    junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "Arrays.asList( ",  originalSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "Arrays.asList( ",  originalSize);	  Node    emptyStringNode    =    Node.newString(       "java.util.Arrays.asList(       ");    Node    emptyStringNode    =    Node.newString(   "java.util.Arrays.asList(   ",);    	non-compiled	[CE]  no  suitable  method  found  for  newString(String,int)	80	None	replace
298	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "Arrays.asList( ",  n);  [CE]  no  suitable  method  found  for  newString(String,Node)  [FE]                      junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "Arrays.asList( ",  n);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "Arrays.asList( ",  n);	  Node    emptyStringNode    =    Node.newString(       "java.util.Arrays.asList(       ");    Node    emptyStringNode    =    Node.newString(   "java.util.Arrays.asList(   ",);    	non-compiled	[CE]  no  suitable  method  found  for  newString(String,Node)	80	None	replace
299	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "Arrays.asList( ",  foldedSize);  [CE]  no  suitable  method  found  for  newString(String,int)  [FE]                        junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "Arrays.asList( ",  foldedSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "Arrays.asList( ",  foldedSize);	  Node    emptyStringNode    =    Node.newString(       "java.util.Arrays.asList(       ");    Node    emptyStringNode    =    Node.newString(   "java.util.Arrays.asList(   ",);    	non-compiled	[CE]  no  suitable  method  found  for  newString(String,int)	80	None	replace
300	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.ArrayList ",  foldedSize,  originalSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "java.util.ArrayList ",  foldedSize,  originalSize);	  Node    emptyStringNode    =    Node.newString(   "java.util.ArrayList   ",    originalSize);    	compilable	  [FE]  AssertionFailedError  	127	3	replace
301	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.ArrayList ",  foldedSize,  originalSize);  [FE]  AssertionFailedError  [FE]          AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.ArrayList ",  foldedSize,  originalSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "java.util.ArrayList ",  foldedSize,  originalSize);	  Node    emptyStringNode    =    Node.newString(   "java.util.ArrayList   ",    originalSize);    	compilable	  [FE]  AssertionFailedError  	127	3	replace
302	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]            AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "ArrayList ",  foldedSize,  originalSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "ArrayList ",  foldedSize,  originalSize);	  Node    emptyStringNode    =    Node.newString(   "java.util.ArrayList   ",    originalSize);    	compilable	  [FE]  AssertionFailedError  	127	3	replace
303	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "ArrayList ",  foldedSize,  originalSize);  [FE]  AssertionFailedError  [FE]            AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "ArrayList ",  foldedSize,  originalSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "ArrayList ",  foldedSize,  originalSize);	  Node    emptyStringNode    =    Node.newString(   "java.util.ArrayList   ",    originalSize);    	compilable	  [FE]  AssertionFailedError  	127	3	replace
304	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME,  functionName);  [CE]  no  suitable  method  found  for  newString(int,Node)  [FE]    junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME,  functionName);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(Token.NAME,  functionName);	  Node    emptyStringNode    =    Node.newString(Token.NAME,   "]   ");    	non-compiled	[CE]  no  suitable  method  found  for  newString(int,Node)	157	None	replace
305	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME,  suffix);  [CE]  cannot  find  symbol  suffix  [FE]      junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME,  suffix);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(Token.NAME,  suffix);	  Node    emptyStringNode    =    Node.newString(Token.NAME,   "]   ");    	non-compiled	[CE]  cannot  find  symbol  suffix	157	None	replace
306	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME,  foldedSize  +  1);  [CE]  no  suitable  method  found  for  newString(int,int)  [FE]        junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME,  foldedSize  +  1);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(Token.NAME,  foldedSize  +  1);	  Node    emptyStringNode    =    Node.newString(Token.NAME,   "]   ");    	non-compiled	[CE]  no  suitable  method  found  for  newString(int,int)	157	None	replace
307	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(... "Array ");  [CE]  illegal  start  of  expression  [FE]                AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(... "Array ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(... "Array ");	  Node    emptyStringNode    =    Node.newString(       "Array       ");    Node    emptyStringNode    =    Node.newString(...   "Array       ");    	non-compiled	[CE]  illegal  start  of  expression	34	None	replace
308	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(]);  [CE]  illegal  start  of  expression  [FE]                  AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(]);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(]);	  Node    emptyStringNode    =    Node.newString(       "Array       ");    Node    emptyStringNode    =    Node.newString(...   "Array       ");    	non-compiled	[CE]  illegal  start  of  expression	34	None	replace
309	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "- ").replaceChild(n,  prev,  foldedSize);  [CE]  method  replaceChild  in  class  Node  cannot  be  applied  to  given  types;  [FE]          AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "- ").replaceChild(n,  prev,  foldedSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "- ").replaceChild(n,  prev,  foldedSize);	  Node    emptyStringNode    =    Node.newString(   "-   ").replaceChild(n,    prev);    	non-compiled	[CE]  method  replaceChild  in  class  Node  cannot  be  applied  to  given  types;	185	None	replace
310	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "- ").replaceChild(n,  prev,  left);  [CE]  cannot  find  symbol  left  [FE]            AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "- ").replaceChild(n,  prev,  left);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "- ").replaceChild(n,  prev,  left);	  Node    emptyStringNode    =    Node.newString(   "-   ").replaceChild(n,    prev);    	non-compiled	[CE]  cannot  find  symbol  left	185	None	replace
311	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "- ").replaceChild(n,  prev,  sb);  [CE]  method  replaceChild  in  class  Node  cannot  be  applied  to  given  types;  [FE]              AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "- ").replaceChild(n,  prev,  sb);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "- ").replaceChild(n,  prev,  sb);	  Node    emptyStringNode    =    Node.newString(   "-   ").replaceChild(n,    prev);    	non-compiled	[CE]  method  replaceChild  in  class  Node  cannot  be  applied  to  given  types;	185	None	replace
312	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "- ").replaceChild(n,  prev,  originalSize);  [CE]  method  replaceChild  in  class  Node  cannot  be  applied  to  given  types;  [FE]                AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "- ").replaceChild(n,  prev,  originalSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "- ").replaceChild(n,  prev,  originalSize);	  Node    emptyStringNode    =    Node.newString(   "-   ").replaceChild(n,    prev);    	non-compiled	[CE]  method  replaceChild  in  class  Node  cannot  be  applied  to  given  types;	185	None	replace
313	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "- ").replaceChild(n,  left,  prev);  [CE]  cannot  find  symbol  left  [FE]                  AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "- ").replaceChild(n,  left,  prev);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "- ").replaceChild(n,  left,  prev);	  Node    emptyStringNode    =    Node.newString(   "-   ").replaceChild(n,    prev);    	non-compiled	[CE]  cannot  find  symbol  left	185	None	replace
314	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "- ").replaceChild(prev,  n);  [CE]  incompatible  types  [FE]                    AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "- ").replaceChild(prev,  n);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "- ").replaceChild(prev,  n);	  Node    emptyStringNode    =    Node.newString(   "-   ").replaceChild(n,    prev);    	non-compiled	[CE]  incompatible  types	185	None	replace
315	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "] "));  [CE]  [FE]              AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "] "));  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "] "));	  Node    emptyStringNode    =    Node.newString(       "]       ");    Node    emptyStringNode    =    Node.newString(       "]       "));    	non-compiled	[CE]  	94	None	replace
316	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "- ").replaceChild(n,  originalSize);  [CE]  method  replaceChild  in  class  Node  cannot  be  applied  to  given  types;  [FE]              AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "- ").replaceChild(n,  originalSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "- ").replaceChild(n,  originalSize);	  Node    emptyStringNode    =    Node.newString(   "-   ").replaceChild(n,    foldedSize);    	non-compiled	[CE]  method  replaceChild  in  class  Node  cannot  be  applied  to  given  types;	50	None	replace
317	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "- ").replaceChild(n,  arrayFoldedChildren,  foldedSize);  [CE]  method  replaceChild  in  class  Node  cannot  be  applied  to  given  types;  [FE]                AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "- ").replaceChild(n,  arrayFoldedChildren,  foldedSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "- ").replaceChild(n,  arrayFoldedChildren,  foldedSize);	  Node    emptyStringNode    =    Node.newString(   "-   ").replaceChild(n,    foldedSize);    	non-compiled	[CE]  method  replaceChild  in  class  Node  cannot  be  applied  to  given  types;	50	None	replace
318	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "- ").replaceChild(n,  foldedSize,  originalSize);  [CE]  method  replaceChild  in  class  Node  cannot  be  applied  to  given  types;  [FE]                  AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "- ").replaceChild(n,  foldedSize,  originalSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "- ").replaceChild(n,  foldedSize,  originalSize);	  Node    emptyStringNode    =    Node.newString(   "-   ").replaceChild(n,    foldedSize);    	non-compiled	[CE]  method  replaceChild  in  class  Node  cannot  be  applied  to  given  types;	50	None	replace
319	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "- ").replaceChild(n,  foldedSize,  kJoinOverhead);  [CE]  cannot  find  symbol  kJoinOverhead  [FE]                    AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "- ").replaceChild(n,  foldedSize,  kJoinOverhead);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "- ").replaceChild(n,  foldedSize,  kJoinOverhead);	  Node    emptyStringNode    =    Node.newString(   "-   ").replaceChild(n,    foldedSize);    	non-compiled	[CE]  cannot  find  symbol  kJoinOverhead	50	None	replace
320	[BUG]  [BUGGY]  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('  [FE]    junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME,  sb.toString());  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString(Token.NAME,  sb.toString());	  Node    emptyStringNode    =    Node.newString(Token.NAME,   "ArrayBuilder   ");    	compilable	  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('  	168	3	replace
321	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME,  sb.toString());  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('  [FE]    junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME,  sb.toString());  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(Token.NAME,  sb.toString());	  Node    emptyStringNode    =    Node.newString(Token.NAME,   "ArrayBuilder   ");    	compilable	  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('  	168	3	replace
322	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "node   ");  Node  emptyStringNode  =  Node.newString(   "node   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "node   ");  Node  emptyStringNode  =  Node.newString(   "node   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "node   ");    Node  emptyStringNode  =  Node.newString(   "node   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	85	None	add
323	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "node   ");  Node  emptyStringNode  =  Node.newString( ".node   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]      AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "node   ");  Node  emptyStringNode  =  Node.newString( ".node   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "node   ");    Node  emptyStringNode  =  Node.newString( ".node   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	85	None	add
324	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "node   ");  Node  emptyStringNode  =  Node.newString( ",node   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]        AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "node   ");  Node  emptyStringNode  =  Node.newString( ",node   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "node   ");    Node  emptyStringNode  =  Node.newString( ",node   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	85	None	add
325	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "node   ");  Node  emptyStringNode  =  Node.newString(? "node   ");  [CE]  illegal  start  of  expression  [FE]          AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "node   ");  Node  emptyStringNode  =  Node.newString(? "node   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "node   ");    Node  emptyStringNode  =  Node.newString(? "node   ");	  	non-compiled	[CE]  illegal  start  of  expression	85	None	add
326	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "node   ");  Node  emptyStringNode  =  Node.newString(. "node   ");  [CE]  illegal  start  of  expression  [FE]            AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "node   ");  Node  emptyStringNode  =  Node.newString(. "node   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "node   ");    Node  emptyStringNode  =  Node.newString(. "node   ");	  	non-compiled	[CE]  illegal  start  of  expression	85	None	add
327	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "node   ");  Node  emptyStringNode  =  Node.newString(... "node   ");  [CE]  illegal  start  of  expression  [FE]              AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "node   ");  Node  emptyStringNode  =  Node.newString(... "node   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "node   ");    Node  emptyStringNode  =  Node.newString(... "node   ");	  	non-compiled	[CE]  illegal  start  of  expression	85	None	add
328	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "string ").replaceChild(n,  new  StringBuilder(sb));  [CE]  method  replaceChild  in  class  Node  cannot  be  applied  to  given  types;  [FE]        AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "string ").replaceChild(n,  new  StringBuilder(sb));  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "string ").replaceChild(n,  new  StringBuilder(sb));	  Node    emptyStringNode    =    Node.newString(   "string   ").replaceChild(n,    new    StringBuilder());    	non-compiled	[CE]  method  replaceChild  in  class  Node  cannot  be  applied  to  given  types;	196	None	replace
329	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "string ").replaceChild(n,  new  StringBuilder(prev));  [CE]  no  suitable  constructor  found  for  StringBuilder(Node)  [FE]          AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "string ").replaceChild(n,  new  StringBuilder(prev));  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "string ").replaceChild(n,  new  StringBuilder(prev));	  Node    emptyStringNode    =    Node.newString(   "string   ").replaceChild(n,    new    StringBuilder());    	non-compiled	[CE]  no  suitable  constructor  found  for  StringBuilder(Node)	196	None	replace
330	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "string ").replaceChild(n,  originalSize,  new  StringBuilder());  [CE]  method  replaceChild  in  class  Node  cannot  be  applied  to  given  types;  [FE]            AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "string ").replaceChild(n,  originalSize,  new  StringBuilder());  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "string ").replaceChild(n,  originalSize,  new  StringBuilder());	  Node    emptyStringNode    =    Node.newString(   "string   ").replaceChild(n,    new    StringBuilder());    	non-compiled	[CE]  method  replaceChild  in  class  Node  cannot  be  applied  to  given  types;	196	None	replace
331	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "string ").replaceChild(n,  arrayFoldedChildren,  new  StringBuilder());  [CE]  method  replaceChild  in  class  Node  cannot  be  applied  to  given  types;  [FE]              AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "string ").replaceChild(n,  arrayFoldedChildren,  new  StringBuilder());  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "string ").replaceChild(n,  arrayFoldedChildren,  new  StringBuilder());	  Node    emptyStringNode    =    Node.newString(   "string   ").replaceChild(n,    new    StringBuilder());    	non-compiled	[CE]  method  replaceChild  in  class  Node  cannot  be  applied  to  given  types;	196	None	replace
332	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "string ").replaceChild(n,  prev,  new  StringBuilder());  [CE]  method  replaceChild  in  class  Node  cannot  be  applied  to  given  types;  [FE]                AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "string ").replaceChild(n,  prev,  new  StringBuilder());  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "string ").replaceChild(n,  prev,  new  StringBuilder());	  Node    emptyStringNode    =    Node.newString(   "string   ").replaceChild(n,    new    StringBuilder());    	non-compiled	[CE]  method  replaceChild  in  class  Node  cannot  be  applied  to  given  types;	196	None	replace
333	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "string ").replaceChild(n,  sb,  new  StringBuilder());  [CE]  method  replaceChild  in  class  Node  cannot  be  applied  to  given  types;  [FE]                  AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "string ").replaceChild(n,  sb,  new  StringBuilder());  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "string ").replaceChild(n,  sb,  new  StringBuilder());	  Node    emptyStringNode    =    Node.newString(   "string   ").replaceChild(n,    new    StringBuilder());    	non-compiled	[CE]  method  replaceChild  in  class  Node  cannot  be  applied  to  given  types;	196	None	replace
334	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "string ").replaceChild(n,  new  StringBuilder(),  foldedSize);  [CE]  method  replaceChild  in  class  Node  cannot  be  applied  to  given  types;  [FE]                    AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "string ").replaceChild(n,  new  StringBuilder(),  foldedSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "string ").replaceChild(n,  new  StringBuilder(),  foldedSize);	  Node    emptyStringNode    =    Node.newString(   "string   ").replaceChild(n,    new    StringBuilder());    	non-compiled	[CE]  method  replaceChild  in  class  Node  cannot  be  applied  to  given  types;	196	None	replace
335	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList( ") "));  [CE]  unclosed  string  literal  [FE]            junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList( ") "));  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList( ") "));	  Node    emptyStringNode    =    Node.newString(       "java.util.Arrays.asList(       ");    Node    emptyStringNode    =    Node.newString(   ")java.util.Arrays.asList(       ");    	non-compiled	[CE]  unclosed  string  literal	173	None	replace
336	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList( "),  java.util.Arrays.asList( ");  [CE]  [FE]              junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList( "),  java.util.Arrays.asList( ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList( "),  java.util.Arrays.asList( ");	  Node    emptyStringNode    =    Node.newString(       "java.util.Arrays.asList(       ");    Node    emptyStringNode    =    Node.newString(   ")java.util.Arrays.asList(       ");    	non-compiled	[CE]  	173	None	replace
337	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList(prev) ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList(prev) ");	  Node    emptyStringNode    =    Node.newString(   "java.util.Arrays.asList(n   ");    	compilable	  [FE]  AssertionFailedError  	151	3	replace
338	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList(prev) ");  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList(prev) ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList(prev) ");	  Node    emptyStringNode    =    Node.newString(   "java.util.Arrays.asList(n   ");    	compilable	  [FE]  AssertionFailedError  	151	3	replace
339	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList(n) ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList(n) ");	  Node    emptyStringNode    =    Node.newString(   "java.util.Arrays.asList(n   ");    	compilable	  [FE]  AssertionFailedError  	151	3	replace
340	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList(n) ");  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList(n) ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList(n) ");	  Node    emptyStringNode    =    Node.newString(   "java.util.Arrays.asList(n   ");    	compilable	  [FE]  AssertionFailedError  	151	3	replace
341	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "Arrays.asList(n) ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "Arrays.asList(n) ");	  Node    emptyStringNode    =    Node.newString(   "java.util.Arrays.asList(n   ");    	compilable	  [FE]  AssertionFailedError  	151	3	replace
342	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "Arrays.asList(n) ");  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "Arrays.asList(n) ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "Arrays.asList(n) ");	  Node    emptyStringNode    =    Node.newString(   "java.util.Arrays.asList(n   ");    	compilable	  [FE]  AssertionFailedError  	151	3	replace
343	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList(n,  originalSize));  [CE]  unclosed  string  literal  [FE]          AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList(n,  originalSize));  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList(n,  originalSize));	  Node    emptyStringNode    =    Node.newString(   "java.util.Arrays.asList(n   ");    	non-compiled	[CE]  unclosed  string  literal	151	None	replace
344	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList(x,  n));  [CE]  unclosed  string  literal  [FE]            AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList(x,  n));  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList(x,  n));	  Node    emptyStringNode    =    Node.newString(   "java.util.Arrays.asList(n   ");    	non-compiled	[CE]  unclosed  string  literal	151	None	replace
345	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList(arrayFoldedChildren.size()  -  1);  [CE]  unclosed  string  literal  [FE]              AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList(arrayFoldedChildren.size()  -  1);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList(arrayFoldedChildren.size()  -  1);	  Node    emptyStringNode    =    Node.newString(   "java.util.Arrays.asList(n   ");    	non-compiled	[CE]  unclosed  string  literal	151	None	replace
346	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "java.util.Arrays.asList(n   ");  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList(n   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "java.util.Arrays.asList(n   ");  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList(n   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "java.util.Arrays.asList(n   ");    Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList(n   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	150	None	add
347	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "java.util.Arrays.asList(n   ");  Node  emptyStringNode  =  Node.newString( ".java.util.Arrays.asList(n   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]      AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "java.util.Arrays.asList(n   ");  Node  emptyStringNode  =  Node.newString( ".java.util.Arrays.asList(n   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "java.util.Arrays.asList(n   ");    Node  emptyStringNode  =  Node.newString( ".java.util.Arrays.asList(n   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	150	None	add
348	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "java.util.Arrays.asList(n   ");  Node  emptyStringNode  =  Node.newString( ",java.util.Arrays.asList(n   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]        AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "java.util.Arrays.asList(n   ");  Node  emptyStringNode  =  Node.newString( ",java.util.Arrays.asList(n   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "java.util.Arrays.asList(n   ");    Node  emptyStringNode  =  Node.newString( ",java.util.Arrays.asList(n   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	150	None	add
349	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "java.util.Arrays.asList(n   ");  Node  emptyStringNode  =  Node.newString(java.util.Arrays.asList(n   ");  [CE]  unclosed  string  literal  [FE]          AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "java.util.Arrays.asList(n   ");  Node  emptyStringNode  =  Node.newString(java.util.Arrays.asList(n   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "java.util.Arrays.asList(n   ");    Node  emptyStringNode  =  Node.newString(java.util.Arrays.asList(n   ");	  	non-compiled	[CE]  unclosed  string  literal	150	None	add
350	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "java.util.Arrays.asList(n   ");  Node  emptyStringNode  =  Node.newString(... "java.util.Arrays.asList(n   ");  [CE]  illegal  start  of  expression  [FE]            AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "java.util.Arrays.asList(n   ");  Node  emptyStringNode  =  Node.newString(... "java.util.Arrays.asList(n   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "java.util.Arrays.asList(n   ");    Node  emptyStringNode  =  Node.newString(... "java.util.Arrays.asList(n   ");	  	non-compiled	[CE]  illegal  start  of  expression	150	None	add
351	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "java.util.Arrays.asList(n   ");  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList(n "));  [CE]  [FE]              AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "java.util.Arrays.asList(n   ");  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList(n "));  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "java.util.Arrays.asList(n   ");    Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList(n "));	  	non-compiled	[CE]  	150	None	add
352	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "java.util.Arrays.asList(n   ");  Node  emptyStringNode  =  Node.newString(? "java.util.Arrays.asList(n   ");  [CE]  illegal  start  of  expression  [FE]                AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "java.util.Arrays.asList(n   ");  Node  emptyStringNode  =  Node.newString(? "java.util.Arrays.asList(n   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "java.util.Arrays.asList(n   ");    Node  emptyStringNode  =  Node.newString(? "java.util.Arrays.asList(n   ");	  	non-compiled	[CE]  illegal  start  of  expression	150	None	add
353	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "JoinBuilder ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "JoinBuilder ");	  Node    emptyStringNode    =    Node.newString(   "ArrayBuilder   ");    	compilable	  [FE]  AssertionFailedError  	101	3	replace
354	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "JoinBuilder ");  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "JoinBuilder ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "JoinBuilder ");	  Node    emptyStringNode    =    Node.newString(   "ArrayBuilder   ");    	compilable	  [FE]  AssertionFailedError  	101	3	replace
355	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "ArrayBuffer ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "ArrayBuffer ");	  Node    emptyStringNode    =    Node.newString(   "ArrayBuilder   ");    	compilable	  [FE]  AssertionFailedError  	101	3	replace
356	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "ArrayBuffer ");  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "ArrayBuffer ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "ArrayBuffer ");	  Node    emptyStringNode    =    Node.newString(   "ArrayBuilder   ");    	compilable	  [FE]  AssertionFailedError  	101	3	replace
357	[BUG]  [BUGGY]  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]        AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "Folder ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "Folder ");	  Node    emptyStringNode    =    Node.newString(   "ArrayBuilder   ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	101	3	replace
358	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "Folder ");  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]        AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "Folder ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "Folder ");	  Node    emptyStringNode    =    Node.newString(   "ArrayBuilder   ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	101	3	replace
359	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "array-foo.   ");  Node  emptyStringNode  =  Node.newString(   "array-foo.   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "array-foo.   ");  Node  emptyStringNode  =  Node.newString(   "array-foo.   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "array-foo.   ");    Node  emptyStringNode  =  Node.newString(   "array-foo.   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	204	None	add
360	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "array-foo.   ");  Node  emptyStringNode  =  Node.newString( ".array-foo.   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]      AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "array-foo.   ");  Node  emptyStringNode  =  Node.newString( ".array-foo.   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "array-foo.   ");    Node  emptyStringNode  =  Node.newString( ".array-foo.   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	204	None	add
361	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "array-foo.   ");  Node  emptyStringNode  =  Node.newString( ",array-foo.   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]        AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "array-foo.   ");  Node  emptyStringNode  =  Node.newString( ",array-foo.   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "array-foo.   ");    Node  emptyStringNode  =  Node.newString( ",array-foo.   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	204	None	add
362	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "array-foo.   ");  Node  emptyStringNode  =  Node.newString(? "array-foo.   ");  [CE]  illegal  start  of  expression  [FE]          AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "array-foo.   ");  Node  emptyStringNode  =  Node.newString(? "array-foo.   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "array-foo.   ");    Node  emptyStringNode  =  Node.newString(? "array-foo.   ");	  	non-compiled	[CE]  illegal  start  of  expression	204	None	add
363	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "array-foo.   ");  Node  emptyStringNode  =  Node.newString(. "array-foo.   ");  [CE]  illegal  start  of  expression  [FE]            AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "array-foo.   ");  Node  emptyStringNode  =  Node.newString(. "array-foo.   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "array-foo.   ");    Node  emptyStringNode  =  Node.newString(. "array-foo.   ");	  	non-compiled	[CE]  illegal  start  of  expression	204	None	add
364	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.ArrayBuffer ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "java.util.ArrayBuffer ");	  Node    emptyStringNode    =    Node.newString(       "java.util.ArrayBuilder       ");    Node    emptyStringNode    =    Node.newString(   "java.util.ArrayBuilder       ");    	compilable	  [FE]  AssertionFailedError  	121	3	replace
365	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.ArrayBuffer ");  [FE]  AssertionFailedError  [FE]        junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.ArrayBuffer ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "java.util.ArrayBuffer ");	  Node    emptyStringNode    =    Node.newString(       "java.util.ArrayBuilder       ");    Node    emptyStringNode    =    Node.newString(   "java.util.ArrayBuilder       ");    	compilable	  [FE]  AssertionFailedError  	121	3	replace
366	[BUG]  [BUGGY]  [FE]  junit.framework.AssertionFailedError:  Expected:  x= " "  Result:  x= "  [FE]            junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ",java.util.ArrayElement ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( ",java.util.ArrayElement ");	  Node    emptyStringNode    =    Node.newString(       "java.util.ArrayElement       ");    Node    emptyStringNode    =    Node.newString(   ",java.util.ArrayElement       ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x= " "  Result:  x= "  	22	3	replace
367	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( ",java.util.ArrayElement ");  [FE]  junit.framework.AssertionFailedError:  Expected:  x= " "  Result:  x= "  [FE]            junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ",java.util.ArrayElement ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( ",java.util.ArrayElement ");	  Node    emptyStringNode    =    Node.newString(       "java.util.ArrayElement       ");    Node    emptyStringNode    =    Node.newString(   ",java.util.ArrayElement       ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x= " "  Result:  x= "  	22	3	replace
368	[BUG]  [BUGGY]  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]              junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ",ArrayElement ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( ",ArrayElement ");	  Node    emptyStringNode    =    Node.newString(       "java.util.ArrayElement       ");    Node    emptyStringNode    =    Node.newString(   ",java.util.ArrayElement       ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	22	3	replace
369	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( ",ArrayElement ");  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]              junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ",ArrayElement ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( ",ArrayElement ");	  Node    emptyStringNode    =    Node.newString(       "java.util.ArrayElement       ");    Node    emptyStringNode    =    Node.newString(   ",java.util.ArrayElement       ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	22	3	replace
370	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( ",java.util.ArrayElement ",  foldedSize);  [CE]  no  suitable  method  found  for  newString(String,int)  [FE]                junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ",java.util.ArrayElement ",  foldedSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( ",java.util.ArrayElement ",  foldedSize);	  Node    emptyStringNode    =    Node.newString(       "java.util.ArrayElement       ");    Node    emptyStringNode    =    Node.newString(   ",java.util.ArrayElement       ");    	non-compiled	[CE]  no  suitable  method  found  for  newString(String,int)	22	None	replace
371	[BUG]  [BUGGY]  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]                  junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ";java.util.ArrayElement ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( ";java.util.ArrayElement ");	  Node    emptyStringNode    =    Node.newString(       "java.util.ArrayElement       ");    Node    emptyStringNode    =    Node.newString(   ",java.util.ArrayElement       ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	22	3	replace
372	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( ";java.util.ArrayElement ");  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]                  junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ";java.util.ArrayElement ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( ";java.util.ArrayElement ");	  Node    emptyStringNode    =    Node.newString(       "java.util.ArrayElement       ");    Node    emptyStringNode    =    Node.newString(   ",java.util.ArrayElement       ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	22	3	replace
373	[BUG]  [BUGGY]  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]                    junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ",java.util.ArrayElement, ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( ",java.util.ArrayElement, ");	  Node    emptyStringNode    =    Node.newString(       "java.util.ArrayElement       ");    Node    emptyStringNode    =    Node.newString(   ",java.util.ArrayElement       ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	22	3	replace
374	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( ",java.util.ArrayElement, ");  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]                    junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ",java.util.ArrayElement, ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( ",java.util.ArrayElement, ");	  Node    emptyStringNode    =    Node.newString(       "java.util.ArrayElement       ");    Node    emptyStringNode    =    Node.newString(   ",java.util.ArrayElement       ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	22	3	replace
375	[BUG]  [BUGGY]  [FE]  junit.framework.AssertionFailedError:  Expected:  x= " "  Result:  x= "  [FE]                      junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ",ArrayElement, ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( ",ArrayElement, ");	  Node    emptyStringNode    =    Node.newString(       "java.util.ArrayElement       ");    Node    emptyStringNode    =    Node.newString(   ",java.util.ArrayElement       ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x= " "  Result:  x= "  	22	3	replace
376	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( ",ArrayElement, ");  [FE]  junit.framework.AssertionFailedError:  Expected:  x= " "  Result:  x= "  [FE]                      junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ",ArrayElement, ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( ",ArrayElement, ");	  Node    emptyStringNode    =    Node.newString(       "java.util.ArrayElement       ");    Node    emptyStringNode    =    Node.newString(   ",java.util.ArrayElement       ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x= " "  Result:  x= "  	22	3	replace
377	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.ArrayList ",  n,  foldedSize);  [CE]  no  suitable  method  found  for  newString(String,Node,int)  [FE]            AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.ArrayList ",  n,  foldedSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "java.util.ArrayList ",  n,  foldedSize);	  Node    emptyStringNode    =    Node.newString(   "java.util.ArrayList   ",    foldedSize);    	non-compiled	[CE]  no  suitable  method  found  for  newString(String,Node,int)	128	None	replace
378	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.ArrayList ",  foldedSize,  kJoinOverhead);  [CE]  cannot  find  symbol  kJoinOverhead  [FE]              AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.ArrayList ",  foldedSize,  kJoinOverhead);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "java.util.ArrayList ",  foldedSize,  kJoinOverhead);	  Node    emptyStringNode    =    Node.newString(   "java.util.ArrayList   ",    foldedSize);    	non-compiled	[CE]  cannot  find  symbol  kJoinOverhead	128	None	replace
379	[BUG]  [BUGGY]  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('  [FE]    java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "string "  +  sb.toString()  +  1);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "string "  +  sb.toString()  +  1);	  Node    emptyStringNode    =    Node.newString(   "string   "    +    sb.toString());    	compilable	  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('  	109	3	replace
380	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "string "  +  sb.toString()  +  1);  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('  [FE]    java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "string "  +  sb.toString()  +  1);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "string "  +  sb.toString()  +  1);	  Node    emptyStringNode    =    Node.newString(   "string   "    +    sb.toString());    	compilable	  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('  	109	3	replace
381	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "string "  +  sb.toString())+  1;  [CE]  bad  operand  types  for  binary  operator  [FE]      java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "string "  +  sb.toString())+  1;  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "string "  +  sb.toString())+  1;	  Node    emptyStringNode    =    Node.newString(   "string   "    +    sb.toString());    	non-compiled	[CE]  bad  operand  types  for  binary  operator  	109	None	replace
382	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "string ")+  sb.toString();  [CE]  incompatible  types  [FE]        java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "string ")+  sb.toString();  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "string ")+  sb.toString();	  Node    emptyStringNode    =    Node.newString(   "string   "    +    sb.toString());    	non-compiled	[CE]  incompatible  types	109	None	replace
383	[BUG]  [BUGGY]  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('  [FE]          java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "string "  +  sb.toString()  +  2);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "string "  +  sb.toString()  +  2);	  Node    emptyStringNode    =    Node.newString(   "string   "    +    sb.toString());    	compilable	  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('  	109	3	replace
384	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "string "  +  sb.toString()  +  2);  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('  [FE]          java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "string "  +  sb.toString()  +  2);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "string "  +  sb.toString()  +  2);	  Node    emptyStringNode    =    Node.newString(   "string   "    +    sb.toString());    	compilable	  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('  	109	3	replace
385	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "string "  +  sb.toString()).replaceChild(n,  foldedSize);  [CE]  method  replaceChild  in  class  Node  cannot  be  applied  to  given  types;  [FE]            java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "string "  +  sb.toString()).replaceChild(n,  foldedSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "string "  +  sb.toString()).replaceChild(n,  foldedSize);	  Node    emptyStringNode    =    Node.newString(   "string   "    +    sb.toString());    	non-compiled	[CE]  method  replaceChild  in  class  Node  cannot  be  applied  to  given  types;	109	None	replace
386	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "string ",  sb.toString());  [CE]  no  suitable  method  found  for  newString(String,String)  [FE]              java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "string ",  sb.toString());  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "string ",  sb.toString());	  Node    emptyStringNode    =    Node.newString(   "string   "    +    sb.toString());    	non-compiled	[CE]  no  suitable  method  found  for  newString(String,String)	109	None	replace
387	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "[node]   ");  Node  emptyStringNode  =  Node.newString( "[node]   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "[node]   ");  Node  emptyStringNode  =  Node.newString( "[node]   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "[node]   ");    Node  emptyStringNode  =  Node.newString( "[node]   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	175	None	add
388	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "[node]   ");  Node  emptyStringNode  =  Node.newString( ".[node]   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]      AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "[node]   ");  Node  emptyStringNode  =  Node.newString( ".[node]   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "[node]   ");    Node  emptyStringNode  =  Node.newString( ".[node]   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	175	None	add
389	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "[node]   ");  Node  emptyStringNode  =  Node.newString( ",[node]   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]        AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "[node]   ");  Node  emptyStringNode  =  Node.newString( ",[node]   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "[node]   ");    Node  emptyStringNode  =  Node.newString( ",[node]   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	175	None	add
390	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "[node]   ");  Node  emptyStringNode  =  Node.newString( "[node] ",);  [CE]  illegal  start  of  expression  [FE]          AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "[node]   ");  Node  emptyStringNode  =  Node.newString( "[node] ",);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "[node]   ");    Node  emptyStringNode  =  Node.newString( "[node] ",);	  	non-compiled	[CE]  illegal  start  of  expression	175	None	add
391	[BUG]  [BUGGY]  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]        AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "no_array ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "no_array ");	  Node    emptyStringNode    =    Node.newString(       "n       ");    Node    emptyStringNode    =    Node.newString(   "n       ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	16	3	replace
392	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "no_array ");  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]        AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "no_array ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "no_array ");	  Node    emptyStringNode    =    Node.newString(       "n       ");    Node    emptyStringNode    =    Node.newString(   "n       ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	16	3	replace
393	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "node. ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "node. ");	  Node    emptyStringNode    =    Node.newString(       "n       ");    Node    emptyStringNode    =    Node.newString(   "n       ");    	compilable	  [FE]  AssertionFailedError  	16	3	replace
394	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "node. ");  [FE]  AssertionFailedError  [FE]          AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "node. ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "node. ");	  Node    emptyStringNode    =    Node.newString(       "n       ");    Node    emptyStringNode    =    Node.newString(   "n       ");    	compilable	  [FE]  AssertionFailedError  	16	3	replace
395	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "node ",  originalSize);  [CE]  no  suitable  method  found  for  newString(String,int)  [FE]            AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "node ",  originalSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "node ",  originalSize);	  Node    emptyStringNode    =    Node.newString(       "n       ");    Node    emptyStringNode    =    Node.newString(   "n       ");    	non-compiled	[CE]  no  suitable  method  found  for  newString(String,int)	16	None	replace
396	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "Arrays. ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "Arrays. ");	  Node    emptyStringNode    =    Node.newString(   "Arrays   ");    	compilable	  [FE]  AssertionFailedError  	192	3	replace
397	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "Arrays. ");  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "Arrays. ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "Arrays. ");	  Node    emptyStringNode    =    Node.newString(   "Arrays   ");    	compilable	  [FE]  AssertionFailedError  	192	3	replace
398	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME, "Arrays ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString(Token.NAME, "Arrays ");	  Node    emptyStringNode    =    Node.newString(   "Arrays   ");    	compilable	  [FE]  AssertionFailedError  	192	3	replace
399	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME, "Arrays ");  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME, "Arrays ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(Token.NAME, "Arrays ");	  Node    emptyStringNode    =    Node.newString(   "Arrays   ");    	compilable	  [FE]  AssertionFailedError  	192	3	replace
400	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]              AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ".Array ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( ".Array ");	  Node    emptyStringNode    =    Node.newString(       "Array       ");    Node    emptyStringNode    =    Node.newString(.   "Array       ");    	compilable	  [FE]  AssertionFailedError  	33	3	replace
401	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( ".Array ");  [FE]  AssertionFailedError  [FE]              AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ".Array ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( ".Array ");	  Node    emptyStringNode    =    Node.newString(       "Array       ");    Node    emptyStringNode    =    Node.newString(.   "Array       ");    	compilable	  [FE]  AssertionFailedError  	33	3	replace
402	[BUG]  [BUGGY]  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]            AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ",string ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( ",string ");	  Node    emptyStringNode    =    Node.newString(       "string       ");    Node    emptyStringNode    =    Node.newString(   ",string       ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	89	3	replace
403	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( ",string ");  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]            AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ",string ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( ",string ");	  Node    emptyStringNode    =    Node.newString(       "string       ");    Node    emptyStringNode    =    Node.newString(   ",string       ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	89	3	replace
404	[BUG]  [BUGGY]  [FE]  junit.framework.AssertionFailedError:  Expected:  x= " "  Result:  x= "  [FE]              AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ",null ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( ",null ");	  Node    emptyStringNode    =    Node.newString(       "string       ");    Node    emptyStringNode    =    Node.newString(   ",string       ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x= " "  Result:  x= "  	89	3	replace
405	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( ",null ");  [FE]  junit.framework.AssertionFailedError:  Expected:  x= " "  Result:  x= "  [FE]              AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ",null ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( ",null ");	  Node    emptyStringNode    =    Node.newString(       "string       ");    Node    emptyStringNode    =    Node.newString(   ",string       ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x= " "  Result:  x= "  	89	3	replace
406	[BUG]  [BUGGY]  [FE]  junit.framework.AssertionFailedError:  Expected:  x= " "  Result:  x= "  [FE]                AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ",originalSize ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( ",originalSize ");	  Node    emptyStringNode    =    Node.newString(       "string       ");    Node    emptyStringNode    =    Node.newString(   ",string       ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x= " "  Result:  x= "  	89	3	replace
407	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( ",originalSize ");  [FE]  junit.framework.AssertionFailedError:  Expected:  x= " "  Result:  x= "  [FE]                AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ",originalSize ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( ",originalSize ");	  Node    emptyStringNode    =    Node.newString(       "string       ");    Node    emptyStringNode    =    Node.newString(   ",string       ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x= " "  Result:  x= "  	89	3	replace
408	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( ",string ",  originalSize);  [CE]  no  suitable  method  found  for  newString(String,int)  [FE]                  AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ",string ",  originalSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( ",string ",  originalSize);	  Node    emptyStringNode    =    Node.newString(       "string       ");    Node    emptyStringNode    =    Node.newString(   ",string       ");    	non-compiled	[CE]  no  suitable  method  found  for  newString(String,int)	89	None	replace
409	[BUG]  [BUGGY]  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]                    AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ",  charset ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( ",  charset ");	  Node    emptyStringNode    =    Node.newString(       "string       ");    Node    emptyStringNode    =    Node.newString(   ",string       ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	89	3	replace
410	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( ",  charset ");  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]                    AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ",  charset ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( ",  charset ");	  Node    emptyStringNode    =    Node.newString(       "string       ");    Node    emptyStringNode    =    Node.newString(   ",string       ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	89	3	replace
411	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( ",string ").replaceChild(n,  foldedSize);  [CE]  method  replaceChild  in  class  Node  cannot  be  applied  to  given  types;  [FE]                      AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ",string ").replaceChild(n,  foldedSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( ",string ").replaceChild(n,  foldedSize);	  Node    emptyStringNode    =    Node.newString(       "string       ");    Node    emptyStringNode    =    Node.newString(   ",string       ");    	non-compiled	[CE]  method  replaceChild  in  class  Node  cannot  be  applied  to  given  types;	89	None	replace
412	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(... "java.util.Arrays.asList( ");  [CE]  illegal  start  of  expression  [FE]        junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(... "java.util.Arrays.asList( ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(... "java.util.Arrays.asList( ");	  Node    emptyStringNode    =    Node.newString(       "java.util.Arrays.asList(       ");    Node    emptyStringNode    =    Node.newString(...   "java.util.Arrays.asList(       ");    	non-compiled	[CE]  illegal  start  of  expression	171	None	replace
413	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(... "Arrays.asList( ");  [CE]  illegal  start  of  expression  [FE]          junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(... "Arrays.asList( ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(... "Arrays.asList( ");	  Node    emptyStringNode    =    Node.newString(       "java.util.Arrays.asList(       ");    Node    emptyStringNode    =    Node.newString(...   "java.util.Arrays.asList(       ");    	non-compiled	[CE]  illegal  start  of  expression	171	None	replace
414	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(...   "java.util.Arrays.asList(prev));  [CE]  illegal  start  of  expression  [FE]            junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(...   "java.util.Arrays.asList(prev));  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(...   "java.util.Arrays.asList(prev));	  Node    emptyStringNode    =    Node.newString(       "java.util.Arrays.asList(       ");    Node    emptyStringNode    =    Node.newString(...   "java.util.Arrays.asList(       ");    	non-compiled	[CE]  illegal  start  of  expression	171	None	replace
415	[BUG]  [BUGGY]  Node  emptyStringNode  =  arrayFoldedChildren.get(0);  Node  emptyStringNode  =  arrayFoldedChildren.get(0);  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]    java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  Index:  0    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  arrayFoldedChildren.get(0);  Node  emptyStringNode  =  arrayFoldedChildren.get(0);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    arrayFoldedChildren.get(0);    Node  emptyStringNode  =  arrayFoldedChildren.get(0);	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	1	None	add
416	[BUG]  [BUGGY]  Node  emptyStringNode  =  arrayFoldedChildren.get(0);  Node  emptyStringNode  =  arrayFoldedChildren.get(1);  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]      java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  Index:  0    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  arrayFoldedChildren.get(0);  Node  emptyStringNode  =  arrayFoldedChildren.get(1);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    arrayFoldedChildren.get(0);    Node  emptyStringNode  =  arrayFoldedChildren.get(1);	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	1	None	add
417	[BUG]  [BUGGY]  Node  emptyStringNode  =  arrayFoldedChildren.get(0);  Node  emptyStringNode  =  arrayFoldedChildren.get(2);  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]        java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  Index:  0    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  arrayFoldedChildren.get(0);  Node  emptyStringNode  =  arrayFoldedChildren.get(2);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    arrayFoldedChildren.get(0);    Node  emptyStringNode  =  arrayFoldedChildren.get(2);	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	1	None	add
418	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "[a-z]   ");  Node  emptyStringNode  =  Node.newString( "[a-z]   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "[a-z]   ");  Node  emptyStringNode  =  Node.newString( "[a-z]   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "[a-z]   ");    Node  emptyStringNode  =  Node.newString( "[a-z]   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	177	None	add
419	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "[a-z]   ");  Node  emptyStringNode  =  Node.newString( ".[a-z]   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]      AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "[a-z]   ");  Node  emptyStringNode  =  Node.newString( ".[a-z]   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "[a-z]   ");    Node  emptyStringNode  =  Node.newString( ".[a-z]   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	177	None	add
420	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "[a-z]   ");  Node  emptyStringNode  =  Node.newString( ",[a-z]   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]        AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "[a-z]   ");  Node  emptyStringNode  =  Node.newString( ",[a-z]   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "[a-z]   ");    Node  emptyStringNode  =  Node.newString( ",[a-z]   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	177	None	add
421	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "[a-z]   ");  Node  emptyStringNode  =  Node.newString( "[a-z] ",);  [CE]  illegal  start  of  expression  [FE]          AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "[a-z]   ");  Node  emptyStringNode  =  Node.newString( "[a-z] ",);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "[a-z]   ");    Node  emptyStringNode  =  Node.newString( "[a-z] ",);	  	non-compiled	[CE]  illegal  start  of  expression	177	None	add
422	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "[a-z] ",  foldedSize);  [CE]  no  suitable  method  found  for  newString(String,int)  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[a-z] ",  foldedSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "[a-z] ",  foldedSize);	  Node    emptyStringNode    =    Node.newString(   "[a-z]   ");    	non-compiled	[CE]  no  suitable  method  found  for  newString(String,int)	178	None	replace
423	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "[a-z] ").replaceChild(n,  foldedSize);  [CE]  method  replaceChild  in  class  Node  cannot  be  applied  to  given  types;  [FE]      AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[a-z] ").replaceChild(n,  foldedSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "[a-z] ").replaceChild(n,  foldedSize);	  Node    emptyStringNode    =    Node.newString(   "[a-z]   ");    	non-compiled	[CE]  method  replaceChild  in  class  Node  cannot  be  applied  to  given  types;	178	None	replace
424	[BUG]  [BUGGY]  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]        AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[a-z] "  +  originalSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "[a-z] "  +  originalSize);	  Node    emptyStringNode    =    Node.newString(   "[a-z]   ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	178	3	replace
425	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "[a-z] "  +  originalSize);  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]        AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[a-z] "  +  originalSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "[a-z] "  +  originalSize);	  Node    emptyStringNode    =    Node.newString(   "[a-z]   ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	178	3	replace
426	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[a-Z] ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "[a-Z] ");	  Node    emptyStringNode    =    Node.newString(   "[a-z]   ");    	compilable	  [FE]  AssertionFailedError  	178	3	replace
427	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "[a-Z] ");  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[a-Z] ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "[a-Z] ");	  Node    emptyStringNode    =    Node.newString(   "[a-z]   ");    	compilable	  [FE]  AssertionFailedError  	178	3	replace
428	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "[a-z] ",  originalSize);  [CE]  no  suitable  method  found  for  newString(String,int)  [FE]            AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[a-z] ",  originalSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "[a-z] ",  originalSize);	  Node    emptyStringNode    =    Node.newString(   "[a-z]   ");    	non-compiled	[CE]  no  suitable  method  found  for  newString(String,int)	178	None	replace
429	[BUG]  [BUGGY]  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('  [FE]    java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[ "  +  sb.toString()  +  1);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "[ "  +  sb.toString()  +  1);	  Node    emptyStringNode    =    Node.newString(   "[   "    +    sb.toString());    	compilable	  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('  	180	3	replace
430	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "[ "  +  sb.toString()  +  1);  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('  [FE]    java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[ "  +  sb.toString()  +  1);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "[ "  +  sb.toString()  +  1);	  Node    emptyStringNode    =    Node.newString(   "[   "    +    sb.toString());    	compilable	  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('  	180	3	replace
431	[BUG]  [BUGGY]  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('  [FE]      java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[ "  +  sb.toString()  +   "] ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "[ "  +  sb.toString()  +   "] ");	  Node    emptyStringNode    =    Node.newString(   "[   "    +    sb.toString());    	compilable	  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('  	180	3	replace
432	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "[ "  +  sb.toString()  +   "] ");  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('  [FE]      java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[ "  +  sb.toString()  +   "] ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "[ "  +  sb.toString()  +   "] ");	  Node    emptyStringNode    =    Node.newString(   "[   "    +    sb.toString());    	compilable	  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('  	180	3	replace
433	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[ "  +  n.toString());  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "[ "  +  n.toString());	  Node    emptyStringNode    =    Node.newString(   "[   "    +    sb.toString());    	compilable	  [FE]  AssertionFailedError  	180	3	replace
434	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "[ "  +  n.toString());  [FE]  AssertionFailedError  [FE]        java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[ "  +  n.toString());  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "[ "  +  n.toString());	  Node    emptyStringNode    =    Node.newString(   "[   "    +    sb.toString());    	compilable	  [FE]  AssertionFailedError  	180	3	replace
435	[BUG]  [BUGGY]  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('  [FE]          java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[] "  +  sb.toString());  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "[] "  +  sb.toString());	  Node    emptyStringNode    =    Node.newString(   "[   "    +    sb.toString());    	compilable	  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('  	180	3	replace
436	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "[] "  +  sb.toString());  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('  [FE]          java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[] "  +  sb.toString());  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "[] "  +  sb.toString());	  Node    emptyStringNode    =    Node.newString(   "[   "    +    sb.toString());    	compilable	  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('  	180	3	replace
437	[BUG]  [BUGGY]  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('  [FE]            java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "] "  +  sb.toString());  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "] "  +  sb.toString());	  Node    emptyStringNode    =    Node.newString(   "[   "    +    sb.toString());    	compilable	  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('  	180	3	replace
438	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "] "  +  sb.toString());  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('  [FE]            java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "] "  +  sb.toString());  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "] "  +  sb.toString());	  Node    emptyStringNode    =    Node.newString(   "[   "    +    sb.toString());    	compilable	  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('  	180	3	replace
439	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.STRING,  n,  foldedSize);  [CE]  no  suitable  method  found  for  newString(int,Node,int)  [FE]            AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.STRING,  n,  foldedSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(Token.STRING,  n,  foldedSize);	  Node    emptyStringNode    =    Node.newString(Token.STRING,    foldedSize);    	non-compiled	[CE]  no  suitable  method  found  for  newString(int,Node,int)	84	None	replace
440	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.STRING,  originalSize);  [CE]  no  suitable  method  found  for  newString(int,int)  [FE]              AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.STRING,  originalSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(Token.STRING,  originalSize);	  Node    emptyStringNode    =    Node.newString(Token.STRING,    foldedSize);    	non-compiled	[CE]  no  suitable  method  found  for  newString(int,int)	84	None	replace
441	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.STRING,  foldedSize,  originalSize);  [CE]  no  suitable  method  found  for  newString(int,int,int)  [FE]                AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.STRING,  foldedSize,  originalSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(Token.STRING,  foldedSize,  originalSize);	  Node    emptyStringNode    =    Node.newString(Token.STRING,    foldedSize);    	non-compiled	[CE]  no  suitable  method  found  for  newString(int,int,int)	84	None	replace
442	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.STRING,  foldedSize,  kJoinOverhead);  [CE]  cannot  find  symbol  kJoinOverhead  [FE]                  AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.STRING,  foldedSize,  kJoinOverhead);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(Token.STRING,  foldedSize,  kJoinOverhead);	  Node    emptyStringNode    =    Node.newString(Token.STRING,    foldedSize);    	non-compiled	[CE]  cannot  find  symbol  kJoinOverhead	84	None	replace
443	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.STRING,  sb,  foldedSize);  [CE]  no  suitable  method  found  for  newString(int,StringBuilder,int)  [FE]                    AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.STRING,  sb,  foldedSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(Token.STRING,  sb,  foldedSize);	  Node    emptyStringNode    =    Node.newString(Token.STRING,    foldedSize);    	non-compiled	[CE]  no  suitable  method  found  for  newString(int,StringBuilder,int)	84	None	replace
444	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.STRING,  prev,  foldedSize);  [CE]  no  suitable  method  found  for  newString(int,Node,int)  [FE]                      AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.STRING,  prev,  foldedSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(Token.STRING,  prev,  foldedSize);	  Node    emptyStringNode    =    Node.newString(Token.STRING,    foldedSize);    	non-compiled	[CE]  no  suitable  method  found  for  newString(int,Node,int)	84	None	replace
445	[BUG]  [BUGGY]  int  kJoinOverhead  =  InlineCostEstimator.getCost(n,  foldedSize);  [CE]  cannot  find  symbol  emptyStringNode  [FE]                            junit.framework.AssertionFailedError:  Expected:  x=[     "a     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  int  kJoinOverhead  =  InlineCostEstimator.getCost(n,  foldedSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	int  kJoinOverhead  =  InlineCostEstimator.getCost(n,  foldedSize);	  int    kJoinOverhead    =    InlineCostEstimator.getCost(n);    	non-compiled	[CE]  cannot  find  symbol  emptyStringNode	148	None	replace
446	[BUG]  [BUGGY]  int  kJoinOverhead  =  InlineCostEstimator.getCost(n,  arrayFoldedChildren);  [CE]  no  suitable  method  found  for  getCost(Node,List<Node>)  [FE]                              junit.framework.AssertionFailedError:  Expected:  x=[     "a     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  int  kJoinOverhead  =  InlineCostEstimator.getCost(n,  arrayFoldedChildren);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	int  kJoinOverhead  =  InlineCostEstimator.getCost(n,  arrayFoldedChildren);	  int    kJoinOverhead    =    InlineCostEstimator.getCost(n);    	non-compiled	[CE]  no  suitable  method  found  for  getCost(Node,List<Node>)	148	None	replace
447	[BUG]  [BUGGY]  int  kJoinOverhead  =  InlineCostEstimator.getCost(n,  parent);  [CE]  cannot  find  symbol  parent  [FE]                                junit.framework.AssertionFailedError:  Expected:  x=[     "a     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  int  kJoinOverhead  =  InlineCostEstimator.getCost(n,  parent);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	int  kJoinOverhead  =  InlineCostEstimator.getCost(n,  parent);	  int    kJoinOverhead    =    InlineCostEstimator.getCost(n);    	non-compiled	[CE]  cannot  find  symbol  parent	148	None	replace
448	[BUG]  [BUGGY]  int  kJoinOverhead  =  InlineCostEstimator.getCost(n,  leftStringNode);  [CE]  cannot  find  symbol  leftStringNode  [FE]                                  junit.framework.AssertionFailedError:  Expected:  x=[     "a     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  int  kJoinOverhead  =  InlineCostEstimator.getCost(n,  leftStringNode);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	int  kJoinOverhead  =  InlineCostEstimator.getCost(n,  leftStringNode);	  int    kJoinOverhead    =    InlineCostEstimator.getCost(n);    	non-compiled	[CE]  cannot  find  symbol  leftStringNode	148	None	replace
449	[BUG]  [BUGGY]  int  kJoinOverhead  =  InlineCostEstimator.getCost(n,  left);  [CE]  cannot  find  symbol  left  [FE]                                    junit.framework.AssertionFailedError:  Expected:  x=[     "a     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  int  kJoinOverhead  =  InlineCostEstimator.getCost(n,  left);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	int  kJoinOverhead  =  InlineCostEstimator.getCost(n,  left);	  int    kJoinOverhead    =    InlineCostEstimator.getCost(n);    	non-compiled	[CE]  cannot  find  symbol  left	148	None	replace
450	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "[   "  +  sb.toString());  Node  emptyStringNode  =  Node.newString( "[   "  +  sb.toString());  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]    java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "[   "  +  sb.toString());  Node  emptyStringNode  =  Node.newString( "[   "  +  sb.toString());  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "[   "    +    sb.toString());    Node  emptyStringNode  =  Node.newString( "[   "  +  sb.toString());	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	179	None	add
451	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "[   "  +  sb.toString());  Node  emptyStringNode  =  Node.newString( ",[   "  +  sb.toString());  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]      java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "[   "  +  sb.toString());  Node  emptyStringNode  =  Node.newString( ",[   "  +  sb.toString());  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "[   "    +    sb.toString());    Node  emptyStringNode  =  Node.newString( ",[   "  +  sb.toString());	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	179	None	add
452	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "[   "  +  sb.toString());  Node  emptyStringNode  =  Node.newString( ".[   "  +  sb.toString());  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]        java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "[   "  +  sb.toString());  Node  emptyStringNode  =  Node.newString( ".[   "  +  sb.toString());  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "[   "    +    sb.toString());    Node  emptyStringNode  =  Node.newString( ".[   "  +  sb.toString());	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	179	None	add
453	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "[   "  +  sb.toString());  Node  emptyStringNode  =  Node.newString(. "[   "  +  sb.toString());  [CE]  illegal  start  of  expression  [FE]          java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "[   "  +  sb.toString());  Node  emptyStringNode  =  Node.newString(. "[   "  +  sb.toString());  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "[   "    +    sb.toString());    Node  emptyStringNode  =  Node.newString(. "[   "  +  sb.toString());	  	non-compiled	[CE]  illegal  start  of  expression	179	None	add
454	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "[   "  +  sb.toString());  Node  emptyStringNode  =  Node.newString(, "[   "  +  sb.toString());  [CE]  illegal  start  of  expression  [FE]            java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "[   "  +  sb.toString());  Node  emptyStringNode  =  Node.newString(, "[   "  +  sb.toString());  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "[   "    +    sb.toString());    Node  emptyStringNode  =  Node.newString(, "[   "  +  sb.toString());	  	non-compiled	[CE]  illegal  start  of  expression	179	None	add
455	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "[   "  +  sb.toString());  Node  emptyStringNode  =  Node.newString(! "[   "  +  sb.toString());  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]              java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "[   "  +  sb.toString());  Node  emptyStringNode  =  Node.newString(! "[   "  +  sb.toString());  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "[   "    +    sb.toString());    Node  emptyStringNode  =  Node.newString(! "[   "  +  sb.toString());	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	179	None	add
456	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "Arrays.asList( "  +  arrayFoldedChildren.size()  -  1));  [CE]  [FE]        junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "Arrays.asList( "  +  arrayFoldedChildren.size()  -  1));  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "Arrays.asList( "  +  arrayFoldedChildren.size()  -  1));	  Node    emptyStringNode    =    Node.newString(   "java.util.Arrays.asList(   "    +    arrayFoldedChildren.size()));    	non-compiled	[CE]  	181	None	replace
457	[BUG]  [BUGGY]  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  Index:  0  [FE]          junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList( "  +  arrayFoldedChildren.get(0));  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList( "  +  arrayFoldedChildren.get(0));	  Node    emptyStringNode    =    Node.newString(   "java.util.Arrays.asList(   "    +    arrayFoldedChildren.size()));    	compilable	  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  Index:  0  	181	3	replace
458	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList( "  +  arrayFoldedChildren.get(0));  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  Index:  0  [FE]          junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList( "  +  arrayFoldedChildren.get(0));  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList( "  +  arrayFoldedChildren.get(0));	  Node    emptyStringNode    =    Node.newString(   "java.util.Arrays.asList(   "    +    arrayFoldedChildren.size()));    	compilable	  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  Index:  0  	181	3	replace
459	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList( "  +  arrayFoldedChildren.size()  -  2));  [CE]  [FE]            junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList( "  +  arrayFoldedChildren.size()  -  2));  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList( "  +  arrayFoldedChildren.size()  -  2));	  Node    emptyStringNode    =    Node.newString(   "java.util.Arrays.asList(   "    +    arrayFoldedChildren.size()));    	non-compiled	[CE]  	181	None	replace
460	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME,   "ArrayJoin ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString(Token.NAME,   "ArrayJoin ");	  Node    emptyStringNode    =    Node.newString(Token.NAME,   "ArrayElement   ");    	compilable	  [FE]  AssertionFailedError  	136	3	replace
461	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME,   "ArrayJoin ");  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME,   "ArrayJoin ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(Token.NAME,   "ArrayJoin ");	  Node    emptyStringNode    =    Node.newString(Token.NAME,   "ArrayElement   ");    	compilable	  [FE]  AssertionFailedError  	136	3	replace
462	[BUG]  [BUGGY]  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]    junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.ArrayListener ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "java.util.ArrayListener ");	  Node    emptyStringNode    =    Node.newString(   "java.util.ArrayListn   ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	130	3	replace
463	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.ArrayListener ");  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]    junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.ArrayListener ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "java.util.ArrayListener ");	  Node    emptyStringNode    =    Node.newString(   "java.util.ArrayListn   ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	130	3	replace
464	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "JoinArrayBuilder   ");  Node  emptyStringNode  =  Node.newString( "JoinArrayBuilder   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]    junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "JoinArrayBuilder   ");  Node  emptyStringNode  =  Node.newString( "JoinArrayBuilder   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "JoinArrayBuilder   ");    Node  emptyStringNode  =  Node.newString( "JoinArrayBuilder   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	102	None	add
465	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "JoinArrayBuilder   ");  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [CE]  not  a  statement  [FE]      junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "JoinArrayBuilder   ");  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "JoinArrayBuilder   ");    junit.framework.AssertionFailedError:  Expected:  x=[].join( "	  	non-compiled	[CE]  not  a  statement	102	None	add
466	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "JoinArrayBuilder   ");  Node  emptyStringNode  =  Node.newString( ".JoinArrayBuilder ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]        junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "JoinArrayBuilder   ");  Node  emptyStringNode  =  Node.newString( ".JoinArrayBuilder ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "JoinArrayBuilder   ");    Node  emptyStringNode  =  Node.newString( ".JoinArrayBuilder ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	102	None	add
467	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "JoinArrayBuilder   ");  junit.framework.AssertionFailedError:  Expected:  x=[0].join( "  [CE]  not  a  statement  [FE]          junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "JoinArrayBuilder   ");  junit.framework.AssertionFailedError:  Expected:  x=[0].join( "  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "JoinArrayBuilder   ");    junit.framework.AssertionFailedError:  Expected:  x=[0].join( "	  	non-compiled	[CE]  not  a  statement	102	None	add
468	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString('-');  [CE]  no  suitable  method  found  for  newString(char)  [FE]        AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString('-');  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString('-');	  Node    emptyStringNode    =    Node.newString(       "-       ");    Node    emptyStringNode    =    Node.newString('-       ");    	non-compiled	[CE]  no  suitable  method  found  for  newString(char)	131	None	replace
469	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "string   "  +  sb.toString());  Node  emptyStringNode  =  Node.newString( "string   "  +  sb.toString());  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]    java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "string   "  +  sb.toString());  Node  emptyStringNode  =  Node.newString( "string   "  +  sb.toString());  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "string   "    +    sb.toString());    Node  emptyStringNode  =  Node.newString( "string   "  +  sb.toString());	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	108	None	add
470	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "string   "  +  sb.toString());  Node  emptyStringNode  =  Node.newString( ",string   "  +  sb.toString());  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]      java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "string   "  +  sb.toString());  Node  emptyStringNode  =  Node.newString( ",string   "  +  sb.toString());  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "string   "    +    sb.toString());    Node  emptyStringNode  =  Node.newString( ",string   "  +  sb.toString());	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	108	None	add
471	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "string   "  +  sb.toString());  Node  emptyStringNode  =  Node.newString( ".string   "  +  sb.toString());  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]        java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "string   "  +  sb.toString());  Node  emptyStringNode  =  Node.newString( ".string   "  +  sb.toString());  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "string   "    +    sb.toString());    Node  emptyStringNode  =  Node.newString( ".string   "  +  sb.toString());	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	108	None	add
472	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "string   "  +  sb.toString());  Node  emptyStringNode  =  Node.newString(. "string   "  +  sb.toString());  [CE]  illegal  start  of  expression  [FE]          java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "string   "  +  sb.toString());  Node  emptyStringNode  =  Node.newString(. "string   "  +  sb.toString());  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "string   "    +    sb.toString());    Node  emptyStringNode  =  Node.newString(. "string   "  +  sb.toString());	  	non-compiled	[CE]  illegal  start  of  expression	108	None	add
473	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "string   "  +  sb.toString());  Node  emptyStringNode  =  Node.newString(, "string   "  +  sb.toString());  [CE]  illegal  start  of  expression  [FE]            java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "string   "  +  sb.toString());  Node  emptyStringNode  =  Node.newString(, "string   "  +  sb.toString());  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "string   "    +    sb.toString());    Node  emptyStringNode  =  Node.newString(, "string   "  +  sb.toString());	  	non-compiled	[CE]  illegal  start  of  expression	108	None	add
474	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "java.util.ArrayListn   ");  Node  emptyStringNode  =  Node.newString( "java.util.ArrayListn   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]    junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "java.util.ArrayListn   ");  Node  emptyStringNode  =  Node.newString( "java.util.ArrayListn   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "java.util.ArrayListn   ");    Node  emptyStringNode  =  Node.newString( "java.util.ArrayListn   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	129	None	add
475	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "java.util.ArrayListn   ");  Node  emptyStringNode  =  Node.newString( ".java.util.ArrayListn   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]      junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "java.util.ArrayListn   ");  Node  emptyStringNode  =  Node.newString( ".java.util.ArrayListn   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "java.util.ArrayListn   ");    Node  emptyStringNode  =  Node.newString( ".java.util.ArrayListn   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	129	None	add
476	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "java.util.ArrayListn   ");  Node  emptyStringNode  =  Node.newString( ",java.util.ArrayListn   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]        junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "java.util.ArrayListn   ");  Node  emptyStringNode  =  Node.newString( ",java.util.ArrayListn   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "java.util.ArrayListn   ");    Node  emptyStringNode  =  Node.newString( ",java.util.ArrayListn   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	129	None	add
477	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "java.util.ArrayListn   ");  Node  emptyStringNode  =  Node.newString(... "java.util.ArrayListn   ");  [CE]  illegal  start  of  expression  [FE]          junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "java.util.ArrayListn   ");  Node  emptyStringNode  =  Node.newString(... "java.util.ArrayListn   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "java.util.ArrayListn   ");    Node  emptyStringNode  =  Node.newString(... "java.util.ArrayListn   ");	  	non-compiled	[CE]  illegal  start  of  expression	129	None	add
478	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "java.util.ArrayListn   ");  Node  emptyStringNode  =  Node.newString(. "java.util.ArrayListn   ");  [CE]  illegal  start  of  expression  [FE]            junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "java.util.ArrayListn   ");  Node  emptyStringNode  =  Node.newString(. "java.util.ArrayListn   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "java.util.ArrayListn   ");    Node  emptyStringNode  =  Node.newString(. "java.util.ArrayListn   ");	  	non-compiled	[CE]  illegal  start  of  expression	129	None	add
479	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(, "Array ");  [CE]  illegal  start  of  expression  [FE]                  AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(, "Array ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(, "Array ");	  Node    emptyStringNode    =    Node.newString(       "Array       ");    Node    emptyStringNode    =    Node.newString(,   "Array       ");    	non-compiled	[CE]  illegal  start  of  expression	35	None	replace
480	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]                    AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.STRING,   "Array ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString(Token.STRING,   "Array ");	  Node    emptyStringNode    =    Node.newString(       "Array       ");    Node    emptyStringNode    =    Node.newString(,   "Array       ");    	compilable	  [FE]  AssertionFailedError  	35	3	replace
481	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.STRING,   "Array ");  [FE]  AssertionFailedError  [FE]                    AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.STRING,   "Array ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(Token.STRING,   "Array ");	  Node    emptyStringNode    =    Node.newString(       "Array       ");    Node    emptyStringNode    =    Node.newString(,   "Array       ");    	compilable	  [FE]  AssertionFailedError  	35	3	replace
482	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "JoinArrayJoin ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "JoinArrayJoin ");	  Node    emptyStringNode    =    Node.newString(   "label   ");    	compilable	  [FE]  AssertionFailedError  	199	3	replace
483	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "JoinArrayJoin ");  [FE]  AssertionFailedError  [FE]    junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "JoinArrayJoin ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "JoinArrayJoin ");	  Node    emptyStringNode    =    Node.newString(   "label   ");    	compilable	  [FE]  AssertionFailedError  	199	3	replace
484	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "] ",  n,  originalSize);  [CE]  no  suitable  method  found  for  newString(String,Node,int)  [FE]          AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "] ",  n,  originalSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "] ",  n,  originalSize);	  Node    emptyStringNode    =    Node.newString(   "]   ",    n);    	non-compiled	[CE]  no  suitable  method  found  for  newString(String,Node,int)	59	None	replace
485	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "] ",  n,  foldedSize);  [CE]  no  suitable  method  found  for  newString(String,Node,int)  [FE]            AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "] ",  n,  foldedSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "] ",  n,  foldedSize);	  Node    emptyStringNode    =    Node.newString(   "]   ",    n);    	non-compiled	[CE]  no  suitable  method  found  for  newString(String,Node,int)	59	None	replace
486	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "] ",  n,  prev);  [CE]  no  suitable  method  found  for  newString(String,Node,Node)  [FE]              AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "] ",  n,  prev);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "] ",  n,  prev);	  Node    emptyStringNode    =    Node.newString(   "]   ",    n);    	non-compiled	[CE]  no  suitable  method  found  for  newString(String,Node,Node)	59	None	replace
487	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.STRING,  n);  [CE]  no  suitable  method  found  for  newString(int,Node)  [FE]                AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.STRING,  n);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(Token.STRING,  n);	  Node    emptyStringNode    =    Node.newString(   "]   ",    n);    	non-compiled	[CE]  no  suitable  method  found  for  newString(int,Node)	59	None	replace
488	[BUG]  [BUGGY]  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[] "  +  originalSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "[] "  +  originalSize);	  Node    emptyStringNode    =    Node.newString(   "[]   ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	58	3	replace
489	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "[] "  +  originalSize);  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[] "  +  originalSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "[] "  +  originalSize);	  Node    emptyStringNode    =    Node.newString(   "[]   ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	58	3	replace
490	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "[] ").replaceChild(n,  foldedSize);  [CE]  method  replaceChild  in  class  Node  cannot  be  applied  to  given  types;  [FE]      AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[] ").replaceChild(n,  foldedSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "[] ").replaceChild(n,  foldedSize);	  Node    emptyStringNode    =    Node.newString(   "[]   ");    	non-compiled	[CE]  method  replaceChild  in  class  Node  cannot  be  applied  to  given  types;	58	None	replace
491	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "[] ").replaceChild(n,  prev);  [CE]  incompatible  types  [FE]        AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[] ").replaceChild(n,  prev);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "[] ").replaceChild(n,  prev);	  Node    emptyStringNode    =    Node.newString(   "[]   ");    	non-compiled	[CE]  incompatible  types	58	None	replace
492	[BUG]  [BUGGY]  Node  emptyStringNode  =  arrayFoldedChildren.get(originalSize);  Node  emptyStringNode  =  arrayFoldedChildren.get(originalSize);  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]    java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  Index:  12    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  arrayFoldedChildren.get(originalSize);  Node  emptyStringNode  =  arrayFoldedChildren.get(originalSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    arrayFoldedChildren.get(originalSize);    Node  emptyStringNode  =  arrayFoldedChildren.get(originalSize);	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	9	None	add
493	[BUG]  [BUGGY]  Node  emptyStringNode  =  arrayFoldedChildren.get(originalSize);  Node  emptyStringNode  =  arrayFoldedChildren.get(originalSize);  n.getParent().replaceChild(n,  emptyStringNode);  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]      java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  Index:  12    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  arrayFoldedChildren.get(originalSize);  Node  emptyStringNode  =  arrayFoldedChildren.get(originalSize);  n.getParent().replaceChild(n,  emptyStringNode);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    arrayFoldedChildren.get(originalSize);    Node  emptyStringNode  =  arrayFoldedChildren.get(originalSize);  n.getParent().replaceChild(n,  emptyStringNode);	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	9	None	add
494	[BUG]  [BUGGY]  Node  emptyStringNode  =  arrayFoldedChildren.get(originalSize);  n.getParent().removeChild(arrayFoldedChildren.get(originalSize));  Node  emptyStringNode  =  arrayFoldedChildren.get(originalSize);  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]        java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  Index:  12    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  arrayFoldedChildren.get(originalSize);  n.getParent().removeChild(arrayFoldedChildren.get(originalSize));  Node  emptyStringNode  =  arrayFoldedChildren.get(originalSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    arrayFoldedChildren.get(originalSize);    n.getParent().removeChild(arrayFoldedChildren.get(originalSize));  Node  emptyStringNode  =  arrayFoldedChildren.get(originalSize);	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	9	None	add
495	[BUG]  [BUGGY]  Node  emptyStringNode  =  arrayFoldedChildren.get(originalSize);  n.getParent().removeChild(arrayFoldedChildren.get(originalSize));  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]          java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  Index:  12    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  arrayFoldedChildren.get(originalSize);  n.getParent().removeChild(arrayFoldedChildren.get(originalSize));  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    arrayFoldedChildren.get(originalSize);    n.getParent().removeChild(arrayFoldedChildren.get(originalSize));	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	9	None	add
496	[BUG]  [BUGGY]  Node  emptyStringNode  =  arrayFoldedChildren.get(originalSize);  Node  emptyStringNode  =  arrayFoldedChildren.get(originalSize);  n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]            java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  Index:  12    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  arrayFoldedChildren.get(originalSize);  Node  emptyStringNode  =  arrayFoldedChildren.get(originalSize);  n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    arrayFoldedChildren.get(originalSize);    Node  emptyStringNode  =  arrayFoldedChildren.get(originalSize);  n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	9	None	add
497	[BUG]  [BUGGY]  Node  emptyStringNode  =  arrayFoldedChildren.get(originalSize);  Node  emptyStringNode  =  arrayFoldedChildren.get(originalSize);  n.getParent().removeChild(new  StringBuilder(sb.toString()));  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]              java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  Index:  12    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  arrayFoldedChildren.get(originalSize);  Node  emptyStringNode  =  arrayFoldedChildren.get(originalSize);  n.getParent().removeChild(new  StringBuilder(sb.toString()));  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    arrayFoldedChildren.get(originalSize);    Node  emptyStringNode  =  arrayFoldedChildren.get(originalSize);  n.getParent().removeChild(new  StringBuilder(sb.toString()));	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	9	None	add
498	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "array_fold ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "array_fold ");	  Node    emptyStringNode    =    Node.newString(   "array_foo   ");    	compilable	  [FE]  AssertionFailedError  	203	3	replace
499	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "array_fold ");  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "array_fold ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "array_fold ");	  Node    emptyStringNode    =    Node.newString(   "array_foo   ");    	compilable	  [FE]  AssertionFailedError  	203	3	replace
500	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "array_foo ",  originalSize);  [CE]  no  suitable  method  found  for  newString(String,int)  [FE]      AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "array_foo ",  originalSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "array_foo ",  originalSize);	  Node    emptyStringNode    =    Node.newString(   "array_foo   ");    	non-compiled	[CE]  no  suitable  method  found  for  newString(String,int)	203	None	replace
501	[BUG]  [BUGGY]  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]        AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "array_foo. ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "array_foo. ");	  Node    emptyStringNode    =    Node.newString(   "array_foo   ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	203	3	replace
502	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "array_foo. ");  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]        AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "array_foo. ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "array_foo. ");	  Node    emptyStringNode    =    Node.newString(   "array_foo   ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	203	3	replace
503	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "array_foo ",  foldedSize);  [CE]  no  suitable  method  found  for  newString(String,int)  [FE]          AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "array_foo ",  foldedSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "array_foo ",  foldedSize);	  Node    emptyStringNode    =    Node.newString(   "array_foo   ");    	non-compiled	[CE]  no  suitable  method  found  for  newString(String,int)	203	None	replace
504	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "Join.ArrayBuffer ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "Join.ArrayBuffer ");	  Node    emptyStringNode    =    Node.newString(   "Join.ArrayBuilder   ");    	compilable	  [FE]  AssertionFailedError  	105	3	replace
505	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "Join.ArrayBuffer ");  [FE]  AssertionFailedError  [FE]    junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "Join.ArrayBuffer ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "Join.ArrayBuffer ");	  Node    emptyStringNode    =    Node.newString(   "Join.ArrayBuilder   ");    	compilable	  [FE]  AssertionFailedError  	105	3	replace
506	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(sb.toString());  Node  emptyStringNode  =  Node.newString(sb.toString());  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]    java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(sb.toString());  Node  emptyStringNode  =  Node.newString(sb.toString());  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(sb.toString());    Node  emptyStringNode  =  Node.newString(sb.toString());	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	189	None	add
507	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(sb.toString());  Node  emptyStringNode  =  Node.newString(sb.toString());  n.getParent().replaceChild(n,  emptyStringNode);  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]      java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(sb.toString());  Node  emptyStringNode  =  Node.newString(sb.toString());  n.getParent().replaceChild(n,  emptyStringNode);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(sb.toString());    Node  emptyStringNode  =  Node.newString(sb.toString());  n.getParent().replaceChild(n,  emptyStringNode);	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	189	None	add
508	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(sb.toString());  Node  emptyStringNode  =  Node.newString(sb.toString());  n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]        java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(sb.toString());  Node  emptyStringNode  =  Node.newString(sb.toString());  n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(sb.toString());    Node  emptyStringNode  =  Node.newString(sb.toString());  n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	189	None	add
509	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(sb.toString());  Node  emptyStringNode  =  Node.newString(sb.toString());  n.getParent().replaceChild(n,  foldedStringNode);  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]          java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(sb.toString());  Node  emptyStringNode  =  Node.newString(sb.toString());  n.getParent().replaceChild(n,  foldedStringNode);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(sb.toString());    Node  emptyStringNode  =  Node.newString(sb.toString());  n.getParent().replaceChild(n,  foldedStringNode);	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	189	None	add
510	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(sb.toString());  Node  emptyStringNode  =  Node.newString(sb.toString());  n.getParent().replaceChild(n,  new  StringBuilder(sb.toString()));  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]            java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(sb.toString());  Node  emptyStringNode  =  Node.newString(sb.toString());  n.getParent().replaceChild(n,  new  StringBuilder(sb.toString()));  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(sb.toString());    Node  emptyStringNode  =  Node.newString(sb.toString());  n.getParent().replaceChild(n,  new  StringBuilder(sb.toString()));	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	189	None	add
511	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(sb.toString());  Node  emptyStringNode  =  Node.newString(sb.toString());  n.getParent().removeChild(oldStringNode);  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]              java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(sb.toString());  Node  emptyStringNode  =  Node.newString(sb.toString());  n.getParent().removeChild(oldStringNode);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(sb.toString());    Node  emptyStringNode  =  Node.newString(sb.toString());  n.getParent().removeChild(oldStringNode);	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	189	None	add
512	[BUG]  [BUGGY]  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "array-name "  +  originalSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "array-name "  +  originalSize);	  Node    emptyStringNode    =    Node.newString(   "array-name   ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	75	3	replace
513	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "array-name "  +  originalSize);  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "array-name "  +  originalSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "array-name "  +  originalSize);	  Node    emptyStringNode    =    Node.newString(   "array-name   ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	75	3	replace
514	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "Array-name ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "Array-name ");	  Node    emptyStringNode    =    Node.newString(   "array-name   ");    	compilable	  [FE]  AssertionFailedError  	75	3	replace
515	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "Array-name ");  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "Array-name ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "Array-name ");	  Node    emptyStringNode    =    Node.newString(   "array-name   ");    	compilable	  [FE]  AssertionFailedError  	75	3	replace
516	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "array-name ",  n);  [CE]  no  suitable  method  found  for  newString(String,Node)  [FE]        AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "array-name ",  n);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "array-name ",  n);	  Node    emptyStringNode    =    Node.newString(   "array-name   ");    	non-compiled	[CE]  no  suitable  method  found  for  newString(String,Node)	75	None	replace
517	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "array-name "  +  functionName);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "array-name "  +  functionName);	  Node    emptyStringNode    =    Node.newString(   "array-name   ");    	compilable	  [FE]  AssertionFailedError  	75	3	replace
518	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "array-name "  +  functionName);  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "array-name "  +  functionName);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "array-name "  +  functionName);	  Node    emptyStringNode    =    Node.newString(   "array-name   ");    	compilable	  [FE]  AssertionFailedError  	75	3	replace
519	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "array-name "  +  name);  [CE]  cannot  find  symbol  name  [FE]            AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "array-name "  +  name);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "array-name "  +  name);	  Node    emptyStringNode    =    Node.newString(   "array-name   ");    	non-compiled	[CE]  cannot  find  symbol  name	75	None	replace
520	[BUG]  [BUGGY]  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]              AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "array-name "  +  prev);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "array-name "  +  prev);	  Node    emptyStringNode    =    Node.newString(   "array-name   ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	75	3	replace
521	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "array-name "  +  prev);  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]              AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "array-name "  +  prev);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "array-name "  +  prev);	  Node    emptyStringNode    =    Node.newString(   "array-name   ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	75	3	replace
522	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(... "java.util.ArrayList ");  [CE]  illegal  start  of  expression  [FE]              AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(... "java.util.ArrayList ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(... "java.util.ArrayList ");	  Node    emptyStringNode    =    Node.newString(       "java.util.ArrayList       ");    Node    emptyStringNode    =    Node.newString(...   "java.util.ArrayList       ");    	non-compiled	[CE]  illegal  start  of  expression	27	None	replace
523	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(... "ArrayList ");  [CE]  illegal  start  of  expression  [FE]                AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(... "ArrayList ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(... "ArrayList ");	  Node    emptyStringNode    =    Node.newString(       "java.util.ArrayList       ");    Node    emptyStringNode    =    Node.newString(...   "java.util.ArrayList       ");    	non-compiled	[CE]  illegal  start  of  expression	27	None	replace
524	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "ArrayElement ", "ArrayElement ");  [CE]  no  suitable  method  found  for  newString(String,String)  [FE]              junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "ArrayElement ", "ArrayElement ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "ArrayElement ", "ArrayElement ");	  Node    emptyStringNode    =    Node.newString(       "java.util.ArrayElement       ");    Node    emptyStringNode    =    Node.newString(   "java.util.ArrayElement   ",);    	non-compiled	[CE]  no  suitable  method  found  for  newString(String,String)	23	None	replace
525	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.ArrayElement ", "java.util.ArrayElement ");  [CE]  no  suitable  method  found  for  newString(String,String)  [FE]                junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.ArrayElement ", "java.util.ArrayElement ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "java.util.ArrayElement ", "java.util.ArrayElement ");	  Node    emptyStringNode    =    Node.newString(       "java.util.ArrayElement       ");    Node    emptyStringNode    =    Node.newString(   "java.util.ArrayElement   ",);    	non-compiled	[CE]  no  suitable  method  found  for  newString(String,String)	23	None	replace
526	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.ArrayElement ",  null);  [CE]  no  suitable  method  found  for  newString(String,<null>)  [FE]                  junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.ArrayElement ",  null);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "java.util.ArrayElement ",  null);	  Node    emptyStringNode    =    Node.newString(       "java.util.ArrayElement       ");    Node    emptyStringNode    =    Node.newString(   "java.util.ArrayElement   ",);    	non-compiled	[CE]  no  suitable  method  found  for  newString(String,<null>)	23	None	replace
527	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.ArrayElement ", " ");  [CE]  no  suitable  method  found  for  newString(String,String)  [FE]                    junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.ArrayElement ", " ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "java.util.ArrayElement ", " ");	  Node    emptyStringNode    =    Node.newString(       "java.util.ArrayElement       ");    Node    emptyStringNode    =    Node.newString(   "java.util.ArrayElement   ",);    	non-compiled	[CE]  no  suitable  method  found  for  newString(String,String)	23	None	replace
528	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "Arrays.asList() ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "Arrays.asList() ");	  Node    emptyStringNode    =    Node.newString(       "java.util.Arrays.asList(       ");    Node    emptyStringNode    =    Node.newString(   "java.util.Arrays.asList(       "));    	compilable	  [FE]  AssertionFailedError  	172	3	replace
529	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "Arrays.asList() ");  [FE]  AssertionFailedError  [FE]          junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "Arrays.asList() ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "Arrays.asList() ");	  Node    emptyStringNode    =    Node.newString(       "java.util.Arrays.asList(       ");    Node    emptyStringNode    =    Node.newString(   "java.util.Arrays.asList(       "));    	compilable	  [FE]  AssertionFailedError  	172	3	replace
530	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "array ",  sb.toString(),  prev);  [CE]  no  suitable  method  found  for  newString(String,String,Node)  [FE]        junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "array ",  sb.toString(),  prev);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "array ",  sb.toString(),  prev);	  Node    emptyStringNode    =    Node.newString(   "array   ",    sb.toString());    	non-compiled	[CE]  no  suitable  method  found  for  newString(String,String,Node)	187	None	replace
531	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(sb.toString(),  originalSize);  [CE]  no  suitable  method  found  for  newString(String,int)  [FE]          junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(sb.toString(),  originalSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(sb.toString(),  originalSize);	  Node    emptyStringNode    =    Node.newString(   "array   ",    sb.toString());    	non-compiled	[CE]  no  suitable  method  found  for  newString(String,int)	187	None	replace
532	[BUG]  [BUGGY]  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('  [FE]            junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "array "  +  sb.toString());  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "array "  +  sb.toString());	  Node    emptyStringNode    =    Node.newString(   "array   ",    sb.toString());    	compilable	  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('  	187	3	replace
533	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "array "  +  sb.toString());  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('  [FE]            junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "array "  +  sb.toString());  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "array "  +  sb.toString());	  Node    emptyStringNode    =    Node.newString(   "array   ",    sb.toString());    	compilable	  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('  	187	3	replace
534	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "array ",  sb.toString(),  originalSize);  [CE]  no  suitable  method  found  for  newString(String,String,int)  [FE]              junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "array ",  sb.toString(),  originalSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "array ",  sb.toString(),  originalSize);	  Node    emptyStringNode    =    Node.newString(   "array   ",    sb.toString());    	non-compiled	[CE]  no  suitable  method  found  for  newString(String,String,int)	187	None	replace
535	[BUG]  [BUGGY]  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('  [FE]                junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.STRING,  sb.toString());  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString(Token.STRING,  sb.toString());	  Node    emptyStringNode    =    Node.newString(   "array   ",    sb.toString());    	compilable	  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('  	187	3	replace
536	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.STRING,  sb.toString());  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('  [FE]                junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.STRING,  sb.toString());  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(Token.STRING,  sb.toString());	  Node    emptyStringNode    =    Node.newString(   "array   ",    sb.toString());    	compilable	  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('  	187	3	replace
537	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "org.join.ArrayBuilder   ");  Node  emptyStringNode  =  Node.newString( "org.join.ArrayBuilder   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]    junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "org.join.ArrayBuilder   ");  Node  emptyStringNode  =  Node.newString( "org.join.ArrayBuilder   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "org.join.ArrayBuilder   ");    Node  emptyStringNode  =  Node.newString( "org.join.ArrayBuilder   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	207	None	add
538	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "org.join.ArrayBuilder   ");  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [CE]  not  a  statement  [FE]      junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "org.join.ArrayBuilder   ");  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "org.join.ArrayBuilder   ");    junit.framework.AssertionFailedError:  Expected:  x=[].join( "	  	non-compiled	[CE]  not  a  statement	207	None	add
539	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "org.join.ArrayBuilder   ");  Node  emptyStringNode  =  Node.newString( ".org.join.ArrayBuilder   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]        junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "org.join.ArrayBuilder   ");  Node  emptyStringNode  =  Node.newString( ".org.join.ArrayBuilder   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "org.join.ArrayBuilder   ");    Node  emptyStringNode  =  Node.newString( ".org.join.ArrayBuilder   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	207	None	add
540	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "org.join.ArrayBuilder   ");  Node  emptyStringNode  =  Node.newString( ",org.join.ArrayBuilder   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]          junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "org.join.ArrayBuilder   ");  Node  emptyStringNode  =  Node.newString( ",org.join.ArrayBuilder   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "org.join.ArrayBuilder   ");    Node  emptyStringNode  =  Node.newString( ",org.join.ArrayBuilder   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	207	None	add
541	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[AssertionFailed] ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "[AssertionFailed] ");	  Node    emptyStringNode    =    Node.newString(   "[AssertionFailedError]   ");    	compilable	  [FE]  AssertionFailedError  	69	3	replace
542	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "[AssertionFailed] ");  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[AssertionFailed] ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "[AssertionFailed] ");	  Node    emptyStringNode    =    Node.newString(   "[AssertionFailedError]   ");    	compilable	  [FE]  AssertionFailedError  	69	3	replace
543	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[AssertionFailedError] "  +  Token.name(originalSize));  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "[AssertionFailedError] "  +  Token.name(originalSize));	  Node    emptyStringNode    =    Node.newString(   "[AssertionFailedError]   ");    	compilable	  [FE]  AssertionFailedError  	69	3	replace
544	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "[AssertionFailedError] "  +  Token.name(originalSize));  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[AssertionFailedError] "  +  Token.name(originalSize));  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "[AssertionFailedError] "  +  Token.name(originalSize));	  Node    emptyStringNode    =    Node.newString(   "[AssertionFailedError]   ");    	compilable	  [FE]  AssertionFailedError  	69	3	replace
545	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "[AssertionFailedError] ").replaceChild(n,  foldedSize);  [CE]  method  replaceChild  in  class  Node  cannot  be  applied  to  given  types;  [FE]        AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[AssertionFailedError] ").replaceChild(n,  foldedSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "[AssertionFailedError] ").replaceChild(n,  foldedSize);	  Node    emptyStringNode    =    Node.newString(   "[AssertionFailedError]   ");    	non-compiled	[CE]  method  replaceChild  in  class  Node  cannot  be  applied  to  given  types;	69	None	replace
546	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "[AssertionFailedError] "  +  Token.name(prev));  [CE]  method  name  in  class  Token  cannot  be  applied  to  given  types;  [FE]          AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[AssertionFailedError] "  +  Token.name(prev));  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "[AssertionFailedError] "  +  Token.name(prev));	  Node    emptyStringNode    =    Node.newString(   "[AssertionFailedError]   ");    	non-compiled	[CE]  method  name  in  class  Token  cannot  be  applied  to  given  types;	69	None	replace
547	[BUG]  [BUGGY]  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]            AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[Assertion] ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "[Assertion] ");	  Node    emptyStringNode    =    Node.newString(   "[AssertionFailedError]   ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	69	3	replace
548	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "[Assertion] ");  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]            AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[Assertion] ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "[Assertion] ");	  Node    emptyStringNode    =    Node.newString(   "[AssertionFailedError]   ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	69	3	replace
549	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "[AssertionFailedError] ",  foldedSize);  [CE]  no  suitable  method  found  for  newString(String,int)  [FE]              AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[AssertionFailedError] ",  foldedSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "[AssertionFailedError] ",  foldedSize);	  Node    emptyStringNode    =    Node.newString(   "[AssertionFailedError]   ");    	non-compiled	[CE]  no  suitable  method  found  for  newString(String,int)	69	None	replace
550	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "JoinArrayBuilder ").build();  [CE]  cannot  find  symbol  [FE]    junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "JoinArrayBuilder ").build();  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "JoinArrayBuilder ").build();	  Node    emptyStringNode    =    Node.newString(   "JoinArrayBuilder   ");    	non-compiled	[CE]  cannot  find  symbol	103	None	replace
551	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "-   "  +  n);  Node  emptyStringNode  =  Node.newString(   "-   "  +  n);  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "-   "  +  n);  Node  emptyStringNode  =  Node.newString(   "-   "  +  n);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "-   "    +    n);    Node  emptyStringNode  =  Node.newString(   "-   "  +  n);	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	48	None	add
552	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "-   "  +  n);  Node  emptyStringNode  =  Node.newString( ".-   "  +  n);  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]      AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "-   "  +  n);  Node  emptyStringNode  =  Node.newString( ".-   "  +  n);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "-   "    +    n);    Node  emptyStringNode  =  Node.newString( ".-   "  +  n);	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	48	None	add
553	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "-   "  +  n);  Node  emptyStringNode  =  Node.newString( ",-   "  +  n);  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]        AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "-   "  +  n);  Node  emptyStringNode  =  Node.newString( ",-   "  +  n);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "-   "    +    n);    Node  emptyStringNode  =  Node.newString( ",-   "  +  n);	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	48	None	add
554	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "-   "  +  n);  Node  emptyStringNode  =  Node.newString(. "-   "  +  n);  [CE]  illegal  start  of  expression  [FE]          AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "-   "  +  n);  Node  emptyStringNode  =  Node.newString(. "-   "  +  n);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "-   "    +    n);    Node  emptyStringNode  =  Node.newString(. "-   "  +  n);	  	non-compiled	[CE]  illegal  start  of  expression	48	None	add
555	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "-   "  +  n);  Node  emptyStringNode  =  Node.newString('-   "  +  n);  [CE]  unclosed  character  literal  [FE]            AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "-   "  +  n);  Node  emptyStringNode  =  Node.newString('-   "  +  n);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "-   "    +    n);    Node  emptyStringNode  =  Node.newString('-   "  +  n);	  	non-compiled	[CE]  unclosed  character  literal	48	None	add
556	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "-   "  +  n);  Node  emptyStringNode  =  Node.newString(... "-   "  +  n);  [CE]  illegal  start  of  expression  [FE]              AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "-   "  +  n);  Node  emptyStringNode  =  Node.newString(... "-   "  +  n);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "-   "    +    n);    Node  emptyStringNode  =  Node.newString(... "-   "  +  n);	  	non-compiled	[CE]  illegal  start  of  expression	48	None	add
557	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.EMPTY,  foldedSize);  [CE]  no  suitable  method  found  for  newString(int,int)  [FE]          junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.EMPTY,  foldedSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(Token.EMPTY,  foldedSize);	  Node    emptyStringNode    =    Node.newString(Token.EMPTY);    	non-compiled	[CE]  no  suitable  method  found  for  newString(int,int)	137	None	replace
558	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.EMPTY,  originalSize);  [CE]  no  suitable  method  found  for  newString(int,int)  [FE]            junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.EMPTY,  originalSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(Token.EMPTY,  originalSize);	  Node    emptyStringNode    =    Node.newString(Token.EMPTY);    	non-compiled	[CE]  no  suitable  method  found  for  newString(int,int)	137	None	replace
559	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.EMPTY,  n);  [CE]  no  suitable  method  found  for  newString(int,Node)  [FE]              junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.EMPTY,  n);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(Token.EMPTY,  n);	  Node    emptyStringNode    =    Node.newString(Token.EMPTY);    	non-compiled	[CE]  no  suitable  method  found  for  newString(int,Node)	137	None	replace
560	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.EMPTY,  left);  [CE]  cannot  find  symbol  left  [FE]                junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.EMPTY,  left);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(Token.EMPTY,  left);	  Node    emptyStringNode    =    Node.newString(Token.EMPTY);    	non-compiled	[CE]  cannot  find  symbol  left	137	None	replace
561	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.EMPTY,  x);  [CE]  cannot  find  symbol  x  [FE]                  junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.EMPTY,  x);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(Token.EMPTY,  x);	  Node    emptyStringNode    =    Node.newString(Token.EMPTY);    	non-compiled	[CE]  cannot  find  symbol  x	137	None	replace
562	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.EMPTY,  sb);  [CE]  no  suitable  method  found  for  newString(int,StringBuilder)  [FE]                    junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.EMPTY,  sb);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(Token.EMPTY,  sb);	  Node    emptyStringNode    =    Node.newString(Token.EMPTY);    	non-compiled	[CE]  no  suitable  method  found  for  newString(int,StringBuilder)	137	None	replace
563	[BUG]  [BUGGY]  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('  [FE]    RuntimeException    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "- "  +  sb.toString()  +  1);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "- "  +  sb.toString()  +  1);	  Node    emptyStringNode    =    Node.newString(   "-   "    +    sb.toString());    	compilable	  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('  	47	3	replace
564	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "- "  +  sb.toString()  +  1);  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('  [FE]    RuntimeException    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "- "  +  sb.toString()  +  1);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "- "  +  sb.toString()  +  1);	  Node    emptyStringNode    =    Node.newString(   "-   "    +    sb.toString());    	compilable	  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('  	47	3	replace
565	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "- "  +  sb.getName());  [CE]  cannot  find  symbol  [FE]      RuntimeException    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "- "  +  sb.getName());  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "- "  +  sb.getName());	  Node    emptyStringNode    =    Node.newString(   "-   "    +    sb.toString());    	non-compiled	[CE]  cannot  find  symbol	47	None	replace
566	[BUG]  [BUGGY]  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('  [FE]        RuntimeException    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "- "  +  sb.toString()).copyInformationFrom(prev);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "- "  +  sb.toString()).copyInformationFrom(prev);	  Node    emptyStringNode    =    Node.newString(   "-   "    +    sb.toString());    	compilable	  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('  	47	3	replace
567	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "- "  +  sb.toString()).copyInformationFrom(prev);  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('  [FE]        RuntimeException    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "- "  +  sb.toString()).copyInformationFrom(prev);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "- "  +  sb.toString()).copyInformationFrom(prev);	  Node    emptyStringNode    =    Node.newString(   "-   "    +    sb.toString());    	compilable	  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('  	47	3	replace
568	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "- "  +  sb.toString()).replaceChild(n,  foldedSize);  [CE]  method  replaceChild  in  class  Node  cannot  be  applied  to  given  types;  [FE]          RuntimeException    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "- "  +  sb.toString()).replaceChild(n,  foldedSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "- "  +  sb.toString()).replaceChild(n,  foldedSize);	  Node    emptyStringNode    =    Node.newString(   "-   "    +    sb.toString());    	non-compiled	[CE]  method  replaceChild  in  class  Node  cannot  be  applied  to  given  types;	47	None	replace
569	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]            RuntimeException    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "- "  +  n.toString());  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "- "  +  n.toString());	  Node    emptyStringNode    =    Node.newString(   "-   "    +    sb.toString());    	compilable	  [FE]  AssertionFailedError  	47	3	replace
570	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "- "  +  n.toString());  [FE]  AssertionFailedError  [FE]            RuntimeException    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "- "  +  n.toString());  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "- "  +  n.toString());	  Node    emptyStringNode    =    Node.newString(   "-   "    +    sb.toString());    	compilable	  [FE]  AssertionFailedError  	47	3	replace
571	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "Arrays.asList(   ");  Node  emptyStringNode  =  Node.newString( "Arrays.asList(   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "Arrays.asList(   ");  Node  emptyStringNode  =  Node.newString( "Arrays.asList(   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "Arrays.asList(   ");    Node  emptyStringNode  =  Node.newString( "Arrays.asList(   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	51	None	add
572	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "Arrays.asList(   ");  Node  emptyStringNode  =  Node.newString( ".Arrays.asList(   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]      AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "Arrays.asList(   ");  Node  emptyStringNode  =  Node.newString( ".Arrays.asList(   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "Arrays.asList(   ");    Node  emptyStringNode  =  Node.newString( ".Arrays.asList(   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	51	None	add
573	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "Arrays.asList(   ");  Node  emptyStringNode  =  Node.newString( "Arrays.asList(   "));  [CE]  [FE]        AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "Arrays.asList(   ");  Node  emptyStringNode  =  Node.newString( "Arrays.asList(   "));  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "Arrays.asList(   ");    Node  emptyStringNode  =  Node.newString( "Arrays.asList(   "));	  	non-compiled	[CE]  	51	None	add
574	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "Arrays.asList(   ");  Node  emptyStringNode  =  Node.newString( ",Arrays.asList(   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]          AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "Arrays.asList(   ");  Node  emptyStringNode  =  Node.newString( ",Arrays.asList(   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "Arrays.asList(   ");    Node  emptyStringNode  =  Node.newString( ",Arrays.asList(   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	51	None	add
575	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "Arrays.asList(   ");  Node  emptyStringNode  =  Node.newString( "Arrays.asList(');  [CE]  unclosed  string  literal  [FE]            AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "Arrays.asList(   ");  Node  emptyStringNode  =  Node.newString( "Arrays.asList(');  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "Arrays.asList(   ");    Node  emptyStringNode  =  Node.newString( "Arrays.asList(');	  	non-compiled	[CE]  unclosed  string  literal	51	None	add
576	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[null] ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "[null] ");	  Node    emptyStringNode    =    Node.newString(   "[n   ");    	compilable	  [FE]  AssertionFailedError  	133	3	replace
577	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "[null] ");  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[null] ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "[null] ");	  Node    emptyStringNode    =    Node.newString(   "[n   ");    	compilable	  [FE]  AssertionFailedError  	133	3	replace
578	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[Locale.ENGLISH] ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "[Locale.ENGLISH] ");	  Node    emptyStringNode    =    Node.newString(   "[n   ");    	compilable	  [FE]  AssertionFailedError  	133	3	replace
579	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "[Locale.ENGLISH] ");  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[Locale.ENGLISH] ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "[Locale.ENGLISH] ");	  Node    emptyStringNode    =    Node.newString(   "[n   ");    	compilable	  [FE]  AssertionFailedError  	133	3	replace
580	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "org.join.ArrayList ",  foldedSize);  [CE]  no  suitable  method  found  for  newString(String,int)  [FE]    junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "org.join.ArrayList ",  foldedSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "org.join.ArrayList ",  foldedSize);	  Node    emptyStringNode    =    Node.newString(   "org.join.ArrayList   ");    	non-compiled	[CE]  no  suitable  method  found  for  newString(String,int)	210	None	replace
581	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "Join.ArrayList ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "Join.ArrayList ");	  Node    emptyStringNode    =    Node.newString(   "org.join.ArrayList   ");    	compilable	  [FE]  AssertionFailedError  	210	3	replace
582	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "Join.ArrayList ");  [FE]  AssertionFailedError  [FE]      junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "Join.ArrayList ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "Join.ArrayList ");	  Node    emptyStringNode    =    Node.newString(   "org.join.ArrayList   ");    	compilable	  [FE]  AssertionFailedError  	210	3	replace
583	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "List ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "List ");	  Node    emptyStringNode    =    Node.newString(   "org.join.ArrayList   ");    	compilable	  [FE]  AssertionFailedError  	210	3	replace
584	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "List ");  [FE]  AssertionFailedError  [FE]        junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "List ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "List ");	  Node    emptyStringNode    =    Node.newString(   "org.join.ArrayList   ");    	compilable	  [FE]  AssertionFailedError  	210	3	replace
585	[BUG]  [BUGGY]  [FE]  junit.framework.AssertionFailedError:  Expected:  x= " "  Result:  x= "  [FE]            AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ",[ ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( ",[ ");	  Node    emptyStringNode    =    Node.newString(       "[       ");    Node    emptyStringNode    =    Node.newString(   ",[       ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x= " "  Result:  x= "  	97	3	replace
586	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( ",[ ");  [FE]  junit.framework.AssertionFailedError:  Expected:  x= " "  Result:  x= "  [FE]            AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ",[ ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( ",[ ");	  Node    emptyStringNode    =    Node.newString(       "[       ");    Node    emptyStringNode    =    Node.newString(   ",[       ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x= " "  Result:  x= "  	97	3	replace
587	[BUG]  [BUGGY]  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]              AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ",[0] ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( ",[0] ");	  Node    emptyStringNode    =    Node.newString(       "[       ");    Node    emptyStringNode    =    Node.newString(   ",[       ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	97	3	replace
588	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( ",[0] ");  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]              AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ",[0] ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( ",[0] ");	  Node    emptyStringNode    =    Node.newString(       "[       ");    Node    emptyStringNode    =    Node.newString(   ",[       ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	97	3	replace
589	[BUG]  [BUGGY]  [FE]  junit.framework.AssertionFailedError:  Expected:  x= " "  Result:  x= "  [FE]                AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ",[] ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( ",[] ");	  Node    emptyStringNode    =    Node.newString(       "[       ");    Node    emptyStringNode    =    Node.newString(   ",[       ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x= " "  Result:  x= "  	97	3	replace
590	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( ",[] ");  [FE]  junit.framework.AssertionFailedError:  Expected:  x= " "  Result:  x= "  [FE]                AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ",[] ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( ",[] ");	  Node    emptyStringNode    =    Node.newString(       "[       ");    Node    emptyStringNode    =    Node.newString(   ",[       ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x= " "  Result:  x= "  	97	3	replace
591	[BUG]  [BUGGY]  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]                  AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ";[ ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( ";[ ");	  Node    emptyStringNode    =    Node.newString(       "[       ");    Node    emptyStringNode    =    Node.newString(   ",[       ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	97	3	replace
592	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( ";[ ");  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]                  AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ";[ ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( ";[ ");	  Node    emptyStringNode    =    Node.newString(       "[       ");    Node    emptyStringNode    =    Node.newString(   ",[       ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	97	3	replace
593	[BUG]  [BUGGY]  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]                    AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ",[0], ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( ",[0], ");	  Node    emptyStringNode    =    Node.newString(       "[       ");    Node    emptyStringNode    =    Node.newString(   ",[       ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	97	3	replace
594	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( ",[0], ");  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]                    AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ",[0], ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( ",[0], ");	  Node    emptyStringNode    =    Node.newString(       "[       ");    Node    emptyStringNode    =    Node.newString(   ",[       ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	97	3	replace
595	[BUG]  [BUGGY]  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  Index:  1  [FE]    java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  Index:  0    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  arrayFoldedChildren.get(1);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  arrayFoldedChildren.get(1);	  Node    emptyStringNode    =    arrayFoldedChildren.get(0);    	compilable	  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  Index:  1  	2	3	replace
596	[BUG]  [BUGGY]  Node  emptyStringNode  =  arrayFoldedChildren.get(1);  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  Index:  1  [FE]    java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  Index:  0    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  arrayFoldedChildren.get(1);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  arrayFoldedChildren.get(1);	  Node    emptyStringNode    =    arrayFoldedChildren.get(0);    	compilable	  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  Index:  1  	2	3	replace
597	[BUG]  [BUGGY]  Node  emptyStringNode  =  arrayFoldedChildren.get(0)  -  1;  [CE]  bad  operand  types  for  binary  operator  '-'  [FE]      java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  Index:  0    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  arrayFoldedChildren.get(0)  -  1;  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  arrayFoldedChildren.get(0)  -  1;	  Node    emptyStringNode    =    arrayFoldedChildren.get(0);    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '-'	2	None	replace
598	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME,  n);  [CE]  no  suitable  method  found  for  newString(int,Node)  [FE]                junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME,  n);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(Token.NAME,  n);	  Node    emptyStringNode    =    Node.newString(Token.NAME);    	non-compiled	[CE]  no  suitable  method  found  for  newString(int,Node)	42	None	replace
599	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME,  left);  [CE]  cannot  find  symbol  left  [FE]                  junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME,  left);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(Token.NAME,  left);	  Node    emptyStringNode    =    Node.newString(Token.NAME);    	non-compiled	[CE]  cannot  find  symbol  left	42	None	replace
600	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME,  sb);  [CE]  no  suitable  method  found  for  newString(int,StringBuilder)  [FE]                    junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME,  sb);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(Token.NAME,  sb);	  Node    emptyStringNode    =    Node.newString(Token.NAME);    	non-compiled	[CE]  no  suitable  method  found  for  newString(int,StringBuilder)	42	None	replace
601	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME,  prev);  [CE]  no  suitable  method  found  for  newString(int,Node)  [FE]                      junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME,  prev);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(Token.NAME,  prev);	  Node    emptyStringNode    =    Node.newString(Token.NAME);    	non-compiled	[CE]  no  suitable  method  found  for  newString(int,Node)	42	None	replace
602	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ".- ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( ".- ");	  Node    emptyStringNode    =    Node.newString(       "-       ");    Node    emptyStringNode    =    Node.newString(   ".-       ");    	compilable	  [FE]  AssertionFailedError  	112	3	replace
603	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( ".- ");  [FE]  AssertionFailedError  [FE]          AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ".- ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( ".- ");	  Node    emptyStringNode    =    Node.newString(       "-       ");    Node    emptyStringNode    =    Node.newString(   ".-       ");    	compilable	  [FE]  AssertionFailedError  	112	3	replace
604	[BUG]  [BUGGY]  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]            AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ": ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( ": ");	  Node    emptyStringNode    =    Node.newString(       "-       ");    Node    emptyStringNode    =    Node.newString(   ".-       ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	112	3	replace
605	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( ": ");  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]            AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ": ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( ": ");	  Node    emptyStringNode    =    Node.newString(       "-       ");    Node    emptyStringNode    =    Node.newString(   ".-       ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	112	3	replace
606	[BUG]  [BUGGY]  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]            AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ",java.util.ArrayList ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( ",java.util.ArrayList ");	  Node    emptyStringNode    =    Node.newString(       "java.util.ArrayList       ");    Node    emptyStringNode    =    Node.newString(   ",java.util.ArrayList       ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	26	3	replace
607	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( ",java.util.ArrayList ");  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]            AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ",java.util.ArrayList ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( ",java.util.ArrayList ");	  Node    emptyStringNode    =    Node.newString(       "java.util.ArrayList       ");    Node    emptyStringNode    =    Node.newString(   ",java.util.ArrayList       ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	26	3	replace
608	[BUG]  [BUGGY]  [FE]  junit.framework.AssertionFailedError:  Expected:  x= " "  Result:  x= "  [FE]              AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ",ArrayList ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( ",ArrayList ");	  Node    emptyStringNode    =    Node.newString(       "java.util.ArrayList       ");    Node    emptyStringNode    =    Node.newString(   ",java.util.ArrayList       ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x= " "  Result:  x= "  	26	3	replace
609	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( ",ArrayList ");  [FE]  junit.framework.AssertionFailedError:  Expected:  x= " "  Result:  x= "  [FE]              AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ",ArrayList ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( ",ArrayList ");	  Node    emptyStringNode    =    Node.newString(       "java.util.ArrayList       ");    Node    emptyStringNode    =    Node.newString(   ",java.util.ArrayList       ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x= " "  Result:  x= "  	26	3	replace
610	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( ",java.util.ArrayList ",  foldedSize);  [CE]  no  suitable  method  found  for  newString(String,int)  [FE]                AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ",java.util.ArrayList ",  foldedSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( ",java.util.ArrayList ",  foldedSize);	  Node    emptyStringNode    =    Node.newString(       "java.util.ArrayList       ");    Node    emptyStringNode    =    Node.newString(   ",java.util.ArrayList       ");    	non-compiled	[CE]  no  suitable  method  found  for  newString(String,int)	26	None	replace
611	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "[ArrayList] ",  arrayFoldedChildren.size());  [CE]  no  suitable  method  found  for  newString(String,int)  [FE]                  AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[ArrayList] ",  arrayFoldedChildren.size());  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "[ArrayList] ",  arrayFoldedChildren.size());	  Node    emptyStringNode    =    Node.newString(       "java.util.ArrayList       ");    Node    emptyStringNode    =    Node.newString(   ",java.util.ArrayList       ");    	non-compiled	[CE]  no  suitable  method  found  for  newString(String,int)	26	None	replace
612	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( ",ArrayList ",  foldedSize);  [CE]  no  suitable  method  found  for  newString(String,int)  [FE]                    AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ",ArrayList ",  foldedSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( ",ArrayList ",  foldedSize);	  Node    emptyStringNode    =    Node.newString(       "java.util.ArrayList       ");    Node    emptyStringNode    =    Node.newString(   ",java.util.ArrayList       ");    	non-compiled	[CE]  no  suitable  method  found  for  newString(String,int)	26	None	replace
613	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "arrayJoin ",  kJoinOverhead);  [CE]  cannot  find  symbol  kJoinOverhead  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "arrayJoin ",  kJoinOverhead);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "arrayJoin ",  kJoinOverhead);	  Node    emptyStringNode    =    Node.newString(   "arrayJoin   ");    	non-compiled	[CE]  cannot  find  symbol  kJoinOverhead	71	None	replace
614	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "arrayJoin ",  originalSize);  [CE]  no  suitable  method  found  for  newString(String,int)  [FE]      AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "arrayJoin ",  originalSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "arrayJoin ",  originalSize);	  Node    emptyStringNode    =    Node.newString(   "arrayJoin   ");    	non-compiled	[CE]  no  suitable  method  found  for  newString(String,int)	71	None	replace
615	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "arrayJoin ",  sb.toString());  [CE]  no  suitable  method  found  for  newString(String,String)  [FE]        AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "arrayJoin ",  sb.toString());  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "arrayJoin ",  sb.toString());	  Node    emptyStringNode    =    Node.newString(   "arrayJoin   ");    	non-compiled	[CE]  no  suitable  method  found  for  newString(String,String)	71	None	replace
616	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "Arrays   ");  Node  emptyStringNode  =  Node.newString(   "Arrays   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "Arrays   ");  Node  emptyStringNode  =  Node.newString(   "Arrays   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "Arrays   ");    Node  emptyStringNode  =  Node.newString(   "Arrays   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	191	None	add
617	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "Arrays   ");  Node  emptyStringNode  =  Node.newString( ",Arrays   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]      AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "Arrays   ");  Node  emptyStringNode  =  Node.newString( ",Arrays   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "Arrays   ");    Node  emptyStringNode  =  Node.newString( ",Arrays   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	191	None	add
618	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "Arrays   ");  Node  emptyStringNode  =  Node.newString( ".Arrays   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]        AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "Arrays   ");  Node  emptyStringNode  =  Node.newString( ".Arrays   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "Arrays   ");    Node  emptyStringNode  =  Node.newString( ".Arrays   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	191	None	add
619	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "Arrays   ");  Node  emptyStringNode  =  Node.newString(. "Arrays   ");  [CE]  illegal  start  of  expression  [FE]          AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "Arrays   ");  Node  emptyStringNode  =  Node.newString(. "Arrays   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "Arrays   ");    Node  emptyStringNode  =  Node.newString(. "Arrays   ");	  	non-compiled	[CE]  illegal  start  of  expression	191	None	add
620	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "Arrays   ");  Node  emptyStringNode  =  Node.newString(, "Arrays   ");  [CE]  illegal  start  of  expression  [FE]            AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "Arrays   ");  Node  emptyStringNode  =  Node.newString(, "Arrays   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "Arrays   ");    Node  emptyStringNode  =  Node.newString(, "Arrays   ");	  	non-compiled	[CE]  illegal  start  of  expression	191	None	add
621	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "Arrays   ");  Node  emptyStringNode  =  Node.newString(... "Arrays   ");  [CE]  illegal  start  of  expression  [FE]              AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "Arrays   ");  Node  emptyStringNode  =  Node.newString(... "Arrays   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "Arrays   ");    Node  emptyStringNode  =  Node.newString(... "Arrays   ");	  	non-compiled	[CE]  illegal  start  of  expression	191	None	add
622	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "Array ").copyInformationFrom(originalSize);  [CE]  method  copyInformationFrom  in  class  Node  cannot  be  applied  to  given  types;  [FE]    java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "Array ").copyInformationFrom(originalSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "Array ").copyInformationFrom(originalSize);	  Node    emptyStringNode    =    Node.newString(   "Array   ").copyInformationFrom(prev);    	non-compiled	[CE]  method  copyInformationFrom  in  class  Node  cannot  be  applied  to  given  types;	166	None	replace
623	[BUG]  [BUGGY]  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('  [FE]      java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(sb.toString()).copyInformationFrom(prev);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString(sb.toString()).copyInformationFrom(prev);	  Node    emptyStringNode    =    Node.newString(   "Array   ").copyInformationFrom(prev);    	compilable	  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('  	166	3	replace
624	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(sb.toString()).copyInformationFrom(prev);  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('  [FE]      java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(sb.toString()).copyInformationFrom(prev);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(sb.toString()).copyInformationFrom(prev);	  Node    emptyStringNode    =    Node.newString(   "Array   ").copyInformationFrom(prev);    	compilable	  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('  	166	3	replace
625	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "Array ").copyInformationFrom(initialSize);  [CE]  cannot  find  symbol  initialSize  [FE]        java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "Array ").copyInformationFrom(initialSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "Array ").copyInformationFrom(initialSize);	  Node    emptyStringNode    =    Node.newString(   "Array   ").copyInformationFrom(prev);    	non-compiled	[CE]  cannot  find  symbol  initialSize	166	None	replace
626	[BUG]  [BUGGY]  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]          java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "Array ").copyInformationFrom(n);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "Array ").copyInformationFrom(n);	  Node    emptyStringNode    =    Node.newString(   "Array   ").copyInformationFrom(prev);    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	166	3	replace
627	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "Array ").copyInformationFrom(n);  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]          java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "Array ").copyInformationFrom(n);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "Array ").copyInformationFrom(n);	  Node    emptyStringNode    =    Node.newString(   "Array   ").copyInformationFrom(prev);    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	166	3	replace
628	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]            java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "Array ").copyInformationFrom(functionName);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "Array ").copyInformationFrom(functionName);	  Node    emptyStringNode    =    Node.newString(   "Array   ").copyInformationFrom(prev);    	compilable	  [FE]  AssertionFailedError  	166	3	replace
629	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "Array ").copyInformationFrom(functionName);  [FE]  AssertionFailedError  [FE]            java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "Array ").copyInformationFrom(functionName);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "Array ").copyInformationFrom(functionName);	  Node    emptyStringNode    =    Node.newString(   "Array   ").copyInformationFrom(prev);    	compilable	  [FE]  AssertionFailedError  	166	3	replace
630	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "Array ").copyInformationFrom(sb);  [CE]  method  copyInformationFrom  in  class  Node  cannot  be  applied  to  given  types;  [FE]              java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "Array ").copyInformationFrom(sb);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "Array ").copyInformationFrom(sb);	  Node    emptyStringNode    =    Node.newString(   "Array   ").copyInformationFrom(prev);    	non-compiled	[CE]  method  copyInformationFrom  in  class  Node  cannot  be  applied  to  given  types;	166	None	replace
631	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "Array ").copyInformationFrom(type);  [CE]  cannot  find  symbol  type  [FE]                java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "Array ").copyInformationFrom(type);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "Array ").copyInformationFrom(type);	  Node    emptyStringNode    =    Node.newString(   "Array   ").copyInformationFrom(prev);    	non-compiled	[CE]  cannot  find  symbol  type	166	None	replace
632	[BUG]  [BUGGY]  Node  emptyStringNode  =  n.getFirstChild();  Node  emptyStringNode  =  n.getFirstChild();  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]    java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  The  new  child  node  has  siblings.  Node(CALL):  testcode:1:11  x  =  [].join('    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  n.getFirstChild();  Node  emptyStringNode  =  n.getFirstChild();  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    n.getFirstChild();    Node  emptyStringNode  =  n.getFirstChild();	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	7	None	add
633	[BUG]  [BUGGY]  Node  emptyStringNode  =  n.getFirstChild();  Node  emptyStringNode  =  n.getLastChild();  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]      java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  The  new  child  node  has  siblings.  Node(CALL):  testcode:1:11  x  =  [].join('    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  n.getFirstChild();  Node  emptyStringNode  =  n.getLastChild();  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    n.getFirstChild();    Node  emptyStringNode  =  n.getLastChild();	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	7	None	add
634	[BUG]  [BUGGY]  Node  emptyStringNode  =  n.getFirstChild();  Node  emptyStringNode  =  sb.getFirstChild();  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]        java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  The  new  child  node  has  siblings.  Node(CALL):  testcode:1:11  x  =  [].join('    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  n.getFirstChild();  Node  emptyStringNode  =  sb.getFirstChild();  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    n.getFirstChild();    Node  emptyStringNode  =  sb.getFirstChild();	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	7	None	add
635	[BUG]  [BUGGY]  Node  emptyStringNode  =  n.getFirstChild();  Node  emptyStringNode  =  n.getFirstChild());  [CE]  ';'  expected  [FE]          java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  The  new  child  node  has  siblings.  Node(CALL):  testcode:1:11  x  =  [].join('    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  n.getFirstChild();  Node  emptyStringNode  =  n.getFirstChild());  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    n.getFirstChild();    Node  emptyStringNode  =  n.getFirstChild());	  	non-compiled	[CE]  ';'  expected	7	None	add
636	[BUG]  [BUGGY]  Node  emptyStringNode  =  n.getFirstChild();  Node  emptyStringNode  =  parent.getFirstChild();  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]            java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  The  new  child  node  has  siblings.  Node(CALL):  testcode:1:11  x  =  [].join('    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  n.getFirstChild();  Node  emptyStringNode  =  parent.getFirstChild();  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    n.getFirstChild();    Node  emptyStringNode  =  parent.getFirstChild();	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	7	None	add
637	[BUG]  [BUGGY]  Node  emptyStringNode  =  n.getFirstChild();  Node  emptyStringNode  =  n.getFirstChild();  case  1:  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]              java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  The  new  child  node  has  siblings.  Node(CALL):  testcode:1:11  x  =  [].join('    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  n.getFirstChild();  Node  emptyStringNode  =  n.getFirstChild();  case  1:  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    n.getFirstChild();    Node  emptyStringNode  =  n.getFirstChild();  case  1:	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	7	None	add
638	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "string "));  [CE]  [FE]              AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "string "));  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "string "));	  Node    emptyStringNode    =    Node.newString(       "string       ");    Node    emptyStringNode    =    Node.newString(   "string   "));    	non-compiled	[CE]  	90	None	replace
639	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "string ").toString();  [CE]  incompatible  types  [FE]                AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "string ").toString();  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "string ").toString();	  Node    emptyStringNode    =    Node.newString(       "string       ");    Node    emptyStringNode    =    Node.newString(   "string   "));    	non-compiled	[CE]  incompatible  types	90	None	replace
640	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME,   "Array "  +  originalSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString(Token.NAME,   "Array "  +  originalSize);	  Node    emptyStringNode    =    Node.newString(Token.NAME,   "Array   ");    	compilable	  [FE]  AssertionFailedError  	120	3	replace
641	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME,   "Array "  +  originalSize);  [FE]  AssertionFailedError  [FE]    junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME,   "Array "  +  originalSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(Token.NAME,   "Array "  +  originalSize);	  Node    emptyStringNode    =    Node.newString(Token.NAME,   "Array   ");    	compilable	  [FE]  AssertionFailedError  	120	3	replace
642	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]            AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "]. ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "]. ");	  Node    emptyStringNode    =    Node.newString(       "]       ");    Node    emptyStringNode    =    Node.newString(       "].   ");    	compilable	  [FE]  AssertionFailedError  	93	3	replace
643	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "]. ");  [FE]  AssertionFailedError  [FE]            AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "]. ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "]. ");	  Node    emptyStringNode    =    Node.newString(       "]       ");    Node    emptyStringNode    =    Node.newString(       "].   ");    	compilable	  [FE]  AssertionFailedError  	93	3	replace
644	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "]. ",  n);  [CE]  no  suitable  method  found  for  newString(String,Node)  [FE]              AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "]. ",  n);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "]. ",  n);	  Node    emptyStringNode    =    Node.newString(       "]       ");    Node    emptyStringNode    =    Node.newString(       "].   ");    	non-compiled	[CE]  no  suitable  method  found  for  newString(String,Node)	93	None	replace
645	[BUG]  [BUGGY]  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]                AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ". ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( ". ");	  Node    emptyStringNode    =    Node.newString(       "]       ");    Node    emptyStringNode    =    Node.newString(       "].   ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	93	3	replace
646	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( ". ");  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]                AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ". ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( ". ");	  Node    emptyStringNode    =    Node.newString(       "]       ");    Node    emptyStringNode    =    Node.newString(       "].   ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	93	3	replace
647	[BUG]  [BUGGY]  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]                  AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "].. ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "].. ");	  Node    emptyStringNode    =    Node.newString(       "]       ");    Node    emptyStringNode    =    Node.newString(       "].   ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	93	3	replace
648	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "].. ");  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]                  AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "].. ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "].. ");	  Node    emptyStringNode    =    Node.newString(       "]       ");    Node    emptyStringNode    =    Node.newString(       "].   ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	93	3	replace
649	[BUG]  [BUGGY]  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "Array_name ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "Array_name ");	  Node    emptyStringNode    =    Node.newString(   "array_name   ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	73	3	replace
650	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "Array_name ");  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "Array_name ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "Array_name ");	  Node    emptyStringNode    =    Node.newString(   "array_name   ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	73	3	replace
651	[BUG]  [BUGGY]  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]      AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "array_name "  +  originalSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "array_name "  +  originalSize);	  Node    emptyStringNode    =    Node.newString(   "array_name   ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	73	3	replace
652	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "array_name "  +  originalSize);  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]      AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "array_name "  +  originalSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "array_name "  +  originalSize);	  Node    emptyStringNode    =    Node.newString(   "array_name   ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	73	3	replace
653	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "array_name ",  n);  [CE]  no  suitable  method  found  for  newString(String,Node)  [FE]        AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "array_name ",  n);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "array_name ",  n);	  Node    emptyStringNode    =    Node.newString(   "array_name   ");    	non-compiled	[CE]  no  suitable  method  found  for  newString(String,Node)	73	None	replace
654	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "array_name ",  sb.toString());  [CE]  no  suitable  method  found  for  newString(String,String)  [FE]          AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "array_name ",  sb.toString());  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "array_name ",  sb.toString());	  Node    emptyStringNode    =    Node.newString(   "array_name   ");    	non-compiled	[CE]  no  suitable  method  found  for  newString(String,String)	73	None	replace
655	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "array_name ",  prev);  [CE]  no  suitable  method  found  for  newString(String,Node)  [FE]            AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "array_name ",  prev);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "array_name ",  prev);	  Node    emptyStringNode    =    Node.newString(   "array_name   ");    	non-compiled	[CE]  no  suitable  method  found  for  newString(String,Node)	73	None	replace
656	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "ArrayElement   ");  Node  emptyStringNode  =  Node.newString( "ArrayElement   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "ArrayElement   ");  Node  emptyStringNode  =  Node.newString( "ArrayElement   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "ArrayElement   ");    Node  emptyStringNode  =  Node.newString( "ArrayElement   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	36	None	add
657	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "ArrayElement   ");  Node  emptyStringNode  =  Node.newString( ",ArrayElement   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]      AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "ArrayElement   ");  Node  emptyStringNode  =  Node.newString( ",ArrayElement   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "ArrayElement   ");    Node  emptyStringNode  =  Node.newString( ",ArrayElement   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	36	None	add
658	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "ArrayElement   ");  Node  emptyStringNode  =  Node.newString( ".ArrayElement   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]        AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "ArrayElement   ");  Node  emptyStringNode  =  Node.newString( ".ArrayElement   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "ArrayElement   ");    Node  emptyStringNode  =  Node.newString( ".ArrayElement   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	36	None	add
659	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "ArrayElement   ");  Node  emptyStringNode  =  Node.newString(, "ArrayElement   ");  [CE]  illegal  start  of  expression  [FE]          AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "ArrayElement   ");  Node  emptyStringNode  =  Node.newString(, "ArrayElement   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "ArrayElement   ");    Node  emptyStringNode  =  Node.newString(, "ArrayElement   ");	  	non-compiled	[CE]  illegal  start  of  expression	36	None	add
660	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "ArrayElement   ");  Node  emptyStringNode  =  Node.newString(. "ArrayElement   ");  [CE]  illegal  start  of  expression  [FE]            AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "ArrayElement   ");  Node  emptyStringNode  =  Node.newString(. "ArrayElement   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "ArrayElement   ");    Node  emptyStringNode  =  Node.newString(. "ArrayElement   ");	  	non-compiled	[CE]  illegal  start  of  expression	36	None	add
661	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "ArrayElement   ");  Node  emptyStringNode  =  Node.newString( "ArrayElement ",);  [CE]  illegal  start  of  expression  [FE]              AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "ArrayElement   ");  Node  emptyStringNode  =  Node.newString( "ArrayElement ",);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "ArrayElement   ");    Node  emptyStringNode  =  Node.newString( "ArrayElement ",);	  	non-compiled	[CE]  illegal  start  of  expression	36	None	add
662	[BUG]  [BUGGY]  Node  emptyStringNode  =  arrayFoldedChildren.get(initialSize);  [CE]  cannot  find  symbol  initialSize  [FE]                            junit.framework.AssertionFailedError:  Expected:  x=[     "a     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  arrayFoldedChildren.get(initialSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  arrayFoldedChildren.get(initialSize);	  Node    emptyStringNode    =    arrayFoldedChildren.get(i);    	non-compiled	[CE]  cannot  find  symbol  initialSize	3	None	replace
663	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.ArrayElement ").join( "  Expected:  x= "  [CE]  [FE]        junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.ArrayElement ").join( "  Expected:  x= "  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "java.util.ArrayElement ").join( "  Expected:  x= "	  Node    emptyStringNode    =    Node.newString(   "java.util.ArrayElement   ").join(   "    Expected:    x=[   "    	non-compiled	[CE]  	193	None	replace
664	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.ArrayElement ").join( "  Expected:  x=[0]  [CE]  unclosed  string  literal  [FE]          junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.ArrayElement ").join( "  Expected:  x=[0]  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "java.util.ArrayElement ").join( "  Expected:  x=[0]	  Node    emptyStringNode    =    Node.newString(   "java.util.ArrayElement   ").join(   "    Expected:    x=[   "    	non-compiled	[CE]  unclosed  string  literal	193	None	replace
665	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "ArrayElement ").join( "  Expected:  x=[   "  [CE]  [FE]            junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "ArrayElement ").join( "  Expected:  x=[   "  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "ArrayElement ").join( "  Expected:  x=[   "	  Node    emptyStringNode    =    Node.newString(   "java.util.ArrayElement   ").join(   "    Expected:    x=[   "    	non-compiled	[CE]  	193	None	replace
666	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.ArrayElement ").join( "  Expected:  x=[  [CE]  unclosed  string  literal  [FE]              junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.ArrayElement ").join( "  Expected:  x=[  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "java.util.ArrayElement ").join( "  Expected:  x=[	  Node    emptyStringNode    =    Node.newString(   "java.util.ArrayElement   ").join(   "    Expected:    x=[   "    	non-compiled	[CE]  unclosed  string  literal	193	None	replace
667	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.ArrayElement ").join( "  Expected:  x=[|  [CE]  unclosed  string  literal  [FE]                junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.ArrayElement ").join( "  Expected:  x=[|  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "java.util.ArrayElement ").join( "  Expected:  x=[|	  Node    emptyStringNode    =    Node.newString(   "java.util.ArrayElement   ").join(   "    Expected:    x=[   "    	non-compiled	[CE]  unclosed  string  literal	193	None	replace
668	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "Join.java.util.ArrayBuilder ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "Join.java.util.ArrayBuilder ");	  Node    emptyStringNode    =    Node.newString(       "java.util.ArrayBuilder       ");    Node    emptyStringNode    =    Node.newString(   ".java.util.ArrayBuilder       ");    	compilable	  [FE]  AssertionFailedError  	122	3	replace
669	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "Join.java.util.ArrayBuilder ");  [FE]  AssertionFailedError  [FE]          junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "Join.java.util.ArrayBuilder ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "Join.java.util.ArrayBuilder ");	  Node    emptyStringNode    =    Node.newString(       "java.util.ArrayBuilder       ");    Node    emptyStringNode    =    Node.newString(   ".java.util.ArrayBuilder       ");    	compilable	  [FE]  AssertionFailedError  	122	3	replace
670	[BUG]  [BUGGY]  n  =  Node.newString( "java.util.ArrayBuilder ");  [CE]  cannot  find  symbol  emptyStringNode  [FE]            junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  n  =  Node.newString( "java.util.ArrayBuilder ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	n  =  Node.newString( "java.util.ArrayBuilder ");	  Node    emptyStringNode    =    Node.newString(       "java.util.ArrayBuilder       ");    Node    emptyStringNode    =    Node.newString(   ".java.util.ArrayBuilder       ");    	non-compiled	[CE]  cannot  find  symbol  emptyStringNode	122	None	replace
671	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "-   "  +  originalSize);  Node  emptyStringNode  =  Node.newString(   "-   "  +  originalSize);  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "-   "  +  originalSize);  Node  emptyStringNode  =  Node.newString(   "-   "  +  originalSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "-   "    +    originalSize);    Node  emptyStringNode  =  Node.newString(   "-   "  +  originalSize);	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	44	None	add
672	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "-   "  +  originalSize);  Node  emptyStringNode  =  Node.newString( ".-   "  +  originalSize);  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]      AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "-   "  +  originalSize);  Node  emptyStringNode  =  Node.newString( ".-   "  +  originalSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "-   "    +    originalSize);    Node  emptyStringNode  =  Node.newString( ".-   "  +  originalSize);	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	44	None	add
673	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "-   "  +  originalSize);  Node  emptyStringNode  =  Node.newString( ",-   "  +  originalSize);  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]        AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "-   "  +  originalSize);  Node  emptyStringNode  =  Node.newString( ",-   "  +  originalSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "-   "    +    originalSize);    Node  emptyStringNode  =  Node.newString( ",-   "  +  originalSize);	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	44	None	add
674	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "-   "  +  originalSize);  Node  emptyStringNode  =  Node.newString(. "-   "  +  originalSize);  [CE]  illegal  start  of  expression  [FE]          AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "-   "  +  originalSize);  Node  emptyStringNode  =  Node.newString(. "-   "  +  originalSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "-   "    +    originalSize);    Node  emptyStringNode  =  Node.newString(. "-   "  +  originalSize);	  	non-compiled	[CE]  illegal  start  of  expression	44	None	add
675	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "-   "  +  originalSize);  Node  emptyStringNode  =  Node.newString(   "-   "  +  initialSize);  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]            AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "-   "  +  originalSize);  Node  emptyStringNode  =  Node.newString(   "-   "  +  initialSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "-   "    +    originalSize);    Node  emptyStringNode  =  Node.newString(   "-   "  +  initialSize);	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	44	None	add
676	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "- "  +  foldedSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "- "  +  foldedSize);	  Node    emptyStringNode    =    Node.newString(   "-   "    +    originalSize);    	compilable	  [FE]  AssertionFailedError  	45	3	replace
677	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "- "  +  foldedSize);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "- "  +  foldedSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "- "  +  foldedSize);	  Node    emptyStringNode    =    Node.newString(   "-   "    +    originalSize);    	compilable	  [FE]  AssertionFailedError  	45	3	replace
678	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "- "  +  originalSize  +  1);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "- "  +  originalSize  +  1);	  Node    emptyStringNode    =    Node.newString(   "-   "    +    originalSize);    	compilable	  [FE]  AssertionFailedError  	45	3	replace
679	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "- "  +  originalSize  +  1);  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "- "  +  originalSize  +  1);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "- "  +  originalSize  +  1);	  Node    emptyStringNode    =    Node.newString(   "-   "    +    originalSize);    	compilable	  [FE]  AssertionFailedError  	45	3	replace
680	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "-   "  +  sb.toString());  Node  emptyStringNode  =  Node.newString( "-   "  +  sb.toString());  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]    RuntimeException    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "-   "  +  sb.toString());  Node  emptyStringNode  =  Node.newString( "-   "  +  sb.toString());  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "-   "    +    sb.toString());    Node  emptyStringNode  =  Node.newString( "-   "  +  sb.toString());	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	46	None	add
681	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "-   "  +  sb.toString());  Node  emptyStringNode  =  Node.newString( ",-   "  +  sb.toString());  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]      RuntimeException    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "-   "  +  sb.toString());  Node  emptyStringNode  =  Node.newString( ",-   "  +  sb.toString());  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "-   "    +    sb.toString());    Node  emptyStringNode  =  Node.newString( ",-   "  +  sb.toString());	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	46	None	add
682	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "-   "  +  sb.toString());  Node  emptyStringNode  =  Node.newString( ".-   "  +  sb.toString());  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]        RuntimeException    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "-   "  +  sb.toString());  Node  emptyStringNode  =  Node.newString( ".-   "  +  sb.toString());  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "-   "    +    sb.toString());    Node  emptyStringNode  =  Node.newString( ".-   "  +  sb.toString());	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	46	None	add
683	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "-   "  +  sb.toString());  Node  emptyStringNode  =  Node.newString(. "-   "  +  sb.toString());  [CE]  illegal  start  of  expression  [FE]          RuntimeException    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "-   "  +  sb.toString());  Node  emptyStringNode  =  Node.newString(. "-   "  +  sb.toString());  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "-   "    +    sb.toString());    Node  emptyStringNode  =  Node.newString(. "-   "  +  sb.toString());	  	non-compiled	[CE]  illegal  start  of  expression	46	None	add
684	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "-   "  +  sb.toString());  Node  emptyStringNode  =  Node.newString(, "-   "  +  sb.toString());  [CE]  illegal  start  of  expression  [FE]            RuntimeException    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "-   "  +  sb.toString());  Node  emptyStringNode  =  Node.newString(, "-   "  +  sb.toString());  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "-   "    +    sb.toString());    Node  emptyStringNode  =  Node.newString(, "-   "  +  sb.toString());	  	non-compiled	[CE]  illegal  start  of  expression	46	None	add
685	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "-   "  +  sb.toString());  Node  emptyStringNode  =  Node.newString(! "-   "  +  sb.toString());  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]              RuntimeException    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "-   "  +  sb.toString());  Node  emptyStringNode  =  Node.newString(! "-   "  +  sb.toString());  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "-   "    +    sb.toString());    Node  emptyStringNode  =  Node.newString(! "-   "  +  sb.toString());	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	46	None	add
686	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "JoinOverhead ",  foldedSize);  [CE]  no  suitable  method  found  for  newString(String,int)  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "JoinOverhead ",  foldedSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "JoinOverhead ",  foldedSize);	  Node    emptyStringNode    =    Node.newString(   "JoinOverhead   ");    	non-compiled	[CE]  no  suitable  method  found  for  newString(String,int)	146	None	replace
687	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "JoinOverhead ",  kJoinOverhead);  [CE]  cannot  find  symbol  kJoinOverhead  [FE]      AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "JoinOverhead ",  kJoinOverhead);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "JoinOverhead ",  kJoinOverhead);	  Node    emptyStringNode    =    Node.newString(   "JoinOverhead   ");    	non-compiled	[CE]  cannot  find  symbol  kJoinOverhead	146	None	replace
688	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "JoinOverhead ",  sb.toString());  [CE]  no  suitable  method  found  for  newString(String,String)  [FE]        AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "JoinOverhead ",  sb.toString());  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "JoinOverhead ",  sb.toString());	  Node    emptyStringNode    =    Node.newString(   "JoinOverhead   ");    	non-compiled	[CE]  no  suitable  method  found  for  newString(String,String)	146	None	replace
689	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "JoinOverhead ",  originalSize);  [CE]  no  suitable  method  found  for  newString(String,int)  [FE]          AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "JoinOverhead ",  originalSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "JoinOverhead ",  originalSize);	  Node    emptyStringNode    =    Node.newString(   "JoinOverhead   ");    	non-compiled	[CE]  no  suitable  method  found  for  newString(String,int)	146	None	replace
690	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "JoinOverhead ",  n);  [CE]  no  suitable  method  found  for  newString(String,Node)  [FE]            AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "JoinOverhead ",  n);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "JoinOverhead ",  n);	  Node    emptyStringNode    =    Node.newString(   "JoinOverhead   ");    	non-compiled	[CE]  no  suitable  method  found  for  newString(String,Node)	146	None	replace
691	[BUG]  [BUGGY]  [FE]  junit.framework.AssertionFailedError:  Expected:  x= " "  Result:  x= "  [FE]              AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ",n ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( ",n ");	  Node    emptyStringNode    =    Node.newString(       "n       ");    Node    emptyStringNode    =    Node.newString(   ",n       ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x= " "  Result:  x= "  	19	3	replace
692	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( ",n ");  [FE]  junit.framework.AssertionFailedError:  Expected:  x= " "  Result:  x= "  [FE]              AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ",n ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( ",n ");	  Node    emptyStringNode    =    Node.newString(       "n       ");    Node    emptyStringNode    =    Node.newString(   ",n       ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x= " "  Result:  x= "  	19	3	replace
693	[BUG]  [BUGGY]  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]                AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ",node ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( ",node ");	  Node    emptyStringNode    =    Node.newString(       "n       ");    Node    emptyStringNode    =    Node.newString(   ",n       ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	19	3	replace
694	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( ",node ");  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]                AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ",node ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( ",node ");	  Node    emptyStringNode    =    Node.newString(       "n       ");    Node    emptyStringNode    =    Node.newString(   ",n       ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	19	3	replace
695	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "ArrayBuilder ", "ArrayBuilder ");  [CE]  no  suitable  method  found  for  newString(String,String)  [FE]              junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "ArrayBuilder ", "ArrayBuilder ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "ArrayBuilder ", "ArrayBuilder ");	  Node    emptyStringNode    =    Node.newString(       "java.util.ArrayBuilder       ");    Node    emptyStringNode    =    Node.newString(   "java.util.ArrayBuilder   ",);    	non-compiled	[CE]  no  suitable  method  found  for  newString(String,String)	124	None	replace
696	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.ArrayBuilder ", ");  [CE]  unclosed  string  literal  [FE]                junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.ArrayBuilder ", ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "java.util.ArrayBuilder ", ");	  Node    emptyStringNode    =    Node.newString(       "java.util.ArrayBuilder       ");    Node    emptyStringNode    =    Node.newString(   "java.util.ArrayBuilder   ",);    	non-compiled	[CE]  unclosed  string  literal	124	None	replace
697	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.ArrayBuilder ", "));  [CE]  unclosed  string  literal  [FE]                  junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.ArrayBuilder ", "));  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "java.util.ArrayBuilder ", "));	  Node    emptyStringNode    =    Node.newString(       "java.util.ArrayBuilder       ");    Node    emptyStringNode    =    Node.newString(   "java.util.ArrayBuilder   ",);    	non-compiled	[CE]  unclosed  string  literal	124	None	replace
698	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "].] ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "].] ");	  Node    emptyStringNode    =    Node.newString(       "]       ");    Node    emptyStringNode    =    Node.newString(   ".]   ");    	compilable	  [FE]  AssertionFailedError  	92	3	replace
699	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "].] ");  [FE]  AssertionFailedError  [FE]          AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "].] ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "].] ");	  Node    emptyStringNode    =    Node.newString(       "]       ");    Node    emptyStringNode    =    Node.newString(   ".]   ");    	compilable	  [FE]  AssertionFailedError  	92	3	replace
700	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.BLOCK,  foldedSize);  [CE]  no  suitable  method  found  for  newString(int,int)  [FE]          AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.BLOCK,  foldedSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(Token.BLOCK,  foldedSize);	  Node    emptyStringNode    =    Node.newString(Token.BLOCK);    	non-compiled	[CE]  no  suitable  method  found  for  newString(int,int)	155	None	replace
701	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.BLOCK,  originalSize);  [CE]  no  suitable  method  found  for  newString(int,int)  [FE]            AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.BLOCK,  originalSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(Token.BLOCK,  originalSize);	  Node    emptyStringNode    =    Node.newString(Token.BLOCK);    	non-compiled	[CE]  no  suitable  method  found  for  newString(int,int)	155	None	replace
702	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.BLOCK,  left);  [CE]  cannot  find  symbol  left  [FE]              AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.BLOCK,  left);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(Token.BLOCK,  left);	  Node    emptyStringNode    =    Node.newString(Token.BLOCK);    	non-compiled	[CE]  cannot  find  symbol  left	155	None	replace
703	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.BLOCK,  n);  [CE]  no  suitable  method  found  for  newString(int,Node)  [FE]                AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.BLOCK,  n);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(Token.BLOCK,  n);	  Node    emptyStringNode    =    Node.newString(Token.BLOCK);    	non-compiled	[CE]  no  suitable  method  found  for  newString(int,Node)	155	None	replace
704	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.BLOCK,  prev);  [CE]  no  suitable  method  found  for  newString(int,Node)  [FE]                  AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.BLOCK,  prev);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(Token.BLOCK,  prev);	  Node    emptyStringNode    =    Node.newString(Token.BLOCK);    	non-compiled	[CE]  no  suitable  method  found  for  newString(int,Node)	155	None	replace
705	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.BLOCK,  sb);  [CE]  no  suitable  method  found  for  newString(int,StringBuilder)  [FE]                    AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.BLOCK,  sb);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(Token.BLOCK,  sb);	  Node    emptyStringNode    =    Node.newString(Token.BLOCK);    	non-compiled	[CE]  no  suitable  method  found  for  newString(int,StringBuilder)	155	None	replace
706	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME,   "ArrayBuilder   ");  Node  emptyStringNode  =  Node.newString(Token.NAME,   "ArrayBuilder   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]    junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME,   "ArrayBuilder   ");  Node  emptyStringNode  =  Node.newString(Token.NAME,   "ArrayBuilder   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(Token.NAME,   "ArrayBuilder   ");    Node  emptyStringNode  =  Node.newString(Token.NAME,   "ArrayBuilder   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	167	None	add
707	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME,   "ArrayBuilder   ");  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [CE]  not  a  statement  [FE]      junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME,   "ArrayBuilder   ");  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(Token.NAME,   "ArrayBuilder   ");    junit.framework.AssertionFailedError:  Expected:  x=[].join( "	  	non-compiled	[CE]  not  a  statement	167	None	add
708	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME,   "ArrayBuilder   ");  Node  emptyStringNode  =  Node.newString(Token.NAME, ",ArrayBuilder   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]        junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME,   "ArrayBuilder   ");  Node  emptyStringNode  =  Node.newString(Token.NAME, ",ArrayBuilder   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(Token.NAME,   "ArrayBuilder   ");    Node  emptyStringNode  =  Node.newString(Token.NAME, ",ArrayBuilder   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	167	None	add
709	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]            AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME, "- ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString(Token.NAME, "- ");	  Node    emptyStringNode    =    Node.newString(       "-       ");    Node    emptyStringNode    =    Node.newString(.   "-       ");    	compilable	  [FE]  AssertionFailedError  	113	3	replace
710	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME, "- ");  [FE]  AssertionFailedError  [FE]            AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME, "- ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(Token.NAME, "- ");	  Node    emptyStringNode    =    Node.newString(       "-       ");    Node    emptyStringNode    =    Node.newString(.   "-       ");    	compilable	  [FE]  AssertionFailedError  	113	3	replace
711	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "- "  +  Token.NAME,  foldedSize);  [CE]  no  suitable  method  found  for  newString(String,int)  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "- "  +  Token.NAME,  foldedSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "- "  +  Token.NAME,  foldedSize);	  Node    emptyStringNode    =    Node.newString(   "-   "    +    Token.NAME);    	non-compiled	[CE]  no  suitable  method  found  for  newString(String,int)	164	None	replace
712	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "- "  +  Token.NAME,  originalSize);  [CE]  no  suitable  method  found  for  newString(String,int)  [FE]      AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "- "  +  Token.NAME,  originalSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "- "  +  Token.NAME,  originalSize);	  Node    emptyStringNode    =    Node.newString(   "-   "    +    Token.NAME);    	non-compiled	[CE]  no  suitable  method  found  for  newString(String,int)	164	None	replace
713	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "[ "));  [CE]  [FE]                AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[ "));  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "[ "));	  Node    emptyStringNode    =    Node.newString(       "[       ");    Node    emptyStringNode    =    Node.newString(   "[       "));    	non-compiled	[CE]  	99	None	replace
714	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "[] "));  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[] "));  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "[] "));	  Node    emptyStringNode    =    Node.newString(       "[       ");    Node    emptyStringNode    =    Node.newString(   "[       "));    	non-compiled	[CE]  	99	None	replace
715	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "ArrayJoin   ");  Node  emptyStringNode  =  Node.newString( "ArrayJoin   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "ArrayJoin   ");  Node  emptyStringNode  =  Node.newString( "ArrayJoin   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "ArrayJoin   ");    Node  emptyStringNode  =  Node.newString( "ArrayJoin   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	81	None	add
716	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "ArrayJoin   ");  Node  emptyStringNode  =  Node.newString( "ArrayJoin "));  [CE]  [FE]      AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "ArrayJoin   ");  Node  emptyStringNode  =  Node.newString( "ArrayJoin "));  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "ArrayJoin   ");    Node  emptyStringNode  =  Node.newString( "ArrayJoin "));	  	non-compiled	[CE]  	81	None	add
717	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "ArrayJoin   ");  Node  emptyStringNode  =  Node.newString( ",ArrayJoin   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]        AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "ArrayJoin   ");  Node  emptyStringNode  =  Node.newString( ",ArrayJoin   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "ArrayJoin   ");    Node  emptyStringNode  =  Node.newString( ",ArrayJoin   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	81	None	add
718	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "ArrayJoin   ");  Node  emptyStringNode  =  Node.newString( ".ArrayJoin   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]          AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "ArrayJoin   ");  Node  emptyStringNode  =  Node.newString( ".ArrayJoin   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "ArrayJoin   ");    Node  emptyStringNode  =  Node.newString( ".ArrayJoin   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	81	None	add
719	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "ArrayJoin   ");  Node  emptyStringNode  =  Node.newString(. "ArrayJoin   ");  [CE]  illegal  start  of  expression  [FE]            AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "ArrayJoin   ");  Node  emptyStringNode  =  Node.newString(. "ArrayJoin   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "ArrayJoin   ");    Node  emptyStringNode  =  Node.newString(. "ArrayJoin   ");	  	non-compiled	[CE]  illegal  start  of  expression	81	None	add
720	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString('-',  foldedSize);  [CE]  no  suitable  method  found  for  newString(char,int)  [FE]                  AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString('-',  foldedSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString('-',  foldedSize);	  Node    emptyStringNode    =    Node.newString(       "-       ");    Node    emptyStringNode    =    Node.newString('-');    	non-compiled	[CE]  no  suitable  method  found  for  newString(char,int)	116	None	replace
721	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList( "),  arrayFoldedren.size());  [CE]  [FE]            junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList( "),  arrayFoldedren.size());  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList( "),  arrayFoldedren.size());	  Node    emptyStringNode    =    Node.newString(       "java.util.Arrays.asList(       ");    Node    emptyStringNode    =    Node.newString(   ".java.util.Arrays.asList(       ");    	non-compiled	[CE]  	78	None	replace
722	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "array() ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "array() ");	  Node    emptyStringNode    =    Node.newString(   "node()   ");    	compilable	  [FE]  AssertionFailedError  	201	3	replace
723	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "array() ");  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "array() ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "array() ");	  Node    emptyStringNode    =    Node.newString(   "node()   ");    	compilable	  [FE]  AssertionFailedError  	201	3	replace
724	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "functionName() ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "functionName() ");	  Node    emptyStringNode    =    Node.newString(   "node()   ");    	compilable	  [FE]  AssertionFailedError  	201	3	replace
725	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "functionName() ");  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "functionName() ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "functionName() ");	  Node    emptyStringNode    =    Node.newString(   "node()   ");    	compilable	  [FE]  AssertionFailedError  	201	3	replace
726	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "Token() ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "Token() ");	  Node    emptyStringNode    =    Node.newString(   "node()   ");    	compilable	  [FE]  AssertionFailedError  	201	3	replace
727	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "Token() ");  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "Token() ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "Token() ");	  Node    emptyStringNode    =    Node.newString(   "node()   ");    	compilable	  [FE]  AssertionFailedError  	201	3	replace
728	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "remove()   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "remove()   ");	  Node    emptyStringNode    =    Node.newString(   "node()   ");    	compilable	  [FE]  AssertionFailedError  	201	3	replace
729	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "remove()   ");  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "remove()   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "remove()   ");	  Node    emptyStringNode    =    Node.newString(   "node()   ");    	compilable	  [FE]  AssertionFailedError  	201	3	replace
730	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "label   ");  Node  emptyStringNode  =  Node.newString( "label   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]    junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "label   ");  Node  emptyStringNode  =  Node.newString( "label   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "label   ");    Node  emptyStringNode  =  Node.newString( "label   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	198	None	add
731	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "label   ");  Node  emptyStringNode  =  Node.newString( ".label   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]      junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "label   ");  Node  emptyStringNode  =  Node.newString( ".label   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "label   ");    Node  emptyStringNode  =  Node.newString( ".label   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	198	None	add
732	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "label   ");  Node  emptyStringNode  =  Node.newString( ",label   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]        junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "label   ");  Node  emptyStringNode  =  Node.newString( ",label   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "label   ");    Node  emptyStringNode  =  Node.newString( ",label   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	198	None	add
733	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "label   ");  Node  emptyStringNode  =  Node.newString( "label "));  [CE]  [FE]          junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "label   ");  Node  emptyStringNode  =  Node.newString( "label "));  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "label   ");    Node  emptyStringNode  =  Node.newString( "label "));	  	non-compiled	[CE]  	198	None	add
734	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "label   ");  Node  emptyStringNode  =  Node.newString(? "label   ");  [CE]  illegal  start  of  expression  [FE]            junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "label   ");  Node  emptyStringNode  =  Node.newString(? "label   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "label   ");    Node  emptyStringNode  =  Node.newString(? "label   ");	  	non-compiled	[CE]  illegal  start  of  expression	198	None	add
735	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "label   ");  Node  emptyStringNode  =  Node.newString( "label ",  n);  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]              junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "label   ");  Node  emptyStringNode  =  Node.newString( "label ",  n);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "label   ");    Node  emptyStringNode  =  Node.newString( "label ",  n);	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	198	None	add
736	[BUG]  [BUGGY]  n.getParent().removeChild(paramNode);  [CE]  cannot  find  symbol  paramNode  [FE]                                      junit.framework.AssertionFailedError:  Expected:  x=[     "a     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  n.getParent().removeChild(paramNode);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	n.getParent().removeChild(paramNode);	  n.getParent().removeChild(prev);    	non-compiled	[CE]  cannot  find  symbol  paramNode	11	None	replace
737	[BUG]  [BUGGY]  n.getParent().removeChild(partialStringNode);  [CE]  cannot  find  symbol  partialStringNode  [FE]                                        junit.framework.AssertionFailedError:  Expected:  x=[     "a     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  n.getParent().removeChild(partialStringNode);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	n.getParent().removeChild(partialStringNode);	  n.getParent().removeChild(prev);    	non-compiled	[CE]  cannot  find  symbol  partialStringNode	11	None	replace
738	[BUG]  [BUGGY]  n.getParent().removeChild(functionName);  [CE]  cannot  find  symbol  emptyStringNode  [FE]                                          junit.framework.AssertionFailedError:  Expected:  x=[     "a     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  n.getParent().removeChild(functionName);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	n.getParent().removeChild(functionName);	  n.getParent().removeChild(prev);    	non-compiled	[CE]  cannot  find  symbol  emptyStringNode	11	None	replace
739	[BUG]  [BUGGY]  n.getParent().removeChild(arrayFoldedNode);  [CE]  cannot  find  symbol  arrayFoldedNode  [FE]                                            junit.framework.AssertionFailedError:  Expected:  x=[     "a     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  n.getParent().removeChild(arrayFoldedNode);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	n.getParent().removeChild(arrayFoldedNode);	  n.getParent().removeChild(prev);    	non-compiled	[CE]  cannot  find  symbol  arrayFoldedNode	11	None	replace
740	[BUG]  [BUGGY]  n.getParent().removeChild(parent);  [CE]  cannot  find  symbol  parent  [FE]                                              junit.framework.AssertionFailedError:  Expected:  x=[     "a     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  n.getParent().removeChild(parent);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	n.getParent().removeChild(parent);	  n.getParent().removeChild(prev);    	non-compiled	[CE]  cannot  find  symbol  parent	11	None	replace
741	[BUG]  [BUGGY]  n.getParent().removeChild(type);  [CE]  cannot  find  symbol  type  [FE]                                                junit.framework.AssertionFailedError:  Expected:  x=[     "a     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  n.getParent().removeChild(type);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	n.getParent().removeChild(type);	  n.getParent().removeChild(prev);    	non-compiled	[CE]  cannot  find  symbol  type	11	None	replace
742	[BUG]  [BUGGY]  n.getParent().removeChild(partialSize);  [CE]  cannot  find  symbol  partialSize  [FE]                                                  junit.framework.AssertionFailedError:  Expected:  x=[     "a     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  n.getParent().removeChild(partialSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	n.getParent().removeChild(partialSize);	  n.getParent().removeChild(prev);    	non-compiled	[CE]  cannot  find  symbol  partialSize	11	None	replace
743	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ".string ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( ".string ");	  Node    emptyStringNode    =    Node.newString(       "string       ");    Node    emptyStringNode    =    Node.newString(   ".string       ");    	compilable	  [FE]  AssertionFailedError  	88	3	replace
744	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( ".string ");  [FE]  AssertionFailedError  [FE]          AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ".string ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( ".string ");	  Node    emptyStringNode    =    Node.newString(       "string       ");    Node    emptyStringNode    =    Node.newString(   ".string       ");    	compilable	  [FE]  AssertionFailedError  	88	3	replace
745	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]            AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "_string ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "_string ");	  Node    emptyStringNode    =    Node.newString(       "string       ");    Node    emptyStringNode    =    Node.newString(   ".string       ");    	compilable	  [FE]  AssertionFailedError  	88	3	replace
746	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "_string ");  [FE]  AssertionFailedError  [FE]            AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "_string ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "_string ");	  Node    emptyStringNode    =    Node.newString(       "string       ");    Node    emptyStringNode    =    Node.newString(   ".string       ");    	compilable	  [FE]  AssertionFailedError  	88	3	replace
747	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]              AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[string ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "[string ");	  Node    emptyStringNode    =    Node.newString(       "string       ");    Node    emptyStringNode    =    Node.newString(   ".string       ");    	compilable	  [FE]  AssertionFailedError  	88	3	replace
748	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "[string ");  [FE]  AssertionFailedError  [FE]              AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[string ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "[string ");	  Node    emptyStringNode    =    Node.newString(       "string       ");    Node    emptyStringNode    =    Node.newString(   ".string       ");    	compilable	  [FE]  AssertionFailedError  	88	3	replace
749	[BUG]  [BUGGY]  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]                AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "-string ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "-string ");	  Node    emptyStringNode    =    Node.newString(       "string       ");    Node    emptyStringNode    =    Node.newString(   ".string       ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	88	3	replace
750	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "-string ");  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]                AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "-string ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "-string ");	  Node    emptyStringNode    =    Node.newString(       "string       ");    Node    emptyStringNode    =    Node.newString(   ".string       ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	88	3	replace
751	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]                  AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "array.string ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "array.string ");	  Node    emptyStringNode    =    Node.newString(       "string       ");    Node    emptyStringNode    =    Node.newString(   ".string       ");    	compilable	  [FE]  AssertionFailedError  	88	3	replace
752	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "array.string ");  [FE]  AssertionFailedError  [FE]                  AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "array.string ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "array.string ");	  Node    emptyStringNode    =    Node.newString(       "string       ");    Node    emptyStringNode    =    Node.newString(   ".string       ");    	compilable	  [FE]  AssertionFailedError  	88	3	replace
753	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.ArrayBuilder ").join(x,   "  [CE]  unclosed  string  literal  [FE]        junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.ArrayBuilder ").join(x,   "  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "java.util.ArrayBuilder ").join(x,   "	  Node    emptyStringNode    =    Node.newString(   "java.util.ArrayBuilder   ").join(   "    	non-compiled	[CE]  unclosed  string  literal	206	None	replace
754	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "Join.ArrayBuilder ").join( "  [CE]  unclosed  string  literal  [FE]          junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "Join.ArrayBuilder ").join( "  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "Join.ArrayBuilder ").join( "	  Node    emptyStringNode    =    Node.newString(   "java.util.ArrayBuilder   ").join(   "    	non-compiled	[CE]  unclosed  string  literal	206	None	replace
755	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "ArrayBuilder ").join( "  [CE]  unclosed  string  literal  [FE]            junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "ArrayBuilder ").join( "  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "ArrayBuilder ").join( "	  Node    emptyStringNode    =    Node.newString(   "java.util.ArrayBuilder   ").join(   "    	non-compiled	[CE]  unclosed  string  literal	206	None	replace
756	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.ArrayBuilder ").join(n,  originalSize);  [CE]  cannot  find  symbol  [FE]              junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.ArrayBuilder ").join(n,  originalSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "java.util.ArrayBuilder ").join(n,  originalSize);	  Node    emptyStringNode    =    Node.newString(   "java.util.ArrayBuilder   ").join(   "    	non-compiled	[CE]  cannot  find  symbol	206	None	replace
757	[BUG]  [BUGGY]  [FE]  junit.framework.AssertionFailedError:  Expected:  x= " "  Result:  x= "  [FE]              junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ",Arrays.asList( ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( ",Arrays.asList( ");	  Node    emptyStringNode    =    Node.newString(       "java.util.Arrays.asList(       ");    Node    emptyStringNode    =    Node.newString(   ",java.util.Arrays.asList(       ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x= " "  Result:  x= "  	79	3	replace
758	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( ",Arrays.asList( ");  [FE]  junit.framework.AssertionFailedError:  Expected:  x= " "  Result:  x= "  [FE]              junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ",Arrays.asList( ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( ",Arrays.asList( ");	  Node    emptyStringNode    =    Node.newString(       "java.util.Arrays.asList(       ");    Node    emptyStringNode    =    Node.newString(   ",java.util.Arrays.asList(       ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x= " "  Result:  x= "  	79	3	replace
759	[BUG]  [BUGGY]  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]                junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ",java.util.Arrays.asList( ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( ",java.util.Arrays.asList( ");	  Node    emptyStringNode    =    Node.newString(       "java.util.Arrays.asList(       ");    Node    emptyStringNode    =    Node.newString(   ",java.util.Arrays.asList(       ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	79	3	replace
760	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( ",java.util.Arrays.asList( ");  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]                junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ",java.util.Arrays.asList( ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( ",java.util.Arrays.asList( ");	  Node    emptyStringNode    =    Node.newString(       "java.util.Arrays.asList(       ");    Node    emptyStringNode    =    Node.newString(   ",java.util.Arrays.asList(       ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	79	3	replace
761	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( ",java.util.Arrays.asList( "));  [CE]  [FE]                  junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ",java.util.Arrays.asList( "));  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( ",java.util.Arrays.asList( "));	  Node    emptyStringNode    =    Node.newString(       "java.util.Arrays.asList(       ");    Node    emptyStringNode    =    Node.newString(   ",java.util.Arrays.asList(       ");    	non-compiled	[CE]  	79	None	replace
762	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( ",Arrays.asList( "));  [CE]  [FE]                    junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ",Arrays.asList( "));  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( ",Arrays.asList( "));	  Node    emptyStringNode    =    Node.newString(       "java.util.Arrays.asList(       ");    Node    emptyStringNode    =    Node.newString(   ",java.util.Arrays.asList(       ");    	non-compiled	[CE]  	79	None	replace
763	[BUG]  [BUGGY]  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]                      junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ",Arrays.asList(4 ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( ",Arrays.asList(4 ");	  Node    emptyStringNode    =    Node.newString(       "java.util.Arrays.asList(       ");    Node    emptyStringNode    =    Node.newString(   ",java.util.Arrays.asList(       ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	79	3	replace
764	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( ",Arrays.asList(4 ");  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]                      junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ",Arrays.asList(4 ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( ",Arrays.asList(4 ");	  Node    emptyStringNode    =    Node.newString(       "java.util.Arrays.asList(       ");    Node    emptyStringNode    =    Node.newString(   ",java.util.Arrays.asList(       ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	79	3	replace
765	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( ",Arrays.asList(0,  arrayFoldedChildren.size()  -  1));  [CE]  unclosed  string  literal  [FE]                        junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ",Arrays.asList(0,  arrayFoldedChildren.size()  -  1));  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( ",Arrays.asList(0,  arrayFoldedChildren.size()  -  1));	  Node    emptyStringNode    =    Node.newString(       "java.util.Arrays.asList(       ");    Node    emptyStringNode    =    Node.newString(   ",java.util.Arrays.asList(       ");    	non-compiled	[CE]  unclosed  string  literal	79	None	replace
766	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( ", ",Arrays.asList(originalSize));  [CE]  cannot  find  symbol  Arrays  [FE]                          junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ", ",Arrays.asList(originalSize));  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( ", ",Arrays.asList(originalSize));	  Node    emptyStringNode    =    Node.newString(       "java.util.Arrays.asList(       ");    Node    emptyStringNode    =    Node.newString(   ",java.util.Arrays.asList(       ");    	non-compiled	[CE]  cannot  find  symbol  Arrays	79	None	replace
767	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "[A-Z]   ");  Node  emptyStringNode  =  Node.newString( "[A-Z]   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "[A-Z]   ");  Node  emptyStringNode  =  Node.newString( "[A-Z]   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "[A-Z]   ");    Node  emptyStringNode  =  Node.newString( "[A-Z]   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	66	None	add
768	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "[A-Z]   ");  Node  emptyStringNode  =  Node.newString( ",[A-Z]   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]      AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "[A-Z]   ");  Node  emptyStringNode  =  Node.newString( ",[A-Z]   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "[A-Z]   ");    Node  emptyStringNode  =  Node.newString( ",[A-Z]   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	66	None	add
769	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "[A-Z]   ");  Node  emptyStringNode  =  Node.newString( "[A-Z] ",);  [CE]  illegal  start  of  expression  [FE]        AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "[A-Z]   ");  Node  emptyStringNode  =  Node.newString( "[A-Z] ",);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "[A-Z]   ");    Node  emptyStringNode  =  Node.newString( "[A-Z] ",);	  	non-compiled	[CE]  illegal  start  of  expression	66	None	add
770	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "[A-Z]   ");  Node  emptyStringNode  =  Node.newString( ".[A-Z]   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]          AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "[A-Z]   ");  Node  emptyStringNode  =  Node.newString( ".[A-Z]   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "[A-Z]   ");    Node  emptyStringNode  =  Node.newString( ".[A-Z]   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	66	None	add
771	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "org.join.ArrayList   ");  Node  emptyStringNode  =  Node.newString( "org.join.ArrayList   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]    junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "org.join.ArrayList   ");  Node  emptyStringNode  =  Node.newString( "org.join.ArrayList   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "org.join.ArrayList   ");    Node  emptyStringNode  =  Node.newString( "org.join.ArrayList   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	209	None	add
772	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "org.join.ArrayList   ");  Node  emptyStringNode  =  Node.newString( ".org.join.ArrayList   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]      junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "org.join.ArrayList   ");  Node  emptyStringNode  =  Node.newString( ".org.join.ArrayList   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "org.join.ArrayList   ");    Node  emptyStringNode  =  Node.newString( ".org.join.ArrayList   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	209	None	add
773	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "org.join.ArrayList   ");  Node  emptyStringNode  =  Node.newString( ",org.join.ArrayList   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]        junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "org.join.ArrayList   ");  Node  emptyStringNode  =  Node.newString( ",org.join.ArrayList   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "org.join.ArrayList   ");    Node  emptyStringNode  =  Node.newString( ",org.join.ArrayList   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	209	None	add
774	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "org.join.ArrayList   ");  Node  emptyStringNode  =  Node.newString( ")org.join.ArrayList   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]          junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "org.join.ArrayList   ");  Node  emptyStringNode  =  Node.newString( ")org.join.ArrayList   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "org.join.ArrayList   ");    Node  emptyStringNode  =  Node.newString( ")org.join.ArrayList   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	209	None	add
775	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "org.join.ArrayList   ");  Node  emptyStringNode  =  Node.newString(. "org.join.ArrayList   ");  [CE]  illegal  start  of  expression  [FE]            junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "org.join.ArrayList   ");  Node  emptyStringNode  =  Node.newString(. "org.join.ArrayList   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "org.join.ArrayList   ");    Node  emptyStringNode  =  Node.newString(. "org.join.ArrayList   ");	  	non-compiled	[CE]  illegal  start  of  expression	209	None	add
776	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "org.join.ArrayList   ");  Node  emptyStringNode  =  Node.newString(org.join.ArrayList   ");  [CE]  unclosed  string  literal  [FE]              junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "org.join.ArrayList   ");  Node  emptyStringNode  =  Node.newString(org.join.ArrayList   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "org.join.ArrayList   ");    Node  emptyStringNode  =  Node.newString(org.join.ArrayList   ");	  	non-compiled	[CE]  unclosed  string  literal	209	None	add
777	[BUG]  [BUGGY]  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "Join ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "Join ");	  Node    emptyStringNode    =    Node.newString(   "ArrayJoin   ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	82	3	replace
778	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "Join ");  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "Join ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "Join ");	  Node    emptyStringNode    =    Node.newString(   "ArrayJoin   ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	82	3	replace
779	[BUG]  [BUGGY]  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]      AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "FieldName ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "FieldName ");	  Node    emptyStringNode    =    Node.newString(   "ArrayJoin   ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	82	3	replace
780	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "FieldName ");  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]      AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "FieldName ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "FieldName ");	  Node    emptyStringNode    =    Node.newString(   "ArrayJoin   ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	82	3	replace
781	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "Join ",  sb.toString());  [CE]  no  suitable  method  found  for  newString(String,String)  [FE]        AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "Join ",  sb.toString());  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "Join ",  sb.toString());	  Node    emptyStringNode    =    Node.newString(   "ArrayJoin   ");    	non-compiled	[CE]  no  suitable  method  found  for  newString(String,String)	82	None	replace
782	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "ArrayJoin ",  sb.toString());  [CE]  no  suitable  method  found  for  newString(String,String)  [FE]          AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "ArrayJoin ",  sb.toString());  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "ArrayJoin ",  sb.toString());	  Node    emptyStringNode    =    Node.newString(   "ArrayJoin   ");    	non-compiled	[CE]  no  suitable  method  found  for  newString(String,String)	82	None	replace
783	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "Join. ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "Join. ");	  Node    emptyStringNode    =    Node.newString(   "ArrayJoin   ");    	compilable	  [FE]  AssertionFailedError  	82	3	replace
784	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "Join. ");  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "Join. ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "Join. ");	  Node    emptyStringNode    =    Node.newString(   "ArrayJoin   ");    	compilable	  [FE]  AssertionFailedError  	82	3	replace
785	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "JoinArray   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "JoinArray   ");	  Node    emptyStringNode    =    Node.newString(   "JoinArrayElement   ");    	compilable	  [FE]  AssertionFailedError  	39	3	replace
786	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "JoinArray   ");  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "JoinArray   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "JoinArray   ");	  Node    emptyStringNode    =    Node.newString(   "JoinArrayElement   ");    	compilable	  [FE]  AssertionFailedError  	39	3	replace
787	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "FoldArrayElement ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "FoldArrayElement ");	  Node    emptyStringNode    =    Node.newString(   "JoinArrayElement   ");    	compilable	  [FE]  AssertionFailedError  	39	3	replace
788	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "FoldArrayElement ");  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "FoldArrayElement ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "FoldArrayElement ");	  Node    emptyStringNode    =    Node.newString(   "JoinArrayElement   ");    	compilable	  [FE]  AssertionFailedError  	39	3	replace
789	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "JoinArray ",  originalSize);  [CE]  no  suitable  method  found  for  newString(String,int)  [FE]        AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "JoinArray ",  originalSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "JoinArray ",  originalSize);	  Node    emptyStringNode    =    Node.newString(   "JoinArrayElement   ");    	non-compiled	[CE]  no  suitable  method  found  for  newString(String,int)	39	None	replace
790	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.List ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "java.util.List ");	  Node    emptyStringNode    =    Node.newString(       "java.util.ArrayList       ");    Node    emptyStringNode    =    Node.newString(   ".java.util.ArrayList       ");    	compilable	  [FE]  AssertionFailedError  	25	3	replace
791	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.List ");  [FE]  AssertionFailedError  [FE]          AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.List ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "java.util.List ");	  Node    emptyStringNode    =    Node.newString(       "java.util.ArrayList       ");    Node    emptyStringNode    =    Node.newString(   ".java.util.ArrayList       ");    	compilable	  [FE]  AssertionFailedError  	25	3	replace
792	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "array "));  [CE]  [FE]            junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "array "));  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "array "));	  Node    emptyStringNode    =    Node.newString(       "array       ");    Node    emptyStringNode    =    Node.newString(   "array   "));    	non-compiled	[CE]  	14	None	replace
793	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "array ",  n.getFirstChild());  [CE]  no  suitable  method  found  for  newString(String,Node)  [FE]              junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "array ",  n.getFirstChild());  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "array ",  n.getFirstChild());	  Node    emptyStringNode    =    Node.newString(       "array       ");    Node    emptyStringNode    =    Node.newString(   "array   "));    	non-compiled	[CE]  no  suitable  method  found  for  newString(String,Node)	14	None	replace
794	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "string   "  +  originalSize);  Node  emptyStringNode  =  Node.newString( "string   "  +  originalSize);  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]    junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "string   "  +  originalSize);  Node  emptyStringNode  =  Node.newString( "string   "  +  originalSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "string   "    +    originalSize);    Node  emptyStringNode  =  Node.newString( "string   "  +  originalSize);	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	106	None	add
795	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "string   "  +  originalSize);  Node  emptyStringNode  =  Node.newString( ".string   "  +  originalSize);  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]      junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "string   "  +  originalSize);  Node  emptyStringNode  =  Node.newString( ".string   "  +  originalSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "string   "    +    originalSize);    Node  emptyStringNode  =  Node.newString( ".string   "  +  originalSize);	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	106	None	add
796	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "string   "  +  originalSize);  Node  emptyStringNode  =  Node.newString( ",string   "  +  originalSize);  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]        junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "string   "  +  originalSize);  Node  emptyStringNode  =  Node.newString( ",string   "  +  originalSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "string   "    +    originalSize);    Node  emptyStringNode  =  Node.newString( ",string   "  +  originalSize);	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	106	None	add
797	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "string   "  +  originalSize);  Node  emptyStringNode  =  Node.newString( "string   "  +  initialSize);  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]          junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "string   "  +  originalSize);  Node  emptyStringNode  =  Node.newString( "string   "  +  initialSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "string   "    +    originalSize);    Node  emptyStringNode  =  Node.newString( "string   "  +  initialSize);	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	106	None	add
798	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "string   "  +  originalSize);  Node  emptyStringNode  =  Node.newString(. "string   "  +  originalSize);  [CE]  illegal  start  of  expression  [FE]            junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "string   "  +  originalSize);  Node  emptyStringNode  =  Node.newString(. "string   "  +  originalSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "string   "    +    originalSize);    Node  emptyStringNode  =  Node.newString(. "string   "  +  originalSize);	  	non-compiled	[CE]  illegal  start  of  expression	106	None	add
799	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "string   "  +  originalSize);  Node  emptyStringNode  =  Node.newString(, "string   "  +  originalSize);  [CE]  illegal  start  of  expression  [FE]              junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "string   "  +  originalSize);  Node  emptyStringNode  =  Node.newString(, "string   "  +  originalSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "string   "    +    originalSize);    Node  emptyStringNode  =  Node.newString(, "string   "  +  originalSize);	  	non-compiled	[CE]  illegal  start  of  expression	106	None	add
800	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME,  n,  foldedSize);  [CE]  no  suitable  method  found  for  newString(int,Node,int)  [FE]          AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME,  n,  foldedSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(Token.NAME,  n,  foldedSize);	  Node    emptyStringNode    =    Node.newString(Token.NAME,    foldedSize);    	non-compiled	[CE]  no  suitable  method  found  for  newString(int,Node,int)	83	None	replace
801	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME,  sb,  foldedSize);  [CE]  no  suitable  method  found  for  newString(int,StringBuilder,int)  [FE]            AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME,  sb,  foldedSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(Token.NAME,  sb,  foldedSize);	  Node    emptyStringNode    =    Node.newString(Token.NAME,    foldedSize);    	non-compiled	[CE]  no  suitable  method  found  for  newString(int,StringBuilder,int)	83	None	replace
802	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME,  functionName,  foldedSize);  [CE]  no  suitable  method  found  for  newString(int,Node,int)  [FE]              AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME,  functionName,  foldedSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(Token.NAME,  functionName,  foldedSize);	  Node    emptyStringNode    =    Node.newString(Token.NAME,    foldedSize);    	non-compiled	[CE]  no  suitable  method  found  for  newString(int,Node,int)	83	None	replace
803	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME,  foldedSize,  kJoinOverhead);  [CE]  cannot  find  symbol  kJoinOverhead  [FE]                AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME,  foldedSize,  kJoinOverhead);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(Token.NAME,  foldedSize,  kJoinOverhead);	  Node    emptyStringNode    =    Node.newString(Token.NAME,    foldedSize);    	non-compiled	[CE]  cannot  find  symbol  kJoinOverhead	83	None	replace
804	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "[Locale.US] ",  foldedSize);  [CE]  no  suitable  method  found  for  newString(String,int)  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[Locale.US] ",  foldedSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "[Locale.US] ",  foldedSize);	  Node    emptyStringNode    =    Node.newString(   "[Locale.US]   ");    	non-compiled	[CE]  no  suitable  method  found  for  newString(String,int)	65	None	replace
805	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "[Locale.US] ",  n);  [CE]  no  suitable  method  found  for  newString(String,Node)  [FE]      AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[Locale.US] ",  n);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "[Locale.US] ",  n);	  Node    emptyStringNode    =    Node.newString(   "[Locale.US]   ");    	non-compiled	[CE]  no  suitable  method  found  for  newString(String,Node)	65	None	replace
806	[BUG]  [BUGGY]  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]        AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[Locale.UK] ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "[Locale.UK] ");	  Node    emptyStringNode    =    Node.newString(   "[Locale.US]   ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	65	3	replace
807	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "[Locale.UK] ");  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]        AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[Locale.UK] ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "[Locale.UK] ");	  Node    emptyStringNode    =    Node.newString(   "[Locale.US]   ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	65	3	replace
808	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[Locale.UTF-8] ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "[Locale.UTF-8] ");	  Node    emptyStringNode    =    Node.newString(   "[Locale.US]   ");    	compilable	  [FE]  AssertionFailedError  	65	3	replace
809	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "[Locale.UTF-8] ");  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[Locale.UTF-8] ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "[Locale.UTF-8] ");	  Node    emptyStringNode    =    Node.newString(   "[Locale.US]   ");    	compilable	  [FE]  AssertionFailedError  	65	3	replace
810	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "[Locale.US] ",  sb.toString());  [CE]  no  suitable  method  found  for  newString(String,String)  [FE]            AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[Locale.US] ",  sb.toString());  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "[Locale.US] ",  sb.toString());	  Node    emptyStringNode    =    Node.newString(   "[Locale.US]   ");    	non-compiled	[CE]  no  suitable  method  found  for  newString(String,String)	65	None	replace
811	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]              AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[Locale.US] "  +  Token.name(originalSize));  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "[Locale.US] "  +  Token.name(originalSize));	  Node    emptyStringNode    =    Node.newString(   "[Locale.US]   ");    	compilable	  [FE]  AssertionFailedError  	65	3	replace
812	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "[Locale.US] "  +  Token.name(originalSize));  [FE]  AssertionFailedError  [FE]              AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[Locale.US] "  +  Token.name(originalSize));  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "[Locale.US] "  +  Token.name(originalSize));	  Node    emptyStringNode    =    Node.newString(   "[Locale.US]   ");    	compilable	  [FE]  AssertionFailedError  	65	3	replace
813	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.FUNCTION,  foldedSize);  [CE]  no  suitable  method  found  for  newString(int,int)  [FE]                  junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.FUNCTION,  foldedSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(Token.FUNCTION,  foldedSize);	  Node    emptyStringNode    =    Node.newString(Token.FUNCTION);    	non-compiled	[CE]  no  suitable  method  found  for  newString(int,int)	43	None	replace
814	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.FUNCTION,  n);  [CE]  no  suitable  method  found  for  newString(int,Node)  [FE]                    junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.FUNCTION,  n);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(Token.FUNCTION,  n);	  Node    emptyStringNode    =    Node.newString(Token.FUNCTION);    	non-compiled	[CE]  no  suitable  method  found  for  newString(int,Node)	43	None	replace
815	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.FUNCTION,  originalSize);  [CE]  no  suitable  method  found  for  newString(int,int)  [FE]                      junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.FUNCTION,  originalSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(Token.FUNCTION,  originalSize);	  Node    emptyStringNode    =    Node.newString(Token.FUNCTION);    	non-compiled	[CE]  no  suitable  method  found  for  newString(int,int)	43	None	replace
816	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.FUNCTION,  left);  [CE]  cannot  find  symbol  left  [FE]                        junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.FUNCTION,  left);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(Token.FUNCTION,  left);	  Node    emptyStringNode    =    Node.newString(Token.FUNCTION);    	non-compiled	[CE]  cannot  find  symbol  left	43	None	replace
817	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.FUNCTION,  prev);  [CE]  no  suitable  method  found  for  newString(int,Node)  [FE]                          junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.FUNCTION,  prev);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(Token.FUNCTION,  prev);	  Node    emptyStringNode    =    Node.newString(Token.FUNCTION);    	non-compiled	[CE]  no  suitable  method  found  for  newString(int,Node)	43	None	replace
818	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.FUNCTION,  initialSize);  [CE]  cannot  find  symbol  initialSize  [FE]                            junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.FUNCTION,  initialSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(Token.FUNCTION,  initialSize);	  Node    emptyStringNode    =    Node.newString(Token.FUNCTION);    	non-compiled	[CE]  cannot  find  symbol  initialSize	43	None	replace
819	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "array_foo   ");  Node  emptyStringNode  =  Node.newString(   "array_foo   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "array_foo   ");  Node  emptyStringNode  =  Node.newString(   "array_foo   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "array_foo   ");    Node  emptyStringNode  =  Node.newString(   "array_foo   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	202	None	add
820	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "array_foo   ");  Node  emptyStringNode  =  Node.newString( ".array_foo   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]      AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "array_foo   ");  Node  emptyStringNode  =  Node.newString( ".array_foo   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "array_foo   ");    Node  emptyStringNode  =  Node.newString( ".array_foo   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	202	None	add
821	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "array_foo   ");  Node  emptyStringNode  =  Node.newString( ",array_foo   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]        AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "array_foo   ");  Node  emptyStringNode  =  Node.newString( ",array_foo   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "array_foo   ");    Node  emptyStringNode  =  Node.newString( ",array_foo   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	202	None	add
822	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "array_foo   ");  Node  emptyStringNode  =  Node.newString(   "array_foo "));  [CE]  [FE]          AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "array_foo   ");  Node  emptyStringNode  =  Node.newString(   "array_foo "));  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "array_foo   ");    Node  emptyStringNode  =  Node.newString(   "array_foo "));	  	non-compiled	[CE]  	202	None	add
823	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "array_foo   ");  Node  emptyStringNode  =  Node.newString(? "array_foo   ");  [CE]  illegal  start  of  expression  [FE]            AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "array_foo   ");  Node  emptyStringNode  =  Node.newString(? "array_foo   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "array_foo   ");    Node  emptyStringNode  =  Node.newString(? "array_foo   ");	  	non-compiled	[CE]  illegal  start  of  expression	202	None	add
824	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "Array   "  +  originalSize);  Node  emptyStringNode  =  Node.newString(   "Array   "  +  originalSize);  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "Array   "  +  originalSize);  Node  emptyStringNode  =  Node.newString(   "Array   "  +  originalSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "Array   "    +    originalSize);    Node  emptyStringNode  =  Node.newString(   "Array   "  +  originalSize);	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	117	None	add
825	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "Array   "  +  originalSize);  Node  emptyStringNode  =  Node.newString( ",Array   "  +  originalSize);  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]      AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "Array   "  +  originalSize);  Node  emptyStringNode  =  Node.newString( ",Array   "  +  originalSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "Array   "    +    originalSize);    Node  emptyStringNode  =  Node.newString( ",Array   "  +  originalSize);	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	117	None	add
826	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "Array   "  +  originalSize);  Node  emptyStringNode  =  Node.newString(   "Array   "  +  initialSize);  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]        AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "Array   "  +  originalSize);  Node  emptyStringNode  =  Node.newString(   "Array   "  +  initialSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "Array   "    +    originalSize);    Node  emptyStringNode  =  Node.newString(   "Array   "  +  initialSize);	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	117	None	add
827	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "Array   "  +  originalSize);  Node  emptyStringNode  =  Node.newString( ".Array   "  +  originalSize);  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]          AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "Array   "  +  originalSize);  Node  emptyStringNode  =  Node.newString( ".Array   "  +  originalSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "Array   "    +    originalSize);    Node  emptyStringNode  =  Node.newString( ".Array   "  +  originalSize);	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	117	None	add
828	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "Array   "  +  originalSize);  Node  emptyStringNode  =  Node.newString(. "Array   "  +  originalSize);  [CE]  illegal  start  of  expression  [FE]            AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "Array   "  +  originalSize);  Node  emptyStringNode  =  Node.newString(. "Array   "  +  originalSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "Array   "    +    originalSize);    Node  emptyStringNode  =  Node.newString(. "Array   "  +  originalSize);	  	non-compiled	[CE]  illegal  start  of  expression	117	None	add
829	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "Array   "  +  originalSize);  Node  emptyStringNode  =  Node.newString(, "Array   "  +  originalSize);  [CE]  illegal  start  of  expression  [FE]              AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "Array   "  +  originalSize);  Node  emptyStringNode  =  Node.newString(, "Array   "  +  originalSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "Array   "    +    originalSize);    Node  emptyStringNode  =  Node.newString(, "Array   "  +  originalSize);	  	non-compiled	[CE]  illegal  start  of  expression	117	None	add
830	[BUG]  [BUGGY]  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]            junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ",java.util.ArrayBuilder ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( ",java.util.ArrayBuilder ");	  Node    emptyStringNode    =    Node.newString(       "java.util.ArrayBuilder       ");    Node    emptyStringNode    =    Node.newString(   ",java.util.ArrayBuilder       ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	123	3	replace
831	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( ",java.util.ArrayBuilder ");  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]            junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ",java.util.ArrayBuilder ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( ",java.util.ArrayBuilder ");	  Node    emptyStringNode    =    Node.newString(       "java.util.ArrayBuilder       ");    Node    emptyStringNode    =    Node.newString(   ",java.util.ArrayBuilder       ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	123	3	replace
832	[BUG]  [BUGGY]  [FE]  junit.framework.AssertionFailedError:  Expected:  x= " "  Result:  x= "  [FE]              junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ",ArrayBuilder ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( ",ArrayBuilder ");	  Node    emptyStringNode    =    Node.newString(       "java.util.ArrayBuilder       ");    Node    emptyStringNode    =    Node.newString(   ",java.util.ArrayBuilder       ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x= " "  Result:  x= "  	123	3	replace
833	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( ",ArrayBuilder ");  [FE]  junit.framework.AssertionFailedError:  Expected:  x= " "  Result:  x= "  [FE]              junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ",ArrayBuilder ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( ",ArrayBuilder ");	  Node    emptyStringNode    =    Node.newString(       "java.util.ArrayBuilder       ");    Node    emptyStringNode    =    Node.newString(   ",java.util.ArrayBuilder       ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x= " "  Result:  x= "  	123	3	replace
834	[BUG]  [BUGGY]  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]                junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ";java.util.ArrayBuilder ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( ";java.util.ArrayBuilder ");	  Node    emptyStringNode    =    Node.newString(       "java.util.ArrayBuilder       ");    Node    emptyStringNode    =    Node.newString(   ",java.util.ArrayBuilder       ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	123	3	replace
835	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( ";java.util.ArrayBuilder ");  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]                junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ";java.util.ArrayBuilder ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( ";java.util.ArrayBuilder ");	  Node    emptyStringNode    =    Node.newString(       "java.util.ArrayBuilder       ");    Node    emptyStringNode    =    Node.newString(   ",java.util.ArrayBuilder       ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	123	3	replace
836	[BUG]  [BUGGY]  [FE]  junit.framework.AssertionFailedError:  Expected:  x= " "  Result:  x= "]  [FE]                  junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "],java.util.ArrayBuilder ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "],java.util.ArrayBuilder ");	  Node    emptyStringNode    =    Node.newString(       "java.util.ArrayBuilder       ");    Node    emptyStringNode    =    Node.newString(   ",java.util.ArrayBuilder       ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x= " "  Result:  x= "]  	123	3	replace
837	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "],java.util.ArrayBuilder ");  [FE]  junit.framework.AssertionFailedError:  Expected:  x= " "  Result:  x= "]  [FE]                  junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "],java.util.ArrayBuilder ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "],java.util.ArrayBuilder ");	  Node    emptyStringNode    =    Node.newString(       "java.util.ArrayBuilder       ");    Node    emptyStringNode    =    Node.newString(   ",java.util.ArrayBuilder       ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x= " "  Result:  x= "]  	123	3	replace
838	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( ",java.util.ArrayBuilder ",  originalSize);  [CE]  no  suitable  method  found  for  newString(String,int)  [FE]                    junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ",java.util.ArrayBuilder ",  originalSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( ",java.util.ArrayBuilder ",  originalSize);	  Node    emptyStringNode    =    Node.newString(       "java.util.ArrayBuilder       ");    Node    emptyStringNode    =    Node.newString(   ",java.util.ArrayBuilder       ");    	non-compiled	[CE]  no  suitable  method  found  for  newString(String,int)	123	None	replace
839	[BUG]  [BUGGY]  Node  emptyStringNode  =  arrayFoldedChildren.get(n,  prev);  [CE]  method  get  in  interface  List<E>  cannot  be  applied  to  given  types;  [FE]                              junit.framework.AssertionFailedError:  Expected:  x=[     "a     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  arrayFoldedChildren.get(n,  prev);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  arrayFoldedChildren.get(n,  prev);	  Node    emptyStringNode    =    arrayFoldedChildren.get(prev);    	non-compiled	[CE]  method  get  in  interface  List<E>  cannot  be  applied  to  given  types;	4	None	replace
840	[BUG]  [BUGGY]  Node  emptyStringNode  =  arrayFoldedChildren.get(prev,  n);  [CE]  method  get  in  interface  List<E>  cannot  be  applied  to  given  types;  [FE]                                junit.framework.AssertionFailedError:  Expected:  x=[     "a     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  arrayFoldedChildren.get(prev,  n);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  arrayFoldedChildren.get(prev,  n);	  Node    emptyStringNode    =    arrayFoldedChildren.get(prev);    	non-compiled	[CE]  method  get  in  interface  List<E>  cannot  be  applied  to  given  types;	4	None	replace
841	[BUG]  [BUGGY]  Node  emptyStringNode  =  arrayFoldedChildren.get(i,  prev);  [CE]  cannot  find  symbol  i  [FE]                                  junit.framework.AssertionFailedError:  Expected:  x=[     "a     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  arrayFoldedChildren.get(i,  prev);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  arrayFoldedChildren.get(i,  prev);	  Node    emptyStringNode    =    arrayFoldedChildren.get(prev);    	non-compiled	[CE]  cannot  find  symbol  i	4	None	replace
842	[BUG]  [BUGGY]  Node  emptyStringNode  =  arrayFoldedChildren.get(pos);  [CE]  cannot  find  symbol  pos  [FE]                                    junit.framework.AssertionFailedError:  Expected:  x=[     "a     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  arrayFoldedChildren.get(pos);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  arrayFoldedChildren.get(pos);	  Node    emptyStringNode    =    arrayFoldedChildren.get(prev);    	non-compiled	[CE]  cannot  find  symbol  pos	4	None	replace
843	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "ArrayList   ");  Node  emptyStringNode  =  Node.newString(   "ArrayList   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "ArrayList   ");  Node  emptyStringNode  =  Node.newString(   "ArrayList   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "ArrayList   ");    Node  emptyStringNode  =  Node.newString(   "ArrayList   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	125	None	add
844	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "ArrayList   ");  Node  emptyStringNode  =  Node.newString( ",ArrayList   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]      AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "ArrayList   ");  Node  emptyStringNode  =  Node.newString( ",ArrayList   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "ArrayList   ");    Node  emptyStringNode  =  Node.newString( ",ArrayList   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	125	None	add
845	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "ArrayList   ");  Node  emptyStringNode  =  Node.newString( ".ArrayList   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]        AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "ArrayList   ");  Node  emptyStringNode  =  Node.newString( ".ArrayList   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "ArrayList   ");    Node  emptyStringNode  =  Node.newString( ".ArrayList   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	125	None	add
846	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "ArrayList   ");  Node  emptyStringNode  =  Node.newString(... "ArrayList   ");  [CE]  illegal  start  of  expression  [FE]          AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "ArrayList   ");  Node  emptyStringNode  =  Node.newString(... "ArrayList   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "ArrayList   ");    Node  emptyStringNode  =  Node.newString(... "ArrayList   ");	  	non-compiled	[CE]  illegal  start  of  expression	125	None	add
847	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "ArrayList   ");  Node  emptyStringNode  =  Node.newString(. "ArrayList   ");  [CE]  illegal  start  of  expression  [FE]            AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "ArrayList   ");  Node  emptyStringNode  =  Node.newString(. "ArrayList   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "ArrayList   ");    Node  emptyStringNode  =  Node.newString(. "ArrayList   ");	  	non-compiled	[CE]  illegal  start  of  expression	125	None	add
848	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "ArrayList   ");  Node  emptyStringNode  =  Node.newString(, "ArrayList   ");  [CE]  illegal  start  of  expression  [FE]              AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "ArrayList   ");  Node  emptyStringNode  =  Node.newString(, "ArrayList   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "ArrayList   ");    Node  emptyStringNode  =  Node.newString(, "ArrayList   ");	  	non-compiled	[CE]  illegal  start  of  expression	125	None	add
849	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "ArrayBuilder   ");  Node  emptyStringNode  =  Node.newString( "ArrayBuilder   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "ArrayBuilder   ");  Node  emptyStringNode  =  Node.newString( "ArrayBuilder   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "ArrayBuilder   ");    Node  emptyStringNode  =  Node.newString( "ArrayBuilder   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	100	None	add
850	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "ArrayBuilder   ");  Node  emptyStringNode  =  Node.newString( ",ArrayBuilder   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]      AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "ArrayBuilder   ");  Node  emptyStringNode  =  Node.newString( ",ArrayBuilder   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "ArrayBuilder   ");    Node  emptyStringNode  =  Node.newString( ",ArrayBuilder   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	100	None	add
851	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "ArrayBuilder   ");  Node  emptyStringNode  =  Node.newString( ".ArrayBuilder   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]        AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "ArrayBuilder   ");  Node  emptyStringNode  =  Node.newString( ".ArrayBuilder   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "ArrayBuilder   ");    Node  emptyStringNode  =  Node.newString( ".ArrayBuilder   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	100	None	add
852	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "ArrayBuilder   ");  Node  emptyStringNode  =  Node.newString(, "ArrayBuilder   ");  [CE]  illegal  start  of  expression  [FE]          AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "ArrayBuilder   ");  Node  emptyStringNode  =  Node.newString(, "ArrayBuilder   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "ArrayBuilder   ");    Node  emptyStringNode  =  Node.newString(, "ArrayBuilder   ");	  	non-compiled	[CE]  illegal  start  of  expression	100	None	add
853	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "ArrayBuilder   ");  Node  emptyStringNode  =  Node.newString(. "ArrayBuilder   ");  [CE]  illegal  start  of  expression  [FE]            AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "ArrayBuilder   ");  Node  emptyStringNode  =  Node.newString(. "ArrayBuilder   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "ArrayBuilder   ");    Node  emptyStringNode  =  Node.newString(. "ArrayBuilder   ");	  	non-compiled	[CE]  illegal  start  of  expression	100	None	add
854	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "ArrayBuilder   ");  Node  emptyStringNode  =  Node.newString(... "ArrayBuilder   ");  [CE]  illegal  start  of  expression  [FE]              AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "ArrayBuilder   ");  Node  emptyStringNode  =  Node.newString(... "ArrayBuilder   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "ArrayBuilder   ");    Node  emptyStringNode  =  Node.newString(... "ArrayBuilder   ");	  	non-compiled	[CE]  illegal  start  of  expression	100	None	add
855	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "[0] ",  n);  [CE]  no  suitable  method  found  for  newString(String,Node)  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[0] ",  n);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "[0] ",  n);	  Node    emptyStringNode    =    Node.newString(   "[0]   ");    	non-compiled	[CE]  no  suitable  method  found  for  newString(String,Node)	63	None	replace
856	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "[0] ",  sb.toString());  [CE]  no  suitable  method  found  for  newString(String,String)  [FE]      AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[0] ",  sb.toString());  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "[0] ",  sb.toString());	  Node    emptyStringNode    =    Node.newString(   "[0]   ");    	non-compiled	[CE]  no  suitable  method  found  for  newString(String,String)	63	None	replace
857	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[0] "  +  originalSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "[0] "  +  originalSize);	  Node    emptyStringNode    =    Node.newString(   "[0]   ");    	compilable	  [FE]  AssertionFailedError  	63	3	replace
858	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "[0] "  +  originalSize);  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[0] "  +  originalSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "[0] "  +  originalSize);	  Node    emptyStringNode    =    Node.newString(   "[0]   ");    	compilable	  [FE]  AssertionFailedError  	63	3	replace
859	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]          AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[0] "  +  sb.toString());  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "[0] "  +  sb.toString());	  Node    emptyStringNode    =    Node.newString(   "[0]   ");    	compilable	  [FE]  RuntimeException  	63	3	replace
860	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "[0] "  +  sb.toString());  [FE]  RuntimeException  [FE]          AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[0] "  +  sb.toString());  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "[0] "  +  sb.toString());	  Node    emptyStringNode    =    Node.newString(   "[0]   ");    	compilable	  [FE]  RuntimeException  	63	3	replace
861	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "JoinArrayElement   ");  Node  emptyStringNode  =  Node.newString( "JoinArrayElement   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "JoinArrayElement   ");  Node  emptyStringNode  =  Node.newString( "JoinArrayElement   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "JoinArrayElement   ");    Node  emptyStringNode  =  Node.newString( "JoinArrayElement   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	38	None	add
862	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "JoinArrayElement   ");  Node  emptyStringNode  =  Node.newString( ",JoinArrayElement   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]      AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "JoinArrayElement   ");  Node  emptyStringNode  =  Node.newString( ",JoinArrayElement   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "JoinArrayElement   ");    Node  emptyStringNode  =  Node.newString( ",JoinArrayElement   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	38	None	add
863	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "JoinArrayElement   ");  Node  emptyStringNode  =  Node.newString( ".JoinArrayElement   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]        AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "JoinArrayElement   ");  Node  emptyStringNode  =  Node.newString( ".JoinArrayElement   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "JoinArrayElement   ");    Node  emptyStringNode  =  Node.newString( ".JoinArrayElement   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	38	None	add
864	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "JoinArrayElement   ");  Node  emptyStringNode  =  Node.newString( "JoinArrayElement ",);  [CE]  illegal  start  of  expression  [FE]          AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "JoinArrayElement   ");  Node  emptyStringNode  =  Node.newString( "JoinArrayElement ",);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "JoinArrayElement   ");    Node  emptyStringNode  =  Node.newString( "JoinArrayElement ",);	  	non-compiled	[CE]  illegal  start  of  expression	38	None	add
865	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "java.util.ArrayList:   ");  Node  emptyStringNode  =  Node.newString( "java.util.ArrayList:   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]    junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "java.util.ArrayList:   ");  Node  emptyStringNode  =  Node.newString( "java.util.ArrayList:   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "java.util.ArrayList:   ");    Node  emptyStringNode  =  Node.newString( "java.util.ArrayList:   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	158	None	add
866	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "java.util.ArrayList:   ");  Node  emptyStringNode  =  Node.newString( ".java.util.ArrayList:   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]      junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "java.util.ArrayList:   ");  Node  emptyStringNode  =  Node.newString( ".java.util.ArrayList:   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "java.util.ArrayList:   ");    Node  emptyStringNode  =  Node.newString( ".java.util.ArrayList:   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	158	None	add
867	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "java.util.ArrayList:   ");  Node  emptyStringNode  =  Node.newString( ",java.util.ArrayList:   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]        junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "java.util.ArrayList:   ");  Node  emptyStringNode  =  Node.newString( ",java.util.ArrayList:   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "java.util.ArrayList:   ");    Node  emptyStringNode  =  Node.newString( ",java.util.ArrayList:   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	158	None	add
868	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "java.util.ArrayList:   ");  Node  emptyStringNode  =  Node.newString( "java.util.ArrayList: ",);  [CE]  illegal  start  of  expression  [FE]          junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "java.util.ArrayList:   ");  Node  emptyStringNode  =  Node.newString( "java.util.ArrayList: ",);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "java.util.ArrayList:   ");    Node  emptyStringNode  =  Node.newString( "java.util.ArrayList: ",);	  	non-compiled	[CE]  illegal  start  of  expression	158	None	add
869	[BUG]  [BUGGY]  [FE]  junit.framework.AssertionFailedError:  Expected:  x= " "  Result:  x= "  [FE]              junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ",array ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( ",array ");	  Node    emptyStringNode    =    Node.newString(       "array       ");    Node    emptyStringNode    =    Node.newString(   ",array       ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x= " "  Result:  x= "  	15	3	replace
870	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( ",array ");  [FE]  junit.framework.AssertionFailedError:  Expected:  x= " "  Result:  x= "  [FE]              junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ",array ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( ",array ");	  Node    emptyStringNode    =    Node.newString(       "array       ");    Node    emptyStringNode    =    Node.newString(   ",array       ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x= " "  Result:  x= "  	15	3	replace
871	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "[array] ",  arrayFoldedChildren.size()  -  1);  [CE]  no  suitable  method  found  for  newString(String,int)  [FE]                junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[array] ",  arrayFoldedChildren.size()  -  1);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "[array] ",  arrayFoldedChildren.size()  -  1);	  Node    emptyStringNode    =    Node.newString(       "array       ");    Node    emptyStringNode    =    Node.newString(   ",array       ");    	non-compiled	[CE]  no  suitable  method  found  for  newString(String,int)	15	None	replace
872	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "[array] ",  arrayFoldedChildren.size());  [CE]  no  suitable  method  found  for  newString(String,int)  [FE]                  junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[array] ",  arrayFoldedChildren.size());  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "[array] ",  arrayFoldedChildren.size());	  Node    emptyStringNode    =    Node.newString(       "array       ");    Node    emptyStringNode    =    Node.newString(   ",array       ");    	non-compiled	[CE]  no  suitable  method  found  for  newString(String,int)	15	None	replace
873	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( ",array ",  originalSize);  [CE]  no  suitable  method  found  for  newString(String,int)  [FE]                    junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ",array ",  originalSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( ",array ",  originalSize);	  Node    emptyStringNode    =    Node.newString(       "array       ");    Node    emptyStringNode    =    Node.newString(   ",array       ");    	non-compiled	[CE]  no  suitable  method  found  for  newString(String,int)	15	None	replace
874	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "array-name   ");  Node  emptyStringNode  =  Node.newString( "array-name   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "array-name   ");  Node  emptyStringNode  =  Node.newString( "array-name   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "array-name   ");    Node  emptyStringNode  =  Node.newString( "array-name   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	74	None	add
875	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "array-name   ");  Node  emptyStringNode  =  Node.newString( ".array-name   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]      AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "array-name   ");  Node  emptyStringNode  =  Node.newString( ".array-name   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "array-name   ");    Node  emptyStringNode  =  Node.newString( ".array-name   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	74	None	add
876	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "array-name   ");  Node  emptyStringNode  =  Node.newString( ",array-name   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]        AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "array-name   ");  Node  emptyStringNode  =  Node.newString( ",array-name   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "array-name   ");    Node  emptyStringNode  =  Node.newString( ",array-name   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	74	None	add
877	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "array-name   ");  Node  emptyStringNode  =  Node.newString(. "array-name   ");  [CE]  illegal  start  of  expression  [FE]          AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "array-name   ");  Node  emptyStringNode  =  Node.newString(. "array-name   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "array-name   ");    Node  emptyStringNode  =  Node.newString(. "array-name   ");	  	non-compiled	[CE]  illegal  start  of  expression	74	None	add
878	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "array-name   ");  Node  emptyStringNode  =  Node.newString( "array-name ",);  [CE]  illegal  start  of  expression  [FE]            AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "array-name   ");  Node  emptyStringNode  =  Node.newString( "array-name ",);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "array-name   ");    Node  emptyStringNode  =  Node.newString( "array-name ",);	  	non-compiled	[CE]  illegal  start  of  expression	74	None	add
879	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "array-name   ");  Node  emptyStringNode  =  Node.newString(? "array-name   ");  [CE]  illegal  start  of  expression  [FE]              AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "array-name   ");  Node  emptyStringNode  =  Node.newString(? "array-name   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "array-name   ");    Node  emptyStringNode  =  Node.newString(? "array-name   ");	  	non-compiled	[CE]  illegal  start  of  expression	74	None	add
880	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "array ",  n,  originalSize);  [CE]  no  suitable  method  found  for  newString(String,Node,int)  [FE]          junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "array ",  n,  originalSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "array ",  n,  originalSize);	  Node    emptyStringNode    =    Node.newString(   "array   ",    n);    	non-compiled	[CE]  no  suitable  method  found  for  newString(String,Node,int)	188	None	replace
881	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "array ",  n,  prev);  [CE]  no  suitable  method  found  for  newString(String,Node,Node)  [FE]            junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "array ",  n,  prev);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "array ",  n,  prev);	  Node    emptyStringNode    =    Node.newString(   "array   ",    n);    	non-compiled	[CE]  no  suitable  method  found  for  newString(String,Node,Node)	188	None	replace
882	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "array ",  n,  foldedSize);  [CE]  no  suitable  method  found  for  newString(String,Node,int)  [FE]              junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "array ",  n,  foldedSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "array ",  n,  foldedSize);	  Node    emptyStringNode    =    Node.newString(   "array   ",    n);    	non-compiled	[CE]  no  suitable  method  found  for  newString(String,Node,int)	188	None	replace
883	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "array ",  n,  initialSize);  [CE]  cannot  find  symbol  initialSize  [FE]                junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "array ",  n,  initialSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "array ",  n,  initialSize);	  Node    emptyStringNode    =    Node.newString(   "array   ",    n);    	non-compiled	[CE]  cannot  find  symbol  initialSize	188	None	replace
884	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.STRING,  left);  [CE]  cannot  find  symbol  left  [FE]            junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.STRING,  left);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(Token.STRING,  left);	  Node    emptyStringNode    =    Node.newString(Token.STRING);    	non-compiled	[CE]  cannot  find  symbol  left	40	None	replace
885	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.STRING,  sb);  [CE]  no  suitable  method  found  for  newString(int,StringBuilder)  [FE]              junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.STRING,  sb);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(Token.STRING,  sb);	  Node    emptyStringNode    =    Node.newString(Token.STRING);    	non-compiled	[CE]  no  suitable  method  found  for  newString(int,StringBuilder)	40	None	replace
886	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.STRING,  prev);  [CE]  no  suitable  method  found  for  newString(int,Node)  [FE]                junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.STRING,  prev);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(Token.STRING,  prev);	  Node    emptyStringNode    =    Node.newString(Token.STRING);    	non-compiled	[CE]  no  suitable  method  found  for  newString(int,Node)	40	None	replace
887	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "org.join.ArrayElement   ");  Node  emptyStringNode  =  Node.newString( "org.join.ArrayElement   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "org.join.ArrayElement   ");  Node  emptyStringNode  =  Node.newString( "org.join.ArrayElement   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "org.join.ArrayElement   ");    Node  emptyStringNode  =  Node.newString( "org.join.ArrayElement   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	194	None	add
888	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "org.join.ArrayElement   ");  Node  emptyStringNode  =  Node.newString( ".org.join.ArrayElement   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]      AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "org.join.ArrayElement   ");  Node  emptyStringNode  =  Node.newString( ".org.join.ArrayElement   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "org.join.ArrayElement   ");    Node  emptyStringNode  =  Node.newString( ".org.join.ArrayElement   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	194	None	add
889	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "org.join.ArrayElement   ");  Node  emptyStringNode  =  Node.newString( ",org.join.ArrayElement   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]        AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "org.join.ArrayElement   ");  Node  emptyStringNode  =  Node.newString( ",org.join.ArrayElement   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "org.join.ArrayElement   ");    Node  emptyStringNode  =  Node.newString( ",org.join.ArrayElement   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	194	None	add
890	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "org.join.ArrayElement   ");  Node  emptyStringNode  =  Node.newString( ")org.join.ArrayElement   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]          AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "org.join.ArrayElement   ");  Node  emptyStringNode  =  Node.newString( ")org.join.ArrayElement   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "org.join.ArrayElement   ");    Node  emptyStringNode  =  Node.newString( ")org.join.ArrayElement   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	194	None	add
891	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "null "));  [CE]  [FE]            AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "null "));  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "null "));	  Node    emptyStringNode    =    Node.newString(       "n       ");    Node    emptyStringNode    =    Node.newString(   "n   "));    	non-compiled	[CE]  	18	None	replace
892	[BUG]  [BUGGY]  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]              AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "no_arguments ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "no_arguments ");	  Node    emptyStringNode    =    Node.newString(       "n       ");    Node    emptyStringNode    =    Node.newString(   "n   "));    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	18	3	replace
893	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "no_arguments ");  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]              AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "no_arguments ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "no_arguments ");	  Node    emptyStringNode    =    Node.newString(       "n       ");    Node    emptyStringNode    =    Node.newString(   "n   "));    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	18	3	replace
894	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "-   "  +  Token.NAME);  Node  emptyStringNode  =  Node.newString( "-   "  +  Token.NAME);  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "-   "  +  Token.NAME);  Node  emptyStringNode  =  Node.newString( "-   "  +  Token.NAME);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "-   "    +    Token.NAME);    Node  emptyStringNode  =  Node.newString( "-   "  +  Token.NAME);	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	163	None	add
895	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "-   "  +  Token.NAME);  Node  emptyStringNode  =  Node.newString( ",-   "  +  Token.NAME);  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]      AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "-   "  +  Token.NAME);  Node  emptyStringNode  =  Node.newString( ",-   "  +  Token.NAME);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "-   "    +    Token.NAME);    Node  emptyStringNode  =  Node.newString( ",-   "  +  Token.NAME);	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	163	None	add
896	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "-   "  +  Token.NAME);  Node  emptyStringNode  =  Node.newString( ".-   "  +  Token.NAME);  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]        AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "-   "  +  Token.NAME);  Node  emptyStringNode  =  Node.newString( ".-   "  +  Token.NAME);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "-   "    +    Token.NAME);    Node  emptyStringNode  =  Node.newString( ".-   "  +  Token.NAME);	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	163	None	add
897	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "-   "  +  Token.NAME);  Node  emptyStringNode  =  Node.newString(. "-   "  +  Token.NAME);  [CE]  illegal  start  of  expression  [FE]          AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "-   "  +  Token.NAME);  Node  emptyStringNode  =  Node.newString(. "-   "  +  Token.NAME);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "-   "    +    Token.NAME);    Node  emptyStringNode  =  Node.newString(. "-   "  +  Token.NAME);	  	non-compiled	[CE]  illegal  start  of  expression	163	None	add
898	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "-   "  +  Token.NAME);  Node  emptyStringNode  =  Node.newString(, "-   "  +  Token.NAME);  [CE]  illegal  start  of  expression  [FE]            AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "-   "  +  Token.NAME);  Node  emptyStringNode  =  Node.newString(, "-   "  +  Token.NAME);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "-   "    +    Token.NAME);    Node  emptyStringNode  =  Node.newString(, "-   "  +  Token.NAME);	  	non-compiled	[CE]  illegal  start  of  expression	163	None	add
899	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "-   "  +  Token.NAME);  Node  emptyStringNode  =  Node.newString(... "-   "  +  Token.NAME);  [CE]  illegal  start  of  expression  [FE]              AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "-   "  +  Token.NAME);  Node  emptyStringNode  =  Node.newString(... "-   "  +  Token.NAME);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "-   "    +    Token.NAME);    Node  emptyStringNode  =  Node.newString(... "-   "  +  Token.NAME);	  	non-compiled	[CE]  illegal  start  of  expression	163	None	add
900	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "Arrays.asList( "  +  arrayFoldedChildren.size()));  [CE]  [FE]              junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "Arrays.asList( "  +  arrayFoldedChildren.size()));  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "Arrays.asList( "  +  arrayFoldedChildren.size()));	  Node    emptyStringNode    =    Node.newString(   "java.util.Arrays.asList(   "    +    arrayFoldedChildren.size()    -    1));    	non-compiled	[CE]  	55	None	replace
901	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "Join.Arrays.asList( "  +  arrayFoldedChildren.size()));  [CE]  [FE]                junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "Join.Arrays.asList( "  +  arrayFoldedChildren.size()));  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "Join.Arrays.asList( "  +  arrayFoldedChildren.size()));	  Node    emptyStringNode    =    Node.newString(   "java.util.Arrays.asList(   "    +    arrayFoldedChildren.size()    -    1));    	non-compiled	[CE]  	55	None	replace
902	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "-   "  +  prev);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "-   "  +  prev);	  Node    emptyStringNode    =    Node.newString(   "-   "    +    name);    	compilable	  [FE]  AssertionFailedError  	162	3	replace
903	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "-   "  +  prev);  [FE]  AssertionFailedError  [FE]          AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "-   "  +  prev);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "-   "  +  prev);	  Node    emptyStringNode    =    Node.newString(   "-   "    +    name);    	compilable	  [FE]  AssertionFailedError  	162	3	replace
904	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "-   "  +  leftStringNode);  [CE]  cannot  find  symbol  leftStringNode  [FE]            AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "-   "  +  leftStringNode);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "-   "  +  leftStringNode);	  Node    emptyStringNode    =    Node.newString(   "-   "    +    name);    	non-compiled	[CE]  cannot  find  symbol  leftStringNode	162	None	replace
905	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList( "  +  foldedSize  +   "));  [CE]  unclosed  string  literal  [FE]          junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList( "  +  foldedSize  +   "));  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList( "  +  foldedSize  +   "));	  Node    emptyStringNode    =    Node.newString(   "java.util.Arrays.asList(   "    +    originalSize    +   "));    	non-compiled	[CE]  unclosed  string  literal	53	None	replace
906	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "Arrays.asList( "  +  foldedSize  +   "));  [CE]  unclosed  string  literal  [FE]            junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "Arrays.asList( "  +  foldedSize  +   "));  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "Arrays.asList( "  +  foldedSize  +   "));	  Node    emptyStringNode    =    Node.newString(   "java.util.Arrays.asList(   "    +    originalSize    +   "));    	non-compiled	[CE]  unclosed  string  literal	53	None	replace
907	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList( "  +  foldedSize  +  1));  [CE]  [FE]              junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList( "  +  foldedSize  +  1));  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList( "  +  foldedSize  +  1));	  Node    emptyStringNode    =    Node.newString(   "java.util.Arrays.asList(   "    +    originalSize    +   "));    	non-compiled	[CE]  	53	None	replace
908	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList( "  +  originalSize  +  1));  [CE]  [FE]                junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList( "  +  originalSize  +  1));  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList( "  +  originalSize  +  1));	  Node    emptyStringNode    =    Node.newString(   "java.util.Arrays.asList(   "    +    originalSize    +   "));    	non-compiled	[CE]  	53	None	replace
909	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME,   "Array   ");  Node  emptyStringNode  =  Node.newString(Token.NAME,   "Array   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]    junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME,   "Array   ");  Node  emptyStringNode  =  Node.newString(Token.NAME,   "Array   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(Token.NAME,   "Array   ");    Node  emptyStringNode  =  Node.newString(Token.NAME,   "Array   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	119	None	add
910	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME,   "Array   ");  Node  emptyStringNode  =  Node.newString(Token.NAME, ",Array   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]      junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME,   "Array   ");  Node  emptyStringNode  =  Node.newString(Token.NAME, ",Array   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(Token.NAME,   "Array   ");    Node  emptyStringNode  =  Node.newString(Token.NAME, ",Array   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	119	None	add
911	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME,   "Array   ");  Node  emptyStringNode  =  Node.newString(Token.NAME,, "Array   ");  [CE]  illegal  start  of  expression  [FE]        junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME,   "Array   ");  Node  emptyStringNode  =  Node.newString(Token.NAME,, "Array   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(Token.NAME,   "Array   ");    Node  emptyStringNode  =  Node.newString(Token.NAME,, "Array   ");	  	non-compiled	[CE]  illegal  start  of  expression	119	None	add
912	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME,   "Array   ");  Node  emptyStringNode  =  Node.newString(Token.NAME,  token, "Array   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]          junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME,   "Array   ");  Node  emptyStringNode  =  Node.newString(Token.NAME,  token, "Array   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(Token.NAME,   "Array   ");    Node  emptyStringNode  =  Node.newString(Token.NAME,  token, "Array   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	119	None	add
913	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME,   "Array   ");  Node  emptyStringNode  =  Node.newString(Token.NAME,. "Array   ");  [CE]  illegal  start  of  expression  [FE]            junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME,   "Array   ");  Node  emptyStringNode  =  Node.newString(Token.NAME,. "Array   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(Token.NAME,   "Array   ");    Node  emptyStringNode  =  Node.newString(Token.NAME,. "Array   ");	  	non-compiled	[CE]  illegal  start  of  expression	119	None	add
914	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(. "string ");  [CE]  illegal  start  of  expression  [FE]        AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(. "string ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(. "string ");	  Node    emptyStringNode    =    Node.newString(       "string       ");    Node    emptyStringNode    =    Node.newString(.   "string       ");    	non-compiled	[CE]  illegal  start  of  expression	143	None	replace
915	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME,   "ArrayElement   ");  Node  emptyStringNode  =  Node.newString(Token.NAME,   "ArrayElement   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME,   "ArrayElement   ");  Node  emptyStringNode  =  Node.newString(Token.NAME,   "ArrayElement   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(Token.NAME,   "ArrayElement   ");    Node  emptyStringNode  =  Node.newString(Token.NAME,   "ArrayElement   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	135	None	add
916	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME,   "ArrayElement   ");  Node  emptyStringNode  =  Node.newString(Token.NAME, ",ArrayElement   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]      AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME,   "ArrayElement   ");  Node  emptyStringNode  =  Node.newString(Token.NAME, ",ArrayElement   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(Token.NAME,   "ArrayElement   ");    Node  emptyStringNode  =  Node.newString(Token.NAME, ",ArrayElement   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	135	None	add
917	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME,   "ArrayElement   ");  Node  emptyStringNode  =  Node.newString(Token.NAME,, "ArrayElement   ");  [CE]  illegal  start  of  expression  [FE]        AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME,   "ArrayElement   ");  Node  emptyStringNode  =  Node.newString(Token.NAME,, "ArrayElement   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(Token.NAME,   "ArrayElement   ");    Node  emptyStringNode  =  Node.newString(Token.NAME,, "ArrayElement   ");	  	non-compiled	[CE]  illegal  start  of  expression	135	None	add
918	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME,   "ArrayElement   ");  Node  emptyStringNode  =  Node.newString(Token.NAME,. "ArrayElement   ");  [CE]  illegal  start  of  expression  [FE]          AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME,   "ArrayElement   ");  Node  emptyStringNode  =  Node.newString(Token.NAME,. "ArrayElement   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(Token.NAME,   "ArrayElement   ");    Node  emptyStringNode  =  Node.newString(Token.NAME,. "ArrayElement   ");	  	non-compiled	[CE]  illegal  start  of  expression	135	None	add
919	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "- "  +  n,  originalSize);  [CE]  no  suitable  method  found  for  newString(String,int)  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "- "  +  n,  originalSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "- "  +  n,  originalSize);	  Node    emptyStringNode    =    Node.newString(   "-   "    +    n);    	non-compiled	[CE]  no  suitable  method  found  for  newString(String,int)	49	None	replace
920	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "- "  +  oldStringNode);  [CE]  cannot  find  symbol  oldStringNode  [FE]      AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "- "  +  oldStringNode);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "- "  +  oldStringNode);	  Node    emptyStringNode    =    Node.newString(   "-   "    +    n);    	non-compiled	[CE]  cannot  find  symbol  oldStringNode	49	None	replace
921	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "ArrayList "  +  originalSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "ArrayList "  +  originalSize);	  Node    emptyStringNode    =    Node.newString(   "ArrayList   ");    	compilable	  [FE]  AssertionFailedError  	126	3	replace
922	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "ArrayList "  +  originalSize);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "ArrayList "  +  originalSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "ArrayList "  +  originalSize);	  Node    emptyStringNode    =    Node.newString(   "ArrayList   ");    	compilable	  [FE]  AssertionFailedError  	126	3	replace
923	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "Arrays.asList( "  +  originalSize  + "));  [CE]  unclosed  string  literal  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "Arrays.asList( "  +  originalSize  + "));  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "Arrays.asList( "  +  originalSize  + "));	  Node    emptyStringNode    =    Node.newString(   "Arrays.asList(   ");    	non-compiled	[CE]  unclosed  string  literal	52	None	replace
924	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "Arrays.asList( "  +  arrayFoldedChildren.size()  +  1));  [CE]  [FE]      AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "Arrays.asList( "  +  arrayFoldedChildren.size()  +  1));  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "Arrays.asList( "  +  arrayFoldedChildren.size()  +  1));	  Node    emptyStringNode    =    Node.newString(   "Arrays.asList(   ");    	non-compiled	[CE]  	52	None	replace
925	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "Arrays.asList( "  +  arrayFoldedChildren.size()  -  1);  [CE]  bad  operand  types  for  binary  operator  [FE]        AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "Arrays.asList( "  +  arrayFoldedChildren.size()  -  1);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "Arrays.asList( "  +  arrayFoldedChildren.size()  -  1);	  Node    emptyStringNode    =    Node.newString(   "Arrays.asList(   ");    	non-compiled	[CE]  bad  operand  types  for  binary  operator  	52	None	replace
926	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "Arrays.asList(n ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "Arrays.asList(n ");	  Node    emptyStringNode    =    Node.newString(   "Arrays.asList(   ");    	compilable	  [FE]  AssertionFailedError  	52	3	replace
927	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "Arrays.asList(n ");  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "Arrays.asList(n ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "Arrays.asList(n ");	  Node    emptyStringNode    =    Node.newString(   "Arrays.asList(   ");    	compilable	  [FE]  AssertionFailedError  	52	3	replace
928	[BUG]  [BUGGY]  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('  [FE]    java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(sb.toString()  +  1);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString(sb.toString()  +  1);	  Node    emptyStringNode    =    Node.newString(sb.toString());    	compilable	  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('  	190	3	replace
929	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(sb.toString()  +  1);  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('  [FE]    java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(sb.toString()  +  1);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(sb.toString()  +  1);	  Node    emptyStringNode    =    Node.newString(sb.toString());    	compilable	  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('  	190	3	replace
930	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(sb.toString(),  foldedSize);  [CE]  no  suitable  method  found  for  newString(String,int)  [FE]      java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(sb.toString(),  foldedSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(sb.toString(),  foldedSize);	  Node    emptyStringNode    =    Node.newString(sb.toString());    	non-compiled	[CE]  no  suitable  method  found  for  newString(String,int)	190	None	replace
931	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(sb.toString(),  prev);  [CE]  no  suitable  method  found  for  newString(String,Node)  [FE]        java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(sb.toString(),  prev);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(sb.toString(),  prev);	  Node    emptyStringNode    =    Node.newString(sb.toString());    	non-compiled	[CE]  no  suitable  method  found  for  newString(String,Node)	190	None	replace
932	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(arrayFoldedChildren.toString());  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString(arrayFoldedChildren.toString());	  Node    emptyStringNode    =    Node.newString(sb.toString());    	compilable	  [FE]  AssertionFailedError  	190	3	replace
933	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(arrayFoldedChildren.toString());  [FE]  AssertionFailedError  [FE]          java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(arrayFoldedChildren.toString());  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(arrayFoldedChildren.toString());	  Node    emptyStringNode    =    Node.newString(sb.toString());    	compilable	  [FE]  AssertionFailedError  	190	3	replace
934	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(arrayFoldedChildren.size()  -  1);  [CE]  no  suitable  method  found  for  newString(int)  [FE]            java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(arrayFoldedChildren.size()  -  1);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(arrayFoldedChildren.size()  -  1);	  Node    emptyStringNode    =    Node.newString(sb.toString());    	non-compiled	[CE]  no  suitable  method  found  for  newString(int)	190	None	replace
935	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "] "  +  Token.NAME,  foldedSize);  [CE]  no  suitable  method  found  for  newString(String,int)  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "] "  +  Token.NAME,  foldedSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "] "  +  Token.NAME,  foldedSize);	  Node    emptyStringNode    =    Node.newString(   "]   "    +    Token.NAME);    	non-compiled	[CE]  no  suitable  method  found  for  newString(String,int)	154	None	replace
936	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "] "  +  Token.NAME,  originalSize);  [CE]  no  suitable  method  found  for  newString(String,int)  [FE]      AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "] "  +  Token.NAME,  originalSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "] "  +  Token.NAME,  originalSize);	  Node    emptyStringNode    =    Node.newString(   "]   "    +    Token.NAME);    	non-compiled	[CE]  no  suitable  method  found  for  newString(String,int)	154	None	replace
937	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[] "  +  Token.NAME);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "[] "  +  Token.NAME);	  Node    emptyStringNode    =    Node.newString(   "]   "    +    Token.NAME);    	compilable	  [FE]  AssertionFailedError  	154	3	replace
938	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "[] "  +  Token.NAME);  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[] "  +  Token.NAME);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "[] "  +  Token.NAME);	  Node    emptyStringNode    =    Node.newString(   "]   "    +    Token.NAME);    	compilable	  [FE]  AssertionFailedError  	154	3	replace
939	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(prev);  [CE]  no  suitable  method  found  for  newString(Node)  [FE]        AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(prev);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(prev);	  Node    emptyStringNode    =    Node.newString(0);    	non-compiled	[CE]  no  suitable  method  found  for  newString(Node)	184	None	replace
940	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(tokenBuffer,  originalSize);  [CE]  cannot  find  symbol  tokenBuffer  [FE]          AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(tokenBuffer,  originalSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(tokenBuffer,  originalSize);	  Node    emptyStringNode    =    Node.newString(0);    	non-compiled	[CE]  cannot  find  symbol  tokenBuffer	184	None	replace
941	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(prev,  n);  [CE]  no  suitable  method  found  for  newString(Node,Node)  [FE]            AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(prev,  n);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(prev,  n);	  Node    emptyStringNode    =    Node.newString(0);    	non-compiled	[CE]  no  suitable  method  found  for  newString(Node,Node)	184	None	replace
942	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(prev,  originalSize);  [CE]  no  suitable  method  found  for  newString(Node,int)  [FE]              AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(prev,  originalSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(prev,  originalSize);	  Node    emptyStringNode    =    Node.newString(0);    	non-compiled	[CE]  no  suitable  method  found  for  newString(Node,int)	184	None	replace
943	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(functionName);  [CE]  no  suitable  method  found  for  newString(Node)  [FE]                AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(functionName);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(functionName);	  Node    emptyStringNode    =    Node.newString(0);    	non-compiled	[CE]  no  suitable  method  found  for  newString(Node)	184	None	replace
944	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "Arrays.asList(prev));  [CE]  unclosed  string  literal  [FE]          junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "Arrays.asList(prev));  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "Arrays.asList(prev));	  Node    emptyStringNode    =    Node.newString(   "java.util.Arrays.asList(prev));    	non-compiled	[CE]  unclosed  string  literal	182	None	replace
945	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "Arrays.asList(originalSize));  [CE]  unclosed  string  literal  [FE]            junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "Arrays.asList(originalSize));  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "Arrays.asList(originalSize));	  Node    emptyStringNode    =    Node.newString(   "java.util.Arrays.asList(prev));    	non-compiled	[CE]  unclosed  string  literal	182	None	replace
946	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList(originalSize));  [CE]  unclosed  string  literal  [FE]              junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList(originalSize));  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList(originalSize));	  Node    emptyStringNode    =    Node.newString(   "java.util.Arrays.asList(prev));    	non-compiled	[CE]  unclosed  string  literal	182	None	replace
947	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "Arrays.asList(n));  [CE]  unclosed  string  literal  [FE]                junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "Arrays.asList(n));  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "Arrays.asList(n));	  Node    emptyStringNode    =    Node.newString(   "java.util.Arrays.asList(prev));    	non-compiled	[CE]  unclosed  string  literal	182	None	replace
948	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList(optional));  [CE]  unclosed  string  literal  [FE]                  junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList(optional));  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList(optional));	  Node    emptyStringNode    =    Node.newString(   "java.util.Arrays.asList(prev));    	non-compiled	[CE]  unclosed  string  literal	182	None	replace
949	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList(functionName));  [CE]  unclosed  string  literal  [FE]                    junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList(functionName));  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList(functionName));	  Node    emptyStringNode    =    Node.newString(   "java.util.Arrays.asList(prev));    	non-compiled	[CE]  unclosed  string  literal	182	None	replace
950	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "- ").toString();  [CE]  incompatible  types  [FE]        AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "- ").toString();  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "- ").toString();	  Node    emptyStringNode    =    Node.newString(       "-       ");    Node    emptyStringNode    =    Node.newString(   ")-       ");    	non-compiled	[CE]  incompatible  types	197	None	replace
951	[BUG]  [BUGGY]  Node  emptyStringNode  =  arrayFoldedChildren.remove(0);  Node  emptyStringNode  =  arrayFoldedChildren.remove(arrayFoldedChildren.size()  -  1);  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]    java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  Index:  0    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  arrayFoldedChildren.remove(0);  Node  emptyStringNode  =  arrayFoldedChildren.remove(arrayFoldedChildren.size()  -  1);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    arrayFoldedChildren.remove(0);    Node  emptyStringNode  =  arrayFoldedChildren.remove(arrayFoldedChildren.size()  -  1);	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	5	None	add
952	[BUG]  [BUGGY]  Node  emptyStringNode  =  arrayFoldedChildren.remove(0);  Node  emptyStringNode  =  arrayFoldedChildren.remove(arrayFoldedChildren.remove(0);  [CE]  ')'  expected  [FE]      java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  Index:  0    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  arrayFoldedChildren.remove(0);  Node  emptyStringNode  =  arrayFoldedChildren.remove(arrayFoldedChildren.remove(0);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    arrayFoldedChildren.remove(0);    Node  emptyStringNode  =  arrayFoldedChildren.remove(arrayFoldedChildren.remove(0);	  	non-compiled	[CE]  ')'  expected	5	None	add
953	[BUG]  [BUGGY]  Node  emptyStringNode  =  arrayFoldedChildren.remove(0);  Node  emptyStringNode  =  arrayFoldedChildren.remove(arrayFoldedChildren.size());  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]        java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  Index:  0    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  arrayFoldedChildren.remove(0);  Node  emptyStringNode  =  arrayFoldedChildren.remove(arrayFoldedChildren.size());  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    arrayFoldedChildren.remove(0);    Node  emptyStringNode  =  arrayFoldedChildren.remove(arrayFoldedChildren.size());	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	5	None	add
954	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME, "Join.ArrayBuilder ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString(Token.NAME, "Join.ArrayBuilder ");	  Node    emptyStringNode    =    Node.newString(   "Join.ArrayBuilder   ");    	compilable	  [FE]  AssertionFailedError  	105	3	replace
955	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME, "Join.ArrayBuilder ");  [FE]  AssertionFailedError  [FE]    junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME, "Join.ArrayBuilder ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(Token.NAME, "Join.ArrayBuilder ");	  Node    emptyStringNode    =    Node.newString(   "Join.ArrayBuilder   ");    	compilable	  [FE]  AssertionFailedError  	105	3	replace
956	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "Join.ArrayBuilder ").build();  [CE]  cannot  find  symbol  [FE]      junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "Join.ArrayBuilder ").build();  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "Join.ArrayBuilder ").build();	  Node    emptyStringNode    =    Node.newString(   "Join.ArrayBuilder   ");    	non-compiled	[CE]  cannot  find  symbol	105	None	replace
957	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(. "[ ");  [CE]  illegal  start  of  expression  [FE]              AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(. "[ ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(. "[ ");	  Node    emptyStringNode    =    Node.newString(       "[       ");    Node    emptyStringNode    =    Node.newString(.   "[       ");    	non-compiled	[CE]  illegal  start  of  expression	98	None	replace
958	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "-   "  +  functionName);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "-   "  +  functionName);	  Node    emptyStringNode    =    Node.newString(   "-   "    +    name);    	compilable	  [FE]  AssertionFailedError  	162	3	replace
959	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "-   "  +  functionName);  [FE]  AssertionFailedError  [FE]          AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "-   "  +  functionName);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "-   "  +  functionName);	  Node    emptyStringNode    =    Node.newString(   "-   "    +    name);    	compilable	  [FE]  AssertionFailedError  	162	3	replace
960	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "- "  +  sb.toString())+  1;  [CE]  bad  operand  types  for  binary  operator  [FE]    RuntimeException    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "- "  +  sb.toString())+  1;  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "- "  +  sb.toString())+  1;	  Node    emptyStringNode    =    Node.newString(   "-   "    +    sb.toString());    	non-compiled	[CE]  bad  operand  types  for  binary  operator  	47	None	replace
961	[BUG]  [BUGGY]  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('  [FE]      RuntimeException    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "- "  +  prev.toString());  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "- "  +  prev.toString());	  Node    emptyStringNode    =    Node.newString(   "-   "    +    sb.toString());    	compilable	  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('  	47	3	replace
962	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "- "  +  prev.toString());  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('  [FE]      RuntimeException    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "- "  +  prev.toString());  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "- "  +  prev.toString());	  Node    emptyStringNode    =    Node.newString(   "-   "    +    sb.toString());    	compilable	  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('  	47	3	replace
963	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "Arrays.asList( "  +  foldedSize  +  1));  [CE]  [FE]          junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "Arrays.asList( "  +  foldedSize  +  1));  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "Arrays.asList( "  +  foldedSize  +  1));	  Node    emptyStringNode    =    Node.newString(   "java.util.Arrays.asList(   "    +    originalSize    +   "));    	non-compiled	[CE]  	53	None	replace
964	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(. "Array ");  [CE]  illegal  start  of  expression  [FE]              AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(. "Array ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(. "Array ");	  Node    emptyStringNode    =    Node.newString(       "Array       ");    Node    emptyStringNode    =    Node.newString(.   "Array       ");    	non-compiled	[CE]  illegal  start  of  expression	33	None	replace
965	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList( ". "));  [CE]  unclosed  string  literal  [FE]            junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList( ". "));  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList( ". "));	  Node    emptyStringNode    =    Node.newString(       "java.util.Arrays.asList(       ");    Node    emptyStringNode    =    Node.newString(   ".java.util.Arrays.asList(       ");    	non-compiled	[CE]  unclosed  string  literal	78	None	replace
966	[BUG]  [BUGGY]  Node  emptyStringNode  =  arrayFoldedChildren.getFirstChild()  +  1;  [CE]  cannot  find  symbol  [FE]                          junit.framework.AssertionFailedError:  Expected:  x=[     "a     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  arrayFoldedChildren.getFirstChild()  +  1;  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  arrayFoldedChildren.getFirstChild()  +  1;	  Node    emptyStringNode    =    arrayFoldedChildren.getFirstChild();    	non-compiled	[CE]  cannot  find  symbol	147	None	replace
967	[BUG]  [BUGGY]  Node  emptyStringNode  =  this.arrayFoldedChildren.getFirstChild();  [CE]  cannot  find  symbol  arrayFoldedChildren  [FE]                            junit.framework.AssertionFailedError:  Expected:  x=[     "a     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  this.arrayFoldedChildren.getFirstChild();  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  this.arrayFoldedChildren.getFirstChild();	  Node    emptyStringNode    =    arrayFoldedChildren.getFirstChild();    	non-compiled	[CE]  cannot  find  symbol  arrayFoldedChildren	147	None	replace
968	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[AssertionFailedException] ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "[AssertionFailedException] ");	  Node    emptyStringNode    =    Node.newString(   "[AssertionFailedError]   ");    	compilable	  [FE]  AssertionFailedError  	69	3	replace
969	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "[AssertionFailedException] ");  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[AssertionFailedException] ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "[AssertionFailedException] ");	  Node    emptyStringNode    =    Node.newString(   "[AssertionFailedError]   ");    	compilable	  [FE]  AssertionFailedError  	69	3	replace
970	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "[AssertionFailedError] "  +  getName());  [CE]  cannot  find  symbol  [FE]      AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[AssertionFailedError] "  +  getName());  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "[AssertionFailedError] "  +  getName());	  Node    emptyStringNode    =    Node.newString(   "[AssertionFailedError]   ");    	non-compiled	[CE]  cannot  find  symbol	69	None	replace
971	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "[AssertionFailedError] "  +  name);  [CE]  cannot  find  symbol  name  [FE]        AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[AssertionFailedError] "  +  name);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "[AssertionFailedError] "  +  name);	  Node    emptyStringNode    =    Node.newString(   "[AssertionFailedError]   ");    	non-compiled	[CE]  cannot  find  symbol  name	69	None	replace
972	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(. "- ");  [CE]  illegal  start  of  expression  [FE]            AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(. "- ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(. "- ");	  Node    emptyStringNode    =    Node.newString(       "-       ");    Node    emptyStringNode    =    Node.newString(.   "-       ");    	non-compiled	[CE]  illegal  start  of  expression	113	None	replace
973	[BUG]  [BUGGY]  Node  emptyStringNode  =  n.getFirstChild();  java.lang.RuntimeException:  Node  emptyStringNode  =  n.getFirstChild();  [CE]  not  a  statement  [FE]    java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  The  new  child  node  has  siblings.  Node(CALL):  testcode:1:11  x  =  [].join('    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  n.getFirstChild();  java.lang.RuntimeException:  Node  emptyStringNode  =  n.getFirstChild();  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    n.getFirstChild();    java.lang.RuntimeException:  Node  emptyStringNode  =  n.getFirstChild();	  	non-compiled	[CE]  not  a  statement	7	None	add
974	[BUG]  [BUGGY]  Node  emptyStringNode  =  n.getFirstChild();  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  AssertionFailedError:  Node  emptyStringNode  =  n.getFirstChild();  [CE]  not  a  statement  [FE]      java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  The  new  child  node  has  siblings.  Node(CALL):  testcode:1:11  x  =  [].join('    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  n.getFirstChild();  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  AssertionFailedError:  Node  emptyStringNode  =  n.getFirstChild();  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    n.getFirstChild();    java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  AssertionFailedError:  Node  emptyStringNode  =  n.getFirstChild();	  	non-compiled	[CE]  not  a  statement	7	None	add
975	[BUG]  [BUGGY]  Node  emptyStringNode  =  n.getFirstChild();  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR:  Node  emptyStringNode  =  n.getFirstChild();  [CE]  not  a  statement  [FE]        java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  The  new  child  node  has  siblings.  Node(CALL):  testcode:1:11  x  =  [].join('    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  n.getFirstChild();  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR:  Node  emptyStringNode  =  n.getFirstChild();  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    n.getFirstChild();    java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR:  Node  emptyStringNode  =  n.getFirstChild();	  	non-compiled	[CE]  not  a  statement	7	None	add
976	[BUG]  [BUGGY]  Node  emptyStringNode  =  n.getFirstChild();  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  AssertionFailedError:  Expected:  x=[ "a   "  +  n.getFirstChild()  +  1);  [CE]  not  a  statement  [FE]          java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  The  new  child  node  has  siblings.  Node(CALL):  testcode:1:11  x  =  [].join('    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  n.getFirstChild();  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  AssertionFailedError:  Expected:  x=[ "a   "  +  n.getFirstChild()  +  1);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    n.getFirstChild();    java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  AssertionFailedError:  Expected:  x=[ "a   "  +  n.getFirstChild()  +  1);	  	non-compiled	[CE]  not  a  statement	7	None	add
977	[BUG]  [BUGGY]  Node  emptyStringNode  =  n.getFirstChild();  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  AssertionFailedError:  Expected:  x=[ "a   "  +  n.getFirstChild();  [CE]  not  a  statement  [FE]            java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  The  new  child  node  has  siblings.  Node(CALL):  testcode:1:11  x  =  [].join('    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  n.getFirstChild();  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  AssertionFailedError:  Expected:  x=[ "a   "  +  n.getFirstChild();  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    n.getFirstChild();    java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  AssertionFailedError:  Expected:  x=[ "a   "  +  n.getFirstChild();	  	non-compiled	[CE]  not  a  statement	7	None	add
978	[BUG]  [BUGGY]  Node  emptyStringNode  =  n.getFirstChild();  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  AssertionFailedError:  Expected:  x=[ "a   "  +  n.getFirstChild()  +  1];  [CE]  not  a  statement  [FE]              java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  The  new  child  node  has  siblings.  Node(CALL):  testcode:1:11  x  =  [].join('    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  n.getFirstChild();  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  AssertionFailedError:  Expected:  x=[ "a   "  +  n.getFirstChild()  +  1];  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    n.getFirstChild();    java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  AssertionFailedError:  Expected:  x=[ "a   "  +  n.getFirstChild()  +  1];	  	non-compiled	[CE]  not  a  statement	7	None	add
979	[BUG]  [BUGGY]  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME, "ArrayBuilders ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString(Token.NAME, "ArrayBuilders ");	  Node    emptyStringNode    =    Node.newString(   "java.util.ArrayBuilders   ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	170	3	replace
980	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME, "ArrayBuilders ");  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME, "ArrayBuilders ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(Token.NAME, "ArrayBuilders ");	  Node    emptyStringNode    =    Node.newString(   "java.util.ArrayBuilders   ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	170	3	replace
981	[BUG]  [BUGGY]  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]      AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "java.util.Arrays ");	  Node    emptyStringNode    =    Node.newString(   "java.util.ArrayBuilders   ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	170	3	replace
982	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays ");  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]      AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "java.util.Arrays ");	  Node    emptyStringNode    =    Node.newString(   "java.util.ArrayBuilders   ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	170	3	replace
983	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "array_name   ");  Node  emptyStringNode  =  Node.newString(? "array_name   ");  [CE]  illegal  start  of  expression  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "array_name   ");  Node  emptyStringNode  =  Node.newString(? "array_name   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "array_name   ");    Node  emptyStringNode  =  Node.newString(? "array_name   ");	  	non-compiled	[CE]  illegal  start  of  expression	72	None	add
984	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "Join.ArrayBuilder   ");  Node  emptyStringNode  =  Node.newString( "Join.ArrayBuilder "));  [CE]  [FE]    junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "Join.ArrayBuilder   ");  Node  emptyStringNode  =  Node.newString( "Join.ArrayBuilder "));  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "Join.ArrayBuilder   ");    Node  emptyStringNode  =  Node.newString( "Join.ArrayBuilder "));	  	non-compiled	[CE]  	104	None	add
985	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList( ".* "),  arrayFoldedChildren);  [CE]  <identifier>  expected  [FE]          junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList( ".* "),  arrayFoldedChildren);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList( ".* "),  arrayFoldedChildren);	  Node    emptyStringNode    =    Node.newString(   "java.util.Arrays.asList(   "),    arrayFoldedChildren);    	non-compiled	[CE]  <identifier>  expected	152	None	replace
986	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList( ", "),  arrayFoldedChildren);  [CE]  unclosed  string  literal  [FE]            junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList( ", "),  arrayFoldedChildren);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList( ", "),  arrayFoldedChildren);	  Node    emptyStringNode    =    Node.newString(   "java.util.Arrays.asList(   "),    arrayFoldedChildren);    	non-compiled	[CE]  unclosed  string  literal	152	None	replace
987	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList( ", ",  arrayFoldedChildren);  [CE]  unclosed  string  literal  [FE]              junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList( ", ",  arrayFoldedChildren);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList( ", ",  arrayFoldedChildren);	  Node    emptyStringNode    =    Node.newString(   "java.util.Arrays.asList(   "),    arrayFoldedChildren);    	non-compiled	[CE]  unclosed  string  literal	152	None	replace
988	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList( ",  arrayFoldedChildren));  [CE]  [FE]                junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList( ",  arrayFoldedChildren));  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList( ",  arrayFoldedChildren));	  Node    emptyStringNode    =    Node.newString(   "java.util.Arrays.asList(   "),    arrayFoldedChildren);    	non-compiled	[CE]  	152	None	replace
989	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME,  ROOT_LOCALE);  [CE]  no  suitable  method  found  for  newString(int,Locale)  [FE]    junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME,  ROOT_LOCALE);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(Token.NAME,  ROOT_LOCALE);	  Node    emptyStringNode    =    Node.newString(Token.NAME,   "ArrayBuilder   ");    	non-compiled	[CE]  no  suitable  method  found  for  newString(int,Locale)	168	None	replace
990	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME,  SHORT_STRING);  [CE]  cannot  find  symbol  SHORT_STRING  [FE]      junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME,  SHORT_STRING);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(Token.NAME,  SHORT_STRING);	  Node    emptyStringNode    =    Node.newString(Token.NAME,   "ArrayBuilder   ");    	non-compiled	[CE]  cannot  find  symbol  SHORT_STRING	168	None	replace
991	[BUG]  [BUGGY]  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]            junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ")java.util.Arrays.asList( ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( ")java.util.Arrays.asList( ");	  Node    emptyStringNode    =    Node.newString(       "java.util.Arrays.asList(       ");    Node    emptyStringNode    =    Node.newString(   ")java.util.Arrays.asList(       ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	173	3	replace
992	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( ")java.util.Arrays.asList( ");  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]            junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ")java.util.Arrays.asList( ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( ")java.util.Arrays.asList( ");	  Node    emptyStringNode    =    Node.newString(       "java.util.Arrays.asList(       ");    Node    emptyStringNode    =    Node.newString(   ")java.util.Arrays.asList(       ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	173	3	replace
993	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList( ") ");  [CE]  unclosed  string  literal  [FE]              junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList( ") ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList( ") ");	  Node    emptyStringNode    =    Node.newString(       "java.util.Arrays.asList(       ");    Node    emptyStringNode    =    Node.newString(   ")java.util.Arrays.asList(       ");    	non-compiled	[CE]  unclosed  string  literal	173	None	replace
994	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(?   "java.util.ArrayList "  : "java.util.ArrayList ");  [CE]  illegal  start  of  expression  [FE]                AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(?   "java.util.ArrayList "  : "java.util.ArrayList ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(?   "java.util.ArrayList "  : "java.util.ArrayList ");	  Node    emptyStringNode    =    Node.newString(       "java.util.ArrayList       ");    Node    emptyStringNode    =    Node.newString(?   "java.util.ArrayList       ");    	non-compiled	[CE]  illegal  start  of  expression	28	None	replace
995	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(?   "java.util.ArrayList "  :  null);  [CE]  illegal  start  of  expression  [FE]                  AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(?   "java.util.ArrayList "  :  null);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(?   "java.util.ArrayList "  :  null);	  Node    emptyStringNode    =    Node.newString(       "java.util.ArrayList       ");    Node    emptyStringNode    =    Node.newString(?   "java.util.ArrayList       ");    	non-compiled	[CE]  illegal  start  of  expression	28	None	replace
996	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(?   "java.util.ArrayList "  :  1);  [CE]  illegal  start  of  expression  [FE]                    AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(?   "java.util.ArrayList "  :  1);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(?   "java.util.ArrayList "  :  1);	  Node    emptyStringNode    =    Node.newString(       "java.util.ArrayList       ");    Node    emptyStringNode    =    Node.newString(?   "java.util.ArrayList       ");    	non-compiled	[CE]  illegal  start  of  expression	28	None	replace
997	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(?   "java.util.ArrayList "  :  Collections.EMPTY_LIST);  [CE]  illegal  start  of  expression  [FE]                      AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(?   "java.util.ArrayList "  :  Collections.EMPTY_LIST);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(?   "java.util.ArrayList "  :  Collections.EMPTY_LIST);	  Node    emptyStringNode    =    Node.newString(       "java.util.ArrayList       ");    Node    emptyStringNode    =    Node.newString(?   "java.util.ArrayList       ");    	non-compiled	[CE]  illegal  start  of  expression	28	None	replace
998	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "array-foo.   ");  Node  emptyStringNode  =  Node.newString( ")array-foo.   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "array-foo.   ");  Node  emptyStringNode  =  Node.newString( ")array-foo.   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "array-foo.   ");    Node  emptyStringNode  =  Node.newString( ")array-foo.   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	204	None	add
999	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList( "  +  arrayFoldedChildren.get(0)));  [CE]  [FE]        junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList( "  +  arrayFoldedChildren.get(0)));  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList( "  +  arrayFoldedChildren.get(0)));	  Node    emptyStringNode    =    Node.newString(   "java.util.Arrays.asList(   "    +    arrayFoldedChildren.size()));    	non-compiled	[CE]  	181	None	replace
1000	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList());  [CE]  unclosed  string  literal  [FE]          junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList());  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList());	  Node    emptyStringNode    =    Node.newString(       "java.util.Arrays.asList(       ");    Node    emptyStringNode    =    Node.newString(   "java.util.Arrays.asList(       "));    	non-compiled	[CE]  unclosed  string  literal	172	None	replace
1001	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]            AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ";java.util.ArrayList ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( ";java.util.ArrayList ");	  Node    emptyStringNode    =    Node.newString(       "java.util.ArrayList       ");    Node    emptyStringNode    =    Node.newString(   ",java.util.ArrayList       ");    	compilable	  [FE]  AssertionFailedError  	26	3	replace
1002	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( ";java.util.ArrayList ");  [FE]  AssertionFailedError  [FE]            AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ";java.util.ArrayList ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( ";java.util.ArrayList ");	  Node    emptyStringNode    =    Node.newString(       "java.util.ArrayList       ");    Node    emptyStringNode    =    Node.newString(   ",java.util.ArrayList       ");    	compilable	  [FE]  AssertionFailedError  	26	3	replace
1003	[BUG]  [BUGGY]  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]              AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ";ArrayList ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( ";ArrayList ");	  Node    emptyStringNode    =    Node.newString(       "java.util.ArrayList       ");    Node    emptyStringNode    =    Node.newString(   ",java.util.ArrayList       ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	26	3	replace
1004	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( ";ArrayList ");  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]              AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ";ArrayList ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( ";ArrayList ");	  Node    emptyStringNode    =    Node.newString(       "java.util.ArrayList       ");    Node    emptyStringNode    =    Node.newString(   ",java.util.ArrayList       ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	26	3	replace
1005	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.ArrayElements ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "java.util.ArrayElements ");	  Node    emptyStringNode    =    Node.newString(       "java.util.ArrayElement       ");    Node    emptyStringNode    =    Node.newString(   "java.util.ArrayElement       ");    	compilable	  [FE]  AssertionFailedError  	20	3	replace
1006	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.ArrayElements ");  [FE]  AssertionFailedError  [FE]        junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.ArrayElements ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "java.util.ArrayElements ");	  Node    emptyStringNode    =    Node.newString(       "java.util.ArrayElement       ");    Node    emptyStringNode    =    Node.newString(   "java.util.ArrayElement       ");    	compilable	  [FE]  AssertionFailedError  	20	3	replace
1007	[BUG]  [BUGGY]  Node  n  =  Node.newString( "java.util.ArrayElement ");  [CE]  variable  n  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]          junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  n  =  Node.newString( "java.util.ArrayElement ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  n  =  Node.newString( "java.util.ArrayElement ");	  Node    emptyStringNode    =    Node.newString(       "java.util.ArrayElement       ");    Node    emptyStringNode    =    Node.newString(   "java.util.ArrayElement       ");    	non-compiled	[CE]  variable  n  is  already  defined  in  method  tryFoldArrayJoin(Node)	20	None	replace
1008	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString('[');  [CE]  no  suitable  method  found  for  newString(char)  [FE]          AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString('[');  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString('[');	  Node    emptyStringNode    =    Node.newString(       "[       ");    Node    emptyStringNode    =    Node.newString('[');    	non-compiled	[CE]  no  suitable  method  found  for  newString(char)	140	None	replace
1009	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString('[')+  1;  [CE]  no  suitable  method  found  for  newString(char)  [FE]            AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString('[')+  1;  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString('[')+  1;	  Node    emptyStringNode    =    Node.newString(       "[       ");    Node    emptyStringNode    =    Node.newString('[');    	non-compiled	[CE]  no  suitable  method  found  for  newString(char)	140	None	replace
1010	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "string ").replaceChild(n,  prev,  null);  [CE]  method  replaceChild  in  class  Node  cannot  be  applied  to  given  types;  [FE]        AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "string ").replaceChild(n,  prev,  null);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "string ").replaceChild(n,  prev,  null);	  Node    emptyStringNode    =    Node.newString(   "string   ").replaceChild(n,    prev);    	non-compiled	[CE]  method  replaceChild  in  class  Node  cannot  be  applied  to  given  types;	141	None	replace
1011	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "string "),  prev.replaceChild(n,  prev);  [CE]  [FE]          AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "string "),  prev.replaceChild(n,  prev);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "string "),  prev.replaceChild(n,  prev);	  Node    emptyStringNode    =    Node.newString(   "string   ").replaceChild(n,    prev);    	non-compiled	[CE]  	141	None	replace
1012	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.STRING).replaceChild(n,  prev);  [CE]  no  suitable  method  found  for  newString(int)  [FE]          AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.STRING).replaceChild(n,  prev);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(Token.STRING).replaceChild(n,  prev);	  Node    emptyStringNode    =    Node.newString(   "-   ").replaceChild(n,    prev);    	non-compiled	[CE]  no  suitable  method  found  for  newString(int)	185	None	replace
1013	[BUG]  [BUGGY]  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]            junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "],java.util.ArrayElement ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "],java.util.ArrayElement ");	  Node    emptyStringNode    =    Node.newString(       "java.util.ArrayElement       ");    Node    emptyStringNode    =    Node.newString(   ",java.util.ArrayElement       ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	22	3	replace
1014	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "],java.util.ArrayElement ");  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]            junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "],java.util.ArrayElement ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "],java.util.ArrayElement ");	  Node    emptyStringNode    =    Node.newString(       "java.util.ArrayElement       ");    Node    emptyStringNode    =    Node.newString(   ",java.util.ArrayElement       ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	22	3	replace
1015	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.ArrayBuilder ", " ");  [CE]  no  suitable  method  found  for  newString(String,String)  [FE]              junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.ArrayBuilder ", " ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "java.util.ArrayBuilder ", " ");	  Node    emptyStringNode    =    Node.newString(       "java.util.ArrayBuilder       ");    Node    emptyStringNode    =    Node.newString(   "java.util.ArrayBuilder   ",);    	non-compiled	[CE]  no  suitable  method  found  for  newString(String,String)	124	None	replace
1016	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.ArrayBuilder ",);  [CE]  illegal  start  of  expression  [FE]                junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.ArrayBuilder ",);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "java.util.ArrayBuilder ",);	  Node    emptyStringNode    =    Node.newString(       "java.util.ArrayBuilder       ");    Node    emptyStringNode    =    Node.newString(   "java.util.ArrayBuilder   ",);    	non-compiled	[CE]  illegal  start  of  expression	124	None	replace
1017	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.ArrayBuilder ", "null ");  [CE]  no  suitable  method  found  for  newString(String,String)  [FE]                  junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.ArrayBuilder ", "null ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "java.util.ArrayBuilder ", "null ");	  Node    emptyStringNode    =    Node.newString(       "java.util.ArrayBuilder       ");    Node    emptyStringNode    =    Node.newString(   "java.util.ArrayBuilder   ",);    	non-compiled	[CE]  no  suitable  method  found  for  newString(String,String)	124	None	replace
1018	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString('-',  n);  [CE]  no  suitable  method  found  for  newString(char,Node)  [FE]                  AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString('-',  n);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString('-',  n);	  Node    emptyStringNode    =    Node.newString(       "-       ");    Node    emptyStringNode    =    Node.newString('-');    	non-compiled	[CE]  no  suitable  method  found  for  newString(char,Node)	116	None	replace
1019	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "java.util.ArrayList:   ");  Node  emptyStringNode  =  Node.newString(java.util.ArrayList:   ");  [CE]  [FE]    junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "java.util.ArrayList:   ");  Node  emptyStringNode  =  Node.newString(java.util.ArrayList:   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "java.util.ArrayList:   ");    Node  emptyStringNode  =  Node.newString(java.util.ArrayList:   ");	  	non-compiled	[CE]  	158	None	add
1020	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "java.util.ArrayList:   ");  Node  emptyStringNode  =  Node.newString(... "java.util.ArrayList:   ");  [CE]  illegal  start  of  expression  [FE]      junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "java.util.ArrayList:   ");  Node  emptyStringNode  =  Node.newString(... "java.util.ArrayList:   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "java.util.ArrayList:   ");    Node  emptyStringNode  =  Node.newString(... "java.util.ArrayList:   ");	  	non-compiled	[CE]  illegal  start  of  expression	158	None	add
1021	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "java.util.ArrayList:   ");  Node  emptyStringNode  =  Node.newString(? "java.util.ArrayList:   ");  [CE]  illegal  start  of  expression  [FE]        junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "java.util.ArrayList:   ");  Node  emptyStringNode  =  Node.newString(? "java.util.ArrayList:   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "java.util.ArrayList:   ");    Node  emptyStringNode  =  Node.newString(? "java.util.ArrayList:   ");	  	non-compiled	[CE]  illegal  start  of  expression	158	None	add
1022	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "ArrayBuilder ").reset();  [CE]  cannot  find  symbol  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "ArrayBuilder ").reset();  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "ArrayBuilder ").reset();	  Node    emptyStringNode    =    Node.newString(   "ArrayBuilder   ");    	non-compiled	[CE]  cannot  find  symbol	101	None	replace
1023	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "-   "  +  sb.toString());  Node  emptyStringNode  =  Node.newString( ")-   "  +  sb.toString());  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]    RuntimeException    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "-   "  +  sb.toString());  Node  emptyStringNode  =  Node.newString( ")-   "  +  sb.toString());  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "-   "    +    sb.toString());    Node  emptyStringNode  =  Node.newString( ")-   "  +  sb.toString());	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	46	None	add
1024	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "-   "  +  sb.toString());  Node  emptyStringNode  =  Node.newString(  -   "  +  sb.toString());  [CE]  unclosed  string  literal  [FE]      RuntimeException    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "-   "  +  sb.toString());  Node  emptyStringNode  =  Node.newString(  -   "  +  sb.toString());  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "-   "    +    sb.toString());    Node  emptyStringNode  =  Node.newString(  -   "  +  sb.toString());	  	non-compiled	[CE]  unclosed  string  literal	46	None	add
1025	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(arrayFoldedren.toString());  [CE]  cannot  find  symbol  arrayFoldedren  [FE]    java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(arrayFoldedren.toString());  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(arrayFoldedren.toString());	  Node    emptyStringNode    =    Node.newString(sb.toString());    	non-compiled	[CE]  cannot  find  symbol  arrayFoldedren	190	None	replace
1026	[BUG]  [BUGGY]  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('  [FE]      java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(prev.toString());  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString(prev.toString());	  Node    emptyStringNode    =    Node.newString(sb.toString());    	compilable	  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('  	190	3	replace
1027	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(prev.toString());  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('  [FE]      java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(prev.toString());  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(prev.toString());	  Node    emptyStringNode    =    Node.newString(sb.toString());    	compilable	  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('  	190	3	replace
1028	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(arrayFoldedParent.toString());  [CE]  cannot  find  symbol  arrayFoldedParent  [FE]        java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(arrayFoldedParent.toString());  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(arrayFoldedParent.toString());	  Node    emptyStringNode    =    Node.newString(sb.toString());    	non-compiled	[CE]  cannot  find  symbol  arrayFoldedParent	190	None	replace
1029	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "string   "  +  sb.toString());  Node  emptyStringNode  =  Node.newString( ")string   "  +  sb.toString());  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]    java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "string   "  +  sb.toString());  Node  emptyStringNode  =  Node.newString( ")string   "  +  sb.toString());  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "string   "    +    sb.toString());    Node  emptyStringNode  =  Node.newString( ")string   "  +  sb.toString());	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	108	None	add
1030	[BUG]  [BUGGY]  [FE]  junit.framework.AssertionFailedError:  Expected:  x= " "  Result:  x= "]  [FE]              junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "],Arrays.asList( ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "],Arrays.asList( ");	  Node    emptyStringNode    =    Node.newString(       "java.util.Arrays.asList(       ");    Node    emptyStringNode    =    Node.newString(   ",java.util.Arrays.asList(       ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x= " "  Result:  x= "]  	79	3	replace
1031	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "],Arrays.asList( ");  [FE]  junit.framework.AssertionFailedError:  Expected:  x= " "  Result:  x= "]  [FE]              junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "],Arrays.asList( ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "],Arrays.asList( ");	  Node    emptyStringNode    =    Node.newString(       "java.util.Arrays.asList(       ");    Node    emptyStringNode    =    Node.newString(   ",java.util.Arrays.asList(       ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x= " "  Result:  x= "]  	79	3	replace
1032	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( ",java.util.Arrays.asList( "),java.util.Arrays.asList( "));  [CE]  [FE]                junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ",java.util.Arrays.asList( "),java.util.Arrays.asList( "));  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( ",java.util.Arrays.asList( "),java.util.Arrays.asList( "));	  Node    emptyStringNode    =    Node.newString(       "java.util.Arrays.asList(       ");    Node    emptyStringNode    =    Node.newString(   ",java.util.Arrays.asList(       ");    	non-compiled	[CE]  	79	None	replace
1033	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(sb.toString());  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node  emptyStringNode  =  Node.newString(sb.toString());  [CE]  not  a  statement  [FE]    java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(sb.toString());  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node  emptyStringNode  =  Node.newString(sb.toString());  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(sb.toString());    java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node  emptyStringNode  =  Node.newString(sb.toString());	  	non-compiled	[CE]  not  a  statement	189	None	add
1034	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(sb.toString());  java.lang.RuntimeException:  Node  emptyStringNode  =  Node.newString(sb.toString());  [CE]  not  a  statement  [FE]      java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(sb.toString());  java.lang.RuntimeException:  Node  emptyStringNode  =  Node.newString(sb.toString());  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(sb.toString());    java.lang.RuntimeException:  Node  emptyStringNode  =  Node.newString(sb.toString());	  	non-compiled	[CE]  not  a  statement	189	None	add
1035	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(sb.toString());  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem:  null  Node  emptyStringNode  =  Node.newString(sb.toString());  [CE]  not  a  statement  [FE]        java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(sb.toString());  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem:  null  Node  emptyStringNode  =  Node.newString(sb.toString());  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(sb.toString());    java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem:  null  Node  emptyStringNode  =  Node.newString(sb.toString());	  	non-compiled	[CE]  not  a  statement	189	None	add
1036	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "- ").replaceChild(n,  arrayFoldedChildren);  [CE]  method  replaceChild  in  class  Node  cannot  be  applied  to  given  types;  [FE]              AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "- ").replaceChild(n,  arrayFoldedChildren);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "- ").replaceChild(n,  arrayFoldedChildren);	  Node    emptyStringNode    =    Node.newString(   "-   ").replaceChild(n,    foldedSize);    	non-compiled	[CE]  method  replaceChild  in  class  Node  cannot  be  applied  to  given  types;	50	None	replace
1037	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "]. ",  null);  [CE]  no  suitable  method  found  for  newString(String,<null>)  [FE]            AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "]. ",  null);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "]. ",  null);	  Node    emptyStringNode    =    Node.newString(       "]       ");    Node    emptyStringNode    =    Node.newString(       "].   ");    	non-compiled	[CE]  no  suitable  method  found  for  newString(String,<null>)	93	None	replace
1038	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.EMPTY,  prev);  [CE]  no  suitable  method  found  for  newString(int,Node)  [FE]          junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.EMPTY,  prev);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(Token.EMPTY,  prev);	  Node    emptyStringNode    =    Node.newString(Token.EMPTY);    	non-compiled	[CE]  no  suitable  method  found  for  newString(int,Node)	137	None	replace
1039	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.ASSIGN);  [CE]  no  suitable  method  found  for  newString(int)  [FE]    junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.ASSIGN);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(Token.ASSIGN);	  Node    emptyStringNode    =    Node.newString(   "org.join.ArrayBuilder   ");    	non-compiled	[CE]  no  suitable  method  found  for  newString(int)	208	None	replace
1040	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList(prev);  [CE]  unclosed  string  literal  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList(prev);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList(prev);	  Node    emptyStringNode    =    Node.newString(   "java.util.Arrays.asList(n   ");    	non-compiled	[CE]  unclosed  string  literal	151	None	replace
1041	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList(prev,  n);  [CE]  unclosed  string  literal  [FE]      AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList(prev,  n);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList(prev,  n);	  Node    emptyStringNode    =    Node.newString(   "java.util.Arrays.asList(n   ");    	non-compiled	[CE]  unclosed  string  literal	151	None	replace
1042	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList(prev "));  [CE]  [FE]        AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList(prev "));  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList(prev "));	  Node    emptyStringNode    =    Node.newString(   "java.util.Arrays.asList(n   ");    	non-compiled	[CE]  	151	None	replace
1043	[BUG]  [BUGGY]  [FE]  junit.framework.AssertionFailedError:  Expected:  var  x= " "  Result:  var  x= "java.util.Arrays.asList(prev  [FE]          AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList(prev,  n   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList(prev,  n   ");	  Node    emptyStringNode    =    Node.newString(   "java.util.Arrays.asList(n   ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  var  x= " "  Result:  var  x= "java.util.Arrays.asList(prev  	151	3	replace
1044	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList(prev,  n   ");  [FE]  junit.framework.AssertionFailedError:  Expected:  var  x= " "  Result:  var  x= "java.util.Arrays.asList(prev  [FE]          AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList(prev,  n   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList(prev,  n   ");	  Node    emptyStringNode    =    Node.newString(   "java.util.Arrays.asList(n   ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  var  x= " "  Result:  var  x= "java.util.Arrays.asList(prev  	151	3	replace
1045	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.STRING).toString();  [CE]  no  suitable  method  found  for  newString(int)  [FE]            AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.STRING).toString();  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(Token.STRING).toString();	  Node    emptyStringNode    =    Node.newString(   "]   ").toString();    	non-compiled	[CE]  no  suitable  method  found  for  newString(int)	60	None	replace
1046	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "] "),  arrayFoldedChildren.toString();  [CE]  [FE]              AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "] "),  arrayFoldedChildren.toString();  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "] "),  arrayFoldedChildren.toString();	  Node    emptyStringNode    =    Node.newString(   "]   ").toString();    	non-compiled	[CE]  	60	None	replace
1047	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "-   "  +  Token.NAME);  Node  emptyStringNode  =  Node.newString( ")-   "  +  Token.NAME);  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "-   "  +  Token.NAME);  Node  emptyStringNode  =  Node.newString( ")-   "  +  Token.NAME);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "-   "    +    Token.NAME);    Node  emptyStringNode  =  Node.newString( ")-   "  +  Token.NAME);	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	163	None	add
1048	[BUG]  [BUGGY]  Node  emptyStringNode  =  arrayFoldedChildren.get(preferredSize);  [CE]  cannot  find  symbol  preferredSize  [FE]    java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  Index:  12    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  arrayFoldedChildren.get(preferredSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  arrayFoldedChildren.get(preferredSize);	  Node    emptyStringNode    =    arrayFoldedChildren.get(originalSize);    	non-compiled	[CE]  cannot  find  symbol  preferredSize	10	None	replace
1049	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "node "));  [CE]  [FE]            AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "node "));  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "node "));	  Node    emptyStringNode    =    Node.newString(       "n       ");    Node    emptyStringNode    =    Node.newString(   "n   "));    	non-compiled	[CE]  	18	None	replace
1050	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "] ",  n,  left);  [CE]  cannot  find  symbol  left  [FE]          AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "] ",  n,  left);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "] ",  n,  left);	  Node    emptyStringNode    =    Node.newString(   "]   ",    n);    	non-compiled	[CE]  cannot  find  symbol  left	59	None	replace
1051	[BUG]  [BUGGY]  Node  emptyStringNode  =  arrayFoldedChildren.get(arraySize);  [CE]  cannot  find  symbol  arraySize  [FE]    java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  Index:  0    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  arrayFoldedChildren.get(arraySize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  arrayFoldedChildren.get(arraySize);	  Node    emptyStringNode    =    arrayFoldedChildren.remove(0);    	non-compiled	[CE]  cannot  find  symbol  arraySize	6	None	replace
1052	[BUG]  [BUGGY]  Node  emptyStringNode  =  arrayFoldedChildren.get(0);  Node  emptyStringNode  =  arrayFoldedChildren.get(-1);  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]    java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  Index:  0    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  arrayFoldedChildren.get(0);  Node  emptyStringNode  =  arrayFoldedChildren.get(-1);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    arrayFoldedChildren.get(0);    Node  emptyStringNode  =  arrayFoldedChildren.get(-1);	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	1	None	add
1053	[BUG]  [BUGGY]  n.removeChild(arrayFoldedChildren,  emptyStringNode);  [CE]  cannot  find  symbol  emptyStringNode  [FE]                          junit.framework.AssertionFailedError:  Expected:  x=[     "a     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  n.removeChild(arrayFoldedChildren,  emptyStringNode);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	n.removeChild(arrayFoldedChildren,  emptyStringNode);	  n.removeChild(arrayFoldedChildren);    	non-compiled	[CE]  cannot  find  symbol  emptyStringNode	186	None	replace
1054	[BUG]  [BUGGY]  n.removeChild(arrayFoldedChildren,  oldStringNode);  [CE]  cannot  find  symbol  oldStringNode  [FE]                            junit.framework.AssertionFailedError:  Expected:  x=[     "a     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  n.removeChild(arrayFoldedChildren,  oldStringNode);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	n.removeChild(arrayFoldedChildren,  oldStringNode);	  n.removeChild(arrayFoldedChildren);    	non-compiled	[CE]  cannot  find  symbol  oldStringNode	186	None	replace
1055	[BUG]  [BUGGY]  n.removeChild(arrayFoldedChildren.size());  [CE]  method  removeChild  in  class  Node  cannot  be  applied  to  given  types;  [FE]                              junit.framework.AssertionFailedError:  Expected:  x=[     "a     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  n.removeChild(arrayFoldedChildren.size());  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	n.removeChild(arrayFoldedChildren.size());	  n.removeChild(arrayFoldedChildren);    	non-compiled	[CE]  method  removeChild  in  class  Node  cannot  be  applied  to  given  types;	186	None	replace
1056	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "cloneTarget() ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "cloneTarget() ");	  Node    emptyStringNode    =    Node.newString(   "node()   ");    	compilable	  [FE]  AssertionFailedError  	201	3	replace
1057	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "cloneTarget() ");  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "cloneTarget() ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "cloneTarget() ");	  Node    emptyStringNode    =    Node.newString(   "node()   ");    	compilable	  [FE]  AssertionFailedError  	201	3	replace
1058	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "replaceChild( ", ");  [CE]  unclosed  string  literal  [FE]      AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "replaceChild( ", ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "replaceChild( ", ");	  Node    emptyStringNode    =    Node.newString(   "node()   ");    	non-compiled	[CE]  unclosed  string  literal	201	None	replace
1059	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "org.join.ArrayElements ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "org.join.ArrayElements ");	  Node    emptyStringNode    =    Node.newString(   "org.join.ArrayElement   ");    	compilable	  [FE]  AssertionFailedError  	195	3	replace
1060	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "org.join.ArrayElements ");  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "org.join.ArrayElements ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "org.join.ArrayElements ");	  Node    emptyStringNode    =    Node.newString(   "org.join.ArrayElement   ");    	compilable	  [FE]  AssertionFailedError  	195	3	replace
1061	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "array-name   ");  Node  emptyStringNode  =  Node.newString( ")array-name   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "array-name   ");  Node  emptyStringNode  =  Node.newString( ")array-name   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "array-name   ");    Node  emptyStringNode  =  Node.newString( ")array-name   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	74	None	add
1062	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(. "ArrayList ");  [CE]  illegal  start  of  expression  [FE]                  AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(. "ArrayList ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(. "ArrayList ");	  Node    emptyStringNode    =    Node.newString(       "java.util.ArrayList       ");    Node    emptyStringNode    =    Node.newString(.   "java.util.ArrayList       ");    	non-compiled	[CE]  illegal  start  of  expression	29	None	replace
1063	[BUG]  [BUGGY]  Node  emptyStringNode  =  arrayFoldedChildren.get(prev  +  1);  [CE]  bad  operand  types  for  binary  operator  '+'  [FE]                              junit.framework.AssertionFailedError:  Expected:  x=[     "a     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  arrayFoldedChildren.get(prev  +  1);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  arrayFoldedChildren.get(prev  +  1);	  Node    emptyStringNode    =    arrayFoldedChildren.get(prev);    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '+'	4	None	replace
1064	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "JoinOverhead   ");  Node  emptyStringNode  =  Node.newString( ")JoinOverhead   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "JoinOverhead   ");  Node  emptyStringNode  =  Node.newString( ")JoinOverhead   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "JoinOverhead   ");    Node  emptyStringNode  =  Node.newString( ")JoinOverhead   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	145	None	add
1065	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Arrays.asList(emptyString));  [CE]  cannot  find  symbol  emptyString  [FE]        AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Arrays.asList(emptyString));  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(Arrays.asList(emptyString));	  Node    emptyStringNode    =    Node.newString(       "java.util.ArrayList       ");    Node    emptyStringNode    =    Node.newString(java.util.ArrayList       ");    	non-compiled	[CE]  cannot  find  symbol  emptyString	174	None	replace
1066	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Arrays.asList(oldStringNode));  [CE]  cannot  find  symbol  oldStringNode  [FE]          AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Arrays.asList(oldStringNode));  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(Arrays.asList(oldStringNode));	  Node    emptyStringNode    =    Node.newString(       "java.util.ArrayList       ");    Node    emptyStringNode    =    Node.newString(java.util.ArrayList       ");    	non-compiled	[CE]  cannot  find  symbol  oldStringNode	174	None	replace
1067	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Arrays.asList(false));  [CE]  cannot  find  symbol  Arrays  [FE]            AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Arrays.asList(false));  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(Arrays.asList(false));	  Node    emptyStringNode    =    Node.newString(       "java.util.ArrayList       ");    Node    emptyStringNode    =    Node.newString(java.util.ArrayList       ");    	non-compiled	[CE]  cannot  find  symbol  Arrays	174	None	replace
1068	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(...   ");  [CE]  illegal  start  of  expression  [FE]        junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(...   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(...   ");	  Node    emptyStringNode    =    Node.newString(       "java.util.Arrays.asList(       ");    Node    emptyStringNode    =    Node.newString(...   "java.util.Arrays.asList(       ");    	non-compiled	[CE]  illegal  start  of  expression	171	None	replace
1069	[BUG]  [BUGGY]  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]    junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME, "JoinArrayBuilder ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString(Token.NAME, "JoinArrayBuilder ");	  Node    emptyStringNode    =    Node.newString(   "JoinArrayBuilder   ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	103	3	replace
1070	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME, "JoinArrayBuilder ");  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]    junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME, "JoinArrayBuilder ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(Token.NAME, "JoinArrayBuilder ");	  Node    emptyStringNode    =    Node.newString(   "JoinArrayBuilder   ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	103	3	replace
1071	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.EXPR_RESULT,  leftStringNode);  [CE]  cannot  find  symbol  leftStringNode  [FE]              junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.EXPR_RESULT,  leftStringNode);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(Token.EXPR_RESULT,  leftStringNode);	  Node    emptyStringNode    =    Node.newString(Token.EXPR_RESULT);    	non-compiled	[CE]  cannot  find  symbol  leftStringNode	41	None	replace
1072	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.EXPR_RESULT,  prev);  [CE]  no  suitable  method  found  for  newString(int,Node)  [FE]                junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.EXPR_RESULT,  prev);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(Token.EXPR_RESULT,  prev);	  Node    emptyStringNode    =    Node.newString(Token.EXPR_RESULT);    	non-compiled	[CE]  no  suitable  method  found  for  newString(int,Node)	41	None	replace
1073	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.EXPR_RESULT,  functionName);  [CE]  no  suitable  method  found  for  newString(int,Node)  [FE]                  junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.EXPR_RESULT,  functionName);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(Token.EXPR_RESULT,  functionName);	  Node    emptyStringNode    =    Node.newString(Token.EXPR_RESULT);    	non-compiled	[CE]  no  suitable  method  found  for  newString(int,Node)	41	None	replace
1074	[BUG]  [BUGGY]  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "Array "  +  arrayFoldedChildren.size());  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "Array "  +  arrayFoldedChildren.size());	  Node    emptyStringNode    =    Node.newString(   "Array   "    +    originalSize);    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	118	3	replace
1075	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "Array "  +  arrayFoldedChildren.size());  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "Array "  +  arrayFoldedChildren.size());  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "Array "  +  arrayFoldedChildren.size());	  Node    emptyStringNode    =    Node.newString(   "Array   "    +    originalSize);    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	118	3	replace
1076	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "Array "  +  originalSize  -  1);  [CE]  bad  operand  types  for  binary  operator  [FE]      AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "Array "  +  originalSize  -  1);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "Array "  +  originalSize  -  1);	  Node    emptyStringNode    =    Node.newString(   "Array   "    +    originalSize);    	non-compiled	[CE]  bad  operand  types  for  binary  operator  	118	None	replace
1077	[BUG]  [BUGGY]  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('  [FE]        AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "Array "  +  sb.toString());  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "Array "  +  sb.toString());	  Node    emptyStringNode    =    Node.newString(   "Array   "    +    originalSize);    	compilable	  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('  	118	3	replace
1078	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "Array "  +  sb.toString());  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('  [FE]        AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "Array "  +  sb.toString());  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "Array "  +  sb.toString());	  Node    emptyStringNode    =    Node.newString(   "Array   "    +    originalSize);    	compilable	  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('  	118	3	replace
1079	[BUG]  [BUGGY]  int  kJoinOverhead  =  InlineCostEstimator.getCost(n,  prev);  [CE]  no  suitable  method  found  for  getCost(Node,Node)  [FE]                            junit.framework.AssertionFailedError:  Expected:  x=[     "a     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  int  kJoinOverhead  =  InlineCostEstimator.getCost(n,  prev);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	int  kJoinOverhead  =  InlineCostEstimator.getCost(n,  prev);	  int    kJoinOverhead    =    InlineCostEstimator.getCost(n);    	non-compiled	[CE]  no  suitable  method  found  for  getCost(Node,Node)	148	None	replace
1080	[BUG]  [BUGGY]  int  kJoinOverhead  =  InlineCostEstimator.getCost(n  +  1);  [CE]  bad  operand  types  for  binary  operator  [FE]                              junit.framework.AssertionFailedError:  Expected:  x=[     "a     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  int  kJoinOverhead  =  InlineCostEstimator.getCost(n  +  1);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	int  kJoinOverhead  =  InlineCostEstimator.getCost(n  +  1);	  int    kJoinOverhead    =    InlineCostEstimator.getCost(n);    	non-compiled	[CE]  bad  operand  types  for  binary  operator  	148	None	replace
1081	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "JoinArrayBuilder   ");  Node  emptyStringNode  =  Node.newString( "JoinArrayBuilder "));  [CE]  [FE]    junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "JoinArrayBuilder   ");  Node  emptyStringNode  =  Node.newString( "JoinArrayBuilder "));  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "JoinArrayBuilder   ");    Node  emptyStringNode  =  Node.newString( "JoinArrayBuilder "));	  	non-compiled	[CE]  	102	None	add
1082	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "JoinArrayBuilder   ");  Node  emptyStringNode  =  Node.newString( ",JoinArrayBuilder   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]      junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "JoinArrayBuilder   ");  Node  emptyStringNode  =  Node.newString( ",JoinArrayBuilder   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "JoinArrayBuilder   ");    Node  emptyStringNode  =  Node.newString( ",JoinArrayBuilder   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	102	None	add
1083	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(ArrayElement.UNKNOWN);  [CE]  cannot  find  symbol  ArrayElement  [FE]        junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(ArrayElement.UNKNOWN);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(ArrayElement.UNKNOWN);	  Node    emptyStringNode    =    Node.newString(       "java.util.ArrayElement       ");    Node    emptyStringNode    =    Node.newString(java.util.ArrayElement       ");    	non-compiled	[CE]  cannot  find  symbol  ArrayElement	160	None	replace
1084	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(ArrayElement.BLOCK);  [CE]  cannot  find  symbol  ArrayElement  [FE]          junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(ArrayElement.BLOCK);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(ArrayElement.BLOCK);	  Node    emptyStringNode    =    Node.newString(       "java.util.ArrayElement       ");    Node    emptyStringNode    =    Node.newString(java.util.ArrayElement       ");    	non-compiled	[CE]  cannot  find  symbol  ArrayElement	160	None	replace
1085	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(ArrayElement.EMPTY);  [CE]  cannot  find  symbol  ArrayElement  [FE]            junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(ArrayElement.EMPTY);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(ArrayElement.EMPTY);	  Node    emptyStringNode    =    Node.newString(       "java.util.ArrayElement       ");    Node    emptyStringNode    =    Node.newString(java.util.ArrayElement       ");    	non-compiled	[CE]  cannot  find  symbol  ArrayElement	160	None	replace
1086	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(ArrayElement.VOID);  [CE]  cannot  find  symbol  ArrayElement  [FE]              junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(ArrayElement.VOID);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(ArrayElement.VOID);	  Node    emptyStringNode    =    Node.newString(       "java.util.ArrayElement       ");    Node    emptyStringNode    =    Node.newString(java.util.ArrayElement       ");    	non-compiled	[CE]  cannot  find  symbol  ArrayElement	160	None	replace
1087	[BUG]  [BUGGY]  n.getParent().removeChild(arrayFoldedChildren.size()  -  1);  [CE]  method  removeChild  in  class  Node  cannot  be  applied  to  given  types;  [FE]                                      junit.framework.AssertionFailedError:  Expected:  x=[     "a     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  n.getParent().removeChild(arrayFoldedChildren.size()  -  1);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	n.getParent().removeChild(arrayFoldedChildren.size()  -  1);	  n.getParent().removeChild(prev);    	non-compiled	[CE]  method  removeChild  in  class  Node  cannot  be  applied  to  given  types;	11	None	replace
1088	[BUG]  [BUGGY]  n.getParent().removeChild(leftStringNode);  [CE]  cannot  find  symbol  leftStringNode  [FE]                                        junit.framework.AssertionFailedError:  Expected:  x=[     "a     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  n.getParent().removeChild(leftStringNode);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	n.getParent().removeChild(leftStringNode);	  n.getParent().removeChild(prev);    	non-compiled	[CE]  cannot  find  symbol  leftStringNode	11	None	replace
1089	[BUG]  [BUGGY]  n.getParent().removeChild(rootNode);  [CE]  cannot  find  symbol  rootNode  [FE]                                          junit.framework.AssertionFailedError:  Expected:  x=[     "a     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  n.getParent().removeChild(rootNode);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	n.getParent().removeChild(rootNode);	  n.getParent().removeChild(prev);    	non-compiled	[CE]  cannot  find  symbol  rootNode	11	None	replace
1090	[BUG]  [BUGGY]  n.getParent().removeChild(callTarget);  [CE]  cannot  find  symbol  emptyStringNode  [FE]                                            junit.framework.AssertionFailedError:  Expected:  x=[     "a     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  n.getParent().removeChild(callTarget);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	n.getParent().removeChild(callTarget);	  n.getParent().removeChild(prev);    	non-compiled	[CE]  cannot  find  symbol  emptyStringNode	11	None	replace
1091	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "org.join.ArrayElement   ");  Node  emptyStringNode  =  Node.newString(  org.join.ArrayElement   ");  [CE]  unclosed  string  literal  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "org.join.ArrayElement   ");  Node  emptyStringNode  =  Node.newString(  org.join.ArrayElement   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "org.join.ArrayElement   ");    Node  emptyStringNode  =  Node.newString(  org.join.ArrayElement   ");	  	non-compiled	[CE]  unclosed  string  literal	194	None	add
1092	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.ArrayElement ",);  [CE]  illegal  start  of  expression  [FE]              junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.ArrayElement ",);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "java.util.ArrayElement ",);	  Node    emptyStringNode    =    Node.newString(       "java.util.ArrayElement       ");    Node    emptyStringNode    =    Node.newString(   "java.util.ArrayElement   ",);    	non-compiled	[CE]  illegal  start  of  expression	23	None	replace
1093	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.ArrayElement ", ");  [CE]  unclosed  string  literal  [FE]                junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.ArrayElement ", ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "java.util.ArrayElement ", ");	  Node    emptyStringNode    =    Node.newString(       "java.util.ArrayElement       ");    Node    emptyStringNode    =    Node.newString(   "java.util.ArrayElement   ",);    	non-compiled	[CE]  unclosed  string  literal	23	None	replace
1094	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.ArrayElement ", "));  [CE]  unclosed  string  literal  [FE]                  junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.ArrayElement ", "));  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "java.util.ArrayElement ", "));	  Node    emptyStringNode    =    Node.newString(       "java.util.ArrayElement       ");    Node    emptyStringNode    =    Node.newString(   "java.util.ArrayElement   ",);    	non-compiled	[CE]  unclosed  string  literal	23	None	replace
1095	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME,  prev,  originalSize);  [CE]  no  suitable  method  found  for  newString(int,Node,int)  [FE]              AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME,  prev,  originalSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(Token.NAME,  prev,  originalSize);	  Node    emptyStringNode    =    Node.newString(Token.NAME,    originalSize);    	non-compiled	[CE]  no  suitable  method  found  for  newString(int,Node,int)	61	None	replace
1096	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.ArrayList   ",  foldedSize  +  1);  [CE]  no  suitable  method  found  for  newString(String,int)  [FE]            AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.ArrayList   ",  foldedSize  +  1);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "java.util.ArrayList   ",  foldedSize  +  1);	  Node    emptyStringNode    =    Node.newString(   "java.util.ArrayList   ",    foldedSize);    	non-compiled	[CE]  no  suitable  method  found  for  newString(String,int)	128	None	replace
1097	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.ArrayList   ",  arrayFoldedChildren.size()  -  1);  [CE]  no  suitable  method  found  for  newString(String,int)  [FE]              AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.ArrayList   ",  arrayFoldedChildren.size()  -  1);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "java.util.ArrayList   ",  arrayFoldedChildren.size()  -  1);	  Node    emptyStringNode    =    Node.newString(   "java.util.ArrayList   ",    foldedSize);    	non-compiled	[CE]  no  suitable  method  found  for  newString(String,int)	128	None	replace
1098	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.ArrayList   ",  arrayFoldedChildren.size());  [CE]  no  suitable  method  found  for  newString(String,int)  [FE]                AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.ArrayList   ",  arrayFoldedChildren.size());  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "java.util.ArrayList   ",  arrayFoldedChildren.size());	  Node    emptyStringNode    =    Node.newString(   "java.util.ArrayList   ",    foldedSize);    	non-compiled	[CE]  no  suitable  method  found  for  newString(String,int)	128	None	replace
1099	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "string "  +  n.toString());  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "string "  +  n.toString());	  Node    emptyStringNode    =    Node.newString(   "string   "    +    sb.toString());    	compilable	  [FE]  AssertionFailedError  	109	3	replace
1100	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "string "  +  n.toString());  [FE]  AssertionFailedError  [FE]    java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "string "  +  n.toString());  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "string "  +  n.toString());	  Node    emptyStringNode    =    Node.newString(   "string   "    +    sb.toString());    	compilable	  [FE]  AssertionFailedError  	109	3	replace
1101	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "string "  +  sb.removeFirstChild());  [CE]  cannot  find  symbol  [FE]      java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "string "  +  sb.removeFirstChild());  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "string "  +  sb.removeFirstChild());	  Node    emptyStringNode    =    Node.newString(   "string   "    +    sb.toString());    	non-compiled	[CE]  cannot  find  symbol	109	None	replace
1102	[BUG]  [BUGGY]  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('  [FE]        java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "string "  +  prev.toString());  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "string "  +  prev.toString());	  Node    emptyStringNode    =    Node.newString(   "string   "    +    sb.toString());    	compilable	  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('  	109	3	replace
1103	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "string "  +  prev.toString());  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('  [FE]        java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "string "  +  prev.toString());  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "string "  +  prev.toString());	  Node    emptyStringNode    =    Node.newString(   "string   "    +    sb.toString());    	compilable	  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('  	109	3	replace
1104	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "ArrayList   ");  Node  emptyStringNode  =  Node.newString( ")ArrayList   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "ArrayList   ");  Node  emptyStringNode  =  Node.newString( ")ArrayList   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "ArrayList   ");    Node  emptyStringNode  =  Node.newString( ")ArrayList   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	125	None	add
1105	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(2);  [CE]  no  suitable  method  found  for  newString(int)  [FE]        AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(2);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(2);	  Node    emptyStringNode    =    Node.newString(       "Array       ");    Node    emptyStringNode    =    Node.newString(   ")Array       ");    	non-compiled	[CE]  no  suitable  method  found  for  newString(int)	144	None	replace
1106	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "org.join.ArrayBuilder   ");  Node  emptyStringNode  =  Node.newString( ")org.join.ArrayBuilder   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]    junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "org.join.ArrayBuilder   ");  Node  emptyStringNode  =  Node.newString( ")org.join.ArrayBuilder   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "org.join.ArrayBuilder   ");    Node  emptyStringNode  =  Node.newString( ")org.join.ArrayBuilder   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	207	None	add
1107	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "org.join.ArrayBuilder   ");  junit.framework.ArrayBuilder:  Expected:  x=[].join( "  [CE]  not  a  statement  [FE]      junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "org.join.ArrayBuilder   ");  junit.framework.ArrayBuilder:  Expected:  x=[].join( "  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "org.join.ArrayBuilder   ");    junit.framework.ArrayBuilder:  Expected:  x=[].join( "	  	non-compiled	[CE]  not  a  statement	207	None	add
1108	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "- "  +  Token.NAME,  prev);  [CE]  no  suitable  method  found  for  newString(String,Node)  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "- "  +  Token.NAME,  prev);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "- "  +  Token.NAME,  prev);	  Node    emptyStringNode    =    Node.newString(   "-   "    +    Token.NAME);    	non-compiled	[CE]  no  suitable  method  found  for  newString(String,Node)	164	None	replace
1109	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME,  foldedSize  +  originalSize);  [CE]  no  suitable  method  found  for  newString(int,int)  [FE]      AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME,  foldedSize  +  originalSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(Token.NAME,  foldedSize  +  originalSize);	  Node    emptyStringNode    =    Node.newString(   "-   "    +    Token.NAME);    	non-compiled	[CE]  no  suitable  method  found  for  newString(int,int)	164	None	replace
1110	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "node()   ");  Node  emptyStringNode  =  Node.newString( ")node()   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "node()   ");  Node  emptyStringNode  =  Node.newString( ")node()   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "node()   ");    Node  emptyStringNode  =  Node.newString( ")node()   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	200	None	add
1111	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(]  {   "Array ", "Array "  }  );  [CE]  illegal  start  of  expression  [FE]                AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(]  {   "Array ", "Array "  }  );  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(]  {   "Array ", "Array "  }  );	  Node    emptyStringNode    =    Node.newString(       "Array       ");    Node    emptyStringNode    =    Node.newString(...   "Array       ");    	non-compiled	[CE]  illegal  start  of  expression	34	None	replace
1112	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "java.util.ArrayListn   ");  Node  emptyStringNode  =  Node.newString(? "java.util.ArrayListn   ");  [CE]  illegal  start  of  expression  [FE]    junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "java.util.ArrayListn   ");  Node  emptyStringNode  =  Node.newString(? "java.util.ArrayListn   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "java.util.ArrayListn   ");    Node  emptyStringNode  =  Node.newString(? "java.util.ArrayListn   ");	  	non-compiled	[CE]  illegal  start  of  expression	129	None	add
1113	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "java.util.ArrayListn   ");  Node  emptyStringNode  =  Node.newString(java.util.ArrayListn   ");  [CE]  unclosed  string  literal  [FE]      junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "java.util.ArrayListn   ");  Node  emptyStringNode  =  Node.newString(java.util.ArrayListn   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "java.util.ArrayListn   ");    Node  emptyStringNode  =  Node.newString(java.util.ArrayListn   ");	  	non-compiled	[CE]  unclosed  string  literal	129	None	add
1114	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "Arrays.asList(   ");  Node  emptyStringNode  =  Node.newString( ")Arrays.asList(   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "Arrays.asList(   ");  Node  emptyStringNode  =  Node.newString( ")Arrays.asList(   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "Arrays.asList(   ");    Node  emptyStringNode  =  Node.newString( ")Arrays.asList(   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	51	None	add
1115	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "Arrays.asList(   ");  Node  emptyStringNode  =  Node.newString(. "Arrays.asList(   ");  [CE]  illegal  start  of  expression  [FE]      AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "Arrays.asList(   ");  Node  emptyStringNode  =  Node.newString(. "Arrays.asList(   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "Arrays.asList(   ");    Node  emptyStringNode  =  Node.newString(. "Arrays.asList(   ");	  	non-compiled	[CE]  illegal  start  of  expression	51	None	add
1116	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(relativeSize);  [CE]  cannot  find  symbol  relativeSize  [FE]        AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(relativeSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(relativeSize);	  Node    emptyStringNode    =    Node.newString(0);    	non-compiled	[CE]  cannot  find  symbol  relativeSize	184	None	replace
1117	[BUG]  [BUGGY]  Node  emptyStringNode  =  parent.getFirstChild();  [CE]  cannot  find  symbol  parent  [FE]    java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  The  new  child  node  has  siblings.  Node(CALL):  testcode:1:11  x  =  [].join('    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  parent.getFirstChild();  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  parent.getFirstChild();	  Node    emptyStringNode    =    n.getFirstChild();    	non-compiled	[CE]  cannot  find  symbol  parent	8	None	replace
1118	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "- "  +  parent);  [CE]  cannot  find  symbol  parent  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "- "  +  parent);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "- "  +  parent);	  Node    emptyStringNode    =    Node.newString(   "-   "    +    n);    	non-compiled	[CE]  cannot  find  symbol  parent	49	None	replace
1119	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "- "  +  suffix);  [CE]  cannot  find  symbol  suffix  [FE]      AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "- "  +  suffix);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "- "  +  suffix);	  Node    emptyStringNode    =    Node.newString(   "-   "    +    n);    	non-compiled	[CE]  cannot  find  symbol  suffix	49	None	replace
1120	[BUG]  [BUGGY]  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]          AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[ArrayList] ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "[ArrayList] ");	  Node    emptyStringNode    =    Node.newString(       "java.util.ArrayList       ");    Node    emptyStringNode    =    Node.newString(   ".java.util.ArrayList       ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	25	3	replace
1121	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "[ArrayList] ");  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]          AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[ArrayList] ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "[ArrayList] ");	  Node    emptyStringNode    =    Node.newString(       "java.util.ArrayList       ");    Node    emptyStringNode    =    Node.newString(   ".java.util.ArrayList       ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	25	3	replace
1122	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]            AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[ArrayList   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "[ArrayList   ");	  Node    emptyStringNode    =    Node.newString(       "java.util.ArrayList       ");    Node    emptyStringNode    =    Node.newString(   ".java.util.ArrayList       ");    	compilable	  [FE]  AssertionFailedError  	25	3	replace
1123	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "[ArrayList   ");  [FE]  AssertionFailedError  [FE]            AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[ArrayList   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "[ArrayList   ");	  Node    emptyStringNode    =    Node.newString(       "java.util.ArrayList       ");    Node    emptyStringNode    =    Node.newString(   ".java.util.ArrayList       ");    	compilable	  [FE]  AssertionFailedError  	25	3	replace
1124	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList( ").join(x  +  foldedSize)  [CE]  [FE]            junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList( ").join(x  +  foldedSize)  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList( ").join(x  +  foldedSize)	  Node    emptyStringNode    =    Node.newString(   "java.util.Arrays.asList(   ").join(   "    	non-compiled	[CE]  	183	None	replace
1125	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList( ").join(x,  y)  [CE]  [FE]              junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList( ").join(x,  y)  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList( ").join(x,  y)	  Node    emptyStringNode    =    Node.newString(   "java.util.Arrays.asList(   ").join(   "    	non-compiled	[CE]  	183	None	replace
1126	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.join( ").join(   "  [CE]  unclosed  string  literal  [FE]                junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.join( ").join(   "  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "java.util.Arrays.join( ").join(   "	  Node    emptyStringNode    =    Node.newString(   "java.util.Arrays.asList(   ").join(   "    	non-compiled	[CE]  unclosed  string  literal	183	None	replace
1127	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "string ").replaceChild(n,  foldedStringNode);  [CE]  cannot  find  symbol  foldedStringNode  [FE]        AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "string ").replaceChild(n,  foldedStringNode);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "string ").replaceChild(n,  foldedStringNode);	  Node    emptyStringNode    =    Node.newString(       "string       ");    Node    emptyStringNode    =    Node.newString(   "string       ");    	non-compiled	[CE]  cannot  find  symbol  foldedStringNode	87	None	replace
1128	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "JoinArrayElement   ");  Node  emptyStringNode  =  Node.newString( "JoinArrayElement "));  [CE]  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "JoinArrayElement   ");  Node  emptyStringNode  =  Node.newString( "JoinArrayElement "));  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "JoinArrayElement   ");    Node  emptyStringNode  =  Node.newString( "JoinArrayElement "));	  	non-compiled	[CE]  	38	None	add
1129	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[java.util.ArrayElement] ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "[java.util.ArrayElement] ");	  Node    emptyStringNode    =    Node.newString(       "java.util.ArrayElement       ");    Node    emptyStringNode    =    Node.newString(   ".java.util.ArrayElement       ");    	compilable	  [FE]  AssertionFailedError  	21	3	replace
1130	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "[java.util.ArrayElement] ");  [FE]  AssertionFailedError  [FE]          junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[java.util.ArrayElement] ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "[java.util.ArrayElement] ");	  Node    emptyStringNode    =    Node.newString(       "java.util.ArrayElement       ");    Node    emptyStringNode    =    Node.newString(   ".java.util.ArrayElement       ");    	compilable	  [FE]  AssertionFailedError  	21	3	replace
1131	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]            junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[ArrayElement] ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "[ArrayElement] ");	  Node    emptyStringNode    =    Node.newString(       "java.util.ArrayElement       ");    Node    emptyStringNode    =    Node.newString(   ".java.util.ArrayElement       ");    	compilable	  [FE]  AssertionFailedError  	21	3	replace
1132	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "[ArrayElement] ");  [FE]  AssertionFailedError  [FE]            junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[ArrayElement] ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "[ArrayElement] ");	  Node    emptyStringNode    =    Node.newString(       "java.util.ArrayElement       ");    Node    emptyStringNode    =    Node.newString(   ".java.util.ArrayElement       ");    	compilable	  [FE]  AssertionFailedError  	21	3	replace
1133	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "[node] "  +  name);  [CE]  cannot  find  symbol  name  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[node] "  +  name);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "[node] "  +  name);	  Node    emptyStringNode    =    Node.newString(   "[node]   ");    	non-compiled	[CE]  cannot  find  symbol  name	176	None	replace
1134	[BUG]  [BUGGY]  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]      AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[node] "  +  prev);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "[node] "  +  prev);	  Node    emptyStringNode    =    Node.newString(   "[node]   ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	176	3	replace
1135	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "[node] "  +  prev);  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]      AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[node] "  +  prev);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "[node] "  +  prev);	  Node    emptyStringNode    =    Node.newString(   "[node]   ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	176	3	replace
1136	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "[node] ").replaceChild(n,  prev);  [CE]  incompatible  types  [FE]        AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[node] ").replaceChild(n,  prev);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "[node] ").replaceChild(n,  prev);	  Node    emptyStringNode    =    Node.newString(   "[node]   ");    	non-compiled	[CE]  incompatible  types	176	None	replace
1137	[BUG]  [BUGGY]  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "array_name "  +  functionName);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "array_name "  +  functionName);	  Node    emptyStringNode    =    Node.newString(   "array_name   ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	73	3	replace
1138	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "array_name "  +  functionName);  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "array_name "  +  functionName);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "array_name "  +  functionName);	  Node    emptyStringNode    =    Node.newString(   "array_name   ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	73	3	replace
1139	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "array_foo ".toString());  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "array_foo ".toString());	  Node    emptyStringNode    =    Node.newString(   "array_foo   ");    	compilable	  [FE]  AssertionFailedError  	203	3	replace
1140	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "array_foo ".toString());  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "array_foo ".toString());  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "array_foo ".toString());	  Node    emptyStringNode    =    Node.newString(   "array_foo   ");    	compilable	  [FE]  AssertionFailedError  	203	3	replace
1141	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "array_foo ",  n);  [CE]  no  suitable  method  found  for  newString(String,Node)  [FE]      AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "array_foo ",  n);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "array_foo ",  n);	  Node    emptyStringNode    =    Node.newString(   "array_foo   ");    	non-compiled	[CE]  no  suitable  method  found  for  newString(String,Node)	203	None	replace
1142	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]            AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ";string ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( ";string ");	  Node    emptyStringNode    =    Node.newString(       "string       ");    Node    emptyStringNode    =    Node.newString(   ",string       ");    	compilable	  [FE]  AssertionFailedError  	89	3	replace
1143	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( ";string ");  [FE]  AssertionFailedError  [FE]            AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ";string ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( ";string ");	  Node    emptyStringNode    =    Node.newString(       "string       ");    Node    emptyStringNode    =    Node.newString(   ",string       ");    	compilable	  [FE]  AssertionFailedError  	89	3	replace
1144	[BUG]  [BUGGY]  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]              AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ",infinity ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( ",infinity ");	  Node    emptyStringNode    =    Node.newString(       "string       ");    Node    emptyStringNode    =    Node.newString(   ",string       ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	89	3	replace
1145	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( ",infinity ");  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]              AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ",infinity ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( ",infinity ");	  Node    emptyStringNode    =    Node.newString(       "string       ");    Node    emptyStringNode    =    Node.newString(   ",string       ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	89	3	replace
1146	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList(prev)+  1);  [CE]  unclosed  string  literal  [FE]          junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList(prev)+  1);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList(prev)+  1);	  Node    emptyStringNode    =    Node.newString(   "java.util.Arrays.asList(prev));    	non-compiled	[CE]  unclosed  string  literal	182	None	replace
1147	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList(n));  [CE]  unclosed  string  literal  [FE]            junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList(n));  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList(n));	  Node    emptyStringNode    =    Node.newString(   "java.util.Arrays.asList(prev));    	non-compiled	[CE]  unclosed  string  literal	182	None	replace
1148	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList(prev),  n);  [CE]  unclosed  string  literal  [FE]              junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList(prev),  n);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList(prev),  n);	  Node    emptyStringNode    =    Node.newString(   "java.util.Arrays.asList(prev));    	non-compiled	[CE]  unclosed  string  literal	182	None	replace
1149	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "Arrays.asList(unused));  [CE]  unclosed  string  literal  [FE]                junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "Arrays.asList(unused));  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "Arrays.asList(unused));	  Node    emptyStringNode    =    Node.newString(   "java.util.Arrays.asList(prev));    	non-compiled	[CE]  unclosed  string  literal	182	None	replace
1150	[BUG]  [BUGGY]  [FE]  junit.framework.AssertionFailedError:  Expected:  x= " "  Result:  x= "JoinArray  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "JoinArray, ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "JoinArray, ");	  Node    emptyStringNode    =    Node.newString(   "JoinArrayElement   ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x= " "  Result:  x= "JoinArray  	39	3	replace
1151	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "JoinArray, ");  [FE]  junit.framework.AssertionFailedError:  Expected:  x= " "  Result:  x= "JoinArray  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "JoinArray, ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "JoinArray, ");	  Node    emptyStringNode    =    Node.newString(   "JoinArrayElement   ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x= " "  Result:  x= "JoinArray  	39	3	replace
1152	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.BLOCK,  leftStringNode);  [CE]  cannot  find  symbol  leftStringNode  [FE]          AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.BLOCK,  leftStringNode);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(Token.BLOCK,  leftStringNode);	  Node    emptyStringNode    =    Node.newString(Token.BLOCK);    	non-compiled	[CE]  cannot  find  symbol  leftStringNode	155	None	replace
1153	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "].[ ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "].[ ");	  Node    emptyStringNode    =    Node.newString(       "[       ");    Node    emptyStringNode    =    Node.newString(   ".[       ");    	compilable	  [FE]  AssertionFailedError  	96	3	replace
1154	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "].[ ");  [FE]  AssertionFailedError  [FE]          AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "].[ ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "].[ ");	  Node    emptyStringNode    =    Node.newString(       "[       ");    Node    emptyStringNode    =    Node.newString(   ".[       ");    	compilable	  [FE]  AssertionFailedError  	96	3	replace
1155	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "[   "  +  sb.toString());  Node  emptyStringNode  =  Node.newString( ")[   "  +  sb.toString());  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]    java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "[   "  +  sb.toString());  Node  emptyStringNode  =  Node.newString( ")[   "  +  sb.toString());  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "[   "    +    sb.toString());    Node  emptyStringNode  =  Node.newString( ")[   "  +  sb.toString());	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	179	None	add
1156	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "ArrayList   ",  arrayFoldedChildren.size());  [CE]  no  suitable  method  found  for  newString(String,int)  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "ArrayList   ",  arrayFoldedChildren.size());  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "ArrayList   ",  arrayFoldedChildren.size());	  Node    emptyStringNode    =    Node.newString(   "ArrayList   ");    	non-compiled	[CE]  no  suitable  method  found  for  newString(String,int)	126	None	replace
1157	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "ArrayList   ",  arrayFoldedChildren.size()  -  1);  [CE]  no  suitable  method  found  for  newString(String,int)  [FE]      AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "ArrayList   ",  arrayFoldedChildren.size()  -  1);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "ArrayList   ",  arrayFoldedChildren.size()  -  1);	  Node    emptyStringNode    =    Node.newString(   "ArrayList   ");    	non-compiled	[CE]  no  suitable  method  found  for  newString(String,int)	126	None	replace
1158	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "ArrayListn ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "ArrayListn ");	  Node    emptyStringNode    =    Node.newString(   "ArrayList   ");    	compilable	  [FE]  AssertionFailedError  	126	3	replace
1159	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "ArrayListn ");  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "ArrayListn ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "ArrayListn ");	  Node    emptyStringNode    =    Node.newString(   "ArrayList   ");    	compilable	  [FE]  AssertionFailedError  	126	3	replace
1160	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "ArrayList   ",  sb.toString());  [CE]  no  suitable  method  found  for  newString(String,String)  [FE]          AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "ArrayList   ",  sb.toString());  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "ArrayList   ",  sb.toString());	  Node    emptyStringNode    =    Node.newString(   "ArrayList   ");    	non-compiled	[CE]  no  suitable  method  found  for  newString(String,String)	126	None	replace
1161	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "-   "  +  n);  Node  emptyStringNode  =  Node.newString(  n);  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "-   "  +  n);  Node  emptyStringNode  =  Node.newString(  n);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "-   "    +    n);    Node  emptyStringNode  =  Node.newString(  n);	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	48	None	add
1162	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "n ",  arrayFoldedChildren.size()  -  1);  [CE]  no  suitable  method  found  for  newString(String,int)  [FE]          AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "n ",  arrayFoldedChildren.size()  -  1);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "n ",  arrayFoldedChildren.size()  -  1);	  Node    emptyStringNode    =    Node.newString(       "Array       ");    Node    emptyStringNode    =    Node.newString(   ",Array       ");    	non-compiled	[CE]  no  suitable  method  found  for  newString(String,int)	31	None	replace
1163	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "n ",  arrayFoldedChildren.size());  [CE]  no  suitable  method  found  for  newString(String,int)  [FE]            AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "n ",  arrayFoldedChildren.size());  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "n ",  arrayFoldedChildren.size());	  Node    emptyStringNode    =    Node.newString(       "Array       ");    Node    emptyStringNode    =    Node.newString(   ",Array       ");    	non-compiled	[CE]  no  suitable  method  found  for  newString(String,int)	31	None	replace
1164	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[A-Z] "  +  Token.NAME);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "[A-Z] "  +  Token.NAME);	  Node    emptyStringNode    =    Node.newString(   "[A-Z]   ");    	compilable	  [FE]  AssertionFailedError  	67	3	replace
1165	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "[A-Z] "  +  Token.NAME);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[A-Z] "  +  Token.NAME);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "[A-Z] "  +  Token.NAME);	  Node    emptyStringNode    =    Node.newString(   "[A-Z]   ");    	compilable	  [FE]  AssertionFailedError  	67	3	replace
1166	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "[A-Z] ").replaceChild(n,  prev);  [CE]  incompatible  types  [FE]      AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[A-Z] ").replaceChild(n,  prev);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "[A-Z] ").replaceChild(n,  prev);	  Node    emptyStringNode    =    Node.newString(   "[A-Z]   ");    	non-compiled	[CE]  incompatible  types	67	None	replace
1167	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "[A-Z] ").replaceChild(n,  foldedStringNode);  [CE]  cannot  find  symbol  foldedStringNode  [FE]        AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[A-Z] ").replaceChild(n,  foldedStringNode);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "[A-Z] ").replaceChild(n,  foldedStringNode);	  Node    emptyStringNode    =    Node.newString(   "[A-Z]   ");    	non-compiled	[CE]  cannot  find  symbol  foldedStringNode	67	None	replace
1168	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[A-Z] "  +  Token.STRING);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "[A-Z] "  +  Token.STRING);	  Node    emptyStringNode    =    Node.newString(   "[A-Z]   ");    	compilable	  [FE]  AssertionFailedError  	67	3	replace
1169	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "[A-Z] "  +  Token.STRING);  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[A-Z] "  +  Token.STRING);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "[A-Z] "  +  Token.STRING);	  Node    emptyStringNode    =    Node.newString(   "[A-Z]   ");    	compilable	  [FE]  AssertionFailedError  	67	3	replace
1170	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[A-Z] "  +  Token.VAR);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "[A-Z] "  +  Token.VAR);	  Node    emptyStringNode    =    Node.newString(   "[A-Z]   ");    	compilable	  [FE]  AssertionFailedError  	67	3	replace
1171	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "[A-Z] "  +  Token.VAR);  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[A-Z] "  +  Token.VAR);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "[A-Z] "  +  Token.VAR);	  Node    emptyStringNode    =    Node.newString(   "[A-Z]   ");    	compilable	  [FE]  AssertionFailedError  	67	3	replace
1172	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "Array ").copyInformationFrom(leftStringNode);  [CE]  cannot  find  symbol  leftStringNode  [FE]    java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "Array ").copyInformationFrom(leftStringNode);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "Array ").copyInformationFrom(leftStringNode);	  Node    emptyStringNode    =    Node.newString(   "Array   ").copyInformationFrom(prev);    	non-compiled	[CE]  cannot  find  symbol  leftStringNode	166	None	replace
1173	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.STRING,  suffix);  [CE]  cannot  find  symbol  suffix  [FE]            junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.STRING,  suffix);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(Token.STRING,  suffix);	  Node    emptyStringNode    =    Node.newString(Token.STRING);    	non-compiled	[CE]  cannot  find  symbol  suffix	40	None	replace
1174	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "string ").replaceChild(n,  oldStringNode,  new  StringBuilder());  [CE]  cannot  find  symbol  oldStringNode  [FE]        AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "string ").replaceChild(n,  oldStringNode,  new  StringBuilder());  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "string ").replaceChild(n,  oldStringNode,  new  StringBuilder());	  Node    emptyStringNode    =    Node.newString(   "string   ").replaceChild(n,    new    StringBuilder());    	non-compiled	[CE]  cannot  find  symbol  oldStringNode	196	None	replace
1175	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "string ").replaceChild(n,  new  StringBuilder(initialSize));  [CE]  cannot  find  symbol  initialSize  [FE]          AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "string ").replaceChild(n,  new  StringBuilder(initialSize));  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "string ").replaceChild(n,  new  StringBuilder(initialSize));	  Node    emptyStringNode    =    Node.newString(   "string   ").replaceChild(n,    new    StringBuilder());    	non-compiled	[CE]  cannot  find  symbol  initialSize	196	None	replace
1176	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "string ").replaceChild(n,  arrayFoldedChildren,  prev);  [CE]  method  replaceChild  in  class  Node  cannot  be  applied  to  given  types;  [FE]          AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "string ").replaceChild(n,  arrayFoldedChildren,  prev);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "string ").replaceChild(n,  arrayFoldedChildren,  prev);	  Node    emptyStringNode    =    Node.newString(   "string   ").replaceChild(n,    arrayFoldedChildren);    	non-compiled	[CE]  method  replaceChild  in  class  Node  cannot  be  applied  to  given  types;	142	None	replace
1177	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "string ").replaceChild(n,  arrayFoldedChildren,  left);  [CE]  cannot  find  symbol  left  [FE]            AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "string ").replaceChild(n,  arrayFoldedChildren,  left);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "string ").replaceChild(n,  arrayFoldedChildren,  left);	  Node    emptyStringNode    =    Node.newString(   "string   ").replaceChild(n,    arrayFoldedChildren);    	non-compiled	[CE]  cannot  find  symbol  left	142	None	replace
1178	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "string ").replaceChild(arrayFoldedChildren,  n);  [CE]  method  replaceChild  in  class  Node  cannot  be  applied  to  given  types;  [FE]              AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "string ").replaceChild(arrayFoldedChildren,  n);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "string ").replaceChild(arrayFoldedChildren,  n);	  Node    emptyStringNode    =    Node.newString(   "string   ").replaceChild(n,    arrayFoldedChildren);    	non-compiled	[CE]  method  replaceChild  in  class  Node  cannot  be  applied  to  given  types;	142	None	replace
1179	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "string ").replaceChild(n,  arrayFoldedChildren,  suffix);  [CE]  cannot  find  symbol  suffix  [FE]                AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "string ").replaceChild(n,  arrayFoldedChildren,  suffix);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "string ").replaceChild(n,  arrayFoldedChildren,  suffix);	  Node    emptyStringNode    =    Node.newString(   "string   ").replaceChild(n,    arrayFoldedChildren);    	non-compiled	[CE]  cannot  find  symbol  suffix	142	None	replace
1180	[BUG]  [BUGGY]  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[] "  +  prev);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "[] "  +  prev);	  Node    emptyStringNode    =    Node.newString(   "[]   ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	58	3	replace
1181	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "[] "  +  prev);  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[] "  +  prev);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "[] "  +  prev);	  Node    emptyStringNode    =    Node.newString(   "[]   ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	58	3	replace
1182	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList( ")));  [CE]  [FE]            junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList( ")));  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList( ")));	  Node    emptyStringNode    =    Node.newString(   "java.util.Arrays.asList(   "));    	non-compiled	[CE]  	54	None	replace
1183	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME,  prev,  foldedSize);  [CE]  no  suitable  method  found  for  newString(int,Node,int)  [FE]          AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME,  prev,  foldedSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(Token.NAME,  prev,  foldedSize);	  Node    emptyStringNode    =    Node.newString(Token.NAME,    foldedSize);    	non-compiled	[CE]  no  suitable  method  found  for  newString(int,Node,int)	83	None	replace
1184	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList( ",);  [CE]  illegal  start  of  expression  [FE]                junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList( ",);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList( ",);	  Node    emptyStringNode    =    Node.newString(       "java.util.Arrays.asList(       ");    Node    emptyStringNode    =    Node.newString(   "java.util.Arrays.asList(   ",);    	non-compiled	[CE]  illegal  start  of  expression	80	None	replace
1185	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList( ", ",);  [CE]  unclosed  string  literal  [FE]                  junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList( ", ",);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList( ", ",);	  Node    emptyStringNode    =    Node.newString(       "java.util.Arrays.asList(       ");    Node    emptyStringNode    =    Node.newString(   "java.util.Arrays.asList(   ",);    	non-compiled	[CE]  unclosed  string  literal	80	None	replace
1186	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList( ",  n);  [CE]  no  suitable  method  found  for  newString(String,Node)  [FE]                    junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList( ",  n);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList( ",  n);	  Node    emptyStringNode    =    Node.newString(       "java.util.Arrays.asList(       ");    Node    emptyStringNode    =    Node.newString(   "java.util.Arrays.asList(   ",);    	non-compiled	[CE]  no  suitable  method  found  for  newString(String,Node)	80	None	replace
1187	[BUG]  [BUGGY]  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "Arrays ").copyInformationFrom(prev);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "Arrays ").copyInformationFrom(prev);	  Node    emptyStringNode    =    Node.newString(   "Arrays   ");    	compilable	  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('  	192	3	replace
1188	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "Arrays ").copyInformationFrom(prev);  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "Arrays ").copyInformationFrom(prev);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "Arrays ").copyInformationFrom(prev);	  Node    emptyStringNode    =    Node.newString(   "Arrays   ");    	compilable	  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('  	192	3	replace
1189	[BUG]  [BUGGY]  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]      AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "Arrays: ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "Arrays: ");	  Node    emptyStringNode    =    Node.newString(   "Arrays   ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	192	3	replace
1190	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "Arrays: ");  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]      AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "Arrays: ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "Arrays: ");	  Node    emptyStringNode    =    Node.newString(   "Arrays   ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	192	3	replace
1191	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "ArrayBuilder   ");  Node  emptyStringNode  =  Node.newString( ")ArrayBuilder   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "ArrayBuilder   ");  Node  emptyStringNode  =  Node.newString( ")ArrayBuilder   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "ArrayBuilder   ");    Node  emptyStringNode  =  Node.newString( ")ArrayBuilder   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	100	None	add
1192	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ")- ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( ")- ");	  Node    emptyStringNode    =    Node.newString(       "-       ");    Node    emptyStringNode    =    Node.newString(   ")-       ");    	compilable	  [FE]  AssertionFailedError  	197	3	replace
1193	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( ")- ");  [FE]  AssertionFailedError  [FE]        AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ")- ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( ")- ");	  Node    emptyStringNode    =    Node.newString(       "-       ");    Node    emptyStringNode    =    Node.newString(   ")-       ");    	compilable	  [FE]  AssertionFailedError  	197	3	replace
1194	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ")-  1 ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( ")-  1 ");	  Node    emptyStringNode    =    Node.newString(       "-       ");    Node    emptyStringNode    =    Node.newString(   ")-       ");    	compilable	  [FE]  AssertionFailedError  	197	3	replace
1195	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( ")-  1 ");  [FE]  AssertionFailedError  [FE]          AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ")-  1 ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( ")-  1 ");	  Node    emptyStringNode    =    Node.newString(       "-       ");    Node    emptyStringNode    =    Node.newString(   ")-       ");    	compilable	  [FE]  AssertionFailedError  	197	3	replace
1196	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.ArrayElement ").join( "  Expected:  x=[]  [CE]  unclosed  string  literal  [FE]        junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.ArrayElement ").join( "  Expected:  x=[]  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "java.util.ArrayElement ").join( "  Expected:  x=[]	  Node    emptyStringNode    =    Node.newString(   "java.util.ArrayElement   ").join(   "    Expected:    x=[   "    	non-compiled	[CE]  unclosed  string  literal	193	None	replace
1197	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.ArrayElement ").join( "  Expected:  x=['  [CE]  unclosed  string  literal  [FE]          junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.ArrayElement ").join( "  Expected:  x=['  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "java.util.ArrayElement ").join( "  Expected:  x=['	  Node    emptyStringNode    =    Node.newString(   "java.util.ArrayElement   ").join(   "    Expected:    x=[   "    	non-compiled	[CE]  unclosed  string  literal	193	None	replace
1198	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "ArrayElement   ");  Node  emptyStringNode  =  Node.newString( ")ArrayElement   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "ArrayElement   ");  Node  emptyStringNode  =  Node.newString( ")ArrayElement   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "ArrayElement   ");    Node  emptyStringNode  =  Node.newString( ")ArrayElement   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	36	None	add
1199	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "ArrayElement   ");  Node  emptyStringNode  =  Node.newString( "ArrayElement "));  [CE]  [FE]      AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "ArrayElement   ");  Node  emptyStringNode  =  Node.newString( "ArrayElement "));  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "ArrayElement   ");    Node  emptyStringNode  =  Node.newString( "ArrayElement "));	  	non-compiled	[CE]  	36	None	add
1200	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "[a-z] ").replaceChild(n,  prev);  [CE]  incompatible  types  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[a-z] ").replaceChild(n,  prev);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "[a-z] ").replaceChild(n,  prev);	  Node    emptyStringNode    =    Node.newString(   "[a-z]   ");    	non-compiled	[CE]  incompatible  types	178	None	replace
1201	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "[a-z] ").replaceChild(n,  foldedStringNode);  [CE]  cannot  find  symbol  foldedStringNode  [FE]      AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[a-z] ").replaceChild(n,  foldedStringNode);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "[a-z] ").replaceChild(n,  foldedStringNode);	  Node    emptyStringNode    =    Node.newString(   "[a-z]   ");    	non-compiled	[CE]  cannot  find  symbol  foldedStringNode	178	None	replace
1202	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "[a-z] ").replaceChild(n,  n);  [CE]  incompatible  types  [FE]        AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[a-z] ").replaceChild(n,  n);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "[a-z] ").replaceChild(n,  n);	  Node    emptyStringNode    =    Node.newString(   "[a-z]   ");    	non-compiled	[CE]  incompatible  types	178	None	replace
1203	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME,   "ArrayBuilder   ");  Node  emptyStringNode  =  Node.newString(Token.NAME,   "ArrayBuilder "));  [CE]  [FE]    junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME,   "ArrayBuilder   ");  Node  emptyStringNode  =  Node.newString(Token.NAME,   "ArrayBuilder "));  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(Token.NAME,   "ArrayBuilder   ");    Node  emptyStringNode  =  Node.newString(Token.NAME,   "ArrayBuilder "));	  	non-compiled	[CE]  	167	None	add
1204	[BUG]  [BUGGY]  Node  n  =  Node.newString( "array ");  [CE]  variable  n  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]        junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  n  =  Node.newString( "array ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  n  =  Node.newString( "array ");	  Node    emptyStringNode    =    Node.newString(       "array       ");    Node    emptyStringNode    =    Node.newString(   "array       ");    	non-compiled	[CE]  variable  n  is  already  defined  in  method  tryFoldArrayJoin(Node)	12	None	replace
1205	[BUG]  [BUGGY]  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]    junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME, "ArrayList: ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString(Token.NAME, "ArrayList: ");	  Node    emptyStringNode    =    Node.newString(   "java.util.ArrayList:   ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	159	3	replace
1206	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME, "ArrayList: ");  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]    junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME, "ArrayList: ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(Token.NAME, "ArrayList: ");	  Node    emptyStringNode    =    Node.newString(   "java.util.ArrayList:   ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	159	3	replace
1207	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "[node]   ");  Node  emptyStringNode  =  Node.newString( ")[node]   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "[node]   ");  Node  emptyStringNode  =  Node.newString( ")[node]   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "[node]   ");    Node  emptyStringNode  =  Node.newString( ")[node]   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	175	None	add
1208	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "[node]   ");  Node  emptyStringNode  =  Node.newString(. "[node]   ");  [CE]  illegal  start  of  expression  [FE]      AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "[node]   ");  Node  emptyStringNode  =  Node.newString(. "[node]   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "[node]   ");    Node  emptyStringNode  =  Node.newString(. "[node]   ");	  	non-compiled	[CE]  illegal  start  of  expression	175	None	add
1209	[BUG]  [BUGGY]  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "ArraySize ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "ArraySize ");	  Node    emptyStringNode    =    Node.newString(   "ArrayElement   ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	37	3	replace
1210	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "ArraySize ");  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "ArraySize ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "ArraySize ");	  Node    emptyStringNode    =    Node.newString(   "ArrayElement   ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	37	3	replace
1211	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "[n   ");  Node  emptyStringNode  =  Node.newString(... "[n   ");  [CE]  illegal  start  of  expression  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "[n   ");  Node  emptyStringNode  =  Node.newString(... "[n   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "[n   ");    Node  emptyStringNode  =  Node.newString(... "[n   ");	  	non-compiled	[CE]  illegal  start  of  expression	132	None	add
1212	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "-   "  +  originalSize);  Node  emptyStringNode  =  Node.newString(  -   "  +  originalSize);  [CE]  unclosed  string  literal  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "-   "  +  originalSize);  Node  emptyStringNode  =  Node.newString(  -   "  +  originalSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "-   "    +    originalSize);    Node  emptyStringNode  =  Node.newString(  -   "  +  originalSize);	  	non-compiled	[CE]  unclosed  string  literal	44	None	add
1213	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "node   ");  Node  emptyStringNode  =  Node.newString( ")node   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "node   ");  Node  emptyStringNode  =  Node.newString( ")node   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "node   ");    Node  emptyStringNode  =  Node.newString( ")node   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	85	None	add
1214	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME,  1, "ArrayElement ");  [CE]  no  suitable  method  found  for  newString(int,int,String)  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME,  1, "ArrayElement ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(Token.NAME,  1, "ArrayElement ");	  Node    emptyStringNode    =    Node.newString(Token.NAME,   "ArrayElement   ");    	non-compiled	[CE]  no  suitable  method  found  for  newString(int,int,String)	136	None	replace
1215	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME,  1, "Array ");  [CE]  no  suitable  method  found  for  newString(int,int,String)  [FE]      AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME,  1, "Array ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(Token.NAME,  1, "Array ");	  Node    emptyStringNode    =    Node.newString(Token.NAME,   "ArrayElement   ");    	non-compiled	[CE]  no  suitable  method  found  for  newString(int,int,String)	136	None	replace
1216	[BUG]  [BUGGY]  [FE]  IllegalStateException  [FE]                  AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(1,   "Array ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString(1,   "Array ");	  Node    emptyStringNode    =    Node.newString(       "Array       ");    Node    emptyStringNode    =    Node.newString(,   "Array       ");    	compilable	  [FE]  IllegalStateException  	35	3	replace
1217	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(1,   "Array ");  [FE]  IllegalStateException  [FE]                  AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(1,   "Array ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(1,   "Array ");	  Node    emptyStringNode    =    Node.newString(       "Array       ");    Node    emptyStringNode    =    Node.newString(,   "Array       ");    	compilable	  [FE]  IllegalStateException  	35	3	replace
1218	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "string   "  +  originalSize);  Node  emptyStringNode  =  Node.newString( ")string   "  +  originalSize);  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]    junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "string   "  +  originalSize);  Node  emptyStringNode  =  Node.newString( ")string   "  +  originalSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "string   "    +    originalSize);    Node  emptyStringNode  =  Node.newString( ")string   "  +  originalSize);	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	106	None	add
1219	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[node   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "[node   ");	  Node    emptyStringNode    =    Node.newString(   "[n   ");    	compilable	  [FE]  AssertionFailedError  	133	3	replace
1220	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "[node   ");  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[node   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "[node   ");	  Node    emptyStringNode    =    Node.newString(   "[n   ");    	compilable	  [FE]  AssertionFailedError  	133	3	replace
1221	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[node()] ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "[node()] ");	  Node    emptyStringNode    =    Node.newString(   "[n   ");    	compilable	  [FE]  AssertionFailedError  	133	3	replace
1222	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "[node()] ");  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[node()] ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "[node()] ");	  Node    emptyStringNode    =    Node.newString(   "[n   ");    	compilable	  [FE]  AssertionFailedError  	133	3	replace
1223	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[loop] ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "[loop] ");	  Node    emptyStringNode    =    Node.newString(   "[n   ");    	compilable	  [FE]  AssertionFailedError  	133	3	replace
1224	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "[loop] ");  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[loop] ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "[loop] ");	  Node    emptyStringNode    =    Node.newString(   "[n   ");    	compilable	  [FE]  AssertionFailedError  	133	3	replace
1225	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[labels] ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "[labels] ");	  Node    emptyStringNode    =    Node.newString(   "[n   ");    	compilable	  [FE]  AssertionFailedError  	133	3	replace
1226	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "[labels] ");  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[labels] ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "[labels] ");	  Node    emptyStringNode    =    Node.newString(   "[n   ");    	compilable	  [FE]  AssertionFailedError  	133	3	replace
1227	[BUG]  [BUGGY]  [FE]  junit.framework.AssertionFailedError:  Expected:  x= " "  Result:  x= "]  [FE]              junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "],array ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "],array ");	  Node    emptyStringNode    =    Node.newString(       "array       ");    Node    emptyStringNode    =    Node.newString(   ",array       ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x= " "  Result:  x= "]  	15	3	replace
1228	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "],array ");  [FE]  junit.framework.AssertionFailedError:  Expected:  x= " "  Result:  x= "]  [FE]              junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "],array ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "],array ");	  Node    emptyStringNode    =    Node.newString(       "array       ");    Node    emptyStringNode    =    Node.newString(   ",array       ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x= " "  Result:  x= "]  	15	3	replace
1229	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]                junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ";array ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( ";array ");	  Node    emptyStringNode    =    Node.newString(       "array       ");    Node    emptyStringNode    =    Node.newString(   ",array       ");    	compilable	  [FE]  AssertionFailedError  	15	3	replace
1230	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( ";array ");  [FE]  AssertionFailedError  [FE]                junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ";array ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( ";array ");	  Node    emptyStringNode    =    Node.newString(       "array       ");    Node    emptyStringNode    =    Node.newString(   ",array       ");    	compilable	  [FE]  AssertionFailedError  	15	3	replace
1231	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME,   "ArrayElement   ");  Node  emptyStringNode  =  Node.newString(Token.NAME,   "ArrayElement "));  [CE]  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME,   "ArrayElement   ");  Node  emptyStringNode  =  Node.newString(Token.NAME,   "ArrayElement "));  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(Token.NAME,   "ArrayElement   ");    Node  emptyStringNode  =  Node.newString(Token.NAME,   "ArrayElement "));	  	non-compiled	[CE]  	135	None	add
1232	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME,   "ArrayElement   ");  Node  emptyStringNode  =  Node.newString(Token.NAME,   "ArrayElement ",);  [CE]  illegal  start  of  expression  [FE]      AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME,   "ArrayElement   ");  Node  emptyStringNode  =  Node.newString(Token.NAME,   "ArrayElement ",);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(Token.NAME,   "ArrayElement   ");    Node  emptyStringNode  =  Node.newString(Token.NAME,   "ArrayElement ",);	  	non-compiled	[CE]  illegal  start  of  expression	135	None	add
1233	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ")[ ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( ")[ ");	  Node    emptyStringNode    =    Node.newString(       "[       ");    Node    emptyStringNode    =    Node.newString(   ")[       ");    	compilable	  [FE]  AssertionFailedError  	139	3	replace
1234	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( ")[ ");  [FE]  AssertionFailedError  [FE]        AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ")[ ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( ")[ ");	  Node    emptyStringNode    =    Node.newString(       "[       ");    Node    emptyStringNode    =    Node.newString(   ")[       ");    	compilable	  [FE]  AssertionFailedError  	139	3	replace
1235	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME, "ArrayList ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString(Token.NAME, "ArrayList ");	  Node    emptyStringNode    =    Node.newString(   "org.join.ArrayList   ");    	compilable	  [FE]  AssertionFailedError  	210	3	replace
1236	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME, "ArrayList ");  [FE]  AssertionFailedError  [FE]    junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME, "ArrayList ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(Token.NAME, "ArrayList ");	  Node    emptyStringNode    =    Node.newString(   "org.join.ArrayList   ");    	compilable	  [FE]  AssertionFailedError  	210	3	replace
1237	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList( "  +  arrayFoldedChildren.size()  1));  [CE]  [FE]              junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList( "  +  arrayFoldedChildren.size()  1));  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList( "  +  arrayFoldedChildren.size()  1));	  Node    emptyStringNode    =    Node.newString(   "java.util.Arrays.asList(   "    +    arrayFoldedChildren.size()    -    1));    	non-compiled	[CE]  	55	None	replace
1238	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "string ").replaceChild(n,  oldStringNode);  [CE]  cannot  find  symbol  oldStringNode  [FE]            AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "string ").replaceChild(n,  oldStringNode);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "string ").replaceChild(n,  oldStringNode);	  Node    emptyStringNode    =    Node.newString(   "string   ").replaceChild(n,    foldedSize);    	non-compiled	[CE]  cannot  find  symbol  oldStringNode	110	None	replace
1239	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "string ").replaceChild(n,  sb,  foldedSize);  [CE]  method  replaceChild  in  class  Node  cannot  be  applied  to  given  types;  [FE]              AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "string ").replaceChild(n,  sb,  foldedSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "string ").replaceChild(n,  sb,  foldedSize);	  Node    emptyStringNode    =    Node.newString(   "string   ").replaceChild(n,    foldedSize);    	non-compiled	[CE]  method  replaceChild  in  class  Node  cannot  be  applied  to  given  types;	110	None	replace
1240	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "label   ");  Node  emptyStringNode  =  Node.newString( ")label   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]    junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "label   ");  Node  emptyStringNode  =  Node.newString( ")label   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "label   ");    Node  emptyStringNode  =  Node.newString( ")label   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	198	None	add
1241	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "label   ");  Node  emptyStringNode  =  Node.newString(. "label   ");  [CE]  illegal  start  of  expression  [FE]      junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "label   ");  Node  emptyStringNode  =  Node.newString(. "label   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "label   ");    Node  emptyStringNode  =  Node.newString(. "label   ");	  	non-compiled	[CE]  illegal  start  of  expression	198	None	add
1242	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( ",[0]);  [CE]  unclosed  string  literal  [FE]            AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ",[0]);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( ",[0]);	  Node    emptyStringNode    =    Node.newString(       "[       ");    Node    emptyStringNode    =    Node.newString(   ",[       ");    	non-compiled	[CE]  unclosed  string  literal	97	None	replace
1243	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( ",[1]);  [CE]  unclosed  string  literal  [FE]              AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ",[1]);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( ",[1]);	  Node    emptyStringNode    =    Node.newString(       "[       ");    Node    emptyStringNode    =    Node.newString(   ",[       ");    	non-compiled	[CE]  unclosed  string  literal	97	None	replace
1244	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[0] "  +  Token.NAME);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "[0] "  +  Token.NAME);	  Node    emptyStringNode    =    Node.newString(   "[0]   ");    	compilable	  [FE]  AssertionFailedError  	63	3	replace
1245	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "[0] "  +  Token.NAME);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[0] "  +  Token.NAME);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "[0] "  +  Token.NAME);	  Node    emptyStringNode    =    Node.newString(   "[0]   ");    	compilable	  [FE]  AssertionFailedError  	63	3	replace
1246	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[0] "  +  Token.STRING);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "[0] "  +  Token.STRING);	  Node    emptyStringNode    =    Node.newString(   "[0]   ");    	compilable	  [FE]  AssertionFailedError  	63	3	replace
1247	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "[0] "  +  Token.STRING);  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[0] "  +  Token.STRING);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "[0] "  +  Token.STRING);	  Node    emptyStringNode    =    Node.newString(   "[0]   ");    	compilable	  [FE]  AssertionFailedError  	63	3	replace
1248	[BUG]  [BUGGY]  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('  [FE]        junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.ArrayBuilder ").copyInformationFrom(prev);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "java.util.ArrayBuilder ").copyInformationFrom(prev);	  Node    emptyStringNode    =    Node.newString(   "java.util.ArrayBuilder   ").join(   "    	compilable	  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('  	206	3	replace
1249	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.ArrayBuilder ").copyInformationFrom(prev);  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('  [FE]        junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.ArrayBuilder ").copyInformationFrom(prev);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "java.util.ArrayBuilder ").copyInformationFrom(prev);	  Node    emptyStringNode    =    Node.newString(   "java.util.ArrayBuilder   ").join(   "    	compilable	  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('  	206	3	replace
1250	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.ArrayBuilder ").clone();  [CE]  clone()  has  protected  access  in  Object  [FE]          junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.ArrayBuilder ").clone();  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "java.util.ArrayBuilder ").clone();	  Node    emptyStringNode    =    Node.newString(   "java.util.ArrayBuilder   ").join(   "    	non-compiled	[CE]  clone()  has  protected  access  in  Object	206	None	replace
1251	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.ArrayBuilder ").join(x,  true);  [CE]  cannot  find  symbol  x  [FE]            junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.ArrayBuilder ").join(x,  true);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "java.util.ArrayBuilder ").join(x,  true);	  Node    emptyStringNode    =    Node.newString(   "java.util.ArrayBuilder   ").join(   "    	non-compiled	[CE]  cannot  find  symbol  x	206	None	replace
1252	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.ArrayBuilder ").join(x  +   "  [CE]  unclosed  string  literal  [FE]              junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.ArrayBuilder ").join(x  +   "  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "java.util.ArrayBuilder ").join(x  +   "	  Node    emptyStringNode    =    Node.newString(   "java.util.ArrayBuilder   ").join(   "    	non-compiled	[CE]  unclosed  string  literal	206	None	replace
1253	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME,   "Array   ");  Node  emptyStringNode  =  Node.newString(Token.NAME,   "Array   "));  [CE]  [FE]    junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME,   "Array   ");  Node  emptyStringNode  =  Node.newString(Token.NAME,   "Array   "));  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(Token.NAME,   "Array   ");    Node  emptyStringNode  =  Node.newString(Token.NAME,   "Array   "));	  	non-compiled	[CE]  	119	None	add
1254	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME,   "Array   ");  Node  emptyStringNode  =  Node.newString(Token.NAME,   "Array ",);  [CE]  illegal  start  of  expression  [FE]      junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME,   "Array   ");  Node  emptyStringNode  =  Node.newString(Token.NAME,   "Array ",);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(Token.NAME,   "Array   ");    Node  emptyStringNode  =  Node.newString(Token.NAME,   "Array ",);	  	non-compiled	[CE]  illegal  start  of  expression	119	None	add
1255	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME,   "Array "  +  name);  [CE]  cannot  find  symbol  name  [FE]    junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME,   "Array "  +  name);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(Token.NAME,   "Array "  +  name);	  Node    emptyStringNode    =    Node.newString(Token.NAME,   "Array   ");    	non-compiled	[CE]  cannot  find  symbol  name	120	None	replace
1256	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "arrayJoin ",  n);  [CE]  no  suitable  method  found  for  newString(String,Node)  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "arrayJoin ",  n);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "arrayJoin ",  n);	  Node    emptyStringNode    =    Node.newString(   "arrayJoin   ");    	non-compiled	[CE]  no  suitable  method  found  for  newString(String,Node)	71	None	replace
1257	[BUG]  [BUGGY]  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]      AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "arrayJoin. ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "arrayJoin. ");	  Node    emptyStringNode    =    Node.newString(   "arrayJoin   ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	71	3	replace
1258	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "arrayJoin. ");  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]      AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "arrayJoin. ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "arrayJoin. ");	  Node    emptyStringNode    =    Node.newString(   "arrayJoin   ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	71	3	replace
1259	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "arrayJoin "  +  kJoinOverhead);  [CE]  cannot  find  symbol  kJoinOverhead  [FE]        AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "arrayJoin "  +  kJoinOverhead);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "arrayJoin "  +  kJoinOverhead);	  Node    emptyStringNode    =    Node.newString(   "arrayJoin   ");    	non-compiled	[CE]  cannot  find  symbol  kJoinOverhead	71	None	replace
1260	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "Array   ").copyInformationFrom(prev);  Node  emptyStringNode  =  Node.newString( ")Array   ").copyInformationFrom(prev);  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]    java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "Array   ").copyInformationFrom(prev);  Node  emptyStringNode  =  Node.newString( ")Array   ").copyInformationFrom(prev);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "Array   ").copyInformationFrom(prev);    Node  emptyStringNode  =  Node.newString( ")Array   ").copyInformationFrom(prev);	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	165	None	add
1261	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "java.util.Arrays.asList(n   ");  Node  emptyStringNode  =  Node.newString( ")java.util.Arrays.asList(n   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "java.util.Arrays.asList(n   ");  Node  emptyStringNode  =  Node.newString( ")java.util.Arrays.asList(n   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "java.util.Arrays.asList(n   ");    Node  emptyStringNode  =  Node.newString( ")java.util.Arrays.asList(n   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	150	None	add
1262	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Arrays.asList(prev));  [CE]  cannot  find  symbol  Arrays  [FE]          junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Arrays.asList(prev));  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(Arrays.asList(prev));	  Node    emptyStringNode    =    Node.newString(       "java.util.Arrays.asList(       ");    Node    emptyStringNode    =    Node.newString(java.util.Arrays.asList(       ");    	non-compiled	[CE]  cannot  find  symbol  Arrays	77	None	replace
1263	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Arrays.asList(new  String[]  {  }  ));  [CE]  cannot  find  symbol  Arrays  [FE]            junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Arrays.asList(new  String[]  {  }  ));  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(Arrays.asList(new  String[]  {  }  ));	  Node    emptyStringNode    =    Node.newString(       "java.util.Arrays.asList(       ");    Node    emptyStringNode    =    Node.newString(java.util.Arrays.asList(       ");    	non-compiled	[CE]  cannot  find  symbol  Arrays	77	None	replace
1264	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Arrays.asList(new  String[]  {  n  }  ));  [CE]  incompatible  types  [FE]              junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Arrays.asList(new  String[]  {  n  }  ));  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(Arrays.asList(new  String[]  {  n  }  ));	  Node    emptyStringNode    =    Node.newString(       "java.util.Arrays.asList(       ");    Node    emptyStringNode    =    Node.newString(java.util.Arrays.asList(       ");    	non-compiled	[CE]  incompatible  types	77	None	replace
1265	[BUG]  [BUGGY]  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  CALL  1  [source_file:  testcode]  is  not  a  string  node  Node(CALL):  testcode:1:11  x  =  [].join('  [FE]        AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(n.getString());  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString(n.getString());	  Node    emptyStringNode    =    Node.newString(       "string       ");    Node    emptyStringNode    =    Node.newString(.   "string       ");    	compilable	  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  CALL  1  [source_file:  testcode]  is  not  a  string  node  Node(CALL):  testcode:1:11  x  =  [].join('  	143	3	replace
1266	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(n.getString());  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  CALL  1  [source_file:  testcode]  is  not  a  string  node  Node(CALL):  testcode:1:11  x  =  [].join('  [FE]        AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(n.getString());  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(n.getString());	  Node    emptyStringNode    =    Node.newString(       "string       ");    Node    emptyStringNode    =    Node.newString(.   "string       ");    	compilable	  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  CALL  1  [source_file:  testcode]  is  not  a  string  node  Node(CALL):  testcode:1:11  x  =  [].join('  	143	3	replace
1267	[BUG]  [BUGGY]  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]          AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(n.toString());  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString(n.toString());	  Node    emptyStringNode    =    Node.newString(       "string       ");    Node    emptyStringNode    =    Node.newString(.   "string       ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	143	3	replace
1268	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(n.toString());  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]          AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(n.toString());  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(n.toString());	  Node    emptyStringNode    =    Node.newString(       "string       ");    Node    emptyStringNode    =    Node.newString(.   "string       ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	143	3	replace
1269	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "arrayJoin   ");  Node  emptyStringNode  =  Node.newString(. "arrayJoin   ");  [CE]  illegal  start  of  expression  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "arrayJoin   ");  Node  emptyStringNode  =  Node.newString(. "arrayJoin   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "arrayJoin   ");    Node  emptyStringNode  =  Node.newString(. "arrayJoin   ");	  	non-compiled	[CE]  illegal  start  of  expression	70	None	add
1270	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "[Locale.US] ",  prev);  [CE]  no  suitable  method  found  for  newString(String,Node)  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[Locale.US] ",  prev);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "[Locale.US] ",  prev);	  Node    emptyStringNode    =    Node.newString(   "[Locale.US]   ");    	non-compiled	[CE]  no  suitable  method  found  for  newString(String,Node)	65	None	replace
1271	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[Locale.US] "  +  Token.STRING);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "[Locale.US] "  +  Token.STRING);	  Node    emptyStringNode    =    Node.newString(   "[Locale.US]   ");    	compilable	  [FE]  AssertionFailedError  	65	3	replace
1272	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "[Locale.US] "  +  Token.STRING);  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[Locale.US] "  +  Token.STRING);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "[Locale.US] "  +  Token.STRING);	  Node    emptyStringNode    =    Node.newString(   "[Locale.US]   ");    	compilable	  [FE]  AssertionFailedError  	65	3	replace
1273	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "] "  +  Token.NAME,  prev);  [CE]  no  suitable  method  found  for  newString(String,Node)  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "] "  +  Token.NAME,  prev);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "] "  +  Token.NAME,  prev);	  Node    emptyStringNode    =    Node.newString(   "]   "    +    Token.NAME);    	non-compiled	[CE]  no  suitable  method  found  for  newString(String,Node)	154	None	replace
1274	[BUG]  [BUGGY]  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "JoinOverhead ").copyInformationFrom(prev);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "JoinOverhead ").copyInformationFrom(prev);	  Node    emptyStringNode    =    Node.newString(   "JoinOverhead   ");    	compilable	  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('  	146	3	replace
1275	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "JoinOverhead ").copyInformationFrom(prev);  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "JoinOverhead ").copyInformationFrom(prev);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "JoinOverhead ").copyInformationFrom(prev);	  Node    emptyStringNode    =    Node.newString(   "JoinOverhead   ");    	compilable	  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('  	146	3	replace
1276	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "JoinOverhead "  +  kJoinOverhead);  [CE]  cannot  find  symbol  kJoinOverhead  [FE]      AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "JoinOverhead "  +  kJoinOverhead);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "JoinOverhead "  +  kJoinOverhead);	  Node    emptyStringNode    =    Node.newString(   "JoinOverhead   ");    	non-compiled	[CE]  cannot  find  symbol  kJoinOverhead	146	None	replace
1277	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "JoinOverhead ").replaceChild(n,  foldedSize);  [CE]  method  replaceChild  in  class  Node  cannot  be  applied  to  given  types;  [FE]        AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "JoinOverhead ").replaceChild(n,  foldedSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "JoinOverhead ").replaceChild(n,  foldedSize);	  Node    emptyStringNode    =    Node.newString(   "JoinOverhead   ");    	non-compiled	[CE]  method  replaceChild  in  class  Node  cannot  be  applied  to  given  types;	146	None	replace
1278	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ";] ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( ";] ");	  Node    emptyStringNode    =    Node.newString(       "]       ");    Node    emptyStringNode    =    Node.newString(   ".]   ");    	compilable	  [FE]  AssertionFailedError  	92	3	replace
1279	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( ";] ");  [FE]  AssertionFailedError  [FE]          AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ";] ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( ";] ");	  Node    emptyStringNode    =    Node.newString(       "]       ");    Node    emptyStringNode    =    Node.newString(   ".]   ");    	compilable	  [FE]  AssertionFailedError  	92	3	replace
1280	[BUG]  [BUGGY]  Node  emptyStringNode  =  arrayFoldedChildren.get(originalSize);  Node  emptyStringNode  =  arrayFoldedParameters.get(originalSize);  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]    java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  Index:  12    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  arrayFoldedChildren.get(originalSize);  Node  emptyStringNode  =  arrayFoldedParameters.get(originalSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    arrayFoldedChildren.get(originalSize);    Node  emptyStringNode  =  arrayFoldedParameters.get(originalSize);	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	9	None	add
1281	[BUG]  [BUGGY]  Node  emptyStringNode  =  arrayFoldedChildren.get(originalSize);  Node  emptyStringNode  =  arrayFoldedPildren.get(originalSize);  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]      java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  Index:  12    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  arrayFoldedChildren.get(originalSize);  Node  emptyStringNode  =  arrayFoldedPildren.get(originalSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    arrayFoldedChildren.get(originalSize);    Node  emptyStringNode  =  arrayFoldedPildren.get(originalSize);	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	9	None	add
1282	[BUG]  [BUGGY]  Node  emptyStringNode  =  arrayFoldedChildren.get(originalSize);  Node  emptyStringNode  =  arrayFoldedParent.get(originalSize);  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]        java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  Index:  12    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  arrayFoldedChildren.get(originalSize);  Node  emptyStringNode  =  arrayFoldedParent.get(originalSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    arrayFoldedChildren.get(originalSize);    Node  emptyStringNode  =  arrayFoldedParent.get(originalSize);	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	9	None	add
1283	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "n ",-1);  [CE]  no  suitable  method  found  for  newString(String,int)  [FE]              AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "n ",-1);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "n ",-1);	  Node    emptyStringNode    =    Node.newString(       "-       ");    Node    emptyStringNode    =    Node.newString(   ",-       ");    	non-compiled	[CE]  no  suitable  method  found  for  newString(String,int)	114	None	replace
1284	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]                AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "u ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "u ");	  Node    emptyStringNode    =    Node.newString(       "-       ");    Node    emptyStringNode    =    Node.newString(   ",-       ");    	compilable	  [FE]  AssertionFailedError  	114	3	replace
1285	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "u ");  [FE]  AssertionFailedError  [FE]                AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "u ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "u ");	  Node    emptyStringNode    =    Node.newString(       "-       ");    Node    emptyStringNode    =    Node.newString(   ",-       ");    	compilable	  [FE]  AssertionFailedError  	114	3	replace
1286	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[java.util.ArrayBuilder] ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "[java.util.ArrayBuilder] ");	  Node    emptyStringNode    =    Node.newString(       "java.util.ArrayBuilder       ");    Node    emptyStringNode    =    Node.newString(   ".java.util.ArrayBuilder       ");    	compilable	  [FE]  AssertionFailedError  	122	3	replace
1287	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "[java.util.ArrayBuilder] ");  [FE]  AssertionFailedError  [FE]          junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[java.util.ArrayBuilder] ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "[java.util.ArrayBuilder] ");	  Node    emptyStringNode    =    Node.newString(       "java.util.ArrayBuilder       ");    Node    emptyStringNode    =    Node.newString(   ".java.util.ArrayBuilder       ");    	compilable	  [FE]  AssertionFailedError  	122	3	replace
1288	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(ArrayBuilder.EMPTY_STRING);  [CE]  cannot  find  symbol  ArrayBuilder  [FE]        junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(ArrayBuilder.EMPTY_STRING);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(ArrayBuilder.EMPTY_STRING);	  Node    emptyStringNode    =    Node.newString(       "java.util.ArrayBuilder       ");    Node    emptyStringNode    =    Node.newString(java.util.ArrayBuilder       ");    	non-compiled	[CE]  cannot  find  symbol  ArrayBuilder	138	None	replace
1289	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(ArrayBuilder.EMPTY);  [CE]  cannot  find  symbol  ArrayBuilder  [FE]          junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(ArrayBuilder.EMPTY);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(ArrayBuilder.EMPTY);	  Node    emptyStringNode    =    Node.newString(       "java.util.ArrayBuilder       ");    Node    emptyStringNode    =    Node.newString(java.util.ArrayBuilder       ");    	non-compiled	[CE]  cannot  find  symbol  ArrayBuilder	138	None	replace
1290	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(ArrayBuilder.BLOCK);  [CE]  cannot  find  symbol  ArrayBuilder  [FE]            junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(ArrayBuilder.BLOCK);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(ArrayBuilder.BLOCK);	  Node    emptyStringNode    =    Node.newString(       "java.util.ArrayBuilder       ");    Node    emptyStringNode    =    Node.newString(java.util.ArrayBuilder       ");    	non-compiled	[CE]  cannot  find  symbol  ArrayBuilder	138	None	replace
1291	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(ArrayBuilder.BLOCK_SIZE);  [CE]  cannot  find  symbol  ArrayBuilder  [FE]              junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(ArrayBuilder.BLOCK_SIZE);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(ArrayBuilder.BLOCK_SIZE);	  Node    emptyStringNode    =    Node.newString(       "java.util.ArrayBuilder       ");    Node    emptyStringNode    =    Node.newString(java.util.ArrayBuilder       ");    	non-compiled	[CE]  cannot  find  symbol  ArrayBuilder	138	None	replace
1292	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.FUNCTION,  functionName);  [CE]  no  suitable  method  found  for  newString(int,Node)  [FE]                  junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.FUNCTION,  functionName);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(Token.FUNCTION,  functionName);	  Node    emptyStringNode    =    Node.newString(Token.FUNCTION);    	non-compiled	[CE]  no  suitable  method  found  for  newString(int,Node)	43	None	replace
1293	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.ArrayElement ", "ArrayElement ");  [CE]  no  suitable  method  found  for  newString(String,String)  [FE]              junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.ArrayElement ", "ArrayElement ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "java.util.ArrayElement ", "ArrayElement ");	  Node    emptyStringNode    =    Node.newString(       "java.util.ArrayElement       ");    Node    emptyStringNode    =    Node.newString(   "java.util.ArrayElement   ",);    	non-compiled	[CE]  no  suitable  method  found  for  newString(String,String)	23	None	replace
1294	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.ArrayElement ", "org.apache.commons.reportUnsupportedOperation ");  [CE]  no  suitable  method  found  for  newString(String,String)  [FE]                junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.ArrayElement ", "org.apache.commons.reportUnsupportedOperation ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "java.util.ArrayElement ", "org.apache.commons.reportUnsupportedOperation ");	  Node    emptyStringNode    =    Node.newString(       "java.util.ArrayElement       ");    Node    emptyStringNode    =    Node.newString(   "java.util.ArrayElement   ",);    	non-compiled	[CE]  no  suitable  method  found  for  newString(String,String)	23	None	replace
1295	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList( "  +  n.size()));  [CE]  [FE]        junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList( "  +  n.size()));  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList( "  +  n.size()));	  Node    emptyStringNode    =    Node.newString(   "java.util.Arrays.asList(   "    +    arrayFoldedChildren.size()));    	non-compiled	[CE]  	181	None	replace
1296	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME,  1);  [CE]  no  suitable  method  found  for  newString(int,int)  [FE]    junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME,  1);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(Token.NAME,  1);	  Node    emptyStringNode    =    Node.newString(Token.NAME,   "]   ");    	non-compiled	[CE]  no  suitable  method  found  for  newString(int,int)	157	None	replace
1297	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME,  name);  [CE]  cannot  find  symbol  name  [FE]      junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME,  name);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(Token.NAME,  name);	  Node    emptyStringNode    =    Node.newString(Token.NAME,   "]   ");    	non-compiled	[CE]  cannot  find  symbol  name	157	None	replace
1298	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME,  XML_STRING);  [CE]  cannot  find  symbol  XML_STRING  [FE]        junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME,  XML_STRING);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(Token.NAME,  XML_STRING);	  Node    emptyStringNode    =    Node.newString(Token.NAME,   "]   ");    	non-compiled	[CE]  cannot  find  symbol  XML_STRING	157	None	replace
1299	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "]. ".equals(prev);  [CE]  [FE]            AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "]. ".equals(prev);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "]. ".equals(prev);	  Node    emptyStringNode    =    Node.newString(       "]       ");    Node    emptyStringNode    =    Node.newString(       "].   ");    	non-compiled	[CE]  	93	None	replace
1300	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "Join.ArrayBuilder ").toString();  [CE]  incompatible  types  [FE]    junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "Join.ArrayBuilder ").toString();  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "Join.ArrayBuilder ").toString();	  Node    emptyStringNode    =    Node.newString(   "Join.ArrayBuilder   ");    	non-compiled	[CE]  incompatible  types	105	None	replace
1301	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "Join.Arraybuilder ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "Join.Arraybuilder ");	  Node    emptyStringNode    =    Node.newString(   "Join.ArrayBuilder   ");    	compilable	  [FE]  AssertionFailedError  	105	3	replace
1302	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "Join.Arraybuilder ");  [FE]  AssertionFailedError  [FE]      junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "Join.Arraybuilder ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "Join.Arraybuilder ");	  Node    emptyStringNode    =    Node.newString(   "Join.ArrayBuilder   ");    	compilable	  [FE]  AssertionFailedError  	105	3	replace
1303	[BUG]  [BUGGY]  Node  emptyStringNode  =  n.getFirstChild();  Node  emptyStringNode  =  node.getFirstChild();  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]    java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  The  new  child  node  has  siblings.  Node(CALL):  testcode:1:11  x  =  [].join('    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  n.getFirstChild();  Node  emptyStringNode  =  node.getFirstChild();  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    n.getFirstChild();    Node  emptyStringNode  =  node.getFirstChild();	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	7	None	add
1304	[BUG]  [BUGGY]  Node  emptyStringNode  =  n.getFirstChild();  Node  emptyStringNode  =  null.getFirstChild();  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]      java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  The  new  child  node  has  siblings.  Node(CALL):  testcode:1:11  x  =  [].join('    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  n.getFirstChild();  Node  emptyStringNode  =  null.getFirstChild();  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    n.getFirstChild();    Node  emptyStringNode  =  null.getFirstChild();	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	7	None	add
1305	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "JoinArrayElement   ");  Node  emptyStringNode  =  Node.newString(. "JoinArrayElement   ");  [CE]  illegal  start  of  expression  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "JoinArrayElement   ");  Node  emptyStringNode  =  Node.newString(. "JoinArrayElement   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "JoinArrayElement   ");    Node  emptyStringNode  =  Node.newString(. "JoinArrayElement   ");	  	non-compiled	[CE]  illegal  start  of  expression	38	None	add
1306	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "JoinArrayElement   ");  Node  emptyStringNode  =  Node.newString( ")JoinArrayElement   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]      AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "JoinArrayElement   ");  Node  emptyStringNode  =  Node.newString( ")JoinArrayElement   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "JoinArrayElement   ");    Node  emptyStringNode  =  Node.newString( ")JoinArrayElement   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	38	None	add
1307	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME,   "Array   ");  Node  emptyStringNode  =  Node.newString(Token.NAME,... "Array   ");  [CE]  illegal  start  of  expression  [FE]    junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME,   "Array   ");  Node  emptyStringNode  =  Node.newString(Token.NAME,... "Array   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(Token.NAME,   "Array   ");    Node  emptyStringNode  =  Node.newString(Token.NAME,... "Array   ");	  	non-compiled	[CE]  illegal  start  of  expression	119	None	add
1308	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "java.util.ArrayList:   ");  Node  emptyStringNode  =  Node.newString( ")java.util.ArrayList:   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]    junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "java.util.ArrayList:   ");  Node  emptyStringNode  =  Node.newString( ")java.util.ArrayList:   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "java.util.ArrayList:   ");    Node  emptyStringNode  =  Node.newString( ")java.util.ArrayList:   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	158	None	add
1309	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.BLOCK,  wrappedSize);  [CE]  cannot  find  symbol  wrappedSize  [FE]          AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.BLOCK,  wrappedSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(Token.BLOCK,  wrappedSize);	  Node    emptyStringNode    =    Node.newString(Token.BLOCK);    	non-compiled	[CE]  cannot  find  symbol  wrappedSize	155	None	replace
1310	[BUG]  [BUGGY]  [FE]  junit.framework.AssertionFailedError:  Expected:  var  x= " "  Result:  var  x= "array  [FE]        junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "array, ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "array, ");	  Node    emptyStringNode    =    Node.newString(       "array       ");    Node    emptyStringNode    =    Node.newString(   "array       ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  var  x= " "  Result:  var  x= "array  	12	3	replace
1311	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "array, ");  [FE]  junit.framework.AssertionFailedError:  Expected:  var  x= " "  Result:  var  x= "array  [FE]        junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "array, ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "array, ");	  Node    emptyStringNode    =    Node.newString(       "array       ");    Node    emptyStringNode    =    Node.newString(   "array       ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  var  x= " "  Result:  var  x= "array  	12	3	replace
1312	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.ArrayBuilder ", "ImmediateParentcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtTokenNode  =  Node.newString( "  [CE]  [FE]              junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.ArrayBuilder ", "ImmediateParentcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtTokenNode  =  Node.newString( "  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "java.util.ArrayBuilder ", "ImmediateParentcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtTokenNode  =  Node.newString( "	  Node    emptyStringNode    =    Node.newString(       "java.util.ArrayBuilder       ");    Node    emptyStringNode    =    Node.newString(   "java.util.ArrayBuilder   ",);    	non-compiled	[CE]  	124	None	replace
1313	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.ArrayBuilder ", "ImmediateParentcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtdObjectNode  =  Node.newString( "  [CE]  [FE]                junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.ArrayBuilder ", "ImmediateParentcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtdObjectNode  =  Node.newString( "  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "java.util.ArrayBuilder ", "ImmediateParentcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtdObjectNode  =  Node.newString( "	  Node    emptyStringNode    =    Node.newString(       "java.util.ArrayBuilder       ");    Node    emptyStringNode    =    Node.newString(   "java.util.ArrayBuilder   ",);    	non-compiled	[CE]  	124	None	replace
1314	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.ArrayBuilder ", "ImmediateParentcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtFormatter  =  Node  =  Node.newString  [CE]  unclosed  string  literal  [FE]                  junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.ArrayBuilder ", "ImmediateParentcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtFormatter  =  Node  =  Node.newString  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "java.util.ArrayBuilder ", "ImmediateParentcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtFormatter  =  Node  =  Node.newString	  Node    emptyStringNode    =    Node.newString(       "java.util.ArrayBuilder       ");    Node    emptyStringNode    =    Node.newString(   "java.util.ArrayBuilder   ",);    	non-compiled	[CE]  unclosed  string  literal	124	None	replace
1315	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.ArrayBuilder ", "ImmediateParentcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtOpNode  =  Node.newString( "  [CE]  [FE]                    junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.ArrayBuilder ", "ImmediateParentcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtOpNode  =  Node.newString( "  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "java.util.ArrayBuilder ", "ImmediateParentcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtOpNode  =  Node.newString( "	  Node    emptyStringNode    =    Node.newString(       "java.util.ArrayBuilder       ");    Node    emptyStringNode    =    Node.newString(   "java.util.ArrayBuilder   ",);    	non-compiled	[CE]  	124	None	replace
1316	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.ArrayBuilder ", "ImmediateParentcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtPairNode  =  Node.newString( "  [CE]  [FE]                      junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.ArrayBuilder ", "ImmediateParentcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtPairNode  =  Node.newString( "  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "java.util.ArrayBuilder ", "ImmediateParentcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtPairNode  =  Node.newString( "	  Node    emptyStringNode    =    Node.newString(       "java.util.ArrayBuilder       ");    Node    emptyStringNode    =    Node.newString(   "java.util.ArrayBuilder   ",);    	non-compiled	[CE]  	124	None	replace
1317	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.ArrayBuilder ", "ImmediateParentcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtdNode  =  Node  =  Node.newString  [CE]  unclosed  string  literal  [FE]                        junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.ArrayBuilder ", "ImmediateParentcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtdNode  =  Node  =  Node.newString  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "java.util.ArrayBuilder ", "ImmediateParentcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtcîtdNode  =  Node  =  Node.newString	  Node    emptyStringNode    =    Node.newString(       "java.util.ArrayBuilder       ");    Node    emptyStringNode    =    Node.newString(   "java.util.ArrayBuilder   ",);    	non-compiled	[CE]  unclosed  string  literal	124	None	replace
1318	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList( ").join(x  +  foldedSize  [CE]  [FE]            junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList( ").join(x  +  foldedSize  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList( ").join(x  +  foldedSize	  Node    emptyStringNode    =    Node.newString(   "java.util.Arrays.asList(   ").join(   "    	non-compiled	[CE]  	183	None	replace
1319	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.join( ").join(x  +  foldedSize  [CE]  [FE]              junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.join( ").join(x  +  foldedSize  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "java.util.Arrays.join( ").join(x  +  foldedSize	  Node    emptyStringNode    =    Node.newString(   "java.util.Arrays.asList(   ").join(   "    	non-compiled	[CE]  	183	None	replace
1320	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "Arrays.asList( ").join(x  +  foldedSize  [CE]  [FE]                junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "Arrays.asList( ").join(x  +  foldedSize  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "Arrays.asList( ").join(x  +  foldedSize	  Node    emptyStringNode    =    Node.newString(   "java.util.Arrays.asList(   ").join(   "    	non-compiled	[CE]  	183	None	replace
1321	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "array ",  sb.toString()  +  1);  [CE]  no  suitable  method  found  for  newString(String,String)  [FE]        junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "array ",  sb.toString()  +  1);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "array ",  sb.toString()  +  1);	  Node    emptyStringNode    =    Node.newString(   "array   ",    sb.toString());    	non-compiled	[CE]  no  suitable  method  found  for  newString(String,String)	187	None	replace
1322	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "string ").replaceChild(array,  n,  foldedSize);  [CE]  cannot  find  symbol  array  [FE]            AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "string ").replaceChild(array,  n,  foldedSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "string ").replaceChild(array,  n,  foldedSize);	  Node    emptyStringNode    =    Node.newString(   "string   ").replaceChild(n,    foldedSize);    	non-compiled	[CE]  cannot  find  symbol  array	110	None	replace
1323	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( ".node ",  null);  [CE]  no  suitable  method  found  for  newString(String,<null>)  [FE]          AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ".node ",  null);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( ".node ",  null);	  Node    emptyStringNode    =    Node.newString(       "n       ");    Node    emptyStringNode    =    Node.newString(   ".n       ");    	non-compiled	[CE]  no  suitable  method  found  for  newString(String,<null>)	17	None	replace
1324	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "array_Folder ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "array_Folder ");	  Node    emptyStringNode    =    Node.newString(   "label   ");    	compilable	  [FE]  AssertionFailedError  	199	3	replace
1325	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "array_Folder ");  [FE]  AssertionFailedError  [FE]    junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "array_Folder ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "array_Folder ");	  Node    emptyStringNode    =    Node.newString(   "label   ");    	compilable	  [FE]  AssertionFailedError  	199	3	replace
1326	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[arrayFoldedChildren] ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "[arrayFoldedChildren] ");	  Node    emptyStringNode    =    Node.newString(   "[n   ");    	compilable	  [FE]  AssertionFailedError  	133	3	replace
1327	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "[arrayFoldedChildren] ");  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[arrayFoldedChildren] ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "[arrayFoldedChildren] ");	  Node    emptyStringNode    =    Node.newString(   "[n   ");    	compilable	  [FE]  AssertionFailedError  	133	3	replace
1328	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[arrayFoldedChildren: ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "[arrayFoldedChildren: ");	  Node    emptyStringNode    =    Node.newString(   "[n   ");    	compilable	  [FE]  AssertionFailedError  	133	3	replace
1329	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "[arrayFoldedChildren: ");  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[arrayFoldedChildren: ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "[arrayFoldedChildren: ");	  Node    emptyStringNode    =    Node.newString(   "[n   ");    	compilable	  [FE]  AssertionFailedError  	133	3	replace
1330	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[arrayFoldedChildren.size()  -  1] ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "[arrayFoldedChildren.size()  -  1] ");	  Node    emptyStringNode    =    Node.newString(   "[n   ");    	compilable	  [FE]  AssertionFailedError  	133	3	replace
1331	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "[arrayFoldedChildren.size()  -  1] ");  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[arrayFoldedChildren.size()  -  1] ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "[arrayFoldedChildren.size()  -  1] ");	  Node    emptyStringNode    =    Node.newString(   "[n   ");    	compilable	  [FE]  AssertionFailedError  	133	3	replace
1332	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[node: ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "[node: ");	  Node    emptyStringNode    =    Node.newString(   "[n   ");    	compilable	  [FE]  AssertionFailedError  	133	3	replace
1333	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "[node: ");  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[node: ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "[node: ");	  Node    emptyStringNode    =    Node.newString(   "[n   ");    	compilable	  [FE]  AssertionFailedError  	133	3	replace
1334	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]            AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "RawArray ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "RawArray ");	  Node    emptyStringNode    =    Node.newString(       "Array       ");    Node    emptyStringNode    =    Node.newString(   ".Array       ");    	compilable	  [FE]  AssertionFailedError  	32	3	replace
1335	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "RawArray ");  [FE]  AssertionFailedError  [FE]            AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "RawArray ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "RawArray ");	  Node    emptyStringNode    =    Node.newString(       "Array       ");    Node    emptyStringNode    =    Node.newString(   ".Array       ");    	compilable	  [FE]  AssertionFailedError  	32	3	replace
1336	[BUG]  [BUGGY]  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "replaceChild( ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "replaceChild( ");	  Node    emptyStringNode    =    Node.newString(   "node()   ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	201	3	replace
1337	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "replaceChild( ");  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "replaceChild( ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "replaceChild( ");	  Node    emptyStringNode    =    Node.newString(   "node()   ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	201	3	replace
1338	[BUG]  [BUGGY]  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]      AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "replaceChild( "  +  prev  + ") ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "replaceChild( "  +  prev  + ") ");	  Node    emptyStringNode    =    Node.newString(   "node()   ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	201	3	replace
1339	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "replaceChild( "  +  prev  + ") ");  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]      AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "replaceChild( "  +  prev  + ") ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "replaceChild( "  +  prev  + ") ");	  Node    emptyStringNode    =    Node.newString(   "node()   ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	201	3	replace
1340	[BUG]  [BUGGY]  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]        AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "arrayFoldedChildren()   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "arrayFoldedChildren()   ");	  Node    emptyStringNode    =    Node.newString(   "node()   ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	201	3	replace
1341	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "arrayFoldedChildren()   ");  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]        AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "arrayFoldedChildren()   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "arrayFoldedChildren()   ");	  Node    emptyStringNode    =    Node.newString(   "node()   ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	201	3	replace
1342	[BUG]  [BUGGY]  Node  emptyStringNode  =  arrayFoldedChildren.get(0);  Node  emptyStringNode  =  arrayFoldedChildren.get(n);  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]    java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  Index:  0    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  arrayFoldedChildren.get(0);  Node  emptyStringNode  =  arrayFoldedChildren.get(n);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    arrayFoldedChildren.get(0);    Node  emptyStringNode  =  arrayFoldedChildren.get(n);	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	1	None	add
1343	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "string ").replaceChild(n,  arrayFoldedChildren,  emptyStringNode);  [CE]  method  replaceChild  in  class  Node  cannot  be  applied  to  given  types;  [FE]          AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "string ").replaceChild(n,  arrayFoldedChildren,  emptyStringNode);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "string ").replaceChild(n,  arrayFoldedChildren,  emptyStringNode);	  Node    emptyStringNode    =    Node.newString(   "string   ").replaceChild(n,    arrayFoldedChildren);    	non-compiled	[CE]  method  replaceChild  in  class  Node  cannot  be  applied  to  given  types;	142	None	replace
1344	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[node] "  +  Token.NAME);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "[node] "  +  Token.NAME);	  Node    emptyStringNode    =    Node.newString(   "[node]   ");    	compilable	  [FE]  AssertionFailedError  	176	3	replace
1345	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "[node] "  +  Token.NAME);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[node] "  +  Token.NAME);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "[node] "  +  Token.NAME);	  Node    emptyStringNode    =    Node.newString(   "[node]   ");    	compilable	  [FE]  AssertionFailedError  	176	3	replace
1346	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "[node] ").toString();  [CE]  incompatible  types  [FE]      AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[node] ").toString();  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "[node] ").toString();	  Node    emptyStringNode    =    Node.newString(   "[node]   ");    	non-compiled	[CE]  incompatible  types	176	None	replace
1347	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "Array   ").copyInformationFrom(prev);  Node  emptyStringNode  =  Node.newString(   "Array   ").copyInformationFrom(prev));  [CE]  [FE]    java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "Array   ").copyInformationFrom(prev);  Node  emptyStringNode  =  Node.newString(   "Array   ").copyInformationFrom(prev));  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "Array   ").copyInformationFrom(prev);    Node  emptyStringNode  =  Node.newString(   "Array   ").copyInformationFrom(prev));	  	non-compiled	[CE]  	165	None	add
1348	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]                  AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ".s.IFJDCS ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( ".s.IFJDCS ");	  Node    emptyStringNode    =    Node.newString(       "-       ");    Node    emptyStringNode    =    Node.newString('-');    	compilable	  [FE]  AssertionFailedError  	116	3	replace
1349	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( ".s.IFJDCS ");  [FE]  AssertionFailedError  [FE]                  AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ".s.IFJDCS ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( ".s.IFJDCS ");	  Node    emptyStringNode    =    Node.newString(       "-       ");    Node    emptyStringNode    =    Node.newString('-');    	compilable	  [FE]  AssertionFailedError  	116	3	replace
1350	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(3);  [CE]  no  suitable  method  found  for  newString(int)  [FE]        AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(3);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(3);	  Node    emptyStringNode    =    Node.newString(       "Array       ");    Node    emptyStringNode    =    Node.newString(   ")Array       ");    	non-compiled	[CE]  no  suitable  method  found  for  newString(int)	144	None	replace
1351	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "- "  +  sb);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "- "  +  sb);	  Node    emptyStringNode    =    Node.newString(   "-   "    +    n);    	compilable	  [FE]  AssertionFailedError  	49	3	replace
1352	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "- "  +  sb);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "- "  +  sb);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "- "  +  sb);	  Node    emptyStringNode    =    Node.newString(   "-   "    +    n);    	compilable	  [FE]  AssertionFailedError  	49	3	replace
1353	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "- "  +  oldString);  [CE]  cannot  find  symbol  oldString  [FE]      AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "- "  +  oldString);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "- "  +  oldString);	  Node    emptyStringNode    =    Node.newString(   "-   "    +    n);    	non-compiled	[CE]  cannot  find  symbol  oldString	49	None	replace
1354	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "array-foo.clone ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "array-foo.clone ");	  Node    emptyStringNode    =    Node.newString(   "array-foo.   ");    	compilable	  [FE]  AssertionFailedError  	205	3	replace
1355	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "array-foo.clone ");  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "array-foo.clone ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "array-foo.clone ");	  Node    emptyStringNode    =    Node.newString(   "array-foo.   ");    	compilable	  [FE]  AssertionFailedError  	205	3	replace
1356	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "Arrays.asList(prev) ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "Arrays.asList(prev) ");	  Node    emptyStringNode    =    Node.newString(   "java.util.Arrays.asList(n   ");    	compilable	  [FE]  AssertionFailedError  	151	3	replace
1357	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "Arrays.asList(prev) ");  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "Arrays.asList(prev) ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "Arrays.asList(prev) ");	  Node    emptyStringNode    =    Node.newString(   "java.util.Arrays.asList(n   ");    	compilable	  [FE]  AssertionFailedError  	151	3	replace
1358	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(?   "java.util.ArrayList "  : "  <  null> ");  [CE]  illegal  start  of  expression  [FE]                AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(?   "java.util.ArrayList "  : "  <  null> ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(?   "java.util.ArrayList "  : "  <  null> ");	  Node    emptyStringNode    =    Node.newString(       "java.util.ArrayList       ");    Node    emptyStringNode    =    Node.newString(?   "java.util.ArrayList       ");    	non-compiled	[CE]  illegal  start  of  expression	28	None	replace
1359	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(?   "java.util.ArrayList "  : "  }   ");  [CE]  illegal  start  of  expression  [FE]                  AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(?   "java.util.ArrayList "  : "  }   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(?   "java.util.ArrayList "  : "  }   ");	  Node    emptyStringNode    =    Node.newString(       "java.util.ArrayList       ");    Node    emptyStringNode    =    Node.newString(?   "java.util.ArrayList       ");    	non-compiled	[CE]  illegal  start  of  expression	28	None	replace
1360	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(?   "java.util.ArrayList "  : "  <  unknown> ");  [CE]  illegal  start  of  expression  [FE]                    AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(?   "java.util.ArrayList "  : "  <  unknown> ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(?   "java.util.ArrayList "  : "  <  unknown> ");	  Node    emptyStringNode    =    Node.newString(       "java.util.ArrayList       ");    Node    emptyStringNode    =    Node.newString(?   "java.util.ArrayList       ");    	non-compiled	[CE]  illegal  start  of  expression	28	None	replace
1361	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "array ",  n,  arrayFoldedChildren);  [CE]  no  suitable  method  found  for  newString(String,Node,List<Node>)  [FE]          junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "array ",  n,  arrayFoldedChildren);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "array ",  n,  arrayFoldedChildren);	  Node    emptyStringNode    =    Node.newString(   "array   ",    n);    	non-compiled	[CE]  no  suitable  method  found  for  newString(String,Node,List<Node>)	188	None	replace
1362	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(]  {   "java.util.Arrays.asList( ");  [CE]  illegal  start  of  expression  [FE]        junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(]  {   "java.util.Arrays.asList( ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(]  {   "java.util.Arrays.asList( ");	  Node    emptyStringNode    =    Node.newString(       "java.util.Arrays.asList(       ");    Node    emptyStringNode    =    Node.newString(...   "java.util.Arrays.asList(       ");    	non-compiled	[CE]  illegal  start  of  expression	171	None	replace
1363	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]                  AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ".java.util.ArrayList ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( ".java.util.ArrayList ");	  Node    emptyStringNode    =    Node.newString(       "java.util.ArrayList       ");    Node    emptyStringNode    =    Node.newString(.   "java.util.ArrayList       ");    	compilable	  [FE]  AssertionFailedError  	29	3	replace
1364	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( ".java.util.ArrayList ");  [FE]  AssertionFailedError  [FE]                  AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ".java.util.ArrayList ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( ".java.util.ArrayList ");	  Node    emptyStringNode    =    Node.newString(       "java.util.ArrayList       ");    Node    emptyStringNode    =    Node.newString(.   "java.util.ArrayList       ");    	compilable	  [FE]  AssertionFailedError  	29	3	replace
1365	[BUG]  [BUGGY]  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]                    AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ".Arrays. ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( ".Arrays. ");	  Node    emptyStringNode    =    Node.newString(       "java.util.ArrayList       ");    Node    emptyStringNode    =    Node.newString(.   "java.util.ArrayList       ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	29	3	replace
1366	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( ".Arrays. ");  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]                    AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ".Arrays. ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( ".Arrays. ");	  Node    emptyStringNode    =    Node.newString(       "java.util.ArrayList       ");    Node    emptyStringNode    =    Node.newString(.   "java.util.ArrayList       ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	29	3	replace
1367	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "Arrays.asList(   ");  Node  emptyStringNode  =  Node.newString(Arrays.asList(   ");  [CE]  unclosed  string  literal  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "Arrays.asList(   ");  Node  emptyStringNode  =  Node.newString(Arrays.asList(   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "Arrays.asList(   ");    Node  emptyStringNode  =  Node.newString(Arrays.asList(   ");	  	non-compiled	[CE]  unclosed  string  literal	51	None	add
1368	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "Arrays.string ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "Arrays.string ");	  Node    emptyStringNode    =    Node.newString(       "string       ");    Node    emptyStringNode    =    Node.newString(   ".string       ");    	compilable	  [FE]  AssertionFailedError  	88	3	replace
1369	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "Arrays.string ");  [FE]  AssertionFailedError  [FE]          AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "Arrays.string ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "Arrays.string ");	  Node    emptyStringNode    =    Node.newString(       "string       ");    Node    emptyStringNode    =    Node.newString(   ".string       ");    	compilable	  [FE]  AssertionFailedError  	88	3	replace
1370	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.EMPTY,  functionName);  [CE]  no  suitable  method  found  for  newString(int,Node)  [FE]          junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.EMPTY,  functionName);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(Token.EMPTY,  functionName);	  Node    emptyStringNode    =    Node.newString(Token.EMPTY);    	non-compiled	[CE]  no  suitable  method  found  for  newString(int,Node)	137	None	replace
1371	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.EMPTY,  name);  [CE]  cannot  find  symbol  name  [FE]            junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.EMPTY,  name);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(Token.EMPTY,  name);	  Node    emptyStringNode    =    Node.newString(Token.EMPTY);    	non-compiled	[CE]  cannot  find  symbol  name	137	None	replace
1372	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "Join.ArrayBuilder   ");  Node  emptyStringNode  =  Node.newString( ",Join.ArrayBuilder   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]    junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "Join.ArrayBuilder   ");  Node  emptyStringNode  =  Node.newString( ",Join.ArrayBuilder   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "Join.ArrayBuilder   ");    Node  emptyStringNode  =  Node.newString( ",Join.ArrayBuilder   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	104	None	add
1373	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "org.join.ArrayElement ").toString();  [CE]  incompatible  types  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "org.join.ArrayElement ").toString();  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "org.join.ArrayElement ").toString();	  Node    emptyStringNode    =    Node.newString(   "org.join.ArrayElement   ");    	non-compiled	[CE]  incompatible  types	195	None	replace
1374	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "java.util.ArrayListn   ");  Node  emptyStringNode  =  Node.newString( ")java.util.ArrayListn   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]    junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "java.util.ArrayListn   ");  Node  emptyStringNode  =  Node.newString( ")java.util.ArrayListn   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "java.util.ArrayListn   ");    Node  emptyStringNode  =  Node.newString( ")java.util.ArrayListn   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	129	None	add
1375	[BUG]  [BUGGY]  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]    junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "JoinArraybuilder ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "JoinArraybuilder ");	  Node    emptyStringNode    =    Node.newString(   "JoinArrayBuilder   ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	103	3	replace
1376	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "JoinArraybuilder ");  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]    junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "JoinArraybuilder ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "JoinArraybuilder ");	  Node    emptyStringNode    =    Node.newString(   "JoinArrayBuilder   ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	103	3	replace
1377	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "JoinArrayBuilder ").toString();  [CE]  incompatible  types  [FE]      junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "JoinArrayBuilder ").toString();  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "JoinArrayBuilder ").toString();	  Node    emptyStringNode    =    Node.newString(   "JoinArrayBuilder   ");    	non-compiled	[CE]  incompatible  types	103	None	replace
1378	[BUG]  [BUGGY]  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "array-Join ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "array-Join ");	  Node    emptyStringNode    =    Node.newString(   "arrayJoin   ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	71	3	replace
1379	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "array-Join ");  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "array-Join ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "array-Join ");	  Node    emptyStringNode    =    Node.newString(   "arrayJoin   ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	71	3	replace
1380	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "array_Join ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "array_Join ");	  Node    emptyStringNode    =    Node.newString(   "arrayJoin   ");    	compilable	  [FE]  AssertionFailedError  	71	3	replace
1381	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "array_Join ");  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "array_Join ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "array_Join ");	  Node    emptyStringNode    =    Node.newString(   "arrayJoin   ");    	compilable	  [FE]  AssertionFailedError  	71	3	replace
1382	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "node() "));  [CE]  [FE]            AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "node() "));  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "node() "));	  Node    emptyStringNode    =    Node.newString(       "n       ");    Node    emptyStringNode    =    Node.newString(   "n   "));    	non-compiled	[CE]  	18	None	replace
1383	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]              AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "infinity ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "infinity ");	  Node    emptyStringNode    =    Node.newString(       "n       ");    Node    emptyStringNode    =    Node.newString(   "n   "));    	compilable	  [FE]  AssertionFailedError  	18	3	replace
1384	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "infinity ");  [FE]  AssertionFailedError  [FE]              AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "infinity ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "infinity ");	  Node    emptyStringNode    =    Node.newString(       "n       ");    Node    emptyStringNode    =    Node.newString(   "n   "));    	compilable	  [FE]  AssertionFailedError  	18	3	replace
1385	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "[0] ").replaceChild(n,  prev);  [CE]  incompatible  types  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[0] ").replaceChild(n,  prev);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "[0] ").replaceChild(n,  prev);	  Node    emptyStringNode    =    Node.newString(   "[0]   ");    	non-compiled	[CE]  incompatible  types	63	None	replace
1386	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "[0] ").replaceChild(n,  foldedSize);  [CE]  method  replaceChild  in  class  Node  cannot  be  applied  to  given  types;  [FE]      AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[0] ").replaceChild(n,  foldedSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "[0] ").replaceChild(n,  foldedSize);	  Node    emptyStringNode    =    Node.newString(   "[0]   ");    	non-compiled	[CE]  method  replaceChild  in  class  Node  cannot  be  applied  to  given  types;	63	None	replace
1387	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "- ".getBytes());  [CE]  no  suitable  method  found  for  newString(byte[])  [FE]        AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "- ".getBytes());  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "- ".getBytes());	  Node    emptyStringNode    =    Node.newString(       "-       ");    Node    emptyStringNode    =    Node.newString(   "-       ");    	non-compiled	[CE]  no  suitable  method  found  for  newString(byte[])	111	None	replace
1388	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "array_foo ",  sb.toString());  [CE]  no  suitable  method  found  for  newString(String,String)  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "array_foo ",  sb.toString());  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "array_foo ",  sb.toString());	  Node    emptyStringNode    =    Node.newString(   "array_foo   ");    	non-compiled	[CE]  no  suitable  method  found  for  newString(String,String)	203	None	replace
1389	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "array_foo ",  arrayFoldedChildren.size()  -  1);  [CE]  no  suitable  method  found  for  newString(String,int)  [FE]      AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "array_foo ",  arrayFoldedChildren.size()  -  1);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "array_foo ",  arrayFoldedChildren.size()  -  1);	  Node    emptyStringNode    =    Node.newString(   "array_foo   ");    	non-compiled	[CE]  no  suitable  method  found  for  newString(String,int)	203	None	replace
1390	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "array_foo ",  prev);  [CE]  no  suitable  method  found  for  newString(String,Node)  [FE]        AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "array_foo ",  prev);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "array_foo ",  prev);	  Node    emptyStringNode    =    Node.newString(   "array_foo   ");    	non-compiled	[CE]  no  suitable  method  found  for  newString(String,Node)	203	None	replace
1391	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "array_foo ",  arrayFoldedChildren.size());  [CE]  no  suitable  method  found  for  newString(String,int)  [FE]          AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "array_foo ",  arrayFoldedChildren.size());  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "array_foo ",  arrayFoldedChildren.size());	  Node    emptyStringNode    =    Node.newString(   "array_foo   ");    	non-compiled	[CE]  no  suitable  method  found  for  newString(String,int)	203	None	replace
1392	[BUG]  [BUGGY]  Node  emptyStringNode  =  arrayFoldedChildren.get(var);  [CE]  cannot  find  symbol  var  [FE]                            junit.framework.AssertionFailedError:  Expected:  x=[     "a     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  arrayFoldedChildren.get(var);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  arrayFoldedChildren.get(var);	  Node    emptyStringNode    =    arrayFoldedChildren.get(i);    	non-compiled	[CE]  cannot  find  symbol  var	3	None	replace
1393	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList( ",  arrayFoldedChildren.size()  -  1);  [CE]  no  suitable  method  found  for  newString(String,int)  [FE]            junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList( ",  arrayFoldedChildren.size()  -  1);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList( ",  arrayFoldedChildren.size()  -  1);	  Node    emptyStringNode    =    Node.newString(       "java.util.Arrays.asList(       ");    Node    emptyStringNode    =    Node.newString(   ".java.util.Arrays.asList(       ");    	non-compiled	[CE]  no  suitable  method  found  for  newString(String,int)	78	None	replace
1394	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]              junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "org.join.Arrays.asList( ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "org.join.Arrays.asList( ");	  Node    emptyStringNode    =    Node.newString(       "java.util.Arrays.asList(       ");    Node    emptyStringNode    =    Node.newString(   ".java.util.Arrays.asList(       ");    	compilable	  [FE]  AssertionFailedError  	78	3	replace
1395	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "org.join.Arrays.asList( ");  [FE]  AssertionFailedError  [FE]              junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "org.join.Arrays.asList( ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "org.join.Arrays.asList( ");	  Node    emptyStringNode    =    Node.newString(       "java.util.Arrays.asList(       ");    Node    emptyStringNode    =    Node.newString(   ".java.util.Arrays.asList(       ");    	compilable	  [FE]  AssertionFailedError  	78	3	replace
1396	[BUG]  [BUGGY]  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]                junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays. ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "java.util.Arrays. ");	  Node    emptyStringNode    =    Node.newString(       "java.util.Arrays.asList(       ");    Node    emptyStringNode    =    Node.newString(   ".java.util.Arrays.asList(       ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	78	3	replace
1397	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays. ");  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]                junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays. ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "java.util.Arrays. ");	  Node    emptyStringNode    =    Node.newString(       "java.util.Arrays.asList(       ");    Node    emptyStringNode    =    Node.newString(   ".java.util.Arrays.asList(       ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	78	3	replace
1398	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "-   "  +  n);  Node  emptyStringNode  =  Node.newString( ")-   "  +  n);  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "-   "  +  n);  Node  emptyStringNode  =  Node.newString( ")-   "  +  n);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "-   "    +    n);    Node  emptyStringNode  =  Node.newString( ")-   "  +  n);	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	48	None	add
1399	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "[0]   ");  Node  emptyStringNode  =  Node.newString( ")[0]   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "[0]   ");  Node  emptyStringNode  =  Node.newString( ")[0]   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "[0]   ");    Node  emptyStringNode  =  Node.newString( ")[0]   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	62	None	add
1400	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "array_name   ");  Node  emptyStringNode  =  Node.newString( "array_name ",  n);  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "array_name   ");  Node  emptyStringNode  =  Node.newString( "array_name ",  n);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "array_name   ");    Node  emptyStringNode  =  Node.newString( "array_name ",  n);	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	72	None	add
1401	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME,  foldedSize  -  originalSize);  [CE]  no  suitable  method  found  for  newString(int,int)  [FE]              AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME,  foldedSize  -  originalSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(Token.NAME,  foldedSize  -  originalSize);	  Node    emptyStringNode    =    Node.newString(Token.NAME,    originalSize);    	non-compiled	[CE]  no  suitable  method  found  for  newString(int,int)	61	None	replace
1402	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "[Locale.US] ").replaceChild(n,  foldedStringNode);  [CE]  cannot  find  symbol  foldedStringNode  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[Locale.US] ").replaceChild(n,  foldedStringNode);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "[Locale.US] ").replaceChild(n,  foldedStringNode);	  Node    emptyStringNode    =    Node.newString(   "[Locale.US]   ");    	non-compiled	[CE]  cannot  find  symbol  foldedStringNode	65	None	replace
1403	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "[Locale.US] ").replaceChild(n,  prev);  [CE]  incompatible  types  [FE]      AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[Locale.US] ").replaceChild(n,  prev);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "[Locale.US] ").replaceChild(n,  prev);	  Node    emptyStringNode    =    Node.newString(   "[Locale.US]   ");    	non-compiled	[CE]  incompatible  types	65	None	replace
1404	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "[Locale.US] "  +  Token.name(prev));  [CE]  method  name  in  class  Token  cannot  be  applied  to  given  types;  [FE]        AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[Locale.US] "  +  Token.name(prev));  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "[Locale.US] "  +  Token.name(prev));	  Node    emptyStringNode    =    Node.newString(   "[Locale.US]   ");    	non-compiled	[CE]  method  name  in  class  Token  cannot  be  applied  to  given  types;	65	None	replace
1405	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "[Locale.US] ").replaceChild(n,  foldedSize);  [CE]  method  replaceChild  in  class  Node  cannot  be  applied  to  given  types;  [FE]          AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[Locale.US] ").replaceChild(n,  foldedSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "[Locale.US] ").replaceChild(n,  foldedSize);	  Node    emptyStringNode    =    Node.newString(   "[Locale.US]   ");    	non-compiled	[CE]  method  replaceChild  in  class  Node  cannot  be  applied  to  given  types;	65	None	replace
1406	[BUG]  [BUGGY]  Node  emptyStringNode  =  arrayFoldedChildren.remove(0);  Node  emptyStringNode  =  arrayFoldedChildren.remove(child);  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]    java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  Index:  0    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  arrayFoldedChildren.remove(0);  Node  emptyStringNode  =  arrayFoldedChildren.remove(child);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    arrayFoldedChildren.remove(0);    Node  emptyStringNode  =  arrayFoldedChildren.remove(child);	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	5	None	add
1407	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "array-name ").replaceChild(n,  arrayFoldedChildren);  [CE]  method  replaceChild  in  class  Node  cannot  be  applied  to  given  types;  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "array-name ").replaceChild(n,  arrayFoldedChildren);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "array-name ").replaceChild(n,  arrayFoldedChildren);	  Node    emptyStringNode    =    Node.newString(   "array-name   ");    	non-compiled	[CE]  method  replaceChild  in  class  Node  cannot  be  applied  to  given  types;	75	None	replace
1408	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "array-name ",  sb.toString());  [CE]  no  suitable  method  found  for  newString(String,String)  [FE]      AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "array-name ",  sb.toString());  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "array-name ",  sb.toString());	  Node    emptyStringNode    =    Node.newString(   "array-name   ");    	non-compiled	[CE]  no  suitable  method  found  for  newString(String,String)	75	None	replace
1409	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "array-name ").replaceChild(n,  prev);  [CE]  incompatible  types  [FE]        AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "array-name ").replaceChild(n,  prev);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "array-name ").replaceChild(n,  prev);	  Node    emptyStringNode    =    Node.newString(   "array-name   ");    	non-compiled	[CE]  incompatible  types	75	None	replace
1410	[BUG]  [BUGGY]  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('  [FE]    java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "string "  +  sb.toString()).copyInformationFrom(prev);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "string "  +  sb.toString()).copyInformationFrom(prev);	  Node    emptyStringNode    =    Node.newString(   "string   "    +    sb.toString());    	compilable	  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('  	109	3	replace
1411	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "string "  +  sb.toString()).copyInformationFrom(prev);  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('  [FE]    java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "string "  +  sb.toString()).copyInformationFrom(prev);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "string "  +  sb.toString()).copyInformationFrom(prev);	  Node    emptyStringNode    =    Node.newString(   "string   "    +    sb.toString());    	compilable	  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('  	109	3	replace
1412	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "string ").replaceChild(n,  new  StringBuilder(sb),  new  StringBuilder());  [CE]  method  replaceChild  in  class  Node  cannot  be  applied  to  given  types;  [FE]        AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "string ").replaceChild(n,  new  StringBuilder(sb),  new  StringBuilder());  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "string ").replaceChild(n,  new  StringBuilder(sb),  new  StringBuilder());	  Node    emptyStringNode    =    Node.newString(   "string   ").replaceChild(n,    new    StringBuilder());    	non-compiled	[CE]  method  replaceChild  in  class  Node  cannot  be  applied  to  given  types;	196	None	replace
1413	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "string ").replaceChild(n,  new  StringBuilder(length()  -  1));  [CE]  cannot  find  symbol  [FE]          AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "string ").replaceChild(n,  new  StringBuilder(length()  -  1));  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "string ").replaceChild(n,  new  StringBuilder(length()  -  1));	  Node    emptyStringNode    =    Node.newString(   "string   ").replaceChild(n,    new    StringBuilder());    	non-compiled	[CE]  cannot  find  symbol	196	None	replace
1414	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.ArrayBuilder ").join(n  [CE]  [FE]        junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.ArrayBuilder ").join(n  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "java.util.ArrayBuilder ").join(n	  Node    emptyStringNode    =    Node.newString(   "java.util.ArrayBuilder   ").join(   "    	non-compiled	[CE]  	206	None	replace
1415	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.ArrayBuilder ").join('  [CE]  illegal  line  end  in  character  literal  [FE]          junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.ArrayBuilder ").join('  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "java.util.ArrayBuilder ").join('	  Node    emptyStringNode    =    Node.newString(   "java.util.ArrayBuilder   ").join(   "    	non-compiled	[CE]  illegal  line  end  in  character  literal	206	None	replace
1416	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "- ").replaceChild(n,  prev,  type);  [CE]  cannot  find  symbol  type  [FE]          AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "- ").replaceChild(n,  prev,  type);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "- ").replaceChild(n,  prev,  type);	  Node    emptyStringNode    =    Node.newString(   "-   ").replaceChild(n,    prev);    	non-compiled	[CE]  cannot  find  symbol  type	185	None	replace
1417	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "- ").replaceChild(n,  sb);  [CE]  method  replaceChild  in  class  Node  cannot  be  applied  to  given  types;  [FE]            AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "- ").replaceChild(n,  sb);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "- ").replaceChild(n,  sb);	  Node    emptyStringNode    =    Node.newString(   "-   ").replaceChild(n,    prev);    	non-compiled	[CE]  method  replaceChild  in  class  Node  cannot  be  applied  to  given  types;	185	None	replace
1418	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(... ", "Array ");  [CE]  illegal  start  of  expression  [FE]                AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(... ", "Array ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(... ", "Array ");	  Node    emptyStringNode    =    Node.newString(       "Array       ");    Node    emptyStringNode    =    Node.newString(...   "Array       ");    	non-compiled	[CE]  illegal  start  of  expression	34	None	replace
1419	[BUG]  [BUGGY]  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('  [FE]    java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[ "  +  sb.toString()  +  2);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "[ "  +  sb.toString()  +  2);	  Node    emptyStringNode    =    Node.newString(   "[   "    +    sb.toString());    	compilable	  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('  	180	3	replace
1420	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "[ "  +  sb.toString()  +  2);  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('  [FE]    java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[ "  +  sb.toString()  +  2);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "[ "  +  sb.toString()  +  2);	  Node    emptyStringNode    =    Node.newString(   "[   "    +    sb.toString());    	compilable	  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('  	180	3	replace
1421	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( ", ",Arrays.asList(originalSize);  [CE]  [FE]              junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ", ",Arrays.asList(originalSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( ", ",Arrays.asList(originalSize);	  Node    emptyStringNode    =    Node.newString(       "java.util.Arrays.asList(       ");    Node    emptyStringNode    =    Node.newString(   ",java.util.Arrays.asList(       ");    	non-compiled	[CE]  	79	None	replace
1422	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]                junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ";java.util.Arrays.asList( ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( ";java.util.Arrays.asList( ");	  Node    emptyStringNode    =    Node.newString(       "java.util.Arrays.asList(       ");    Node    emptyStringNode    =    Node.newString(   ",java.util.Arrays.asList(       ");    	compilable	  [FE]  AssertionFailedError  	79	3	replace
1423	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( ";java.util.Arrays.asList( ");  [FE]  AssertionFailedError  [FE]                junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ";java.util.Arrays.asList( ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( ";java.util.Arrays.asList( ");	  Node    emptyStringNode    =    Node.newString(       "java.util.Arrays.asList(       ");    Node    emptyStringNode    =    Node.newString(   ",java.util.Arrays.asList(       ");    	compilable	  [FE]  AssertionFailedError  	79	3	replace
1424	[BUG]  [BUGGY]  [FE]  junit.framework.AssertionFailedError:  Expected:  x= " "  Result:  x= "  [FE]              junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ",arrayFoldedChildren ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( ",arrayFoldedChildren ");	  Node    emptyStringNode    =    Node.newString(       "array       ");    Node    emptyStringNode    =    Node.newString(   ",array       ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x= " "  Result:  x= "  	15	3	replace
1425	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( ",arrayFoldedChildren ");  [FE]  junit.framework.AssertionFailedError:  Expected:  x= " "  Result:  x= "  [FE]              junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ",arrayFoldedChildren ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( ",arrayFoldedChildren ");	  Node    emptyStringNode    =    Node.newString(       "array       ");    Node    emptyStringNode    =    Node.newString(   ",array       ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x= " "  Result:  x= "  	15	3	replace
1426	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "Array ").copyInformationFrom(arrayFoldedChildren);  [CE]  method  copyInformationFrom  in  class  Node  cannot  be  applied  to  given  types;  [FE]    java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "Array ").copyInformationFrom(arrayFoldedChildren);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "Array ").copyInformationFrom(arrayFoldedChildren);	  Node    emptyStringNode    =    Node.newString(   "Array   ").copyInformationFrom(prev);    	non-compiled	[CE]  method  copyInformationFrom  in  class  Node  cannot  be  applied  to  given  types;	166	None	replace
1427	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(sb.toString()).copyInformationFrom(originalSize);  [CE]  method  copyInformationFrom  in  class  Node  cannot  be  applied  to  given  types;  [FE]      java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(sb.toString()).copyInformationFrom(originalSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(sb.toString()).copyInformationFrom(originalSize);	  Node    emptyStringNode    =    Node.newString(   "Array   ").copyInformationFrom(prev);    	non-compiled	[CE]  method  copyInformationFrom  in  class  Node  cannot  be  applied  to  given  types;	166	None	replace
1428	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "Array ").copyInformationFrom(removedSize);  [CE]  cannot  find  symbol  removedSize  [FE]        java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "Array ").copyInformationFrom(removedSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "Array ").copyInformationFrom(removedSize);	  Node    emptyStringNode    =    Node.newString(   "Array   ").copyInformationFrom(prev);    	non-compiled	[CE]  cannot  find  symbol  removedSize	166	None	replace
1429	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(R.string.remove(originalSize));  [CE]  package  R  does  not  exist  [FE]                AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(R.string.remove(originalSize));  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(R.string.remove(originalSize));	  Node    emptyStringNode    =    Node.newString(       "-       ");    Node    emptyStringNode    =    Node.newString(?   "-       ");    	non-compiled	[CE]  package  R  does  not  exist	115	None	replace
1430	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(-1);  [CE]  no  suitable  method  found  for  newString(int)  [FE]                  AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(-1);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(-1);	  Node    emptyStringNode    =    Node.newString(       "-       ");    Node    emptyStringNode    =    Node.newString(?   "-       ");    	non-compiled	[CE]  no  suitable  method  found  for  newString(int)	115	None	replace
1431	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "org.joda.ArrayElement ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "org.joda.ArrayElement ");	  Node    emptyStringNode    =    Node.newString(       "java.util.ArrayElement       ");    Node    emptyStringNode    =    Node.newString(   ".java.util.ArrayElement       ");    	compilable	  [FE]  AssertionFailedError  	21	3	replace
1432	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "org.joda.ArrayElement ");  [FE]  AssertionFailedError  [FE]          junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "org.joda.ArrayElement ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "org.joda.ArrayElement ");	  Node    emptyStringNode    =    Node.newString(       "java.util.ArrayElement       ");    Node    emptyStringNode    =    Node.newString(   ".java.util.ArrayElement       ");    	compilable	  [FE]  AssertionFailedError  	21	3	replace
1433	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "java.util.ArrayBuilders   ");  Node  emptyStringNode  =  Node.newString(java.util.ArrayBuilders   ");  [CE]  unclosed  string  literal  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "java.util.ArrayBuilders   ");  Node  emptyStringNode  =  Node.newString(java.util.ArrayBuilders   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "java.util.ArrayBuilders   ");    Node  emptyStringNode  =  Node.newString(java.util.ArrayBuilders   ");	  	non-compiled	[CE]  unclosed  string  literal	169	None	add
1434	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "arrayJoin   ");  Node  emptyStringNode  =  Node.newString( ")arrayJoin   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "arrayJoin   ");  Node  emptyStringNode  =  Node.newString( ")arrayJoin   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "arrayJoin   ");    Node  emptyStringNode  =  Node.newString( ")arrayJoin   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	70	None	add
1435	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[a-z] "  +  Token.NAME);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "[a-z] "  +  Token.NAME);	  Node    emptyStringNode    =    Node.newString(   "[a-z]   ");    	compilable	  [FE]  AssertionFailedError  	178	3	replace
1436	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "[a-z] "  +  Token.NAME);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[a-z] "  +  Token.NAME);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "[a-z] "  +  Token.NAME);	  Node    emptyStringNode    =    Node.newString(   "[a-z]   ");    	compilable	  [FE]  AssertionFailedError  	178	3	replace
1437	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "Array "  +  inlineCostEstimator);  [CE]  cannot  find  symbol  inlineCostEstimator  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "Array "  +  inlineCostEstimator);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "Array "  +  inlineCostEstimator);	  Node    emptyStringNode    =    Node.newString(   "Array   "    +    originalSize);    	non-compiled	[CE]  cannot  find  symbol  inlineCostEstimator	118	None	replace
1438	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]            junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ";ArrayElement ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( ";ArrayElement ");	  Node    emptyStringNode    =    Node.newString(       "java.util.ArrayElement       ");    Node    emptyStringNode    =    Node.newString(   ",java.util.ArrayElement       ");    	compilable	  [FE]  AssertionFailedError  	22	3	replace
1439	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( ";ArrayElement ");  [FE]  AssertionFailedError  [FE]            junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ";ArrayElement ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( ";ArrayElement ");	  Node    emptyStringNode    =    Node.newString(       "java.util.ArrayElement       ");    Node    emptyStringNode    =    Node.newString(   ",java.util.ArrayElement       ");    	compilable	  [FE]  AssertionFailedError  	22	3	replace
1440	[BUG]  [BUGGY]  n.removeChild(arrayFoldedChildren,  first);  [CE]  cannot  find  symbol  first  [FE]                          junit.framework.AssertionFailedError:  Expected:  x=[     "a     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  n.removeChild(arrayFoldedChildren,  first);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	n.removeChild(arrayFoldedChildren,  first);	  n.removeChild(arrayFoldedChildren);    	non-compiled	[CE]  cannot  find  symbol  first	186	None	replace
1441	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME,   "ArrayBuilder   ");  n.getParent().removeChild(arrayFoldedChildren.size()  -  1);  [CE]  method  removeChild  in  class  Node  cannot  be  applied  to  given  types;  [FE]    junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME,   "ArrayBuilder   ");  n.getParent().removeChild(arrayFoldedChildren.size()  -  1);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(Token.NAME,   "ArrayBuilder   ");    n.getParent().removeChild(arrayFoldedChildren.size()  -  1);	  	non-compiled	[CE]  method  removeChild  in  class  Node  cannot  be  applied  to  given  types;	167	None	add
1442	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME,   "ArrayBuilder   ");  n.getParent().removeChild(prev);  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]      junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME,   "ArrayBuilder   ");  n.getParent().removeChild(prev);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(Token.NAME,   "ArrayBuilder   ");    n.getParent().removeChild(prev);	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	167	None	add
1443	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME,   "]   ");  Node  emptyStringNode  =  Node.newString(Token.NAME,   "], ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]    junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME,   "]   ");  Node  emptyStringNode  =  Node.newString(Token.NAME,   "], ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(Token.NAME,   "]   ");    Node  emptyStringNode  =  Node.newString(Token.NAME,   "], ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	156	None	add
1444	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME,   "]   ");  Node  emptyStringNode  =  Node.newString(Token.NAME,   "] ",  null);  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]      junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME,   "]   ");  Node  emptyStringNode  =  Node.newString(Token.NAME,   "] ",  null);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(Token.NAME,   "]   ");    Node  emptyStringNode  =  Node.newString(Token.NAME,   "] ",  null);	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	156	None	add
1445	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "org.join.ArrayElement   ");  Node  emptyStringNode  =  Node.newString(. "org.join.ArrayElement   ");  [CE]  illegal  start  of  expression  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "org.join.ArrayElement   ");  Node  emptyStringNode  =  Node.newString(. "org.join.ArrayElement   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "org.join.ArrayElement   ");    Node  emptyStringNode  =  Node.newString(. "org.join.ArrayElement   ");	  	non-compiled	[CE]  illegal  start  of  expression	194	None	add
1446	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "Arrays.asList( ",  arrayFoldedChildren);  [CE]  no  suitable  method  found  for  newString(String,List<Node>)  [FE]                junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "Arrays.asList( ",  arrayFoldedChildren);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "Arrays.asList( ",  arrayFoldedChildren);	  Node    emptyStringNode    =    Node.newString(       "java.util.Arrays.asList(       ");    Node    emptyStringNode    =    Node.newString(   "java.util.Arrays.asList(   ",);    	non-compiled	[CE]  no  suitable  method  found  for  newString(String,List<Node>)	80	None	replace
1447	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList( ",  arrayFoldedChildren);  [CE]  no  suitable  method  found  for  newString(String,List<Node>)  [FE]                  junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList( ",  arrayFoldedChildren);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList( ",  arrayFoldedChildren);	  Node    emptyStringNode    =    Node.newString(       "java.util.Arrays.asList(       ");    Node    emptyStringNode    =    Node.newString(   "java.util.Arrays.asList(   ",);    	non-compiled	[CE]  no  suitable  method  found  for  newString(String,List<Node>)	80	None	replace
1448	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "[A-Z] ").toString();  [CE]  incompatible  types  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[A-Z] ").toString();  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "[A-Z] ").toString();	  Node    emptyStringNode    =    Node.newString(   "[A-Z]   ");    	non-compiled	[CE]  incompatible  types	67	None	replace
1449	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "array-length ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "array-length ");	  Node    emptyStringNode    =    Node.newString(       "string       ");    Node    emptyStringNode    =    Node.newString(   "string       ");    	compilable	  [FE]  AssertionFailedError  	87	3	replace
1450	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "array-length ");  [FE]  AssertionFailedError  [FE]        AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "array-length ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "array-length ");	  Node    emptyStringNode    =    Node.newString(       "string       ");    Node    emptyStringNode    =    Node.newString(   "string       ");    	compilable	  [FE]  AssertionFailedError  	87	3	replace
1451	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(. " ");  [CE]  illegal  start  of  expression  [FE]        AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(. " ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(. " ");	  Node    emptyStringNode    =    Node.newString(       "n       ");    Node    emptyStringNode    =    Node.newString(.   "n       ");    	non-compiled	[CE]  illegal  start  of  expression	134	None	replace
1452	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(1)-  1;  [CE]  no  suitable  method  found  for  newString(int)  [FE]        AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(1)-  1;  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(1)-  1;	  Node    emptyStringNode    =    Node.newString(       "-       ");    Node    emptyStringNode    =    Node.newString(   ")-       ");    	non-compiled	[CE]  no  suitable  method  found  for  newString(int)	197	None	replace
1453	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "]   "  +  Token.NAME);  Node  emptyStringNode  =  Node.newString( ")]   "  +  Token.NAME);  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "]   "  +  Token.NAME);  Node  emptyStringNode  =  Node.newString( ")]   "  +  Token.NAME);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "]   "    +    Token.NAME);    Node  emptyStringNode  =  Node.newString( ")]   "  +  Token.NAME);	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	153	None	add
1454	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "string ").replaceChild(n,  prev,  oldPosition);  [CE]  cannot  find  symbol  oldPosition  [FE]        AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "string ").replaceChild(n,  prev,  oldPosition);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "string ").replaceChild(n,  prev,  oldPosition);	  Node    emptyStringNode    =    Node.newString(   "string   ").replaceChild(n,    prev);    	non-compiled	[CE]  cannot  find  symbol  oldPosition	141	None	replace
1455	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "-   "  +  originalSize);  Node  emptyStringNode  =  Node.newString( ")-   "  +  originalSize);  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "-   "  +  originalSize);  Node  emptyStringNode  =  Node.newString( ")-   "  +  originalSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "-   "    +    originalSize);    Node  emptyStringNode  =  Node.newString( ")-   "  +  originalSize);	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	44	None	add
1456	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "[AssertionFailed] ").replaceChild(n,  foldedSize);  [CE]  method  replaceChild  in  class  Node  cannot  be  applied  to  given  types;  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[AssertionFailed] ").replaceChild(n,  foldedSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "[AssertionFailed] ").replaceChild(n,  foldedSize);	  Node    emptyStringNode    =    Node.newString(   "[AssertionFailedError]   ");    	non-compiled	[CE]  method  replaceChild  in  class  Node  cannot  be  applied  to  given  types;	69	None	replace
1457	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "[AssertionFailed] "  +  Token.name(prev));  [CE]  method  name  in  class  Token  cannot  be  applied  to  given  types;  [FE]      AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[AssertionFailed] "  +  Token.name(prev));  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "[AssertionFailed] "  +  Token.name(prev));	  Node    emptyStringNode    =    Node.newString(   "[AssertionFailedError]   ");    	non-compiled	[CE]  method  name  in  class  Token  cannot  be  applied  to  given  types;	69	None	replace
1458	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[AssertionFailed] "  +  prev);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "[AssertionFailed] "  +  prev);	  Node    emptyStringNode    =    Node.newString(   "[AssertionFailedError]   ");    	compilable	  [FE]  AssertionFailedError  	69	3	replace
1459	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "[AssertionFailed] "  +  prev);  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[AssertionFailed] "  +  prev);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "[AssertionFailed] "  +  prev);	  Node    emptyStringNode    =    Node.newString(   "[AssertionFailedError]   ");    	compilable	  [FE]  AssertionFailedError  	69	3	replace
1460	[BUG]  [BUGGY]  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('  [FE]          AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[AssertionFailed] "  +  sb.toString());  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "[AssertionFailed] "  +  sb.toString());	  Node    emptyStringNode    =    Node.newString(   "[AssertionFailedError]   ");    	compilable	  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('  	69	3	replace
1461	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "[AssertionFailed] "  +  sb.toString());  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('  [FE]          AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[AssertionFailed] "  +  sb.toString());  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "[AssertionFailed] "  +  sb.toString());	  Node    emptyStringNode    =    Node.newString(   "[AssertionFailedError]   ");    	compilable	  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('  	69	3	replace
1462	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "- "  +  Token.NAME,  arrayFoldedChildren.size());  [CE]  no  suitable  method  found  for  newString(String,int)  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "- "  +  Token.NAME,  arrayFoldedChildren.size());  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "- "  +  Token.NAME,  arrayFoldedChildren.size());	  Node    emptyStringNode    =    Node.newString(   "-   "    +    Token.NAME);    	non-compiled	[CE]  no  suitable  method  found  for  newString(String,int)	164	None	replace
1463	[BUG]  [BUGGY]  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "Element ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "Element ");	  Node    emptyStringNode    =    Node.newString(   "ArrayElement   ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	37	3	replace
1464	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "Element ");  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "Element ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "Element ");	  Node    emptyStringNode    =    Node.newString(   "ArrayElement   ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	37	3	replace
1465	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "[a-z]   ");  Node  emptyStringNode  =  Node.newString( ")[a-z]   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "[a-z]   ");  Node  emptyStringNode  =  Node.newString( ")[a-z]   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "[a-z]   ");    Node  emptyStringNode  =  Node.newString( ")[a-z]   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	177	None	add
1466	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "Arrays.asList( "),  arrayFoldedChildren);  [CE]  [FE]          junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "Arrays.asList( "),  arrayFoldedChildren);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "Arrays.asList( "),  arrayFoldedChildren);	  Node    emptyStringNode    =    Node.newString(   "java.util.Arrays.asList(   "),    arrayFoldedChildren);    	non-compiled	[CE]  	152	None	replace
1467	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList( "  +  prev  + "),  arrayFoldedChildren);  [CE]  unclosed  string  literal  [FE]            junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList( "  +  prev  + "),  arrayFoldedChildren);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "java.util.Arrays.asList( "  +  prev  + "),  arrayFoldedChildren);	  Node    emptyStringNode    =    Node.newString(   "java.util.Arrays.asList(   "),    arrayFoldedChildren);    	non-compiled	[CE]  unclosed  string  literal	152	None	replace
1468	[BUG]  [BUGGY]  int  kJoinOverhead  =  InlineCostEstimator.getCost(n,  originalSize);  [CE]  cannot  find  symbol  emptyStringNode  [FE]                            junit.framework.AssertionFailedError:  Expected:  x=[     "a     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  int  kJoinOverhead  =  InlineCostEstimator.getCost(n,  originalSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	int  kJoinOverhead  =  InlineCostEstimator.getCost(n,  originalSize);	  int    kJoinOverhead    =    InlineCostEstimator.getCost(n);    	non-compiled	[CE]  cannot  find  symbol  emptyStringNode	148	None	replace
1469	[BUG]  [BUGGY]  int  kJoinOverhead  =  InlineCostEstimator.getCost(n,  initialSize);  [CE]  cannot  find  symbol  initialSize  [FE]                              junit.framework.AssertionFailedError:  Expected:  x=[     "a     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  int  kJoinOverhead  =  InlineCostEstimator.getCost(n,  initialSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	int  kJoinOverhead  =  InlineCostEstimator.getCost(n,  initialSize);	  int    kJoinOverhead    =    InlineCostEstimator.getCost(n);    	non-compiled	[CE]  cannot  find  symbol  initialSize	148	None	replace
1470	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "string   "  +  sb.toString());  Node  emptyStringNode  =  Node.newString(  sb.toString());  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]    java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "string   "  +  sb.toString());  Node  emptyStringNode  =  Node.newString(  sb.toString());  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "string   "    +    sb.toString());    Node  emptyStringNode  =  Node.newString(  sb.toString());	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	108	None	add
1471	[BUG]  [BUGGY]  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('  [FE]            AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "] ").copyInformationFrom(prev);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "] ").copyInformationFrom(prev);	  Node    emptyStringNode    =    Node.newString(   "]   ").toString();    	compilable	  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('  	60	3	replace
1472	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "] ").copyInformationFrom(prev);  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('  [FE]            AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "] ").copyInformationFrom(prev);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "] ").copyInformationFrom(prev);	  Node    emptyStringNode    =    Node.newString(   "]   ").toString();    	compilable	  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('  	60	3	replace
1473	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "] ").replaceChild(n,  prev);  [CE]  incompatible  types  [FE]              AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "] ").replaceChild(n,  prev);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "] ").replaceChild(n,  prev);	  Node    emptyStringNode    =    Node.newString(   "]   ").toString();    	non-compiled	[CE]  incompatible  types	60	None	replace
1474	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "ArrayJoin   ");  Node  emptyStringNode  =  Node.newString( ")ArrayJoin   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "ArrayJoin   ");  Node  emptyStringNode  =  Node.newString( ")ArrayJoin   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "ArrayJoin   ");    Node  emptyStringNode  =  Node.newString( ")ArrayJoin   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	81	None	add
1475	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "Arrays   ");  Node  emptyStringNode  =  Node.newString( ")Arrays   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "Arrays   ");  Node  emptyStringNode  =  Node.newString( ")Arrays   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "Arrays   ");    Node  emptyStringNode  =  Node.newString( ")Arrays   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	191	None	add
1476	[BUG]  [BUGGY]  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]          junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "org.apache.jdk.internal.references.ArrayBuilder ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "org.apache.jdk.internal.references.ArrayBuilder ");	  Node    emptyStringNode    =    Node.newString(       "java.util.ArrayBuilder       ");    Node    emptyStringNode    =    Node.newString(   ".java.util.ArrayBuilder       ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	122	3	replace
1477	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "org.apache.jdk.internal.references.ArrayBuilder ");  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  [FE]          junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "org.apache.jdk.internal.references.ArrayBuilder ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "org.apache.jdk.internal.references.ArrayBuilder ");	  Node    emptyStringNode    =    Node.newString(       "java.util.ArrayBuilder       ");    Node    emptyStringNode    =    Node.newString(   ".java.util.ArrayBuilder       ");    	compilable	  [FE]  junit.framework.AssertionFailedError:  Expected:  x=[].join( "  	122	3	replace
1478	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(ArrayBuilder.TYPE_ARRAY);  [CE]  cannot  find  symbol  ArrayBuilder  [FE]        junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(ArrayBuilder.TYPE_ARRAY);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(ArrayBuilder.TYPE_ARRAY);	  Node    emptyStringNode    =    Node.newString(       "java.util.ArrayBuilder       ");    Node    emptyStringNode    =    Node.newString(java.util.ArrayBuilder       ");    	non-compiled	[CE]  cannot  find  symbol  ArrayBuilder	138	None	replace
1479	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]              AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ".Arrays ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( ".Arrays ");	  Node    emptyStringNode    =    Node.newString(       "Array       ");    Node    emptyStringNode    =    Node.newString(.   "Array       ");    	compilable	  [FE]  AssertionFailedError  	33	3	replace
1480	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( ".Arrays ");  [FE]  AssertionFailedError  [FE]              AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ".Arrays ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( ".Arrays ");	  Node    emptyStringNode    =    Node.newString(       "Array       ");    Node    emptyStringNode    =    Node.newString(.   "Array       ");    	compilable	  [FE]  AssertionFailedError  	33	3	replace
1481	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(ArrayElement.TYPE_ARRAY);  [CE]  cannot  find  symbol  ArrayElement  [FE]        junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(ArrayElement.TYPE_ARRAY);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(ArrayElement.TYPE_ARRAY);	  Node    emptyStringNode    =    Node.newString(       "java.util.ArrayElement       ");    Node    emptyStringNode    =    Node.newString(java.util.ArrayElement       ");    	non-compiled	[CE]  cannot  find  symbol  ArrayElement	160	None	replace
1482	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "Arrays.asList());  [CE]  unclosed  string  literal  [FE]          junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "Arrays.asList());  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "Arrays.asList());	  Node    emptyStringNode    =    Node.newString(       "java.util.Arrays.asList(       ");    Node    emptyStringNode    =    Node.newString(   "java.util.Arrays.asList(       "));    	non-compiled	[CE]  unclosed  string  literal	172	None	replace
1483	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(sb.toString());  Node  emptyStringNode  =  Node.newString(b.toString());  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]    java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(sb.toString());  Node  emptyStringNode  =  Node.newString(b.toString());  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(sb.toString());    Node  emptyStringNode  =  Node.newString(b.toString());	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	189	None	add
1484	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(sb.toString());  Node  emptyStringNode  =  Node.newString(Sb.toString());  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]      java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(sb.toString());  Node  emptyStringNode  =  Node.newString(Sb.toString());  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(sb.toString());    Node  emptyStringNode  =  Node.newString(Sb.toString());	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	189	None	add
1485	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(sb.toString());  Node  emptyStringNode  =  Node.newString(n.toString());  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]        java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(sb.toString());  Node  emptyStringNode  =  Node.newString(n.toString());  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(sb.toString());    Node  emptyStringNode  =  Node.newString(n.toString());	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	189	None	add
1486	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(sb.toString());  Number  emptyStringNode  =  Node.newString(sb.toString());  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]          java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(sb.toString());  Number  emptyStringNode  =  Node.newString(sb.toString());  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(sb.toString());    Number  emptyStringNode  =  Node.newString(sb.toString());	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	189	None	add
1487	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(sb.toString());  Node  emptyStringNode  =  Node.newString(mv.toString());  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]            java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(sb.toString());  Node  emptyStringNode  =  Node.newString(mv.toString());  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(sb.toString());    Node  emptyStringNode  =  Node.newString(mv.toString());	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	189	None	add
1488	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Arrays.asList(oldString));  [CE]  cannot  find  symbol  oldString  [FE]          junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Arrays.asList(oldString));  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(Arrays.asList(oldString));	  Node    emptyStringNode    =    Node.newString(       "java.util.Arrays.asList(       ");    Node    emptyStringNode    =    Node.newString(java.util.Arrays.asList(       ");    	non-compiled	[CE]  cannot  find  symbol  oldString	77	None	replace
1489	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Arrays.asList(new  String[]  {   " ")  }  );  [CE]  [FE]            junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Arrays.asList(new  String[]  {   " ")  }  );  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(Arrays.asList(new  String[]  {   " ")  }  );	  Node    emptyStringNode    =    Node.newString(       "java.util.Arrays.asList(       ");    Node    emptyStringNode    =    Node.newString(java.util.Arrays.asList(       ");    	non-compiled	[CE]  	77	None	replace
1490	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "clone ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "clone ");	  Node    emptyStringNode    =    Node.newString(   "node   ");    	compilable	  [FE]  AssertionFailedError  	86	3	replace
1491	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "clone ");  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "clone ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "clone ");	  Node    emptyStringNode    =    Node.newString(   "node   ");    	compilable	  [FE]  AssertionFailedError  	86	3	replace
1492	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME,  READ_STRING);  [CE]  cannot  find  symbol  READ_STRING  [FE]    junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME,  READ_STRING);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString(Token.NAME,  READ_STRING);	  Node    emptyStringNode    =    Node.newString(Token.NAME,   "ArrayBuilder   ");    	non-compiled	[CE]  cannot  find  symbol  READ_STRING	168	None	replace
1493	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "array_ "));  [CE]  [FE]            junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "array_ "));  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "array_ "));	  Node    emptyStringNode    =    Node.newString(       "array       ");    Node    emptyStringNode    =    Node.newString(   "array   "));    	non-compiled	[CE]  	14	None	replace
1494	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "- ").replaceChild(array,  n,  foldedSize);  [CE]  cannot  find  symbol  array  [FE]              AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "- ").replaceChild(array,  n,  foldedSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "- ").replaceChild(array,  n,  foldedSize);	  Node    emptyStringNode    =    Node.newString(   "-   ").replaceChild(n,    foldedSize);    	non-compiled	[CE]  cannot  find  symbol  array	50	None	replace
1495	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "- ").replaceChild(n,  oldStringNode);  [CE]  cannot  find  symbol  oldStringNode  [FE]                AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "- ").replaceChild(n,  oldStringNode);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "- ").replaceChild(n,  oldStringNode);	  Node    emptyStringNode    =    Node.newString(   "-   ").replaceChild(n,    foldedSize);    	non-compiled	[CE]  cannot  find  symbol  oldStringNode	50	None	replace
1496	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "org.join.ArrayBuilder   ");  n.getParent().removeChild(prev);  Node  emptyStringNode  =  Node.newString( "org.join.ArrayBuilder   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]    junit.framework.AssertionFailedError:  Expected:  x=[].join(   "    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "org.join.ArrayBuilder   ");  n.getParent().removeChild(prev);  Node  emptyStringNode  =  Node.newString( "org.join.ArrayBuilder   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "org.join.ArrayBuilder   ");    n.getParent().removeChild(prev);  Node  emptyStringNode  =  Node.newString( "org.join.ArrayBuilder   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	207	None	add
1497	[BUG]  [BUGGY]  Node  emptyStringNode  =  arrayFoldedChildren.get(arrayNode);  [CE]  method  get  in  interface  List<E>  cannot  be  applied  to  given  types;  [FE]                              junit.framework.AssertionFailedError:  Expected:  x=[     "a     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  arrayFoldedChildren.get(arrayNode);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  arrayFoldedChildren.get(arrayNode);	  Node    emptyStringNode    =    arrayFoldedChildren.get(prev);    	non-compiled	[CE]  method  get  in  interface  List<E>  cannot  be  applied  to  given  types;	4	None	replace
1498	[BUG]  [BUGGY]  Node  emptyStringNode  =  arrayFoldedChildren.get(new  StringBuilder());  [CE]  method  get  in  interface  List<E>  cannot  be  applied  to  given  types;  [FE]                                junit.framework.AssertionFailedError:  Expected:  x=[     "a     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  arrayFoldedChildren.get(new  StringBuilder());  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  arrayFoldedChildren.get(new  StringBuilder());	  Node    emptyStringNode    =    arrayFoldedChildren.get(prev);    	non-compiled	[CE]  method  get  in  interface  List<E>  cannot  be  applied  to  given  types;	4	None	replace
1499	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "Arrays.asList( "  +  originalSize  +  1));  [CE]  [FE]          junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "Arrays.asList( "  +  originalSize  +  1));  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "Arrays.asList( "  +  originalSize  +  1));	  Node    emptyStringNode    =    Node.newString(   "java.util.Arrays.asList(   "    +    originalSize    +   "));    	non-compiled	[CE]  	53	None	replace
1500	[BUG]  [BUGGY]  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('  [FE]                          junit.framework.AssertionFailedError:  Expected:  x=[     "a     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  arrayFoldedChildren.iterator().next();  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  arrayFoldedChildren.iterator().next();	  Node    emptyStringNode    =    arrayFoldedChildren.getFirstChild();    	compilable	  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('  	147	3	replace
1501	[BUG]  [BUGGY]  Node  emptyStringNode  =  arrayFoldedChildren.iterator().next();  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('  [FE]                          junit.framework.AssertionFailedError:  Expected:  x=[     "a     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  arrayFoldedChildren.iterator().next();  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  arrayFoldedChildren.iterator().next();	  Node    emptyStringNode    =    arrayFoldedChildren.getFirstChild();    	compilable	  [FE]  java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  null  Node(CALL):  testcode:1:11  x  =  [].join('  	147	3	replace
1502	[BUG]  [BUGGY]  Node  emptyStringNode  =  arrayFoldedChildren.cloneTree();  [CE]  cannot  find  symbol  [FE]                            junit.framework.AssertionFailedError:  Expected:  x=[     "a     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  arrayFoldedChildren.cloneTree();  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  arrayFoldedChildren.cloneTree();	  Node    emptyStringNode    =    arrayFoldedChildren.getFirstChild();    	non-compiled	[CE]  cannot  find  symbol	147	None	replace
1503	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( ",   "Array ");  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( ",   "Array ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( ",   "Array ");	  Node    emptyStringNode    =    Node.newString(       "Array       ");    Node    emptyStringNode    =    Node.newString(,   "Array       ");    	non-compiled	[CE]  	35	None	replace
1504	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "- "  +  foldingSize);  [CE]  cannot  find  symbol  foldingSize  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "- "  +  foldingSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "- "  +  foldingSize);	  Node    emptyStringNode    =    Node.newString(   "-   "    +    originalSize);    	non-compiled	[CE]  cannot  find  symbol  foldingSize	45	None	replace
1505	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME,   "ArrayElement   ");  Node  emptyStringNode  =  Node.newString(Token.NAME,  getArrayElement   ");  [CE]  unclosed  string  literal  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(Token.NAME,   "ArrayElement   ");  Node  emptyStringNode  =  Node.newString(Token.NAME,  getArrayElement   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(Token.NAME,   "ArrayElement   ");    Node  emptyStringNode  =  Node.newString(Token.NAME,  getArrayElement   ");	  	non-compiled	[CE]  unclosed  string  literal	135	None	add
1506	[BUG]  [BUGGY]  Node  emptyStringNode  =  arrayFoldedChildren.get(originalSize);  Node  emptyStringNode  =  arrayFoldedHildren.get(originalSize);  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]    java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  Index:  12    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  arrayFoldedChildren.get(originalSize);  Node  emptyStringNode  =  arrayFoldedHildren.get(originalSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    arrayFoldedChildren.get(originalSize);    Node  emptyStringNode  =  arrayFoldedHildren.get(originalSize);	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	9	None	add
1507	[BUG]  [BUGGY]  Node  emptyStringNode  =  arrayFoldedChildren.get(originalSize);  Node  emptyStringNode  =  arrayFoldedVarren.get(originalSize);  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]      java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  Index:  12    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  arrayFoldedChildren.get(originalSize);  Node  emptyStringNode  =  arrayFoldedVarren.get(originalSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    arrayFoldedChildren.get(originalSize);    Node  emptyStringNode  =  arrayFoldedVarren.get(originalSize);	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	9	None	add
1508	[BUG]  [BUGGY]  n.getParent().removeChild(arrayFoldedChildren);  [CE]  method  removeChild  in  class  Node  cannot  be  applied  to  given  types;  [FE]                                      junit.framework.AssertionFailedError:  Expected:  x=[     "a     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  n.getParent().removeChild(arrayFoldedChildren);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	n.getParent().removeChild(arrayFoldedChildren);	  n.getParent().removeChild(prev);    	non-compiled	[CE]  method  removeChild  in  class  Node  cannot  be  applied  to  given  types;	11	None	replace
1509	[BUG]  [BUGGY]  n.getParent().removeChild(arrayNode);  [CE]  cannot  find  symbol  emptyStringNode  [FE]                                        junit.framework.AssertionFailedError:  Expected:  x=[     "a     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  n.getParent().removeChild(arrayNode);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	n.getParent().removeChild(arrayNode);	  n.getParent().removeChild(prev);    	non-compiled	[CE]  cannot  find  symbol  emptyStringNode	11	None	replace
1510	[BUG]  [BUGGY]  n.getParent().removeChild(arrangementFoldedChildren);  [CE]  cannot  find  symbol  arrangementFoldedChildren  [FE]                                          junit.framework.AssertionFailedError:  Expected:  x=[     "a     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  n.getParent().removeChild(arrangementFoldedChildren);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	n.getParent().removeChild(arrangementFoldedChildren);	  n.getParent().removeChild(prev);    	non-compiled	[CE]  cannot  find  symbol  arrangementFoldedChildren	11	None	replace
1511	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "] "  +  Token.NAME,  arrayFoldedChildren);  [CE]  no  suitable  method  found  for  newString(String,List<Node>)  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "] "  +  Token.NAME,  arrayFoldedChildren);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "] "  +  Token.NAME,  arrayFoldedChildren);	  Node    emptyStringNode    =    Node.newString(   "]   "    +    Token.NAME);    	non-compiled	[CE]  no  suitable  method  found  for  newString(String,List<Node>)	154	None	replace
1512	[BUG]  [BUGGY]  Node  emptyStringNode  =  n.cloneTarget();  [CE]  cannot  find  symbol  [FE]    java.lang.RuntimeException:  INTERNAL  COMPILER  ERROR.  Please  report  this  problem.  The  new  child  node  has  siblings.  Node(CALL):  testcode:1:11  x  =  [].join('    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  n.cloneTarget();  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  n.cloneTarget();	  Node    emptyStringNode    =    n.getFirstChild();    	non-compiled	[CE]  cannot  find  symbol	8	None	replace
1513	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString(   "array_foo   ");  Node  emptyStringNode  =  Node.newString( ")array_foo   ");  [CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString(   "array_foo   ");  Node  emptyStringNode  =  Node.newString( ")array_foo   ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node    emptyStringNode    =    Node.newString(   "array_foo   ");    Node  emptyStringNode  =  Node.newString( ")array_foo   ");	  	non-compiled	[CE]  variable  emptyStringNode  is  already  defined  in  method  tryFoldArrayJoin(Node)	202	None	add
1514	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "JoinArray. ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "JoinArray. ");	  Node    emptyStringNode    =    Node.newString(   "JoinArrayElement   ");    	compilable	  [FE]  AssertionFailedError  	39	3	replace
1515	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "JoinArray. ");  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "JoinArray. ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "JoinArray. ");	  Node    emptyStringNode    =    Node.newString(   "JoinArrayElement   ");    	compilable	  [FE]  AssertionFailedError  	39	3	replace
1516	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.ArrayList "  +  foldedSize,  originalSize);  [CE]  no  suitable  method  found  for  newString(String,int)  [FE]          AssertionFailedError      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "java.util.ArrayList "  +  foldedSize,  originalSize);  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "java.util.ArrayList "  +  foldedSize,  originalSize);	  Node    emptyStringNode    =    Node.newString(   "java.util.ArrayList   ",    originalSize);    	non-compiled	[CE]  no  suitable  method  found  for  newString(String,int)	127	None	replace
1517	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[arrayFoldedChildren.size()  -  1]. ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "[arrayFoldedChildren.size()  -  1]. ");	  Node    emptyStringNode    =    Node.newString(       "array       ");    Node    emptyStringNode    =    Node.newString(   ".array   ");    	compilable	  [FE]  AssertionFailedError  	13	3	replace
1518	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "[arrayFoldedChildren.size()  -  1]. ");  [FE]  AssertionFailedError  [FE]          junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[arrayFoldedChildren.size()  -  1]. ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "[arrayFoldedChildren.size()  -  1]. ");	  Node    emptyStringNode    =    Node.newString(       "array       ");    Node    emptyStringNode    =    Node.newString(   ".array   ");    	compilable	  [FE]  AssertionFailedError  	13	3	replace
1519	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]            junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[arrayFoldedChildren.size()  ] ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	add	Node  emptyStringNode  =  Node.newString( "[arrayFoldedChildren.size()  ] ");	  Node    emptyStringNode    =    Node.newString(       "array       ");    Node    emptyStringNode    =    Node.newString(   ".array   ");    	compilable	  [FE]  AssertionFailedError  	13	3	replace
1520	[BUG]  [BUGGY]  Node  emptyStringNode  =  Node.newString( "[arrayFoldedChildren.size()  ] ");  [FE]  AssertionFailedError  [FE]            junit.framework.AssertionFailedError:  Expected:  x=[].join(     "      [CONTEXT]      foldedSize  +=  sb.length()  +  2;  arrayFoldedChildren.add(  Node.newString(sb.toString()).copyInformationFrom(prev));  }  foldedSize  +=  arrayFoldedChildren.size()  -  1;  int  originalSize  =  InlineCostEstimator.getCost(n);  switch  (arrayFoldedChildren.size())  {  case  0:      [BUGGY]  Node  emptyStringNode  =  Node.newString( "[arrayFoldedChildren.size()  ] ");  [BUGGY]      n.getParent().replaceChild(n,  emptyStringNode);  reportCodeChange();  return  emptyStringNode;  case  1:  Node  foldedStringNode  =  arrayFoldedChildren.remove(0);  if  (foldedSize  >  originalSize)  {  return  n;  }  arrayNode.detachChildren();  if  (foldedStringNode.getType()  !=  Token.STRING)  {  [CLASS]  PeepholeReplaceKnownMethods  [METHOD]  tryFoldArrayJoin  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  Locale  ROOT_LOCALE  boolean  StringBuilder  sb  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  List  arrayFoldedChildren  String  joinString  int  foldedSize  kJoinOverhead  originalSize  	projects/Closure50/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java	0.8164965809277261	435	435	2	replace	Node  emptyStringNode  =  Node.newString( "[arrayFoldedChildren.size()  ] ");	  Node    emptyStringNode    =    Node.newString(       "array       ");    Node    emptyStringNode    =    Node.newString(   ".array   ");    	compilable	  [FE]  AssertionFailedError  	13	3	replace
