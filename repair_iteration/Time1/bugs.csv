bugid	buggy	buggy_class	suspiciousness	buggy_line	endbuggycode	failing_test_number	action	patch
1	[BUG] [BUGGY] throw new IllegalArgumentException("Types array must be in order largest-smallest: " +  types[i - 1].getName() + " < " + loopType.getName()); [FE] AssertionFailedError [CONTEXT] throw new IllegalArgumentException("Types array must not contain null: index " + i); } } DurationField lastUnitField = null; for (int i = 0; i < types.length; i++) { DateTimeFieldType loopType = types[i]; DurationField loopUnitField = loopType.getDurationType().getField(iChronology); if (i > 0) { int compare = lastUnitField.compareTo(loopUnitField); if (compare < 0) { [BUGGY] throw new IllegalArgumentException("Types array must be in order largest-smallest: " +       types[i - 1].getName() + " < " + loopType.getName()); [BUGGY] types[i - 1].getName() + " < " + loopType.getName()); } else if (compare == 0) { if (types[i - 1].getRangeDurationType() == null) { if (loopType.getRangeDurationType() == null) { throw new IllegalArgumentException("Types array must not contain duplicate: " + types[i - 1].getName() + " and " + loopType.getName()); } } else { if (loopType.getRangeDurationType() == null) { throw new IllegalArgumentException("Types array must be in order largest-smallest: " + [CLASS] Partial Property [METHOD] <init> [RETURN_TYPE] Chronology)  DateTimeFieldType[] types int[] values Chronology chronology [VARIABLES] boolean DateTimeFieldType[] iTypes types Partial iPartial DateTimeFieldType loopType int[] iValues values Chronology chrono chronology iChronology DurationField lastRangeField lastUnitField loopRangeField loopUnitField long serialVersionUID DateTimeFormatter[] iFormatter int compare i iFieldIndex value  	projects/Time1/src/main/java/org/joda/time/Partial.java	1.0	219	220	1	replace	
2	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] throw new IllegalArgumentException("Types array must not contain null: index " + i); } } DurationField lastUnitField = null; for (int i = 0; i < types.length; i++) { DateTimeFieldType loopType = types[i]; DurationField loopUnitField = loopType.getDurationType().getField(iChronology); if (i > 0) { int compare = lastUnitField.compareTo(loopUnitField); if (compare < 0) { [BUGGY] [BUGGY] throw new IllegalArgumentException("Types array must be in order largest-smallest: " +       types[i - 1].getName() + " < " + loopType.getName()); types[i - 1].getName() + " < " + loopType.getName()); } else if (compare == 0) { if (types[i - 1].getRangeDurationType() == null) { if (loopType.getRangeDurationType() == null) { throw new IllegalArgumentException("Types array must not contain duplicate: " + types[i - 1].getName() + " and " + loopType.getName()); } } else { if (loopType.getRangeDurationType() == null) { throw new IllegalArgumentException("Types array must be in order largest-smallest: " + [CLASS] Partial Property [METHOD] <init> [RETURN_TYPE] Chronology)  DateTimeFieldType[] types int[] values Chronology chronology [VARIABLES] boolean DateTimeFieldType[] iTypes types Partial iPartial DateTimeFieldType loopType int[] iValues values Chronology chrono chronology iChronology DurationField lastRangeField lastUnitField loopRangeField loopUnitField long serialVersionUID DateTimeFormatter[] iFormatter int compare i iFieldIndex value  	projects/Time1/src/main/java/org/joda/time/Partial.java	1.0	219	220	1	add	
3	[BUG] [BUGGY] if (durationField.isSupported()) { [FE] AssertionFailedError [CONTEXT] public int compareTo(DurationField durationField) { [BUGGY] if (durationField.isSupported()) { [BUGGY] return 1; } return 0; } [CLASS] UnsupportedDurationField [METHOD] compareTo [RETURN_TYPE] int  DurationField durationField [VARIABLES] boolean HashMap cCache DurationField durationField long duration instant minuendInstant serialVersionUID subtrahendInstant value DurationFieldType iType type  	projects/Time1/src/main/java/org/joda/time/field/UnsupportedDurationField.java	0.7071067811865475	227	227	1	replace	
4	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] public int compareTo(DurationField durationField) { [BUGGY] [BUGGY] if (durationField.isSupported()) { return 1; } return 0; } [CLASS] UnsupportedDurationField [METHOD] compareTo [RETURN_TYPE] int  DurationField durationField [VARIABLES] boolean HashMap cCache DurationField durationField long duration instant minuendInstant serialVersionUID subtrahendInstant value DurationFieldType iType type  	projects/Time1/src/main/java/org/joda/time/field/UnsupportedDurationField.java	0.7071067811865475	227	227	1	add	
5	[BUG] [BUGGY] return 1; [FE] AssertionFailedError [CONTEXT] public int compareTo(DurationField durationField) { if (durationField.isSupported()) { [BUGGY] return 1; [BUGGY] } return 0; } [CLASS] UnsupportedDurationField [METHOD] compareTo [RETURN_TYPE] int  DurationField durationField [VARIABLES] boolean HashMap cCache DurationField durationField long duration instant minuendInstant serialVersionUID subtrahendInstant value DurationFieldType iType type  	projects/Time1/src/main/java/org/joda/time/field/UnsupportedDurationField.java	0.7071067811865475	228	228	1	replace	
6	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] public int compareTo(DurationField durationField) { if (durationField.isSupported()) { [BUGGY] [BUGGY] return 1; } return 0; } [CLASS] UnsupportedDurationField [METHOD] compareTo [RETURN_TYPE] int  DurationField durationField [VARIABLES] boolean HashMap cCache DurationField durationField long duration instant minuendInstant serialVersionUID subtrahendInstant value DurationFieldType iType type  	projects/Time1/src/main/java/org/joda/time/field/UnsupportedDurationField.java	0.7071067811865475	228	228	1	add	
7	[BUG] [BUGGY] } [FE] AssertionFailedError [CONTEXT] public Partial(DateTimeFieldType[] types, int[] values) { this(types, values, null); [BUGGY] } [BUGGY]  [CLASS] Partial Property [METHOD] <init> [RETURN_TYPE] DateTimeFieldType[],int[])  DateTimeFieldType[] types int[] values [VARIABLES] boolean DateTimeFieldType[] iTypes types Partial iPartial int[] iValues values Chronology chrono chronology iChronology long serialVersionUID DateTimeFormatter[] iFormatter int iFieldIndex value  	projects/Time1/src/main/java/org/joda/time/Partial.java	0.5773502691896258	176	176	1	replace	
8	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] public Partial(DateTimeFieldType[] types, int[] values) { this(types, values, null); [BUGGY] [BUGGY] } [CLASS] Partial Property [METHOD] <init> [RETURN_TYPE] DateTimeFieldType[],int[])  DateTimeFieldType[] types int[] values [VARIABLES] boolean DateTimeFieldType[] iTypes types Partial iPartial int[] iValues values Chronology chrono chronology iChronology long serialVersionUID DateTimeFormatter[] iFormatter int iFieldIndex value  	projects/Time1/src/main/java/org/joda/time/Partial.java	0.5773502691896258	176	176	1	add	
9	[BUG] [BUGGY] iValues = (int[]) values.clone(); [FE] AssertionFailedError [CONTEXT] types[i - 1].getName() + " and " + loopType.getName()); } } } } lastUnitField = loopUnitField; } iTypes = (DateTimeFieldType[]) types.clone(); chronology.validate(this, values); [BUGGY] iValues = (int[]) values.clone(); [BUGGY] } [CLASS] Partial Property [METHOD] <init> [RETURN_TYPE] Chronology)  DateTimeFieldType[] types int[] values Chronology chronology [VARIABLES] boolean DateTimeFieldType[] iTypes types Partial iPartial DateTimeFieldType loopType int[] iValues values Chronology chrono chronology iChronology DurationField lastRangeField lastUnitField loopRangeField loopUnitField long serialVersionUID DateTimeFormatter[] iFormatter int compare i iFieldIndex value  	projects/Time1/src/main/java/org/joda/time/Partial.java	0.5773502691896258	250	250	1	replace	
10	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] types[i - 1].getName() + " and " + loopType.getName()); } } } } lastUnitField = loopUnitField; } iTypes = (DateTimeFieldType[]) types.clone(); chronology.validate(this, values); [BUGGY] [BUGGY] iValues = (int[]) values.clone(); } [CLASS] Partial Property [METHOD] <init> [RETURN_TYPE] Chronology)  DateTimeFieldType[] types int[] values Chronology chronology [VARIABLES] boolean DateTimeFieldType[] iTypes types Partial iPartial DateTimeFieldType loopType int[] iValues values Chronology chrono chronology iChronology DurationField lastRangeField lastUnitField loopRangeField loopUnitField long serialVersionUID DateTimeFormatter[] iFormatter int compare i iFieldIndex value  	projects/Time1/src/main/java/org/joda/time/Partial.java	0.5773502691896258	250	250	1	add	
11	[BUG] [BUGGY] } [FE] AssertionFailedError [CONTEXT] } } } } lastUnitField = loopUnitField; } iTypes = (DateTimeFieldType[]) types.clone(); chronology.validate(this, values); iValues = (int[]) values.clone(); [BUGGY] } [BUGGY]  [CLASS] Partial Property [METHOD] <init> [RETURN_TYPE] Chronology)  DateTimeFieldType[] types int[] values Chronology chronology [VARIABLES] boolean DateTimeFieldType[] iTypes types Partial iPartial DateTimeFieldType loopType int[] iValues values Chronology chrono chronology iChronology DurationField lastRangeField lastUnitField loopRangeField loopUnitField long serialVersionUID DateTimeFormatter[] iFormatter int compare i iFieldIndex value  	projects/Time1/src/main/java/org/joda/time/Partial.java	0.5773502691896258	251	251	1	replace	
12	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] } } } } lastUnitField = loopUnitField; } iTypes = (DateTimeFieldType[]) types.clone(); chronology.validate(this, values); iValues = (int[]) values.clone(); [BUGGY] [BUGGY] } [CLASS] Partial Property [METHOD] <init> [RETURN_TYPE] Chronology)  DateTimeFieldType[] types int[] values Chronology chronology [VARIABLES] boolean DateTimeFieldType[] iTypes types Partial iPartial DateTimeFieldType loopType int[] iValues values Chronology chrono chronology iChronology DurationField lastRangeField lastUnitField loopRangeField loopUnitField long serialVersionUID DateTimeFormatter[] iFormatter int compare i iFieldIndex value  	projects/Time1/src/main/java/org/joda/time/Partial.java	0.5773502691896258	251	251	1	add	
13	[BUG] [BUGGY] iTypes = (DateTimeFieldType[]) types.clone(); [FE] AssertionFailedError [CONTEXT] if (lastRangeField.compareTo(loopRangeField) == 0) { throw new IllegalArgumentException("Types array must not contain duplicate: " + types[i - 1].getName() + " and " + loopType.getName()); } } } } lastUnitField = loopUnitField; } [BUGGY] iTypes = (DateTimeFieldType[]) types.clone(); [BUGGY] chronology.validate(this, values); iValues = (int[]) values.clone(); } [CLASS] Partial Property [METHOD] <init> [RETURN_TYPE] Chronology)  DateTimeFieldType[] types int[] values Chronology chronology [VARIABLES] boolean DateTimeFieldType[] iTypes types Partial iPartial DateTimeFieldType loopType int[] iValues values Chronology chrono chronology iChronology DurationField lastRangeField lastUnitField loopRangeField loopUnitField long serialVersionUID DateTimeFormatter[] iFormatter int compare i iFieldIndex value  	projects/Time1/src/main/java/org/joda/time/Partial.java	0.5	248	248	1	replace	
14	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] if (lastRangeField.compareTo(loopRangeField) == 0) { throw new IllegalArgumentException("Types array must not contain duplicate: " + types[i - 1].getName() + " and " + loopType.getName()); } } } } lastUnitField = loopUnitField; } [BUGGY] [BUGGY] iTypes = (DateTimeFieldType[]) types.clone(); chronology.validate(this, values); iValues = (int[]) values.clone(); } [CLASS] Partial Property [METHOD] <init> [RETURN_TYPE] Chronology)  DateTimeFieldType[] types int[] values Chronology chronology [VARIABLES] boolean DateTimeFieldType[] iTypes types Partial iPartial DateTimeFieldType loopType int[] iValues values Chronology chrono chronology iChronology DurationField lastRangeField lastUnitField loopRangeField loopUnitField long serialVersionUID DateTimeFormatter[] iFormatter int compare i iFieldIndex value  	projects/Time1/src/main/java/org/joda/time/Partial.java	0.5	248	248	1	add	
15	[BUG] [BUGGY] chronology.validate(this, values); [FE] AssertionFailedError [CONTEXT] throw new IllegalArgumentException("Types array must not contain duplicate: " + types[i - 1].getName() + " and " + loopType.getName()); } } } } lastUnitField = loopUnitField; } iTypes = (DateTimeFieldType[]) types.clone(); [BUGGY] chronology.validate(this, values); [BUGGY] iValues = (int[]) values.clone(); } [CLASS] Partial Property [METHOD] <init> [RETURN_TYPE] Chronology)  DateTimeFieldType[] types int[] values Chronology chronology [VARIABLES] boolean DateTimeFieldType[] iTypes types Partial iPartial DateTimeFieldType loopType int[] iValues values Chronology chrono chronology iChronology DurationField lastRangeField lastUnitField loopRangeField loopUnitField long serialVersionUID DateTimeFormatter[] iFormatter int compare i iFieldIndex value  	projects/Time1/src/main/java/org/joda/time/Partial.java	0.5	249	249	1	replace	
16	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] throw new IllegalArgumentException("Types array must not contain duplicate: " + types[i - 1].getName() + " and " + loopType.getName()); } } } } lastUnitField = loopUnitField; } iTypes = (DateTimeFieldType[]) types.clone(); [BUGGY] [BUGGY] chronology.validate(this, values); iValues = (int[]) values.clone(); } [CLASS] Partial Property [METHOD] <init> [RETURN_TYPE] Chronology)  DateTimeFieldType[] types int[] values Chronology chronology [VARIABLES] boolean DateTimeFieldType[] iTypes types Partial iPartial DateTimeFieldType loopType int[] iValues values Chronology chrono chronology iChronology DurationField lastRangeField lastUnitField loopRangeField loopUnitField long serialVersionUID DateTimeFormatter[] iFormatter int compare i iFieldIndex value  	projects/Time1/src/main/java/org/joda/time/Partial.java	0.5	249	249	1	add	
17	[BUG] [BUGGY] DurationField lastUnitField = null; [FE] AssertionFailedError [CONTEXT] if (types.length == 0) { iTypes = types; iValues = values; return; } for (int i = 0; i < types.length; i++) { if (types[i] == null) { throw new IllegalArgumentException("Types array must not contain null: index " + i); } } [BUGGY] DurationField lastUnitField = null; [BUGGY] for (int i = 0; i < types.length; i++) { DateTimeFieldType loopType = types[i]; DurationField loopUnitField = loopType.getDurationType().getField(iChronology); if (i > 0) { int compare = lastUnitField.compareTo(loopUnitField); if (compare < 0) { throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); } else if (compare == 0) { if (types[i - 1].getRangeDurationType() == null) { [CLASS] Partial Property [METHOD] <init> [RETURN_TYPE] Chronology)  DateTimeFieldType[] types int[] values Chronology chronology [VARIABLES] boolean DateTimeFieldType[] iTypes types Partial iPartial DateTimeFieldType loopType int[] iValues values Chronology chrono chronology iChronology DurationField lastRangeField lastUnitField loopRangeField loopUnitField long serialVersionUID DateTimeFormatter[] iFormatter int compare i iFieldIndex value  	projects/Time1/src/main/java/org/joda/time/Partial.java	0.4472135954999579	212	212	1	replace	
18	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] if (types.length == 0) { iTypes = types; iValues = values; return; } for (int i = 0; i < types.length; i++) { if (types[i] == null) { throw new IllegalArgumentException("Types array must not contain null: index " + i); } } [BUGGY] [BUGGY] DurationField lastUnitField = null; for (int i = 0; i < types.length; i++) { DateTimeFieldType loopType = types[i]; DurationField loopUnitField = loopType.getDurationType().getField(iChronology); if (i > 0) { int compare = lastUnitField.compareTo(loopUnitField); if (compare < 0) { throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); } else if (compare == 0) { if (types[i - 1].getRangeDurationType() == null) { [CLASS] Partial Property [METHOD] <init> [RETURN_TYPE] Chronology)  DateTimeFieldType[] types int[] values Chronology chronology [VARIABLES] boolean DateTimeFieldType[] iTypes types Partial iPartial DateTimeFieldType loopType int[] iValues values Chronology chrono chronology iChronology DurationField lastRangeField lastUnitField loopRangeField loopUnitField long serialVersionUID DateTimeFormatter[] iFormatter int compare i iFieldIndex value  	projects/Time1/src/main/java/org/joda/time/Partial.java	0.4472135954999579	212	212	1	add	
19	[BUG] [BUGGY] for (int i = 0; i < types.length; i++) { [FE] AssertionFailedError [CONTEXT] iTypes = types; iValues = values; return; } for (int i = 0; i < types.length; i++) { if (types[i] == null) { throw new IllegalArgumentException("Types array must not contain null: index " + i); } } DurationField lastUnitField = null; [BUGGY] for (int i = 0; i < types.length; i++) { [BUGGY] DateTimeFieldType loopType = types[i]; DurationField loopUnitField = loopType.getDurationType().getField(iChronology); if (i > 0) { int compare = lastUnitField.compareTo(loopUnitField); if (compare < 0) { throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); } else if (compare == 0) { if (types[i - 1].getRangeDurationType() == null) { if (loopType.getRangeDurationType() == null) { [CLASS] Partial Property [METHOD] <init> [RETURN_TYPE] Chronology)  DateTimeFieldType[] types int[] values Chronology chronology [VARIABLES] boolean DateTimeFieldType[] iTypes types Partial iPartial DateTimeFieldType loopType int[] iValues values Chronology chrono chronology iChronology DurationField lastRangeField lastUnitField loopRangeField loopUnitField long serialVersionUID DateTimeFormatter[] iFormatter int compare i iFieldIndex value  	projects/Time1/src/main/java/org/joda/time/Partial.java	0.4472135954999579	213	213	1	replace	
20	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] iTypes = types; iValues = values; return; } for (int i = 0; i < types.length; i++) { if (types[i] == null) { throw new IllegalArgumentException("Types array must not contain null: index " + i); } } DurationField lastUnitField = null; [BUGGY] [BUGGY] for (int i = 0; i < types.length; i++) { DateTimeFieldType loopType = types[i]; DurationField loopUnitField = loopType.getDurationType().getField(iChronology); if (i > 0) { int compare = lastUnitField.compareTo(loopUnitField); if (compare < 0) { throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); } else if (compare == 0) { if (types[i - 1].getRangeDurationType() == null) { if (loopType.getRangeDurationType() == null) { [CLASS] Partial Property [METHOD] <init> [RETURN_TYPE] Chronology)  DateTimeFieldType[] types int[] values Chronology chronology [VARIABLES] boolean DateTimeFieldType[] iTypes types Partial iPartial DateTimeFieldType loopType int[] iValues values Chronology chrono chronology iChronology DurationField lastRangeField lastUnitField loopRangeField loopUnitField long serialVersionUID DateTimeFormatter[] iFormatter int compare i iFieldIndex value  	projects/Time1/src/main/java/org/joda/time/Partial.java	0.4472135954999579	213	213	1	add	
21	[BUG] [BUGGY] DateTimeFieldType loopType = types[i]; [FE] AssertionFailedError [CONTEXT] iValues = values; return; } for (int i = 0; i < types.length; i++) { if (types[i] == null) { throw new IllegalArgumentException("Types array must not contain null: index " + i); } } DurationField lastUnitField = null; for (int i = 0; i < types.length; i++) { [BUGGY] DateTimeFieldType loopType = types[i]; [BUGGY] DurationField loopUnitField = loopType.getDurationType().getField(iChronology); if (i > 0) { int compare = lastUnitField.compareTo(loopUnitField); if (compare < 0) { throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); } else if (compare == 0) { if (types[i - 1].getRangeDurationType() == null) { if (loopType.getRangeDurationType() == null) { throw new IllegalArgumentException("Types array must not contain duplicate: " + [CLASS] Partial Property [METHOD] <init> [RETURN_TYPE] Chronology)  DateTimeFieldType[] types int[] values Chronology chronology [VARIABLES] boolean DateTimeFieldType[] iTypes types Partial iPartial DateTimeFieldType loopType int[] iValues values Chronology chrono chronology iChronology DurationField lastRangeField lastUnitField loopRangeField loopUnitField long serialVersionUID DateTimeFormatter[] iFormatter int compare i iFieldIndex value  	projects/Time1/src/main/java/org/joda/time/Partial.java	0.4472135954999579	214	214	1	replace	
22	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] iValues = values; return; } for (int i = 0; i < types.length; i++) { if (types[i] == null) { throw new IllegalArgumentException("Types array must not contain null: index " + i); } } DurationField lastUnitField = null; for (int i = 0; i < types.length; i++) { [BUGGY] [BUGGY] DateTimeFieldType loopType = types[i]; DurationField loopUnitField = loopType.getDurationType().getField(iChronology); if (i > 0) { int compare = lastUnitField.compareTo(loopUnitField); if (compare < 0) { throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); } else if (compare == 0) { if (types[i - 1].getRangeDurationType() == null) { if (loopType.getRangeDurationType() == null) { throw new IllegalArgumentException("Types array must not contain duplicate: " + [CLASS] Partial Property [METHOD] <init> [RETURN_TYPE] Chronology)  DateTimeFieldType[] types int[] values Chronology chronology [VARIABLES] boolean DateTimeFieldType[] iTypes types Partial iPartial DateTimeFieldType loopType int[] iValues values Chronology chrono chronology iChronology DurationField lastRangeField lastUnitField loopRangeField loopUnitField long serialVersionUID DateTimeFormatter[] iFormatter int compare i iFieldIndex value  	projects/Time1/src/main/java/org/joda/time/Partial.java	0.4472135954999579	214	214	1	add	
23	[BUG] [BUGGY] DurationField loopUnitField = loopType.getDurationType().getField(iChronology); [FE] AssertionFailedError [CONTEXT] return; } for (int i = 0; i < types.length; i++) { if (types[i] == null) { throw new IllegalArgumentException("Types array must not contain null: index " + i); } } DurationField lastUnitField = null; for (int i = 0; i < types.length; i++) { DateTimeFieldType loopType = types[i]; [BUGGY] DurationField loopUnitField = loopType.getDurationType().getField(iChronology); [BUGGY] if (i > 0) { int compare = lastUnitField.compareTo(loopUnitField); if (compare < 0) { throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); } else if (compare == 0) { if (types[i - 1].getRangeDurationType() == null) { if (loopType.getRangeDurationType() == null) { throw new IllegalArgumentException("Types array must not contain duplicate: " + types[i - 1].getName() + " and " + loopType.getName()); [CLASS] Partial Property [METHOD] <init> [RETURN_TYPE] Chronology)  DateTimeFieldType[] types int[] values Chronology chronology [VARIABLES] boolean DateTimeFieldType[] iTypes types Partial iPartial DateTimeFieldType loopType int[] iValues values Chronology chrono chronology iChronology DurationField lastRangeField lastUnitField loopRangeField loopUnitField long serialVersionUID DateTimeFormatter[] iFormatter int compare i iFieldIndex value  	projects/Time1/src/main/java/org/joda/time/Partial.java	0.4472135954999579	215	215	1	replace	
24	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] return; } for (int i = 0; i < types.length; i++) { if (types[i] == null) { throw new IllegalArgumentException("Types array must not contain null: index " + i); } } DurationField lastUnitField = null; for (int i = 0; i < types.length; i++) { DateTimeFieldType loopType = types[i]; [BUGGY] [BUGGY] DurationField loopUnitField = loopType.getDurationType().getField(iChronology); if (i > 0) { int compare = lastUnitField.compareTo(loopUnitField); if (compare < 0) { throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); } else if (compare == 0) { if (types[i - 1].getRangeDurationType() == null) { if (loopType.getRangeDurationType() == null) { throw new IllegalArgumentException("Types array must not contain duplicate: " + types[i - 1].getName() + " and " + loopType.getName()); [CLASS] Partial Property [METHOD] <init> [RETURN_TYPE] Chronology)  DateTimeFieldType[] types int[] values Chronology chronology [VARIABLES] boolean DateTimeFieldType[] iTypes types Partial iPartial DateTimeFieldType loopType int[] iValues values Chronology chrono chronology iChronology DurationField lastRangeField lastUnitField loopRangeField loopUnitField long serialVersionUID DateTimeFormatter[] iFormatter int compare i iFieldIndex value  	projects/Time1/src/main/java/org/joda/time/Partial.java	0.4472135954999579	215	215	1	add	
25	[BUG] [BUGGY] if (i > 0) { [FE] AssertionFailedError [CONTEXT] } for (int i = 0; i < types.length; i++) { if (types[i] == null) { throw new IllegalArgumentException("Types array must not contain null: index " + i); } } DurationField lastUnitField = null; for (int i = 0; i < types.length; i++) { DateTimeFieldType loopType = types[i]; DurationField loopUnitField = loopType.getDurationType().getField(iChronology); [BUGGY] if (i > 0) { [BUGGY] int compare = lastUnitField.compareTo(loopUnitField); if (compare < 0) { throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); } else if (compare == 0) { if (types[i - 1].getRangeDurationType() == null) { if (loopType.getRangeDurationType() == null) { throw new IllegalArgumentException("Types array must not contain duplicate: " + types[i - 1].getName() + " and " + loopType.getName()); } [CLASS] Partial Property [METHOD] <init> [RETURN_TYPE] Chronology)  DateTimeFieldType[] types int[] values Chronology chronology [VARIABLES] boolean DateTimeFieldType[] iTypes types Partial iPartial DateTimeFieldType loopType int[] iValues values Chronology chrono chronology iChronology DurationField lastRangeField lastUnitField loopRangeField loopUnitField long serialVersionUID DateTimeFormatter[] iFormatter int compare i iFieldIndex value  	projects/Time1/src/main/java/org/joda/time/Partial.java	0.4472135954999579	216	216	1	replace	
26	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] } for (int i = 0; i < types.length; i++) { if (types[i] == null) { throw new IllegalArgumentException("Types array must not contain null: index " + i); } } DurationField lastUnitField = null; for (int i = 0; i < types.length; i++) { DateTimeFieldType loopType = types[i]; DurationField loopUnitField = loopType.getDurationType().getField(iChronology); [BUGGY] [BUGGY] if (i > 0) { int compare = lastUnitField.compareTo(loopUnitField); if (compare < 0) { throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); } else if (compare == 0) { if (types[i - 1].getRangeDurationType() == null) { if (loopType.getRangeDurationType() == null) { throw new IllegalArgumentException("Types array must not contain duplicate: " + types[i - 1].getName() + " and " + loopType.getName()); } [CLASS] Partial Property [METHOD] <init> [RETURN_TYPE] Chronology)  DateTimeFieldType[] types int[] values Chronology chronology [VARIABLES] boolean DateTimeFieldType[] iTypes types Partial iPartial DateTimeFieldType loopType int[] iValues values Chronology chrono chronology iChronology DurationField lastRangeField lastUnitField loopRangeField loopUnitField long serialVersionUID DateTimeFormatter[] iFormatter int compare i iFieldIndex value  	projects/Time1/src/main/java/org/joda/time/Partial.java	0.4472135954999579	216	216	1	add	
27	[BUG] [BUGGY] int compare = lastUnitField.compareTo(loopUnitField); [FE] AssertionFailedError [CONTEXT] for (int i = 0; i < types.length; i++) { if (types[i] == null) { throw new IllegalArgumentException("Types array must not contain null: index " + i); } } DurationField lastUnitField = null; for (int i = 0; i < types.length; i++) { DateTimeFieldType loopType = types[i]; DurationField loopUnitField = loopType.getDurationType().getField(iChronology); if (i > 0) { [BUGGY] int compare = lastUnitField.compareTo(loopUnitField); [BUGGY] if (compare < 0) { throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); } else if (compare == 0) { if (types[i - 1].getRangeDurationType() == null) { if (loopType.getRangeDurationType() == null) { throw new IllegalArgumentException("Types array must not contain duplicate: " + types[i - 1].getName() + " and " + loopType.getName()); } } else { [CLASS] Partial Property [METHOD] <init> [RETURN_TYPE] Chronology)  DateTimeFieldType[] types int[] values Chronology chronology [VARIABLES] boolean DateTimeFieldType[] iTypes types Partial iPartial DateTimeFieldType loopType int[] iValues values Chronology chrono chronology iChronology DurationField lastRangeField lastUnitField loopRangeField loopUnitField long serialVersionUID DateTimeFormatter[] iFormatter int compare i iFieldIndex value  	projects/Time1/src/main/java/org/joda/time/Partial.java	0.4472135954999579	217	217	1	replace	
28	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] for (int i = 0; i < types.length; i++) { if (types[i] == null) { throw new IllegalArgumentException("Types array must not contain null: index " + i); } } DurationField lastUnitField = null; for (int i = 0; i < types.length; i++) { DateTimeFieldType loopType = types[i]; DurationField loopUnitField = loopType.getDurationType().getField(iChronology); if (i > 0) { [BUGGY] [BUGGY] int compare = lastUnitField.compareTo(loopUnitField); if (compare < 0) { throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); } else if (compare == 0) { if (types[i - 1].getRangeDurationType() == null) { if (loopType.getRangeDurationType() == null) { throw new IllegalArgumentException("Types array must not contain duplicate: " + types[i - 1].getName() + " and " + loopType.getName()); } } else { [CLASS] Partial Property [METHOD] <init> [RETURN_TYPE] Chronology)  DateTimeFieldType[] types int[] values Chronology chronology [VARIABLES] boolean DateTimeFieldType[] iTypes types Partial iPartial DateTimeFieldType loopType int[] iValues values Chronology chrono chronology iChronology DurationField lastRangeField lastUnitField loopRangeField loopUnitField long serialVersionUID DateTimeFormatter[] iFormatter int compare i iFieldIndex value  	projects/Time1/src/main/java/org/joda/time/Partial.java	0.4472135954999579	217	217	1	add	
29	[BUG] [BUGGY] if (compare < 0) { [FE] AssertionFailedError [CONTEXT] if (types[i] == null) { throw new IllegalArgumentException("Types array must not contain null: index " + i); } } DurationField lastUnitField = null; for (int i = 0; i < types.length; i++) { DateTimeFieldType loopType = types[i]; DurationField loopUnitField = loopType.getDurationType().getField(iChronology); if (i > 0) { int compare = lastUnitField.compareTo(loopUnitField); [BUGGY] if (compare < 0) { [BUGGY] throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); } else if (compare == 0) { if (types[i - 1].getRangeDurationType() == null) { if (loopType.getRangeDurationType() == null) { throw new IllegalArgumentException("Types array must not contain duplicate: " + types[i - 1].getName() + " and " + loopType.getName()); } } else { if (loopType.getRangeDurationType() == null) { [CLASS] Partial Property [METHOD] <init> [RETURN_TYPE] Chronology)  DateTimeFieldType[] types int[] values Chronology chronology [VARIABLES] boolean DateTimeFieldType[] iTypes types Partial iPartial DateTimeFieldType loopType int[] iValues values Chronology chrono chronology iChronology DurationField lastRangeField lastUnitField loopRangeField loopUnitField long serialVersionUID DateTimeFormatter[] iFormatter int compare i iFieldIndex value  	projects/Time1/src/main/java/org/joda/time/Partial.java	0.4472135954999579	218	218	1	replace	
30	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] if (types[i] == null) { throw new IllegalArgumentException("Types array must not contain null: index " + i); } } DurationField lastUnitField = null; for (int i = 0; i < types.length; i++) { DateTimeFieldType loopType = types[i]; DurationField loopUnitField = loopType.getDurationType().getField(iChronology); if (i > 0) { int compare = lastUnitField.compareTo(loopUnitField); [BUGGY] [BUGGY] if (compare < 0) { throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); } else if (compare == 0) { if (types[i - 1].getRangeDurationType() == null) { if (loopType.getRangeDurationType() == null) { throw new IllegalArgumentException("Types array must not contain duplicate: " + types[i - 1].getName() + " and " + loopType.getName()); } } else { if (loopType.getRangeDurationType() == null) { [CLASS] Partial Property [METHOD] <init> [RETURN_TYPE] Chronology)  DateTimeFieldType[] types int[] values Chronology chronology [VARIABLES] boolean DateTimeFieldType[] iTypes types Partial iPartial DateTimeFieldType loopType int[] iValues values Chronology chrono chronology iChronology DurationField lastRangeField lastUnitField loopRangeField loopUnitField long serialVersionUID DateTimeFormatter[] iFormatter int compare i iFieldIndex value  	projects/Time1/src/main/java/org/joda/time/Partial.java	0.4472135954999579	218	218	1	add	
31	[BUG] [BUGGY] } else if (compare == 0) { [FE] AssertionFailedError [CONTEXT] } DurationField lastUnitField = null; for (int i = 0; i < types.length; i++) { DateTimeFieldType loopType = types[i]; DurationField loopUnitField = loopType.getDurationType().getField(iChronology); if (i > 0) { int compare = lastUnitField.compareTo(loopUnitField); if (compare < 0) { throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); [BUGGY] } else if (compare == 0) { [BUGGY] if (types[i - 1].getRangeDurationType() == null) { if (loopType.getRangeDurationType() == null) { throw new IllegalArgumentException("Types array must not contain duplicate: " + types[i - 1].getName() + " and " + loopType.getName()); } } else { if (loopType.getRangeDurationType() == null) { throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); } [CLASS] Partial Property [METHOD] <init> [RETURN_TYPE] Chronology)  DateTimeFieldType[] types int[] values Chronology chronology [VARIABLES] boolean DateTimeFieldType[] iTypes types Partial iPartial DateTimeFieldType loopType int[] iValues values Chronology chrono chronology iChronology DurationField lastRangeField lastUnitField loopRangeField loopUnitField long serialVersionUID DateTimeFormatter[] iFormatter int compare i iFieldIndex value  	projects/Time1/src/main/java/org/joda/time/Partial.java	0.4472135954999579	221	221	1	replace	
32	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] } DurationField lastUnitField = null; for (int i = 0; i < types.length; i++) { DateTimeFieldType loopType = types[i]; DurationField loopUnitField = loopType.getDurationType().getField(iChronology); if (i > 0) { int compare = lastUnitField.compareTo(loopUnitField); if (compare < 0) { throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); [BUGGY] [BUGGY] } else if (compare == 0) { if (types[i - 1].getRangeDurationType() == null) { if (loopType.getRangeDurationType() == null) { throw new IllegalArgumentException("Types array must not contain duplicate: " + types[i - 1].getName() + " and " + loopType.getName()); } } else { if (loopType.getRangeDurationType() == null) { throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); } [CLASS] Partial Property [METHOD] <init> [RETURN_TYPE] Chronology)  DateTimeFieldType[] types int[] values Chronology chronology [VARIABLES] boolean DateTimeFieldType[] iTypes types Partial iPartial DateTimeFieldType loopType int[] iValues values Chronology chrono chronology iChronology DurationField lastRangeField lastUnitField loopRangeField loopUnitField long serialVersionUID DateTimeFormatter[] iFormatter int compare i iFieldIndex value  	projects/Time1/src/main/java/org/joda/time/Partial.java	0.4472135954999579	221	221	1	add	
33	[BUG] [BUGGY] lastUnitField = loopUnitField; [FE] AssertionFailedError [CONTEXT] throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); } if (lastRangeField.compareTo(loopRangeField) == 0) { throw new IllegalArgumentException("Types array must not contain duplicate: " + types[i - 1].getName() + " and " + loopType.getName()); } } } } [BUGGY] lastUnitField = loopUnitField; [BUGGY] } iTypes = (DateTimeFieldType[]) types.clone(); chronology.validate(this, values); iValues = (int[]) values.clone(); } [CLASS] Partial Property [METHOD] <init> [RETURN_TYPE] Chronology)  DateTimeFieldType[] types int[] values Chronology chronology [VARIABLES] boolean DateTimeFieldType[] iTypes types Partial iPartial DateTimeFieldType loopType int[] iValues values Chronology chrono chronology iChronology DurationField lastRangeField lastUnitField loopRangeField loopUnitField long serialVersionUID DateTimeFormatter[] iFormatter int compare i iFieldIndex value  	projects/Time1/src/main/java/org/joda/time/Partial.java	0.4472135954999579	245	245	1	replace	
34	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); } if (lastRangeField.compareTo(loopRangeField) == 0) { throw new IllegalArgumentException("Types array must not contain duplicate: " + types[i - 1].getName() + " and " + loopType.getName()); } } } } [BUGGY] [BUGGY] lastUnitField = loopUnitField; } iTypes = (DateTimeFieldType[]) types.clone(); chronology.validate(this, values); iValues = (int[]) values.clone(); } [CLASS] Partial Property [METHOD] <init> [RETURN_TYPE] Chronology)  DateTimeFieldType[] types int[] values Chronology chronology [VARIABLES] boolean DateTimeFieldType[] iTypes types Partial iPartial DateTimeFieldType loopType int[] iValues values Chronology chrono chronology iChronology DurationField lastRangeField lastUnitField loopRangeField loopUnitField long serialVersionUID DateTimeFormatter[] iFormatter int compare i iFieldIndex value  	projects/Time1/src/main/java/org/joda/time/Partial.java	0.4472135954999579	245	245	1	add	
35	[BUG] [BUGGY] for (int i = 0; i < types.length; i++) { [FE] AssertionFailedError [CONTEXT] throw new IllegalArgumentException("Values array must not be null"); } if (values.length != types.length) { throw new IllegalArgumentException("Values array must be the same length as the types array"); } if (types.length == 0) { iTypes = types; iValues = values; return; } [BUGGY] for (int i = 0; i < types.length; i++) { [BUGGY] if (types[i] == null) { throw new IllegalArgumentException("Types array must not contain null: index " + i); } } DurationField lastUnitField = null; for (int i = 0; i < types.length; i++) { DateTimeFieldType loopType = types[i]; DurationField loopUnitField = loopType.getDurationType().getField(iChronology); if (i > 0) { int compare = lastUnitField.compareTo(loopUnitField); [CLASS] Partial Property [METHOD] <init> [RETURN_TYPE] Chronology)  DateTimeFieldType[] types int[] values Chronology chronology [VARIABLES] boolean DateTimeFieldType[] iTypes types Partial iPartial DateTimeFieldType loopType int[] iValues values Chronology chrono chronology iChronology DurationField lastRangeField lastUnitField loopRangeField loopUnitField long serialVersionUID DateTimeFormatter[] iFormatter int compare i iFieldIndex value  	projects/Time1/src/main/java/org/joda/time/Partial.java	0.4082482904638631	207	207	1	replace	
36	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] throw new IllegalArgumentException("Values array must not be null"); } if (values.length != types.length) { throw new IllegalArgumentException("Values array must be the same length as the types array"); } if (types.length == 0) { iTypes = types; iValues = values; return; } [BUGGY] [BUGGY] for (int i = 0; i < types.length; i++) { if (types[i] == null) { throw new IllegalArgumentException("Types array must not contain null: index " + i); } } DurationField lastUnitField = null; for (int i = 0; i < types.length; i++) { DateTimeFieldType loopType = types[i]; DurationField loopUnitField = loopType.getDurationType().getField(iChronology); if (i > 0) { int compare = lastUnitField.compareTo(loopUnitField); [CLASS] Partial Property [METHOD] <init> [RETURN_TYPE] Chronology)  DateTimeFieldType[] types int[] values Chronology chronology [VARIABLES] boolean DateTimeFieldType[] iTypes types Partial iPartial DateTimeFieldType loopType int[] iValues values Chronology chrono chronology iChronology DurationField lastRangeField lastUnitField loopRangeField loopUnitField long serialVersionUID DateTimeFormatter[] iFormatter int compare i iFieldIndex value  	projects/Time1/src/main/java/org/joda/time/Partial.java	0.4082482904638631	207	207	1	add	
37	[BUG] [BUGGY] if (types[i] == null) { [FE] AssertionFailedError [CONTEXT] } if (values.length != types.length) { throw new IllegalArgumentException("Values array must be the same length as the types array"); } if (types.length == 0) { iTypes = types; iValues = values; return; } for (int i = 0; i < types.length; i++) { [BUGGY] if (types[i] == null) { [BUGGY] throw new IllegalArgumentException("Types array must not contain null: index " + i); } } DurationField lastUnitField = null; for (int i = 0; i < types.length; i++) { DateTimeFieldType loopType = types[i]; DurationField loopUnitField = loopType.getDurationType().getField(iChronology); if (i > 0) { int compare = lastUnitField.compareTo(loopUnitField); if (compare < 0) { [CLASS] Partial Property [METHOD] <init> [RETURN_TYPE] Chronology)  DateTimeFieldType[] types int[] values Chronology chronology [VARIABLES] boolean DateTimeFieldType[] iTypes types Partial iPartial DateTimeFieldType loopType int[] iValues values Chronology chrono chronology iChronology DurationField lastRangeField lastUnitField loopRangeField loopUnitField long serialVersionUID DateTimeFormatter[] iFormatter int compare i iFieldIndex value  	projects/Time1/src/main/java/org/joda/time/Partial.java	0.4082482904638631	208	208	1	replace	
38	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] } if (values.length != types.length) { throw new IllegalArgumentException("Values array must be the same length as the types array"); } if (types.length == 0) { iTypes = types; iValues = values; return; } for (int i = 0; i < types.length; i++) { [BUGGY] [BUGGY] if (types[i] == null) { throw new IllegalArgumentException("Types array must not contain null: index " + i); } } DurationField lastUnitField = null; for (int i = 0; i < types.length; i++) { DateTimeFieldType loopType = types[i]; DurationField loopUnitField = loopType.getDurationType().getField(iChronology); if (i > 0) { int compare = lastUnitField.compareTo(loopUnitField); if (compare < 0) { [CLASS] Partial Property [METHOD] <init> [RETURN_TYPE] Chronology)  DateTimeFieldType[] types int[] values Chronology chronology [VARIABLES] boolean DateTimeFieldType[] iTypes types Partial iPartial DateTimeFieldType loopType int[] iValues values Chronology chrono chronology iChronology DurationField lastRangeField lastUnitField loopRangeField loopUnitField long serialVersionUID DateTimeFormatter[] iFormatter int compare i iFieldIndex value  	projects/Time1/src/main/java/org/joda/time/Partial.java	0.4082482904638631	208	208	1	add	
39	[BUG] [BUGGY] if (types.length == 0) { [FE] AssertionFailedError [CONTEXT] iChronology = chronology; if (types == null) { throw new IllegalArgumentException("Types array must not be null"); } if (values == null) { throw new IllegalArgumentException("Values array must not be null"); } if (values.length != types.length) { throw new IllegalArgumentException("Values array must be the same length as the types array"); } [BUGGY] if (types.length == 0) { [BUGGY] iTypes = types; iValues = values; return; } for (int i = 0; i < types.length; i++) { if (types[i] == null) { throw new IllegalArgumentException("Types array must not contain null: index " + i); } } DurationField lastUnitField = null; [CLASS] Partial Property [METHOD] <init> [RETURN_TYPE] Chronology)  DateTimeFieldType[] types int[] values Chronology chronology [VARIABLES] boolean DateTimeFieldType[] iTypes types Partial iPartial DateTimeFieldType loopType int[] iValues values Chronology chrono chronology iChronology DurationField lastRangeField lastUnitField loopRangeField loopUnitField long serialVersionUID DateTimeFormatter[] iFormatter int compare i iFieldIndex value  	projects/Time1/src/main/java/org/joda/time/Partial.java	0.3779644730092272	202	202	1	replace	
40	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] iChronology = chronology; if (types == null) { throw new IllegalArgumentException("Types array must not be null"); } if (values == null) { throw new IllegalArgumentException("Values array must not be null"); } if (values.length != types.length) { throw new IllegalArgumentException("Values array must be the same length as the types array"); } [BUGGY] [BUGGY] if (types.length == 0) { iTypes = types; iValues = values; return; } for (int i = 0; i < types.length; i++) { if (types[i] == null) { throw new IllegalArgumentException("Types array must not contain null: index " + i); } } DurationField lastUnitField = null; [CLASS] Partial Property [METHOD] <init> [RETURN_TYPE] Chronology)  DateTimeFieldType[] types int[] values Chronology chronology [VARIABLES] boolean DateTimeFieldType[] iTypes types Partial iPartial DateTimeFieldType loopType int[] iValues values Chronology chrono chronology iChronology DurationField lastRangeField lastUnitField loopRangeField loopUnitField long serialVersionUID DateTimeFormatter[] iFormatter int compare i iFieldIndex value  	projects/Time1/src/main/java/org/joda/time/Partial.java	0.3779644730092272	202	202	1	add	
41	[BUG] [BUGGY] if (values.length != types.length) { [FE] AssertionFailedError [CONTEXT] public Partial(DateTimeFieldType[] types, int[] values, Chronology chronology) { super(); chronology = DateTimeUtils.getChronology(chronology).withUTC(); iChronology = chronology; if (types == null) { throw new IllegalArgumentException("Types array must not be null"); } if (values == null) { throw new IllegalArgumentException("Values array must not be null"); } [BUGGY] if (values.length != types.length) { [BUGGY] throw new IllegalArgumentException("Values array must be the same length as the types array"); } if (types.length == 0) { iTypes = types; iValues = values; return; } for (int i = 0; i < types.length; i++) { if (types[i] == null) { throw new IllegalArgumentException("Types array must not contain null: index " + i); [CLASS] Partial Property [METHOD] <init> [RETURN_TYPE] Chronology)  DateTimeFieldType[] types int[] values Chronology chronology [VARIABLES] boolean DateTimeFieldType[] iTypes types Partial iPartial DateTimeFieldType loopType int[] iValues values Chronology chrono chronology iChronology DurationField lastRangeField lastUnitField loopRangeField loopUnitField long serialVersionUID DateTimeFormatter[] iFormatter int compare i iFieldIndex value  	projects/Time1/src/main/java/org/joda/time/Partial.java	0.35355339059327373	199	199	1	replace	
42	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] public Partial(DateTimeFieldType[] types, int[] values, Chronology chronology) { super(); chronology = DateTimeUtils.getChronology(chronology).withUTC(); iChronology = chronology; if (types == null) { throw new IllegalArgumentException("Types array must not be null"); } if (values == null) { throw new IllegalArgumentException("Values array must not be null"); } [BUGGY] [BUGGY] if (values.length != types.length) { throw new IllegalArgumentException("Values array must be the same length as the types array"); } if (types.length == 0) { iTypes = types; iValues = values; return; } for (int i = 0; i < types.length; i++) { if (types[i] == null) { throw new IllegalArgumentException("Types array must not contain null: index " + i); [CLASS] Partial Property [METHOD] <init> [RETURN_TYPE] Chronology)  DateTimeFieldType[] types int[] values Chronology chronology [VARIABLES] boolean DateTimeFieldType[] iTypes types Partial iPartial DateTimeFieldType loopType int[] iValues values Chronology chrono chronology iChronology DurationField lastRangeField lastUnitField loopRangeField loopUnitField long serialVersionUID DateTimeFormatter[] iFormatter int compare i iFieldIndex value  	projects/Time1/src/main/java/org/joda/time/Partial.java	0.35355339059327373	199	199	1	add	
43	[BUG] [BUGGY] return iTypes[index].getField(chrono); [FE] AssertionFailedError [CONTEXT] protected DateTimeField getField(int index, Chronology chrono) { [BUGGY] return iTypes[index].getField(chrono); [BUGGY] } [CLASS] Partial Property [METHOD] getField [RETURN_TYPE] DateTimeField  int index Chronology chrono [VARIABLES] boolean DateTimeFieldType[] iTypes types Partial iPartial partial int[] iValues values Chronology chrono chronology iChronology long serialVersionUID DateTimeFormatter[] iFormatter int compare fieldIndex i iFieldIndex index value  	projects/Time1/src/main/java/org/joda/time/Partial.java	0.35355339059327373	335	335	1	replace	
44	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] protected DateTimeField getField(int index, Chronology chrono) { [BUGGY] [BUGGY] return iTypes[index].getField(chrono); } [CLASS] Partial Property [METHOD] getField [RETURN_TYPE] DateTimeField  int index Chronology chrono [VARIABLES] boolean DateTimeFieldType[] iTypes types Partial iPartial partial int[] iValues values Chronology chrono chronology iChronology long serialVersionUID DateTimeFormatter[] iFormatter int compare fieldIndex i iFieldIndex index value  	projects/Time1/src/main/java/org/joda/time/Partial.java	0.35355339059327373	335	335	1	add	
45	[BUG] [BUGGY] this(types, values, null); [FE] AssertionFailedError [CONTEXT] public Partial(DateTimeFieldType[] types, int[] values) { [BUGGY] this(types, values, null); [BUGGY] } [CLASS] Partial Property [METHOD] <init> [RETURN_TYPE] DateTimeFieldType[],int[])  DateTimeFieldType[] types int[] values [VARIABLES] boolean DateTimeFieldType[] iTypes types Partial iPartial int[] iValues values Chronology chrono chronology iChronology long serialVersionUID DateTimeFormatter[] iFormatter int iFieldIndex value  	projects/Time1/src/main/java/org/joda/time/Partial.java	0.3333333333333333	175	175	1	replace	
46	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] public Partial(DateTimeFieldType[] types, int[] values) { [BUGGY] [BUGGY] this(types, values, null); } [CLASS] Partial Property [METHOD] <init> [RETURN_TYPE] DateTimeFieldType[],int[])  DateTimeFieldType[] types int[] values [VARIABLES] boolean DateTimeFieldType[] iTypes types Partial iPartial int[] iValues values Chronology chrono chronology iChronology long serialVersionUID DateTimeFormatter[] iFormatter int iFieldIndex value  	projects/Time1/src/main/java/org/joda/time/Partial.java	0.3333333333333333	175	175	1	add	
47	[BUG] [BUGGY] if (values == null) { [FE] AssertionFailedError [CONTEXT] public Partial(DateTimeFieldType[] types, int[] values, Chronology chronology) { super(); chronology = DateTimeUtils.getChronology(chronology).withUTC(); iChronology = chronology; if (types == null) { throw new IllegalArgumentException("Types array must not be null"); } [BUGGY] if (values == null) { [BUGGY] throw new IllegalArgumentException("Values array must not be null"); } if (values.length != types.length) { throw new IllegalArgumentException("Values array must be the same length as the types array"); } if (types.length == 0) { iTypes = types; iValues = values; return; } [CLASS] Partial Property [METHOD] <init> [RETURN_TYPE] Chronology)  DateTimeFieldType[] types int[] values Chronology chronology [VARIABLES] boolean DateTimeFieldType[] iTypes types Partial iPartial DateTimeFieldType loopType int[] iValues values Chronology chrono chronology iChronology DurationField lastRangeField lastUnitField loopRangeField loopUnitField long serialVersionUID DateTimeFormatter[] iFormatter int compare i iFieldIndex value  	projects/Time1/src/main/java/org/joda/time/Partial.java	0.3333333333333333	196	196	1	replace	
48	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] public Partial(DateTimeFieldType[] types, int[] values, Chronology chronology) { super(); chronology = DateTimeUtils.getChronology(chronology).withUTC(); iChronology = chronology; if (types == null) { throw new IllegalArgumentException("Types array must not be null"); } [BUGGY] [BUGGY] if (values == null) { throw new IllegalArgumentException("Values array must not be null"); } if (values.length != types.length) { throw new IllegalArgumentException("Values array must be the same length as the types array"); } if (types.length == 0) { iTypes = types; iValues = values; return; } [CLASS] Partial Property [METHOD] <init> [RETURN_TYPE] Chronology)  DateTimeFieldType[] types int[] values Chronology chronology [VARIABLES] boolean DateTimeFieldType[] iTypes types Partial iPartial DateTimeFieldType loopType int[] iValues values Chronology chrono chronology iChronology DurationField lastRangeField lastUnitField loopRangeField loopUnitField long serialVersionUID DateTimeFormatter[] iFormatter int compare i iFieldIndex value  	projects/Time1/src/main/java/org/joda/time/Partial.java	0.3333333333333333	196	196	1	add	
49	[BUG] [BUGGY] super(); [FE] AssertionFailedError [CONTEXT] public Partial(DateTimeFieldType[] types, int[] values, Chronology chronology) { [BUGGY] super(); [BUGGY] chronology = DateTimeUtils.getChronology(chronology).withUTC(); iChronology = chronology; if (types == null) { throw new IllegalArgumentException("Types array must not be null"); } if (values == null) { throw new IllegalArgumentException("Values array must not be null"); } if (values.length != types.length) { throw new IllegalArgumentException("Values array must be the same length as the types array"); [CLASS] Partial Property [METHOD] <init> [RETURN_TYPE] Chronology)  DateTimeFieldType[] types int[] values Chronology chronology [VARIABLES] boolean DateTimeFieldType[] iTypes types Partial iPartial DateTimeFieldType loopType int[] iValues values Chronology chrono chronology iChronology DurationField lastRangeField lastUnitField loopRangeField loopUnitField long serialVersionUID DateTimeFormatter[] iFormatter int compare i iFieldIndex value  	projects/Time1/src/main/java/org/joda/time/Partial.java	0.31622776601683794	190	190	1	replace	
50	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] public Partial(DateTimeFieldType[] types, int[] values, Chronology chronology) { [BUGGY] [BUGGY] super(); chronology = DateTimeUtils.getChronology(chronology).withUTC(); iChronology = chronology; if (types == null) { throw new IllegalArgumentException("Types array must not be null"); } if (values == null) { throw new IllegalArgumentException("Values array must not be null"); } if (values.length != types.length) { throw new IllegalArgumentException("Values array must be the same length as the types array"); [CLASS] Partial Property [METHOD] <init> [RETURN_TYPE] Chronology)  DateTimeFieldType[] types int[] values Chronology chronology [VARIABLES] boolean DateTimeFieldType[] iTypes types Partial iPartial DateTimeFieldType loopType int[] iValues values Chronology chrono chronology iChronology DurationField lastRangeField lastUnitField loopRangeField loopUnitField long serialVersionUID DateTimeFormatter[] iFormatter int compare i iFieldIndex value  	projects/Time1/src/main/java/org/joda/time/Partial.java	0.31622776601683794	190	190	1	add	
51	[BUG] [BUGGY] chronology = DateTimeUtils.getChronology(chronology).withUTC(); [FE] AssertionFailedError [CONTEXT] public Partial(DateTimeFieldType[] types, int[] values, Chronology chronology) { super(); [BUGGY] chronology = DateTimeUtils.getChronology(chronology).withUTC(); [BUGGY] iChronology = chronology; if (types == null) { throw new IllegalArgumentException("Types array must not be null"); } if (values == null) { throw new IllegalArgumentException("Values array must not be null"); } if (values.length != types.length) { throw new IllegalArgumentException("Values array must be the same length as the types array"); } [CLASS] Partial Property [METHOD] <init> [RETURN_TYPE] Chronology)  DateTimeFieldType[] types int[] values Chronology chronology [VARIABLES] boolean DateTimeFieldType[] iTypes types Partial iPartial DateTimeFieldType loopType int[] iValues values Chronology chrono chronology iChronology DurationField lastRangeField lastUnitField loopRangeField loopUnitField long serialVersionUID DateTimeFormatter[] iFormatter int compare i iFieldIndex value  	projects/Time1/src/main/java/org/joda/time/Partial.java	0.31622776601683794	191	191	1	replace	
52	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] public Partial(DateTimeFieldType[] types, int[] values, Chronology chronology) { super(); [BUGGY] [BUGGY] chronology = DateTimeUtils.getChronology(chronology).withUTC(); iChronology = chronology; if (types == null) { throw new IllegalArgumentException("Types array must not be null"); } if (values == null) { throw new IllegalArgumentException("Values array must not be null"); } if (values.length != types.length) { throw new IllegalArgumentException("Values array must be the same length as the types array"); } [CLASS] Partial Property [METHOD] <init> [RETURN_TYPE] Chronology)  DateTimeFieldType[] types int[] values Chronology chronology [VARIABLES] boolean DateTimeFieldType[] iTypes types Partial iPartial DateTimeFieldType loopType int[] iValues values Chronology chrono chronology iChronology DurationField lastRangeField lastUnitField loopRangeField loopUnitField long serialVersionUID DateTimeFormatter[] iFormatter int compare i iFieldIndex value  	projects/Time1/src/main/java/org/joda/time/Partial.java	0.31622776601683794	191	191	1	add	
53	[BUG] [BUGGY] iChronology = chronology; [FE] AssertionFailedError [CONTEXT] public Partial(DateTimeFieldType[] types, int[] values, Chronology chronology) { super(); chronology = DateTimeUtils.getChronology(chronology).withUTC(); [BUGGY] iChronology = chronology; [BUGGY] if (types == null) { throw new IllegalArgumentException("Types array must not be null"); } if (values == null) { throw new IllegalArgumentException("Values array must not be null"); } if (values.length != types.length) { throw new IllegalArgumentException("Values array must be the same length as the types array"); } if (types.length == 0) { [CLASS] Partial Property [METHOD] <init> [RETURN_TYPE] Chronology)  DateTimeFieldType[] types int[] values Chronology chronology [VARIABLES] boolean DateTimeFieldType[] iTypes types Partial iPartial DateTimeFieldType loopType int[] iValues values Chronology chrono chronology iChronology DurationField lastRangeField lastUnitField loopRangeField loopUnitField long serialVersionUID DateTimeFormatter[] iFormatter int compare i iFieldIndex value  	projects/Time1/src/main/java/org/joda/time/Partial.java	0.31622776601683794	192	192	1	replace	
54	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] public Partial(DateTimeFieldType[] types, int[] values, Chronology chronology) { super(); chronology = DateTimeUtils.getChronology(chronology).withUTC(); [BUGGY] [BUGGY] iChronology = chronology; if (types == null) { throw new IllegalArgumentException("Types array must not be null"); } if (values == null) { throw new IllegalArgumentException("Values array must not be null"); } if (values.length != types.length) { throw new IllegalArgumentException("Values array must be the same length as the types array"); } if (types.length == 0) { [CLASS] Partial Property [METHOD] <init> [RETURN_TYPE] Chronology)  DateTimeFieldType[] types int[] values Chronology chronology [VARIABLES] boolean DateTimeFieldType[] iTypes types Partial iPartial DateTimeFieldType loopType int[] iValues values Chronology chrono chronology iChronology DurationField lastRangeField lastUnitField loopRangeField loopUnitField long serialVersionUID DateTimeFormatter[] iFormatter int compare i iFieldIndex value  	projects/Time1/src/main/java/org/joda/time/Partial.java	0.31622776601683794	192	192	1	add	
55	[BUG] [BUGGY] if (types == null) { [FE] AssertionFailedError [CONTEXT] public Partial(DateTimeFieldType[] types, int[] values, Chronology chronology) { super(); chronology = DateTimeUtils.getChronology(chronology).withUTC(); iChronology = chronology; [BUGGY] if (types == null) { [BUGGY] throw new IllegalArgumentException("Types array must not be null"); } if (values == null) { throw new IllegalArgumentException("Values array must not be null"); } if (values.length != types.length) { throw new IllegalArgumentException("Values array must be the same length as the types array"); } if (types.length == 0) { iTypes = types; [CLASS] Partial Property [METHOD] <init> [RETURN_TYPE] Chronology)  DateTimeFieldType[] types int[] values Chronology chronology [VARIABLES] boolean DateTimeFieldType[] iTypes types Partial iPartial DateTimeFieldType loopType int[] iValues values Chronology chrono chronology iChronology DurationField lastRangeField lastUnitField loopRangeField loopUnitField long serialVersionUID DateTimeFormatter[] iFormatter int compare i iFieldIndex value  	projects/Time1/src/main/java/org/joda/time/Partial.java	0.31622776601683794	193	193	1	replace	
56	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] public Partial(DateTimeFieldType[] types, int[] values, Chronology chronology) { super(); chronology = DateTimeUtils.getChronology(chronology).withUTC(); iChronology = chronology; [BUGGY] [BUGGY] if (types == null) { throw new IllegalArgumentException("Types array must not be null"); } if (values == null) { throw new IllegalArgumentException("Values array must not be null"); } if (values.length != types.length) { throw new IllegalArgumentException("Values array must be the same length as the types array"); } if (types.length == 0) { iTypes = types; [CLASS] Partial Property [METHOD] <init> [RETURN_TYPE] Chronology)  DateTimeFieldType[] types int[] values Chronology chronology [VARIABLES] boolean DateTimeFieldType[] iTypes types Partial iPartial DateTimeFieldType loopType int[] iValues values Chronology chrono chronology iChronology DurationField lastRangeField lastUnitField loopRangeField loopUnitField long serialVersionUID DateTimeFormatter[] iFormatter int compare i iFieldIndex value  	projects/Time1/src/main/java/org/joda/time/Partial.java	0.31622776601683794	193	193	1	add	
57	[BUG] [BUGGY] return iTypes.length; [FE] AssertionFailedError [CONTEXT] public int size() { [BUGGY] return iTypes.length; [BUGGY] } [CLASS] Partial Property [METHOD] size [RETURN_TYPE] int  [VARIABLES] boolean DateTimeFieldType[] iTypes types Partial iPartial partial int[] iValues values Chronology chrono chronology iChronology long serialVersionUID DateTimeFormatter[] iFormatter int compare fieldIndex i iFieldIndex value  	projects/Time1/src/main/java/org/joda/time/Partial.java	0.2886751345948129	311	311	1	replace	
58	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] public int size() { [BUGGY] [BUGGY] return iTypes.length; } [CLASS] Partial Property [METHOD] size [RETURN_TYPE] int  [VARIABLES] boolean DateTimeFieldType[] iTypes types Partial iPartial partial int[] iValues values Chronology chrono chronology iChronology long serialVersionUID DateTimeFormatter[] iFormatter int compare fieldIndex i iFieldIndex value  	projects/Time1/src/main/java/org/joda/time/Partial.java	0.2886751345948129	311	311	1	add	
59	[BUG] [BUGGY] return iChronology; [FE] AssertionFailedError [CONTEXT] public Chronology getChronology() { [BUGGY] return iChronology; [BUGGY] } [CLASS] Partial Property [METHOD] getChronology [RETURN_TYPE] Chronology  [VARIABLES] boolean DateTimeFieldType[] iTypes types Partial iPartial partial int[] iValues values Chronology chrono chronology iChronology long serialVersionUID DateTimeFormatter[] iFormatter int compare fieldIndex i iFieldIndex value  	projects/Time1/src/main/java/org/joda/time/Partial.java	0.2886751345948129	323	323	1	replace	
60	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] public Chronology getChronology() { [BUGGY] [BUGGY] return iChronology; } [CLASS] Partial Property [METHOD] getChronology [RETURN_TYPE] Chronology  [VARIABLES] boolean DateTimeFieldType[] iTypes types Partial iPartial partial int[] iValues values Chronology chrono chronology iChronology long serialVersionUID DateTimeFormatter[] iFormatter int compare fieldIndex i iFieldIndex value  	projects/Time1/src/main/java/org/joda/time/Partial.java	0.2886751345948129	323	323	1	add	
61	[BUG] [BUGGY] private UnsupportedDurationField(DurationFieldType type) { [FE] AssertionFailedError [CONTEXT] [BUGGY] private UnsupportedDurationField(DurationFieldType type) { [BUGGY] iType = type; } [CLASS] UnsupportedDurationField [METHOD] <init> [RETURN_TYPE] DurationFieldType)  DurationFieldType type [VARIABLES] boolean HashMap cCache long serialVersionUID DurationFieldType iType type  	projects/Time1/src/main/java/org/joda/time/field/UnsupportedDurationField.java	0.22360679774997896	70	70	1	replace	
62	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] [BUGGY] [BUGGY] private UnsupportedDurationField(DurationFieldType type) { iType = type; } [CLASS] UnsupportedDurationField [METHOD] <init> [RETURN_TYPE] DurationFieldType)  DurationFieldType type [VARIABLES] boolean HashMap cCache long serialVersionUID DurationFieldType iType type  	projects/Time1/src/main/java/org/joda/time/field/UnsupportedDurationField.java	0.22360679774997896	70	70	1	add	
63	[BUG] [BUGGY] iType = type; [FE] AssertionFailedError [CONTEXT] private UnsupportedDurationField(DurationFieldType type) { [BUGGY] iType = type; [BUGGY] } [CLASS] UnsupportedDurationField [METHOD] <init> [RETURN_TYPE] DurationFieldType)  DurationFieldType type [VARIABLES] boolean HashMap cCache long serialVersionUID DurationFieldType iType type  	projects/Time1/src/main/java/org/joda/time/field/UnsupportedDurationField.java	0.22360679774997896	71	71	1	replace	
64	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] private UnsupportedDurationField(DurationFieldType type) { [BUGGY] [BUGGY] iType = type; } [CLASS] UnsupportedDurationField [METHOD] <init> [RETURN_TYPE] DurationFieldType)  DurationFieldType type [VARIABLES] boolean HashMap cCache long serialVersionUID DurationFieldType iType type  	projects/Time1/src/main/java/org/joda/time/field/UnsupportedDurationField.java	0.22360679774997896	71	71	1	add	
65	[BUG] [BUGGY] } [FE] AssertionFailedError [CONTEXT] private UnsupportedDurationField(DurationFieldType type) { iType = type; [BUGGY] } [BUGGY]  [CLASS] UnsupportedDurationField [METHOD] <init> [RETURN_TYPE] DurationFieldType)  DurationFieldType type [VARIABLES] boolean HashMap cCache long serialVersionUID DurationFieldType iType type  	projects/Time1/src/main/java/org/joda/time/field/UnsupportedDurationField.java	0.22360679774997896	72	72	1	replace	
66	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] private UnsupportedDurationField(DurationFieldType type) { iType = type; [BUGGY] [BUGGY] } [CLASS] UnsupportedDurationField [METHOD] <init> [RETURN_TYPE] DurationFieldType)  DurationFieldType type [VARIABLES] boolean HashMap cCache long serialVersionUID DurationFieldType iType type  	projects/Time1/src/main/java/org/joda/time/field/UnsupportedDurationField.java	0.22360679774997896	72	72	1	add	
67	[BUG] [BUGGY] if (cCache == null) { [FE] AssertionFailedError [CONTEXT] public static synchronized UnsupportedDurationField getInstance(DurationFieldType type) { UnsupportedDurationField field; [BUGGY] if (cCache == null) { [BUGGY] cCache = new HashMap<DurationFieldType, UnsupportedDurationField>(7); field = null; } else { field = cCache.get(type); } if (field == null) { field = new UnsupportedDurationField(type); cCache.put(type, field); } return field; [CLASS] UnsupportedDurationField [METHOD] getInstance [RETURN_TYPE] UnsupportedDurationField  DurationFieldType type [VARIABLES] boolean UnsupportedDurationField field HashMap cCache long serialVersionUID DurationFieldType iType type  	projects/Time1/src/main/java/org/joda/time/field/UnsupportedDurationField.java	0.22360679774997896	49	49	1	replace	
68	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] public static synchronized UnsupportedDurationField getInstance(DurationFieldType type) { UnsupportedDurationField field; [BUGGY] [BUGGY] if (cCache == null) { cCache = new HashMap<DurationFieldType, UnsupportedDurationField>(7); field = null; } else { field = cCache.get(type); } if (field == null) { field = new UnsupportedDurationField(type); cCache.put(type, field); } return field; [CLASS] UnsupportedDurationField [METHOD] getInstance [RETURN_TYPE] UnsupportedDurationField  DurationFieldType type [VARIABLES] boolean UnsupportedDurationField field HashMap cCache long serialVersionUID DurationFieldType iType type  	projects/Time1/src/main/java/org/joda/time/field/UnsupportedDurationField.java	0.22360679774997896	49	49	1	add	
69	[BUG] [BUGGY] cCache = new HashMap<DurationFieldType, UnsupportedDurationField>(7); [FE] AssertionFailedError [CONTEXT] public static synchronized UnsupportedDurationField getInstance(DurationFieldType type) { UnsupportedDurationField field; if (cCache == null) { [BUGGY] cCache = new HashMap<DurationFieldType, UnsupportedDurationField>(7); [BUGGY] field = null; } else { field = cCache.get(type); } if (field == null) { field = new UnsupportedDurationField(type); cCache.put(type, field); } return field; } [CLASS] UnsupportedDurationField [METHOD] getInstance [RETURN_TYPE] UnsupportedDurationField  DurationFieldType type [VARIABLES] boolean UnsupportedDurationField field HashMap cCache long serialVersionUID DurationFieldType iType type  	projects/Time1/src/main/java/org/joda/time/field/UnsupportedDurationField.java	0.22360679774997896	50	50	1	replace	
70	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] public static synchronized UnsupportedDurationField getInstance(DurationFieldType type) { UnsupportedDurationField field; if (cCache == null) { [BUGGY] [BUGGY] cCache = new HashMap<DurationFieldType, UnsupportedDurationField>(7); field = null; } else { field = cCache.get(type); } if (field == null) { field = new UnsupportedDurationField(type); cCache.put(type, field); } return field; } [CLASS] UnsupportedDurationField [METHOD] getInstance [RETURN_TYPE] UnsupportedDurationField  DurationFieldType type [VARIABLES] boolean UnsupportedDurationField field HashMap cCache long serialVersionUID DurationFieldType iType type  	projects/Time1/src/main/java/org/joda/time/field/UnsupportedDurationField.java	0.22360679774997896	50	50	1	add	
71	[BUG] [BUGGY] field = null; [FE] AssertionFailedError [CONTEXT] public static synchronized UnsupportedDurationField getInstance(DurationFieldType type) { UnsupportedDurationField field; if (cCache == null) { cCache = new HashMap<DurationFieldType, UnsupportedDurationField>(7); [BUGGY] field = null; [BUGGY] } else { field = cCache.get(type); } if (field == null) { field = new UnsupportedDurationField(type); cCache.put(type, field); } return field; } [CLASS] UnsupportedDurationField [METHOD] getInstance [RETURN_TYPE] UnsupportedDurationField  DurationFieldType type [VARIABLES] boolean UnsupportedDurationField field HashMap cCache long serialVersionUID DurationFieldType iType type  	projects/Time1/src/main/java/org/joda/time/field/UnsupportedDurationField.java	0.22360679774997896	51	51	1	replace	
72	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] public static synchronized UnsupportedDurationField getInstance(DurationFieldType type) { UnsupportedDurationField field; if (cCache == null) { cCache = new HashMap<DurationFieldType, UnsupportedDurationField>(7); [BUGGY] [BUGGY] field = null; } else { field = cCache.get(type); } if (field == null) { field = new UnsupportedDurationField(type); cCache.put(type, field); } return field; } [CLASS] UnsupportedDurationField [METHOD] getInstance [RETURN_TYPE] UnsupportedDurationField  DurationFieldType type [VARIABLES] boolean UnsupportedDurationField field HashMap cCache long serialVersionUID DurationFieldType iType type  	projects/Time1/src/main/java/org/joda/time/field/UnsupportedDurationField.java	0.22360679774997896	51	51	1	add	
73	[BUG] [BUGGY] field = cCache.get(type); [FE] AssertionFailedError [CONTEXT] public static synchronized UnsupportedDurationField getInstance(DurationFieldType type) { UnsupportedDurationField field; if (cCache == null) { cCache = new HashMap<DurationFieldType, UnsupportedDurationField>(7); field = null; } else { [BUGGY] field = cCache.get(type); [BUGGY] } if (field == null) { field = new UnsupportedDurationField(type); cCache.put(type, field); } return field; } [CLASS] UnsupportedDurationField [METHOD] getInstance [RETURN_TYPE] UnsupportedDurationField  DurationFieldType type [VARIABLES] boolean UnsupportedDurationField field HashMap cCache long serialVersionUID DurationFieldType iType type  	projects/Time1/src/main/java/org/joda/time/field/UnsupportedDurationField.java	0.22360679774997896	53	53	1	replace	
74	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] public static synchronized UnsupportedDurationField getInstance(DurationFieldType type) { UnsupportedDurationField field; if (cCache == null) { cCache = new HashMap<DurationFieldType, UnsupportedDurationField>(7); field = null; } else { [BUGGY] [BUGGY] field = cCache.get(type); } if (field == null) { field = new UnsupportedDurationField(type); cCache.put(type, field); } return field; } [CLASS] UnsupportedDurationField [METHOD] getInstance [RETURN_TYPE] UnsupportedDurationField  DurationFieldType type [VARIABLES] boolean UnsupportedDurationField field HashMap cCache long serialVersionUID DurationFieldType iType type  	projects/Time1/src/main/java/org/joda/time/field/UnsupportedDurationField.java	0.22360679774997896	53	53	1	add	
75	[BUG] [BUGGY] if (field == null) { [FE] AssertionFailedError [CONTEXT] public static synchronized UnsupportedDurationField getInstance(DurationFieldType type) { UnsupportedDurationField field; if (cCache == null) { cCache = new HashMap<DurationFieldType, UnsupportedDurationField>(7); field = null; } else { field = cCache.get(type); } [BUGGY] if (field == null) { [BUGGY] field = new UnsupportedDurationField(type); cCache.put(type, field); } return field; } [CLASS] UnsupportedDurationField [METHOD] getInstance [RETURN_TYPE] UnsupportedDurationField  DurationFieldType type [VARIABLES] boolean UnsupportedDurationField field HashMap cCache long serialVersionUID DurationFieldType iType type  	projects/Time1/src/main/java/org/joda/time/field/UnsupportedDurationField.java	0.22360679774997896	55	55	1	replace	
76	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] public static synchronized UnsupportedDurationField getInstance(DurationFieldType type) { UnsupportedDurationField field; if (cCache == null) { cCache = new HashMap<DurationFieldType, UnsupportedDurationField>(7); field = null; } else { field = cCache.get(type); } [BUGGY] [BUGGY] if (field == null) { field = new UnsupportedDurationField(type); cCache.put(type, field); } return field; } [CLASS] UnsupportedDurationField [METHOD] getInstance [RETURN_TYPE] UnsupportedDurationField  DurationFieldType type [VARIABLES] boolean UnsupportedDurationField field HashMap cCache long serialVersionUID DurationFieldType iType type  	projects/Time1/src/main/java/org/joda/time/field/UnsupportedDurationField.java	0.22360679774997896	55	55	1	add	
77	[BUG] [BUGGY] field = new UnsupportedDurationField(type); [FE] AssertionFailedError [CONTEXT] public static synchronized UnsupportedDurationField getInstance(DurationFieldType type) { UnsupportedDurationField field; if (cCache == null) { cCache = new HashMap<DurationFieldType, UnsupportedDurationField>(7); field = null; } else { field = cCache.get(type); } if (field == null) { [BUGGY] field = new UnsupportedDurationField(type); [BUGGY] cCache.put(type, field); } return field; } [CLASS] UnsupportedDurationField [METHOD] getInstance [RETURN_TYPE] UnsupportedDurationField  DurationFieldType type [VARIABLES] boolean UnsupportedDurationField field HashMap cCache long serialVersionUID DurationFieldType iType type  	projects/Time1/src/main/java/org/joda/time/field/UnsupportedDurationField.java	0.22360679774997896	56	56	1	replace	
78	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] public static synchronized UnsupportedDurationField getInstance(DurationFieldType type) { UnsupportedDurationField field; if (cCache == null) { cCache = new HashMap<DurationFieldType, UnsupportedDurationField>(7); field = null; } else { field = cCache.get(type); } if (field == null) { [BUGGY] [BUGGY] field = new UnsupportedDurationField(type); cCache.put(type, field); } return field; } [CLASS] UnsupportedDurationField [METHOD] getInstance [RETURN_TYPE] UnsupportedDurationField  DurationFieldType type [VARIABLES] boolean UnsupportedDurationField field HashMap cCache long serialVersionUID DurationFieldType iType type  	projects/Time1/src/main/java/org/joda/time/field/UnsupportedDurationField.java	0.22360679774997896	56	56	1	add	
79	[BUG] [BUGGY] cCache.put(type, field); [FE] AssertionFailedError [CONTEXT] public static synchronized UnsupportedDurationField getInstance(DurationFieldType type) { UnsupportedDurationField field; if (cCache == null) { cCache = new HashMap<DurationFieldType, UnsupportedDurationField>(7); field = null; } else { field = cCache.get(type); } if (field == null) { field = new UnsupportedDurationField(type); [BUGGY] cCache.put(type, field); [BUGGY] } return field; } [CLASS] UnsupportedDurationField [METHOD] getInstance [RETURN_TYPE] UnsupportedDurationField  DurationFieldType type [VARIABLES] boolean UnsupportedDurationField field HashMap cCache long serialVersionUID DurationFieldType iType type  	projects/Time1/src/main/java/org/joda/time/field/UnsupportedDurationField.java	0.22360679774997896	57	57	1	replace	
80	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] public static synchronized UnsupportedDurationField getInstance(DurationFieldType type) { UnsupportedDurationField field; if (cCache == null) { cCache = new HashMap<DurationFieldType, UnsupportedDurationField>(7); field = null; } else { field = cCache.get(type); } if (field == null) { field = new UnsupportedDurationField(type); [BUGGY] [BUGGY] cCache.put(type, field); } return field; } [CLASS] UnsupportedDurationField [METHOD] getInstance [RETURN_TYPE] UnsupportedDurationField  DurationFieldType type [VARIABLES] boolean UnsupportedDurationField field HashMap cCache long serialVersionUID DurationFieldType iType type  	projects/Time1/src/main/java/org/joda/time/field/UnsupportedDurationField.java	0.22360679774997896	57	57	1	add	
81	[BUG] [BUGGY] return field; [FE] AssertionFailedError [CONTEXT] if (cCache == null) { cCache = new HashMap<DurationFieldType, UnsupportedDurationField>(7); field = null; } else { field = cCache.get(type); } if (field == null) { field = new UnsupportedDurationField(type); cCache.put(type, field); } [BUGGY] return field; [BUGGY] } [CLASS] UnsupportedDurationField [METHOD] getInstance [RETURN_TYPE] UnsupportedDurationField  DurationFieldType type [VARIABLES] boolean UnsupportedDurationField field HashMap cCache long serialVersionUID DurationFieldType iType type  	projects/Time1/src/main/java/org/joda/time/field/UnsupportedDurationField.java	0.22360679774997896	59	59	1	replace	
82	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] if (cCache == null) { cCache = new HashMap<DurationFieldType, UnsupportedDurationField>(7); field = null; } else { field = cCache.get(type); } if (field == null) { field = new UnsupportedDurationField(type); cCache.put(type, field); } [BUGGY] [BUGGY] return field; } [CLASS] UnsupportedDurationField [METHOD] getInstance [RETURN_TYPE] UnsupportedDurationField  DurationFieldType type [VARIABLES] boolean UnsupportedDurationField field HashMap cCache long serialVersionUID DurationFieldType iType type  	projects/Time1/src/main/java/org/joda/time/field/UnsupportedDurationField.java	0.22360679774997896	59	59	1	add	
83	[BUG] [BUGGY] return false; [FE] AssertionFailedError [CONTEXT] public boolean isSupported() { [BUGGY] return false; [BUGGY] } [CLASS] UnsupportedDurationField [METHOD] isSupported [RETURN_TYPE] boolean  [VARIABLES] boolean HashMap cCache long serialVersionUID DurationFieldType iType type  	projects/Time1/src/main/java/org/joda/time/field/UnsupportedDurationField.java	0.22360679774997896	92	92	1	replace	
84	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] public boolean isSupported() { [BUGGY] [BUGGY] return false; } [CLASS] UnsupportedDurationField [METHOD] isSupported [RETURN_TYPE] boolean  [VARIABLES] boolean HashMap cCache long serialVersionUID DurationFieldType iType type  	projects/Time1/src/main/java/org/joda/time/field/UnsupportedDurationField.java	0.22360679774997896	92	92	1	add	
85	[BUG] [BUGGY] return 0; [FE] AssertionFailedError [CONTEXT] public long getUnitMillis() { [BUGGY] return 0; [BUGGY] } [CLASS] UnsupportedDurationField [METHOD] getUnitMillis [RETURN_TYPE] long  [VARIABLES] boolean HashMap cCache long duration instant minuendInstant serialVersionUID subtrahendInstant value DurationFieldType iType type  	projects/Time1/src/main/java/org/joda/time/field/UnsupportedDurationField.java	0.22360679774997896	218	218	1	replace	
86	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] public long getUnitMillis() { [BUGGY] [BUGGY] return 0; } [CLASS] UnsupportedDurationField [METHOD] getUnitMillis [RETURN_TYPE] long  [VARIABLES] boolean HashMap cCache long duration instant minuendInstant serialVersionUID subtrahendInstant value DurationFieldType iType type  	projects/Time1/src/main/java/org/joda/time/field/UnsupportedDurationField.java	0.22360679774997896	218	218	1	add	
