bugid	buggy	buggy_class	suspiciousness	buggy_line	endbuggycode	failing_test_number	action	patch
1	[BUG] [BUGGY] scope = traverse(arg, scope); [FE] ComparisonFailure [CONTEXT]  ct = (FunctionType) constructorType; } if (ct != null && ct.isConstructor()) { type = ct.getInstanceType(); } } } n.setJSType(type); for (Node arg = constructor.getNext(); arg != null; arg = arg.getNext()) { [BUGGY] scope = traverse(arg, scope); [BUGGY] } return scope; } [CLASS] TypeInference BooleanOutcomePair [METHOD] traverseNew [RETURN_TYPE] FlowScope  Node n FlowScope scope [VARIABLES] ReverseAbstractInterpreter reverseInterpreter AbstractCompiler compiler JSTypeRegistry registry JSType constructorType type boolean Scope functionScope syntacticScope DiagnosticType FUNCTION_LITERAL_UNDEFINED_THIS TEMPLATE_TYPE_NOT_OBJECT_TYPE TEMPLATE_TYPE_OF_THIS_EXPECTED Node arg constructor n FunctionType ct BooleanLiteralSet booleanValues toBooleanOutcomes Map assertionFunctionsMap FlowScope bottomScope conditionFlowScope falseScope functionScope informed input joinedScope leftScope newScope output rightScope scope trueScope  	projects/Closure25/src/com/google/javascript/jscomp/TypeInference.java	0.5773502691896258	1060	1060	1	replace	
2	[BUG] [BUGGY] [FE] ComparisonFailure [CONTEXT]  ct = (FunctionType) constructorType; } if (ct != null && ct.isConstructor()) { type = ct.getInstanceType(); } } } n.setJSType(type); for (Node arg = constructor.getNext(); arg != null; arg = arg.getNext()) { [BUGGY] [BUGGY] scope = traverse(arg, scope); } return scope; } [CLASS] TypeInference BooleanOutcomePair [METHOD] traverseNew [RETURN_TYPE] FlowScope  Node n FlowScope scope [VARIABLES] ReverseAbstractInterpreter reverseInterpreter AbstractCompiler compiler JSTypeRegistry registry JSType constructorType type boolean Scope functionScope syntacticScope DiagnosticType FUNCTION_LITERAL_UNDEFINED_THIS TEMPLATE_TYPE_NOT_OBJECT_TYPE TEMPLATE_TYPE_OF_THIS_EXPECTED Node arg constructor n FunctionType ct BooleanLiteralSet booleanValues toBooleanOutcomes Map assertionFunctionsMap FlowScope bottomScope conditionFlowScope falseScope functionScope informed input joinedScope leftScope newScope output rightScope scope trueScope  	projects/Closure25/src/com/google/javascript/jscomp/TypeInference.java	0.5773502691896258	1060	1060	1	add	
3	[BUG] [BUGGY] scope = traverseNew(n, scope); [FE] ComparisonFailure [CONTEXT] case Token.OBJECTLIT: scope = traverseObjectLiteral(n, scope); break; case Token.CALL: scope = traverseCall(n, scope); break; case Token.NEW: [BUGGY] scope = traverseNew(n, scope); [BUGGY] break; case Token.ASSIGN_ADD: case Token.ADD: scope = traverseAdd(n, scope); break; case Token.POS: case Token.NEG: scope = traverse(n.getFirstChild(), scope);// Find types. [CLASS] TypeInference BooleanOutcomePair [METHOD] traverse [RETURN_TYPE] FlowScope  Node n FlowScope scope [VARIABLES] ReverseAbstractInterpreter reverseInterpreter AbstractCompiler compiler JSTypeRegistry registry JSType castType boolean Scope functionScope syntacticScope DiagnosticType FUNCTION_LITERAL_UNDEFINED_THIS TEMPLATE_TYPE_NOT_OBJECT_TYPE TEMPLATE_TYPE_OF_THIS_EXPECTED Node n BooleanLiteralSet booleanValues toBooleanOutcomes JSDocInfo info Map assertionFunctionsMap FlowScope bottomScope conditionFlowScope functionScope informed input joinedScope leftScope newScope output rightScope scope  	projects/Closure25/src/com/google/javascript/jscomp/TypeInference.java	0.5	288	288	1	replace	
4	[BUG] [BUGGY] [FE] ComparisonFailure [CONTEXT] case Token.OBJECTLIT: scope = traverseObjectLiteral(n, scope); break; case Token.CALL: scope = traverseCall(n, scope); break; case Token.NEW: [BUGGY] [BUGGY] scope = traverseNew(n, scope); break; case Token.ASSIGN_ADD: case Token.ADD: scope = traverseAdd(n, scope); break; case Token.POS: case Token.NEG: scope = traverse(n.getFirstChild(), scope);// Find types. [CLASS] TypeInference BooleanOutcomePair [METHOD] traverse [RETURN_TYPE] FlowScope  Node n FlowScope scope [VARIABLES] ReverseAbstractInterpreter reverseInterpreter AbstractCompiler compiler JSTypeRegistry registry JSType castType boolean Scope functionScope syntacticScope DiagnosticType FUNCTION_LITERAL_UNDEFINED_THIS TEMPLATE_TYPE_NOT_OBJECT_TYPE TEMPLATE_TYPE_OF_THIS_EXPECTED Node n BooleanLiteralSet booleanValues toBooleanOutcomes JSDocInfo info Map assertionFunctionsMap FlowScope bottomScope conditionFlowScope functionScope informed input joinedScope leftScope newScope output rightScope scope  	projects/Closure25/src/com/google/javascript/jscomp/TypeInference.java	0.5	288	288	1	add	
5	[BUG] [BUGGY] break; [FE] ComparisonFailure [CONTEXT] case Token.OBJECTLIT: scope = traverseObjectLiteral(n, scope); break; case Token.CALL: scope = traverseCall(n, scope); break; case Token.NEW: scope = traverseNew(n, scope); [BUGGY] break; [BUGGY]  case Token.ASSIGN_ADD: case Token.ADD: scope = traverseAdd(n, scope); break; case Token.POS: case Token.NEG: scope = traverse(n.getFirstChild(), scope);// Find types. n.setJSType(getNativeType(NUMBER_TYPE)); [CLASS] TypeInference BooleanOutcomePair [METHOD] traverse [RETURN_TYPE] FlowScope  Node n FlowScope scope [VARIABLES] ReverseAbstractInterpreter reverseInterpreter AbstractCompiler compiler JSTypeRegistry registry JSType castType boolean Scope functionScope syntacticScope DiagnosticType FUNCTION_LITERAL_UNDEFINED_THIS TEMPLATE_TYPE_NOT_OBJECT_TYPE TEMPLATE_TYPE_OF_THIS_EXPECTED Node n BooleanLiteralSet booleanValues toBooleanOutcomes JSDocInfo info Map assertionFunctionsMap FlowScope bottomScope conditionFlowScope functionScope informed input joinedScope leftScope newScope output rightScope scope  	projects/Closure25/src/com/google/javascript/jscomp/TypeInference.java	0.5	289	289	1	replace	
6	[BUG] [BUGGY] [FE] ComparisonFailure [CONTEXT] case Token.OBJECTLIT: scope = traverseObjectLiteral(n, scope); break; case Token.CALL: scope = traverseCall(n, scope); break; case Token.NEW: scope = traverseNew(n, scope); [BUGGY] [BUGGY] break; case Token.ASSIGN_ADD: case Token.ADD: scope = traverseAdd(n, scope); break; case Token.POS: case Token.NEG: scope = traverse(n.getFirstChild(), scope);// Find types. n.setJSType(getNativeType(NUMBER_TYPE)); [CLASS] TypeInference BooleanOutcomePair [METHOD] traverse [RETURN_TYPE] FlowScope  Node n FlowScope scope [VARIABLES] ReverseAbstractInterpreter reverseInterpreter AbstractCompiler compiler JSTypeRegistry registry JSType castType boolean Scope functionScope syntacticScope DiagnosticType FUNCTION_LITERAL_UNDEFINED_THIS TEMPLATE_TYPE_NOT_OBJECT_TYPE TEMPLATE_TYPE_OF_THIS_EXPECTED Node n BooleanLiteralSet booleanValues toBooleanOutcomes JSDocInfo info Map assertionFunctionsMap FlowScope bottomScope conditionFlowScope functionScope informed input joinedScope leftScope newScope output rightScope scope  	projects/Closure25/src/com/google/javascript/jscomp/TypeInference.java	0.5	289	289	1	add	
7	[BUG] [BUGGY] Node constructor = n.getFirstChild(); [FE] ComparisonFailure [CONTEXT] private FlowScope traverseNew(Node n, FlowScope scope) { [BUGGY] Node constructor = n.getFirstChild(); [BUGGY] scope = traverse(constructor, scope); JSType constructorType = constructor.getJSType(); JSType type = null; if (constructorType != null) { constructorType = constructorType.restrictByNotNullOrUndefined(); if (constructorType.isUnknownType()) { type = getNativeType(UNKNOWN_TYPE); } else { FunctionType ct = constructorType.toMaybeFunctionType(); if (ct == null && constructorType instanceof FunctionType) { [CLASS] TypeInference BooleanOutcomePair [METHOD] traverseNew [RETURN_TYPE] FlowScope  Node n FlowScope scope [VARIABLES] ReverseAbstractInterpreter reverseInterpreter AbstractCompiler compiler JSTypeRegistry registry JSType constructorType type boolean Scope functionScope syntacticScope DiagnosticType FUNCTION_LITERAL_UNDEFINED_THIS TEMPLATE_TYPE_NOT_OBJECT_TYPE TEMPLATE_TYPE_OF_THIS_EXPECTED Node arg constructor n FunctionType ct BooleanLiteralSet booleanValues toBooleanOutcomes Map assertionFunctionsMap FlowScope bottomScope conditionFlowScope falseScope functionScope informed input joinedScope leftScope newScope output rightScope scope trueScope  	projects/Closure25/src/com/google/javascript/jscomp/TypeInference.java	0.5	1037	1037	1	replace	
8	[BUG] [BUGGY] [FE] ComparisonFailure [CONTEXT] private FlowScope traverseNew(Node n, FlowScope scope) { [BUGGY] [BUGGY] Node constructor = n.getFirstChild(); scope = traverse(constructor, scope); JSType constructorType = constructor.getJSType(); JSType type = null; if (constructorType != null) { constructorType = constructorType.restrictByNotNullOrUndefined(); if (constructorType.isUnknownType()) { type = getNativeType(UNKNOWN_TYPE); } else { FunctionType ct = constructorType.toMaybeFunctionType(); if (ct == null && constructorType instanceof FunctionType) { [CLASS] TypeInference BooleanOutcomePair [METHOD] traverseNew [RETURN_TYPE] FlowScope  Node n FlowScope scope [VARIABLES] ReverseAbstractInterpreter reverseInterpreter AbstractCompiler compiler JSTypeRegistry registry JSType constructorType type boolean Scope functionScope syntacticScope DiagnosticType FUNCTION_LITERAL_UNDEFINED_THIS TEMPLATE_TYPE_NOT_OBJECT_TYPE TEMPLATE_TYPE_OF_THIS_EXPECTED Node arg constructor n FunctionType ct BooleanLiteralSet booleanValues toBooleanOutcomes Map assertionFunctionsMap FlowScope bottomScope conditionFlowScope falseScope functionScope informed input joinedScope leftScope newScope output rightScope scope trueScope  	projects/Closure25/src/com/google/javascript/jscomp/TypeInference.java	0.5	1037	1037	1	add	
9	[BUG] [BUGGY] scope = traverse(constructor, scope); [FE] ComparisonFailure [CONTEXT] private FlowScope traverseNew(Node n, FlowScope scope) { Node constructor = n.getFirstChild(); [BUGGY] scope = traverse(constructor, scope); [BUGGY] JSType constructorType = constructor.getJSType(); JSType type = null; if (constructorType != null) { constructorType = constructorType.restrictByNotNullOrUndefined(); if (constructorType.isUnknownType()) { type = getNativeType(UNKNOWN_TYPE); } else { FunctionType ct = constructorType.toMaybeFunctionType(); if (ct == null && constructorType instanceof FunctionType) {  [CLASS] TypeInference BooleanOutcomePair [METHOD] traverseNew [RETURN_TYPE] FlowScope  Node n FlowScope scope [VARIABLES] ReverseAbstractInterpreter reverseInterpreter AbstractCompiler compiler JSTypeRegistry registry JSType constructorType type boolean Scope functionScope syntacticScope DiagnosticType FUNCTION_LITERAL_UNDEFINED_THIS TEMPLATE_TYPE_NOT_OBJECT_TYPE TEMPLATE_TYPE_OF_THIS_EXPECTED Node arg constructor n FunctionType ct BooleanLiteralSet booleanValues toBooleanOutcomes Map assertionFunctionsMap FlowScope bottomScope conditionFlowScope falseScope functionScope informed input joinedScope leftScope newScope output rightScope scope trueScope  	projects/Closure25/src/com/google/javascript/jscomp/TypeInference.java	0.5	1038	1038	1	replace	
10	[BUG] [BUGGY] [FE] ComparisonFailure [CONTEXT] private FlowScope traverseNew(Node n, FlowScope scope) { Node constructor = n.getFirstChild(); [BUGGY] [BUGGY] scope = traverse(constructor, scope); JSType constructorType = constructor.getJSType(); JSType type = null; if (constructorType != null) { constructorType = constructorType.restrictByNotNullOrUndefined(); if (constructorType.isUnknownType()) { type = getNativeType(UNKNOWN_TYPE); } else { FunctionType ct = constructorType.toMaybeFunctionType(); if (ct == null && constructorType instanceof FunctionType) {  [CLASS] TypeInference BooleanOutcomePair [METHOD] traverseNew [RETURN_TYPE] FlowScope  Node n FlowScope scope [VARIABLES] ReverseAbstractInterpreter reverseInterpreter AbstractCompiler compiler JSTypeRegistry registry JSType constructorType type boolean Scope functionScope syntacticScope DiagnosticType FUNCTION_LITERAL_UNDEFINED_THIS TEMPLATE_TYPE_NOT_OBJECT_TYPE TEMPLATE_TYPE_OF_THIS_EXPECTED Node arg constructor n FunctionType ct BooleanLiteralSet booleanValues toBooleanOutcomes Map assertionFunctionsMap FlowScope bottomScope conditionFlowScope falseScope functionScope informed input joinedScope leftScope newScope output rightScope scope trueScope  	projects/Closure25/src/com/google/javascript/jscomp/TypeInference.java	0.5	1038	1038	1	add	
11	[BUG] [BUGGY] JSType constructorType = constructor.getJSType(); [FE] ComparisonFailure [CONTEXT] private FlowScope traverseNew(Node n, FlowScope scope) { Node constructor = n.getFirstChild(); scope = traverse(constructor, scope); [BUGGY] JSType constructorType = constructor.getJSType(); [BUGGY] JSType type = null; if (constructorType != null) { constructorType = constructorType.restrictByNotNullOrUndefined(); if (constructorType.isUnknownType()) { type = getNativeType(UNKNOWN_TYPE); } else { FunctionType ct = constructorType.toMaybeFunctionType(); if (ct == null && constructorType instanceof FunctionType) {   [CLASS] TypeInference BooleanOutcomePair [METHOD] traverseNew [RETURN_TYPE] FlowScope  Node n FlowScope scope [VARIABLES] ReverseAbstractInterpreter reverseInterpreter AbstractCompiler compiler JSTypeRegistry registry JSType constructorType type boolean Scope functionScope syntacticScope DiagnosticType FUNCTION_LITERAL_UNDEFINED_THIS TEMPLATE_TYPE_NOT_OBJECT_TYPE TEMPLATE_TYPE_OF_THIS_EXPECTED Node arg constructor n FunctionType ct BooleanLiteralSet booleanValues toBooleanOutcomes Map assertionFunctionsMap FlowScope bottomScope conditionFlowScope falseScope functionScope informed input joinedScope leftScope newScope output rightScope scope trueScope  	projects/Closure25/src/com/google/javascript/jscomp/TypeInference.java	0.5	1039	1039	1	replace	
12	[BUG] [BUGGY] [FE] ComparisonFailure [CONTEXT] private FlowScope traverseNew(Node n, FlowScope scope) { Node constructor = n.getFirstChild(); scope = traverse(constructor, scope); [BUGGY] [BUGGY] JSType constructorType = constructor.getJSType(); JSType type = null; if (constructorType != null) { constructorType = constructorType.restrictByNotNullOrUndefined(); if (constructorType.isUnknownType()) { type = getNativeType(UNKNOWN_TYPE); } else { FunctionType ct = constructorType.toMaybeFunctionType(); if (ct == null && constructorType instanceof FunctionType) {   [CLASS] TypeInference BooleanOutcomePair [METHOD] traverseNew [RETURN_TYPE] FlowScope  Node n FlowScope scope [VARIABLES] ReverseAbstractInterpreter reverseInterpreter AbstractCompiler compiler JSTypeRegistry registry JSType constructorType type boolean Scope functionScope syntacticScope DiagnosticType FUNCTION_LITERAL_UNDEFINED_THIS TEMPLATE_TYPE_NOT_OBJECT_TYPE TEMPLATE_TYPE_OF_THIS_EXPECTED Node arg constructor n FunctionType ct BooleanLiteralSet booleanValues toBooleanOutcomes Map assertionFunctionsMap FlowScope bottomScope conditionFlowScope falseScope functionScope informed input joinedScope leftScope newScope output rightScope scope trueScope  	projects/Closure25/src/com/google/javascript/jscomp/TypeInference.java	0.5	1039	1039	1	add	
13	[BUG] [BUGGY] JSType type = null; [FE] ComparisonFailure [CONTEXT] private FlowScope traverseNew(Node n, FlowScope scope) { Node constructor = n.getFirstChild(); scope = traverse(constructor, scope); JSType constructorType = constructor.getJSType(); [BUGGY] JSType type = null; [BUGGY] if (constructorType != null) { constructorType = constructorType.restrictByNotNullOrUndefined(); if (constructorType.isUnknownType()) { type = getNativeType(UNKNOWN_TYPE); } else { FunctionType ct = constructorType.toMaybeFunctionType(); if (ct == null && constructorType instanceof FunctionType) {    [CLASS] TypeInference BooleanOutcomePair [METHOD] traverseNew [RETURN_TYPE] FlowScope  Node n FlowScope scope [VARIABLES] ReverseAbstractInterpreter reverseInterpreter AbstractCompiler compiler JSTypeRegistry registry JSType constructorType type boolean Scope functionScope syntacticScope DiagnosticType FUNCTION_LITERAL_UNDEFINED_THIS TEMPLATE_TYPE_NOT_OBJECT_TYPE TEMPLATE_TYPE_OF_THIS_EXPECTED Node arg constructor n FunctionType ct BooleanLiteralSet booleanValues toBooleanOutcomes Map assertionFunctionsMap FlowScope bottomScope conditionFlowScope falseScope functionScope informed input joinedScope leftScope newScope output rightScope scope trueScope  	projects/Closure25/src/com/google/javascript/jscomp/TypeInference.java	0.5	1040	1040	1	replace	
14	[BUG] [BUGGY] [FE] ComparisonFailure [CONTEXT] private FlowScope traverseNew(Node n, FlowScope scope) { Node constructor = n.getFirstChild(); scope = traverse(constructor, scope); JSType constructorType = constructor.getJSType(); [BUGGY] [BUGGY] JSType type = null; if (constructorType != null) { constructorType = constructorType.restrictByNotNullOrUndefined(); if (constructorType.isUnknownType()) { type = getNativeType(UNKNOWN_TYPE); } else { FunctionType ct = constructorType.toMaybeFunctionType(); if (ct == null && constructorType instanceof FunctionType) {    [CLASS] TypeInference BooleanOutcomePair [METHOD] traverseNew [RETURN_TYPE] FlowScope  Node n FlowScope scope [VARIABLES] ReverseAbstractInterpreter reverseInterpreter AbstractCompiler compiler JSTypeRegistry registry JSType constructorType type boolean Scope functionScope syntacticScope DiagnosticType FUNCTION_LITERAL_UNDEFINED_THIS TEMPLATE_TYPE_NOT_OBJECT_TYPE TEMPLATE_TYPE_OF_THIS_EXPECTED Node arg constructor n FunctionType ct BooleanLiteralSet booleanValues toBooleanOutcomes Map assertionFunctionsMap FlowScope bottomScope conditionFlowScope falseScope functionScope informed input joinedScope leftScope newScope output rightScope scope trueScope  	projects/Closure25/src/com/google/javascript/jscomp/TypeInference.java	0.5	1040	1040	1	add	
15	[BUG] [BUGGY] if (constructorType != null) { [FE] ComparisonFailure [CONTEXT] private FlowScope traverseNew(Node n, FlowScope scope) { Node constructor = n.getFirstChild(); scope = traverse(constructor, scope); JSType constructorType = constructor.getJSType(); JSType type = null; [BUGGY] if (constructorType != null) { [BUGGY] constructorType = constructorType.restrictByNotNullOrUndefined(); if (constructorType.isUnknownType()) { type = getNativeType(UNKNOWN_TYPE); } else { FunctionType ct = constructorType.toMaybeFunctionType(); if (ct == null && constructorType instanceof FunctionType) {    ct = (FunctionType) constructorType; [CLASS] TypeInference BooleanOutcomePair [METHOD] traverseNew [RETURN_TYPE] FlowScope  Node n FlowScope scope [VARIABLES] ReverseAbstractInterpreter reverseInterpreter AbstractCompiler compiler JSTypeRegistry registry JSType constructorType type boolean Scope functionScope syntacticScope DiagnosticType FUNCTION_LITERAL_UNDEFINED_THIS TEMPLATE_TYPE_NOT_OBJECT_TYPE TEMPLATE_TYPE_OF_THIS_EXPECTED Node arg constructor n FunctionType ct BooleanLiteralSet booleanValues toBooleanOutcomes Map assertionFunctionsMap FlowScope bottomScope conditionFlowScope falseScope functionScope informed input joinedScope leftScope newScope output rightScope scope trueScope  	projects/Closure25/src/com/google/javascript/jscomp/TypeInference.java	0.5	1041	1041	1	replace	
16	[BUG] [BUGGY] [FE] ComparisonFailure [CONTEXT] private FlowScope traverseNew(Node n, FlowScope scope) { Node constructor = n.getFirstChild(); scope = traverse(constructor, scope); JSType constructorType = constructor.getJSType(); JSType type = null; [BUGGY] [BUGGY] if (constructorType != null) { constructorType = constructorType.restrictByNotNullOrUndefined(); if (constructorType.isUnknownType()) { type = getNativeType(UNKNOWN_TYPE); } else { FunctionType ct = constructorType.toMaybeFunctionType(); if (ct == null && constructorType instanceof FunctionType) {    ct = (FunctionType) constructorType; [CLASS] TypeInference BooleanOutcomePair [METHOD] traverseNew [RETURN_TYPE] FlowScope  Node n FlowScope scope [VARIABLES] ReverseAbstractInterpreter reverseInterpreter AbstractCompiler compiler JSTypeRegistry registry JSType constructorType type boolean Scope functionScope syntacticScope DiagnosticType FUNCTION_LITERAL_UNDEFINED_THIS TEMPLATE_TYPE_NOT_OBJECT_TYPE TEMPLATE_TYPE_OF_THIS_EXPECTED Node arg constructor n FunctionType ct BooleanLiteralSet booleanValues toBooleanOutcomes Map assertionFunctionsMap FlowScope bottomScope conditionFlowScope falseScope functionScope informed input joinedScope leftScope newScope output rightScope scope trueScope  	projects/Closure25/src/com/google/javascript/jscomp/TypeInference.java	0.5	1041	1041	1	add	
17	[BUG] [BUGGY] constructorType = constructorType.restrictByNotNullOrUndefined(); [FE] ComparisonFailure [CONTEXT] private FlowScope traverseNew(Node n, FlowScope scope) { Node constructor = n.getFirstChild(); scope = traverse(constructor, scope); JSType constructorType = constructor.getJSType(); JSType type = null; if (constructorType != null) { [BUGGY] constructorType = constructorType.restrictByNotNullOrUndefined(); [BUGGY] if (constructorType.isUnknownType()) { type = getNativeType(UNKNOWN_TYPE); } else { FunctionType ct = constructorType.toMaybeFunctionType(); if (ct == null && constructorType instanceof FunctionType) {    ct = (FunctionType) constructorType; } [CLASS] TypeInference BooleanOutcomePair [METHOD] traverseNew [RETURN_TYPE] FlowScope  Node n FlowScope scope [VARIABLES] ReverseAbstractInterpreter reverseInterpreter AbstractCompiler compiler JSTypeRegistry registry JSType constructorType type boolean Scope functionScope syntacticScope DiagnosticType FUNCTION_LITERAL_UNDEFINED_THIS TEMPLATE_TYPE_NOT_OBJECT_TYPE TEMPLATE_TYPE_OF_THIS_EXPECTED Node arg constructor n FunctionType ct BooleanLiteralSet booleanValues toBooleanOutcomes Map assertionFunctionsMap FlowScope bottomScope conditionFlowScope falseScope functionScope informed input joinedScope leftScope newScope output rightScope scope trueScope  	projects/Closure25/src/com/google/javascript/jscomp/TypeInference.java	0.5	1042	1042	1	replace	
18	[BUG] [BUGGY] [FE] ComparisonFailure [CONTEXT] private FlowScope traverseNew(Node n, FlowScope scope) { Node constructor = n.getFirstChild(); scope = traverse(constructor, scope); JSType constructorType = constructor.getJSType(); JSType type = null; if (constructorType != null) { [BUGGY] [BUGGY] constructorType = constructorType.restrictByNotNullOrUndefined(); if (constructorType.isUnknownType()) { type = getNativeType(UNKNOWN_TYPE); } else { FunctionType ct = constructorType.toMaybeFunctionType(); if (ct == null && constructorType instanceof FunctionType) {    ct = (FunctionType) constructorType; } [CLASS] TypeInference BooleanOutcomePair [METHOD] traverseNew [RETURN_TYPE] FlowScope  Node n FlowScope scope [VARIABLES] ReverseAbstractInterpreter reverseInterpreter AbstractCompiler compiler JSTypeRegistry registry JSType constructorType type boolean Scope functionScope syntacticScope DiagnosticType FUNCTION_LITERAL_UNDEFINED_THIS TEMPLATE_TYPE_NOT_OBJECT_TYPE TEMPLATE_TYPE_OF_THIS_EXPECTED Node arg constructor n FunctionType ct BooleanLiteralSet booleanValues toBooleanOutcomes Map assertionFunctionsMap FlowScope bottomScope conditionFlowScope falseScope functionScope informed input joinedScope leftScope newScope output rightScope scope trueScope  	projects/Closure25/src/com/google/javascript/jscomp/TypeInference.java	0.5	1042	1042	1	add	
19	[BUG] [BUGGY] if (constructorType.isUnknownType()) { [FE] ComparisonFailure [CONTEXT] private FlowScope traverseNew(Node n, FlowScope scope) { Node constructor = n.getFirstChild(); scope = traverse(constructor, scope); JSType constructorType = constructor.getJSType(); JSType type = null; if (constructorType != null) { constructorType = constructorType.restrictByNotNullOrUndefined(); [BUGGY] if (constructorType.isUnknownType()) { [BUGGY] type = getNativeType(UNKNOWN_TYPE); } else { FunctionType ct = constructorType.toMaybeFunctionType(); if (ct == null && constructorType instanceof FunctionType) {    ct = (FunctionType) constructorType; } if (ct != null && ct.isConstructor()) { [CLASS] TypeInference BooleanOutcomePair [METHOD] traverseNew [RETURN_TYPE] FlowScope  Node n FlowScope scope [VARIABLES] ReverseAbstractInterpreter reverseInterpreter AbstractCompiler compiler JSTypeRegistry registry JSType constructorType type boolean Scope functionScope syntacticScope DiagnosticType FUNCTION_LITERAL_UNDEFINED_THIS TEMPLATE_TYPE_NOT_OBJECT_TYPE TEMPLATE_TYPE_OF_THIS_EXPECTED Node arg constructor n FunctionType ct BooleanLiteralSet booleanValues toBooleanOutcomes Map assertionFunctionsMap FlowScope bottomScope conditionFlowScope falseScope functionScope informed input joinedScope leftScope newScope output rightScope scope trueScope  	projects/Closure25/src/com/google/javascript/jscomp/TypeInference.java	0.5	1043	1043	1	replace	
20	[BUG] [BUGGY] [FE] ComparisonFailure [CONTEXT] private FlowScope traverseNew(Node n, FlowScope scope) { Node constructor = n.getFirstChild(); scope = traverse(constructor, scope); JSType constructorType = constructor.getJSType(); JSType type = null; if (constructorType != null) { constructorType = constructorType.restrictByNotNullOrUndefined(); [BUGGY] [BUGGY] if (constructorType.isUnknownType()) { type = getNativeType(UNKNOWN_TYPE); } else { FunctionType ct = constructorType.toMaybeFunctionType(); if (ct == null && constructorType instanceof FunctionType) {    ct = (FunctionType) constructorType; } if (ct != null && ct.isConstructor()) { [CLASS] TypeInference BooleanOutcomePair [METHOD] traverseNew [RETURN_TYPE] FlowScope  Node n FlowScope scope [VARIABLES] ReverseAbstractInterpreter reverseInterpreter AbstractCompiler compiler JSTypeRegistry registry JSType constructorType type boolean Scope functionScope syntacticScope DiagnosticType FUNCTION_LITERAL_UNDEFINED_THIS TEMPLATE_TYPE_NOT_OBJECT_TYPE TEMPLATE_TYPE_OF_THIS_EXPECTED Node arg constructor n FunctionType ct BooleanLiteralSet booleanValues toBooleanOutcomes Map assertionFunctionsMap FlowScope bottomScope conditionFlowScope falseScope functionScope informed input joinedScope leftScope newScope output rightScope scope trueScope  	projects/Closure25/src/com/google/javascript/jscomp/TypeInference.java	0.5	1043	1043	1	add	
21	[BUG] [BUGGY] FunctionType ct = constructorType.toMaybeFunctionType(); [FE] ComparisonFailure [CONTEXT] if (constructorType.isUnknownType()) { type = getNativeType(UNKNOWN_TYPE); } else { [BUGGY] FunctionType ct = constructorType.toMaybeFunctionType(); [BUGGY] if (ct == null && constructorType instanceof FunctionType) {    ct = (FunctionType) constructorType; } if (ct != null && ct.isConstructor()) { type = ct.getInstanceType(); } } [CLASS] TypeInference BooleanOutcomePair [METHOD] traverseNew [RETURN_TYPE] FlowScope  Node n FlowScope scope [VARIABLES] ReverseAbstractInterpreter reverseInterpreter AbstractCompiler compiler JSTypeRegistry registry JSType constructorType type boolean Scope functionScope syntacticScope DiagnosticType FUNCTION_LITERAL_UNDEFINED_THIS TEMPLATE_TYPE_NOT_OBJECT_TYPE TEMPLATE_TYPE_OF_THIS_EXPECTED Node arg constructor n FunctionType ct BooleanLiteralSet booleanValues toBooleanOutcomes Map assertionFunctionsMap FlowScope bottomScope conditionFlowScope falseScope functionScope informed input joinedScope leftScope newScope output rightScope scope trueScope  	projects/Closure25/src/com/google/javascript/jscomp/TypeInference.java	0.5	1046	1046	1	replace	
22	[BUG] [BUGGY] [FE] ComparisonFailure [CONTEXT] if (constructorType.isUnknownType()) { type = getNativeType(UNKNOWN_TYPE); } else { [BUGGY] [BUGGY] FunctionType ct = constructorType.toMaybeFunctionType(); if (ct == null && constructorType instanceof FunctionType) {    ct = (FunctionType) constructorType; } if (ct != null && ct.isConstructor()) { type = ct.getInstanceType(); } } [CLASS] TypeInference BooleanOutcomePair [METHOD] traverseNew [RETURN_TYPE] FlowScope  Node n FlowScope scope [VARIABLES] ReverseAbstractInterpreter reverseInterpreter AbstractCompiler compiler JSTypeRegistry registry JSType constructorType type boolean Scope functionScope syntacticScope DiagnosticType FUNCTION_LITERAL_UNDEFINED_THIS TEMPLATE_TYPE_NOT_OBJECT_TYPE TEMPLATE_TYPE_OF_THIS_EXPECTED Node arg constructor n FunctionType ct BooleanLiteralSet booleanValues toBooleanOutcomes Map assertionFunctionsMap FlowScope bottomScope conditionFlowScope falseScope functionScope informed input joinedScope leftScope newScope output rightScope scope trueScope  	projects/Closure25/src/com/google/javascript/jscomp/TypeInference.java	0.5	1046	1046	1	add	
23	[BUG] [BUGGY] if (ct == null && constructorType instanceof FunctionType) { [FE] ComparisonFailure [CONTEXT] if (constructorType.isUnknownType()) { type = getNativeType(UNKNOWN_TYPE); } else { FunctionType ct = constructorType.toMaybeFunctionType(); [BUGGY] if (ct == null && constructorType instanceof FunctionType) { [BUGGY]    ct = (FunctionType) constructorType; } if (ct != null && ct.isConstructor()) { type = ct.getInstanceType(); } } [CLASS] TypeInference BooleanOutcomePair [METHOD] traverseNew [RETURN_TYPE] FlowScope  Node n FlowScope scope [VARIABLES] ReverseAbstractInterpreter reverseInterpreter AbstractCompiler compiler JSTypeRegistry registry JSType constructorType type boolean Scope functionScope syntacticScope DiagnosticType FUNCTION_LITERAL_UNDEFINED_THIS TEMPLATE_TYPE_NOT_OBJECT_TYPE TEMPLATE_TYPE_OF_THIS_EXPECTED Node arg constructor n FunctionType ct BooleanLiteralSet booleanValues toBooleanOutcomes Map assertionFunctionsMap FlowScope bottomScope conditionFlowScope falseScope functionScope informed input joinedScope leftScope newScope output rightScope scope trueScope  	projects/Closure25/src/com/google/javascript/jscomp/TypeInference.java	0.5	1047	1047	1	replace	
24	[BUG] [BUGGY] [FE] ComparisonFailure [CONTEXT] if (constructorType.isUnknownType()) { type = getNativeType(UNKNOWN_TYPE); } else { FunctionType ct = constructorType.toMaybeFunctionType(); [BUGGY] [BUGGY] if (ct == null && constructorType instanceof FunctionType) {    ct = (FunctionType) constructorType; } if (ct != null && ct.isConstructor()) { type = ct.getInstanceType(); } } [CLASS] TypeInference BooleanOutcomePair [METHOD] traverseNew [RETURN_TYPE] FlowScope  Node n FlowScope scope [VARIABLES] ReverseAbstractInterpreter reverseInterpreter AbstractCompiler compiler JSTypeRegistry registry JSType constructorType type boolean Scope functionScope syntacticScope DiagnosticType FUNCTION_LITERAL_UNDEFINED_THIS TEMPLATE_TYPE_NOT_OBJECT_TYPE TEMPLATE_TYPE_OF_THIS_EXPECTED Node arg constructor n FunctionType ct BooleanLiteralSet booleanValues toBooleanOutcomes Map assertionFunctionsMap FlowScope bottomScope conditionFlowScope falseScope functionScope informed input joinedScope leftScope newScope output rightScope scope trueScope  	projects/Closure25/src/com/google/javascript/jscomp/TypeInference.java	0.5	1047	1047	1	add	
25	[BUG] [BUGGY] if (ct != null && ct.isConstructor()) { [FE] ComparisonFailure [CONTEXT] if (constructorType.isUnknownType()) { type = getNativeType(UNKNOWN_TYPE); } else { FunctionType ct = constructorType.toMaybeFunctionType(); if (ct == null && constructorType instanceof FunctionType) {    ct = (FunctionType) constructorType; } [BUGGY] if (ct != null && ct.isConstructor()) { [BUGGY] type = ct.getInstanceType(); } } [CLASS] TypeInference BooleanOutcomePair [METHOD] traverseNew [RETURN_TYPE] FlowScope  Node n FlowScope scope [VARIABLES] ReverseAbstractInterpreter reverseInterpreter AbstractCompiler compiler JSTypeRegistry registry JSType constructorType type boolean Scope functionScope syntacticScope DiagnosticType FUNCTION_LITERAL_UNDEFINED_THIS TEMPLATE_TYPE_NOT_OBJECT_TYPE TEMPLATE_TYPE_OF_THIS_EXPECTED Node arg constructor n FunctionType ct BooleanLiteralSet booleanValues toBooleanOutcomes Map assertionFunctionsMap FlowScope bottomScope conditionFlowScope falseScope functionScope informed input joinedScope leftScope newScope output rightScope scope trueScope  	projects/Closure25/src/com/google/javascript/jscomp/TypeInference.java	0.5	1053	1053	1	replace	
26	[BUG] [BUGGY] [FE] ComparisonFailure [CONTEXT] if (constructorType.isUnknownType()) { type = getNativeType(UNKNOWN_TYPE); } else { FunctionType ct = constructorType.toMaybeFunctionType(); if (ct == null && constructorType instanceof FunctionType) {    ct = (FunctionType) constructorType; } [BUGGY] [BUGGY] if (ct != null && ct.isConstructor()) { type = ct.getInstanceType(); } } [CLASS] TypeInference BooleanOutcomePair [METHOD] traverseNew [RETURN_TYPE] FlowScope  Node n FlowScope scope [VARIABLES] ReverseAbstractInterpreter reverseInterpreter AbstractCompiler compiler JSTypeRegistry registry JSType constructorType type boolean Scope functionScope syntacticScope DiagnosticType FUNCTION_LITERAL_UNDEFINED_THIS TEMPLATE_TYPE_NOT_OBJECT_TYPE TEMPLATE_TYPE_OF_THIS_EXPECTED Node arg constructor n FunctionType ct BooleanLiteralSet booleanValues toBooleanOutcomes Map assertionFunctionsMap FlowScope bottomScope conditionFlowScope falseScope functionScope informed input joinedScope leftScope newScope output rightScope scope trueScope  	projects/Closure25/src/com/google/javascript/jscomp/TypeInference.java	0.5	1053	1053	1	add	
27	[BUG] [BUGGY] type = ct.getInstanceType(); [FE] ComparisonFailure [CONTEXT] type = getNativeType(UNKNOWN_TYPE); } else { FunctionType ct = constructorType.toMaybeFunctionType(); if (ct == null && constructorType instanceof FunctionType) {    ct = (FunctionType) constructorType; } if (ct != null && ct.isConstructor()) { [BUGGY] type = ct.getInstanceType(); [BUGGY] } } [CLASS] TypeInference BooleanOutcomePair [METHOD] traverseNew [RETURN_TYPE] FlowScope  Node n FlowScope scope [VARIABLES] ReverseAbstractInterpreter reverseInterpreter AbstractCompiler compiler JSTypeRegistry registry JSType constructorType type boolean Scope functionScope syntacticScope DiagnosticType FUNCTION_LITERAL_UNDEFINED_THIS TEMPLATE_TYPE_NOT_OBJECT_TYPE TEMPLATE_TYPE_OF_THIS_EXPECTED Node arg constructor n FunctionType ct BooleanLiteralSet booleanValues toBooleanOutcomes Map assertionFunctionsMap FlowScope bottomScope conditionFlowScope falseScope functionScope informed input joinedScope leftScope newScope output rightScope scope trueScope  	projects/Closure25/src/com/google/javascript/jscomp/TypeInference.java	0.5	1054	1054	1	replace	
28	[BUG] [BUGGY] [FE] ComparisonFailure [CONTEXT] type = getNativeType(UNKNOWN_TYPE); } else { FunctionType ct = constructorType.toMaybeFunctionType(); if (ct == null && constructorType instanceof FunctionType) {    ct = (FunctionType) constructorType; } if (ct != null && ct.isConstructor()) { [BUGGY] [BUGGY] type = ct.getInstanceType(); } } [CLASS] TypeInference BooleanOutcomePair [METHOD] traverseNew [RETURN_TYPE] FlowScope  Node n FlowScope scope [VARIABLES] ReverseAbstractInterpreter reverseInterpreter AbstractCompiler compiler JSTypeRegistry registry JSType constructorType type boolean Scope functionScope syntacticScope DiagnosticType FUNCTION_LITERAL_UNDEFINED_THIS TEMPLATE_TYPE_NOT_OBJECT_TYPE TEMPLATE_TYPE_OF_THIS_EXPECTED Node arg constructor n FunctionType ct BooleanLiteralSet booleanValues toBooleanOutcomes Map assertionFunctionsMap FlowScope bottomScope conditionFlowScope falseScope functionScope informed input joinedScope leftScope newScope output rightScope scope trueScope  	projects/Closure25/src/com/google/javascript/jscomp/TypeInference.java	0.5	1054	1054	1	add	
29	[BUG] [BUGGY] n.setJSType(type); [FE] ComparisonFailure [CONTEXT]    ct = (FunctionType) constructorType; } if (ct != null && ct.isConstructor()) { type = ct.getInstanceType(); } } } [BUGGY] n.setJSType(type); [BUGGY] for (Node arg = constructor.getNext(); arg != null; arg = arg.getNext()) { scope = traverse(arg, scope); } return scope; } [CLASS] TypeInference BooleanOutcomePair [METHOD] traverseNew [RETURN_TYPE] FlowScope  Node n FlowScope scope [VARIABLES] ReverseAbstractInterpreter reverseInterpreter AbstractCompiler compiler JSTypeRegistry registry JSType constructorType type boolean Scope functionScope syntacticScope DiagnosticType FUNCTION_LITERAL_UNDEFINED_THIS TEMPLATE_TYPE_NOT_OBJECT_TYPE TEMPLATE_TYPE_OF_THIS_EXPECTED Node arg constructor n FunctionType ct BooleanLiteralSet booleanValues toBooleanOutcomes Map assertionFunctionsMap FlowScope bottomScope conditionFlowScope falseScope functionScope informed input joinedScope leftScope newScope output rightScope scope trueScope  	projects/Closure25/src/com/google/javascript/jscomp/TypeInference.java	0.5	1058	1058	1	replace	
30	[BUG] [BUGGY] [FE] ComparisonFailure [CONTEXT]    ct = (FunctionType) constructorType; } if (ct != null && ct.isConstructor()) { type = ct.getInstanceType(); } } } [BUGGY] [BUGGY] n.setJSType(type); for (Node arg = constructor.getNext(); arg != null; arg = arg.getNext()) { scope = traverse(arg, scope); } return scope; } [CLASS] TypeInference BooleanOutcomePair [METHOD] traverseNew [RETURN_TYPE] FlowScope  Node n FlowScope scope [VARIABLES] ReverseAbstractInterpreter reverseInterpreter AbstractCompiler compiler JSTypeRegistry registry JSType constructorType type boolean Scope functionScope syntacticScope DiagnosticType FUNCTION_LITERAL_UNDEFINED_THIS TEMPLATE_TYPE_NOT_OBJECT_TYPE TEMPLATE_TYPE_OF_THIS_EXPECTED Node arg constructor n FunctionType ct BooleanLiteralSet booleanValues toBooleanOutcomes Map assertionFunctionsMap FlowScope bottomScope conditionFlowScope falseScope functionScope informed input joinedScope leftScope newScope output rightScope scope trueScope  	projects/Closure25/src/com/google/javascript/jscomp/TypeInference.java	0.5	1058	1058	1	add	
31	[BUG] [BUGGY] for (Node arg = constructor.getNext(); arg != null; arg = arg.getNext()) { [FE] ComparisonFailure [CONTEXT]   ct = (FunctionType) constructorType; } if (ct != null && ct.isConstructor()) { type = ct.getInstanceType(); } } } n.setJSType(type); [BUGGY] for (Node arg = constructor.getNext(); arg != null; arg = arg.getNext()) { [BUGGY] scope = traverse(arg, scope); } return scope; } [CLASS] TypeInference BooleanOutcomePair [METHOD] traverseNew [RETURN_TYPE] FlowScope  Node n FlowScope scope [VARIABLES] ReverseAbstractInterpreter reverseInterpreter AbstractCompiler compiler JSTypeRegistry registry JSType constructorType type boolean Scope functionScope syntacticScope DiagnosticType FUNCTION_LITERAL_UNDEFINED_THIS TEMPLATE_TYPE_NOT_OBJECT_TYPE TEMPLATE_TYPE_OF_THIS_EXPECTED Node arg constructor n FunctionType ct BooleanLiteralSet booleanValues toBooleanOutcomes Map assertionFunctionsMap FlowScope bottomScope conditionFlowScope falseScope functionScope informed input joinedScope leftScope newScope output rightScope scope trueScope  	projects/Closure25/src/com/google/javascript/jscomp/TypeInference.java	0.5	1059	1059	1	replace	
32	[BUG] [BUGGY] [FE] ComparisonFailure [CONTEXT]   ct = (FunctionType) constructorType; } if (ct != null && ct.isConstructor()) { type = ct.getInstanceType(); } } } n.setJSType(type); [BUGGY] [BUGGY] for (Node arg = constructor.getNext(); arg != null; arg = arg.getNext()) { scope = traverse(arg, scope); } return scope; } [CLASS] TypeInference BooleanOutcomePair [METHOD] traverseNew [RETURN_TYPE] FlowScope  Node n FlowScope scope [VARIABLES] ReverseAbstractInterpreter reverseInterpreter AbstractCompiler compiler JSTypeRegistry registry JSType constructorType type boolean Scope functionScope syntacticScope DiagnosticType FUNCTION_LITERAL_UNDEFINED_THIS TEMPLATE_TYPE_NOT_OBJECT_TYPE TEMPLATE_TYPE_OF_THIS_EXPECTED Node arg constructor n FunctionType ct BooleanLiteralSet booleanValues toBooleanOutcomes Map assertionFunctionsMap FlowScope bottomScope conditionFlowScope falseScope functionScope informed input joinedScope leftScope newScope output rightScope scope trueScope  	projects/Closure25/src/com/google/javascript/jscomp/TypeInference.java	0.5	1059	1059	1	add	
33	[BUG] [BUGGY] return scope; [FE] ComparisonFailure [CONTEXT] } if (ct != null && ct.isConstructor()) { type = ct.getInstanceType(); } } } n.setJSType(type); for (Node arg = constructor.getNext(); arg != null; arg = arg.getNext()) { scope = traverse(arg, scope); } [BUGGY] return scope; [BUGGY] } [CLASS] TypeInference BooleanOutcomePair [METHOD] traverseNew [RETURN_TYPE] FlowScope  Node n FlowScope scope [VARIABLES] ReverseAbstractInterpreter reverseInterpreter AbstractCompiler compiler JSTypeRegistry registry JSType constructorType type boolean Scope functionScope syntacticScope DiagnosticType FUNCTION_LITERAL_UNDEFINED_THIS TEMPLATE_TYPE_NOT_OBJECT_TYPE TEMPLATE_TYPE_OF_THIS_EXPECTED Node arg constructor n FunctionType ct BooleanLiteralSet booleanValues toBooleanOutcomes Map assertionFunctionsMap FlowScope bottomScope conditionFlowScope falseScope functionScope informed input joinedScope leftScope newScope output rightScope scope trueScope  	projects/Closure25/src/com/google/javascript/jscomp/TypeInference.java	0.5	1062	1062	1	replace	
34	[BUG] [BUGGY] [FE] ComparisonFailure [CONTEXT] } if (ct != null && ct.isConstructor()) { type = ct.getInstanceType(); } } } n.setJSType(type); for (Node arg = constructor.getNext(); arg != null; arg = arg.getNext()) { scope = traverse(arg, scope); } [BUGGY] [BUGGY] return scope; } [CLASS] TypeInference BooleanOutcomePair [METHOD] traverseNew [RETURN_TYPE] FlowScope  Node n FlowScope scope [VARIABLES] ReverseAbstractInterpreter reverseInterpreter AbstractCompiler compiler JSTypeRegistry registry JSType constructorType type boolean Scope functionScope syntacticScope DiagnosticType FUNCTION_LITERAL_UNDEFINED_THIS TEMPLATE_TYPE_NOT_OBJECT_TYPE TEMPLATE_TYPE_OF_THIS_EXPECTED Node arg constructor n FunctionType ct BooleanLiteralSet booleanValues toBooleanOutcomes Map assertionFunctionsMap FlowScope bottomScope conditionFlowScope falseScope functionScope informed input joinedScope leftScope newScope output rightScope scope trueScope  	projects/Closure25/src/com/google/javascript/jscomp/TypeInference.java	0.5	1062	1062	1	add	
35	[BUG] [BUGGY] scope = traverseObjectLiteral(n, scope); [FE] ComparisonFailure [CONTEXT] case Token.OR: scope = traverseOr(n, scope).getJoinedFlowScope() .createChildFlowScope(); break; case Token.HOOK: scope = traverseHook(n, scope); break; case Token.OBJECTLIT: [BUGGY] scope = traverseObjectLiteral(n, scope); [BUGGY] break; case Token.CALL: scope = traverseCall(n, scope); break; case Token.NEW: scope = traverseNew(n, scope); break;  [CLASS] TypeInference BooleanOutcomePair [METHOD] traverse [RETURN_TYPE] FlowScope  Node n FlowScope scope [VARIABLES] ReverseAbstractInterpreter reverseInterpreter AbstractCompiler compiler JSTypeRegistry registry JSType castType boolean Scope functionScope syntacticScope DiagnosticType FUNCTION_LITERAL_UNDEFINED_THIS TEMPLATE_TYPE_NOT_OBJECT_TYPE TEMPLATE_TYPE_OF_THIS_EXPECTED Node n BooleanLiteralSet booleanValues toBooleanOutcomes JSDocInfo info Map assertionFunctionsMap FlowScope bottomScope conditionFlowScope functionScope informed input joinedScope leftScope newScope output rightScope scope  	projects/Closure25/src/com/google/javascript/jscomp/TypeInference.java	0.2773500981126146	280	280	1	replace	
36	[BUG] [BUGGY] [FE] ComparisonFailure [CONTEXT] case Token.OR: scope = traverseOr(n, scope).getJoinedFlowScope() .createChildFlowScope(); break; case Token.HOOK: scope = traverseHook(n, scope); break; case Token.OBJECTLIT: [BUGGY] [BUGGY] scope = traverseObjectLiteral(n, scope); break; case Token.CALL: scope = traverseCall(n, scope); break; case Token.NEW: scope = traverseNew(n, scope); break;  [CLASS] TypeInference BooleanOutcomePair [METHOD] traverse [RETURN_TYPE] FlowScope  Node n FlowScope scope [VARIABLES] ReverseAbstractInterpreter reverseInterpreter AbstractCompiler compiler JSTypeRegistry registry JSType castType boolean Scope functionScope syntacticScope DiagnosticType FUNCTION_LITERAL_UNDEFINED_THIS TEMPLATE_TYPE_NOT_OBJECT_TYPE TEMPLATE_TYPE_OF_THIS_EXPECTED Node n BooleanLiteralSet booleanValues toBooleanOutcomes JSDocInfo info Map assertionFunctionsMap FlowScope bottomScope conditionFlowScope functionScope informed input joinedScope leftScope newScope output rightScope scope  	projects/Closure25/src/com/google/javascript/jscomp/TypeInference.java	0.2773500981126146	280	280	1	add	
37	[BUG] [BUGGY] break; [FE] ComparisonFailure [CONTEXT] scope = traverseOr(n, scope).getJoinedFlowScope() .createChildFlowScope(); break; case Token.HOOK: scope = traverseHook(n, scope); break; case Token.OBJECTLIT: scope = traverseObjectLiteral(n, scope); [BUGGY] break; [BUGGY]  case Token.CALL: scope = traverseCall(n, scope); break; case Token.NEW: scope = traverseNew(n, scope); break; case Token.ASSIGN_ADD: [CLASS] TypeInference BooleanOutcomePair [METHOD] traverse [RETURN_TYPE] FlowScope  Node n FlowScope scope [VARIABLES] ReverseAbstractInterpreter reverseInterpreter AbstractCompiler compiler JSTypeRegistry registry JSType castType boolean Scope functionScope syntacticScope DiagnosticType FUNCTION_LITERAL_UNDEFINED_THIS TEMPLATE_TYPE_NOT_OBJECT_TYPE TEMPLATE_TYPE_OF_THIS_EXPECTED Node n BooleanLiteralSet booleanValues toBooleanOutcomes JSDocInfo info Map assertionFunctionsMap FlowScope bottomScope conditionFlowScope functionScope informed input joinedScope leftScope newScope output rightScope scope  	projects/Closure25/src/com/google/javascript/jscomp/TypeInference.java	0.2773500981126146	281	281	1	replace	
38	[BUG] [BUGGY] [FE] ComparisonFailure [CONTEXT] scope = traverseOr(n, scope).getJoinedFlowScope() .createChildFlowScope(); break; case Token.HOOK: scope = traverseHook(n, scope); break; case Token.OBJECTLIT: scope = traverseObjectLiteral(n, scope); [BUGGY] [BUGGY] break; case Token.CALL: scope = traverseCall(n, scope); break; case Token.NEW: scope = traverseNew(n, scope); break; case Token.ASSIGN_ADD: [CLASS] TypeInference BooleanOutcomePair [METHOD] traverse [RETURN_TYPE] FlowScope  Node n FlowScope scope [VARIABLES] ReverseAbstractInterpreter reverseInterpreter AbstractCompiler compiler JSTypeRegistry registry JSType castType boolean Scope functionScope syntacticScope DiagnosticType FUNCTION_LITERAL_UNDEFINED_THIS TEMPLATE_TYPE_NOT_OBJECT_TYPE TEMPLATE_TYPE_OF_THIS_EXPECTED Node n BooleanLiteralSet booleanValues toBooleanOutcomes JSDocInfo info Map assertionFunctionsMap FlowScope bottomScope conditionFlowScope functionScope informed input joinedScope leftScope newScope output rightScope scope  	projects/Closure25/src/com/google/javascript/jscomp/TypeInference.java	0.2773500981126146	281	281	1	add	
39	[BUG] [BUGGY] JSType type = n.getJSType(); [FE] ComparisonFailure [CONTEXT] private FlowScope traverseObjectLiteral(Node n, FlowScope scope) { [BUGGY] JSType type = n.getJSType(); [BUGGY] Preconditions.checkNotNull(type); for (Node name = n.getFirstChild(); name != null; name = name.getNext()) { scope = traverse(name.getFirstChild(), scope); }      [CLASS] TypeInference BooleanOutcomePair [METHOD] traverseObjectLiteral [RETURN_TYPE] FlowScope  Node n FlowScope scope [VARIABLES] ReverseAbstractInterpreter reverseInterpreter JSType oldType rawValueType type valueType Var var Node n name value BooleanLiteralSet booleanValues toBooleanOutcomes String memberName qKeyName qObjName ObjectType objectType AbstractCompiler compiler JSTypeRegistry registry boolean hasLendsName Scope functionScope syntacticScope DiagnosticType FUNCTION_LITERAL_UNDEFINED_THIS TEMPLATE_TYPE_NOT_OBJECT_TYPE TEMPLATE_TYPE_OF_THIS_EXPECTED Map assertionFunctionsMap FlowScope bottomScope conditionFlowScope functionScope informed input joinedScope leftScope newScope output rightScope scope  	projects/Closure25/src/com/google/javascript/jscomp/TypeInference.java	0.2773500981126146	649	649	1	replace	
40	[BUG] [BUGGY] [FE] ComparisonFailure [CONTEXT] private FlowScope traverseObjectLiteral(Node n, FlowScope scope) { [BUGGY] [BUGGY] JSType type = n.getJSType(); Preconditions.checkNotNull(type); for (Node name = n.getFirstChild(); name != null; name = name.getNext()) { scope = traverse(name.getFirstChild(), scope); }      [CLASS] TypeInference BooleanOutcomePair [METHOD] traverseObjectLiteral [RETURN_TYPE] FlowScope  Node n FlowScope scope [VARIABLES] ReverseAbstractInterpreter reverseInterpreter JSType oldType rawValueType type valueType Var var Node n name value BooleanLiteralSet booleanValues toBooleanOutcomes String memberName qKeyName qObjName ObjectType objectType AbstractCompiler compiler JSTypeRegistry registry boolean hasLendsName Scope functionScope syntacticScope DiagnosticType FUNCTION_LITERAL_UNDEFINED_THIS TEMPLATE_TYPE_NOT_OBJECT_TYPE TEMPLATE_TYPE_OF_THIS_EXPECTED Map assertionFunctionsMap FlowScope bottomScope conditionFlowScope functionScope informed input joinedScope leftScope newScope output rightScope scope  	projects/Closure25/src/com/google/javascript/jscomp/TypeInference.java	0.2773500981126146	649	649	1	add	
41	[BUG] [BUGGY] Preconditions.checkNotNull(type); [FE] ComparisonFailure [CONTEXT] private FlowScope traverseObjectLiteral(Node n, FlowScope scope) { JSType type = n.getJSType(); [BUGGY] Preconditions.checkNotNull(type); [BUGGY]  for (Node name = n.getFirstChild(); name != null; name = name.getNext()) { scope = traverse(name.getFirstChild(), scope); }       [CLASS] TypeInference BooleanOutcomePair [METHOD] traverseObjectLiteral [RETURN_TYPE] FlowScope  Node n FlowScope scope [VARIABLES] ReverseAbstractInterpreter reverseInterpreter JSType oldType rawValueType type valueType Var var Node n name value BooleanLiteralSet booleanValues toBooleanOutcomes String memberName qKeyName qObjName ObjectType objectType AbstractCompiler compiler JSTypeRegistry registry boolean hasLendsName Scope functionScope syntacticScope DiagnosticType FUNCTION_LITERAL_UNDEFINED_THIS TEMPLATE_TYPE_NOT_OBJECT_TYPE TEMPLATE_TYPE_OF_THIS_EXPECTED Map assertionFunctionsMap FlowScope bottomScope conditionFlowScope functionScope informed input joinedScope leftScope newScope output rightScope scope  	projects/Closure25/src/com/google/javascript/jscomp/TypeInference.java	0.2773500981126146	650	650	1	replace	
42	[BUG] [BUGGY] [FE] ComparisonFailure [CONTEXT] private FlowScope traverseObjectLiteral(Node n, FlowScope scope) { JSType type = n.getJSType(); [BUGGY] [BUGGY] Preconditions.checkNotNull(type); for (Node name = n.getFirstChild(); name != null; name = name.getNext()) { scope = traverse(name.getFirstChild(), scope); }       [CLASS] TypeInference BooleanOutcomePair [METHOD] traverseObjectLiteral [RETURN_TYPE] FlowScope  Node n FlowScope scope [VARIABLES] ReverseAbstractInterpreter reverseInterpreter JSType oldType rawValueType type valueType Var var Node n name value BooleanLiteralSet booleanValues toBooleanOutcomes String memberName qKeyName qObjName ObjectType objectType AbstractCompiler compiler JSTypeRegistry registry boolean hasLendsName Scope functionScope syntacticScope DiagnosticType FUNCTION_LITERAL_UNDEFINED_THIS TEMPLATE_TYPE_NOT_OBJECT_TYPE TEMPLATE_TYPE_OF_THIS_EXPECTED Map assertionFunctionsMap FlowScope bottomScope conditionFlowScope functionScope informed input joinedScope leftScope newScope output rightScope scope  	projects/Closure25/src/com/google/javascript/jscomp/TypeInference.java	0.2773500981126146	650	650	1	add	
43	[BUG] [BUGGY] for (Node name = n.getFirstChild(); name != null; name = name.getNext()) { [FE] ComparisonFailure [CONTEXT] private FlowScope traverseObjectLiteral(Node n, FlowScope scope) { JSType type = n.getJSType(); Preconditions.checkNotNull(type); [BUGGY] for (Node name = n.getFirstChild(); name != null; name = name.getNext()) { [BUGGY] scope = traverse(name.getFirstChild(), scope); }       ObjectType objectType = ObjectType.cast(type); [CLASS] TypeInference BooleanOutcomePair [METHOD] traverseObjectLiteral [RETURN_TYPE] FlowScope  Node n FlowScope scope [VARIABLES] ReverseAbstractInterpreter reverseInterpreter JSType oldType rawValueType type valueType Var var Node n name value BooleanLiteralSet booleanValues toBooleanOutcomes String memberName qKeyName qObjName ObjectType objectType AbstractCompiler compiler JSTypeRegistry registry boolean hasLendsName Scope functionScope syntacticScope DiagnosticType FUNCTION_LITERAL_UNDEFINED_THIS TEMPLATE_TYPE_NOT_OBJECT_TYPE TEMPLATE_TYPE_OF_THIS_EXPECTED Map assertionFunctionsMap FlowScope bottomScope conditionFlowScope functionScope informed input joinedScope leftScope newScope output rightScope scope  	projects/Closure25/src/com/google/javascript/jscomp/TypeInference.java	0.2773500981126146	652	652	1	replace	
44	[BUG] [BUGGY] [FE] ComparisonFailure [CONTEXT] private FlowScope traverseObjectLiteral(Node n, FlowScope scope) { JSType type = n.getJSType(); Preconditions.checkNotNull(type); [BUGGY] [BUGGY] for (Node name = n.getFirstChild(); name != null; name = name.getNext()) { scope = traverse(name.getFirstChild(), scope); }       ObjectType objectType = ObjectType.cast(type); [CLASS] TypeInference BooleanOutcomePair [METHOD] traverseObjectLiteral [RETURN_TYPE] FlowScope  Node n FlowScope scope [VARIABLES] ReverseAbstractInterpreter reverseInterpreter JSType oldType rawValueType type valueType Var var Node n name value BooleanLiteralSet booleanValues toBooleanOutcomes String memberName qKeyName qObjName ObjectType objectType AbstractCompiler compiler JSTypeRegistry registry boolean hasLendsName Scope functionScope syntacticScope DiagnosticType FUNCTION_LITERAL_UNDEFINED_THIS TEMPLATE_TYPE_NOT_OBJECT_TYPE TEMPLATE_TYPE_OF_THIS_EXPECTED Map assertionFunctionsMap FlowScope bottomScope conditionFlowScope functionScope informed input joinedScope leftScope newScope output rightScope scope  	projects/Closure25/src/com/google/javascript/jscomp/TypeInference.java	0.2773500981126146	652	652	1	add	
45	[BUG] [BUGGY] ObjectType objectType = ObjectType.cast(type); [FE] ComparisonFailure [CONTEXT] for (Node name = n.getFirstChild(); name != null; name = name.getNext()) { scope = traverse(name.getFirstChild(), scope); }       [BUGGY] ObjectType objectType = ObjectType.cast(type); [BUGGY] if (objectType == null) { return scope; } boolean hasLendsName = n.getJSDocInfo() != null && n.getJSDocInfo().getLendsName() != null; if (objectType.hasReferenceName() && !hasLendsName) { return scope; }  [CLASS] TypeInference BooleanOutcomePair [METHOD] traverseObjectLiteral [RETURN_TYPE] FlowScope  Node n FlowScope scope [VARIABLES] ReverseAbstractInterpreter reverseInterpreter JSType oldType rawValueType type valueType Var var Node n name value BooleanLiteralSet booleanValues toBooleanOutcomes String memberName qKeyName qObjName ObjectType objectType AbstractCompiler compiler JSTypeRegistry registry boolean hasLendsName Scope functionScope syntacticScope DiagnosticType FUNCTION_LITERAL_UNDEFINED_THIS TEMPLATE_TYPE_NOT_OBJECT_TYPE TEMPLATE_TYPE_OF_THIS_EXPECTED Map assertionFunctionsMap FlowScope bottomScope conditionFlowScope functionScope informed input joinedScope leftScope newScope output rightScope scope  	projects/Closure25/src/com/google/javascript/jscomp/TypeInference.java	0.2773500981126146	662	662	1	replace	
46	[BUG] [BUGGY] [FE] ComparisonFailure [CONTEXT] for (Node name = n.getFirstChild(); name != null; name = name.getNext()) { scope = traverse(name.getFirstChild(), scope); }       [BUGGY] [BUGGY] ObjectType objectType = ObjectType.cast(type); if (objectType == null) { return scope; } boolean hasLendsName = n.getJSDocInfo() != null && n.getJSDocInfo().getLendsName() != null; if (objectType.hasReferenceName() && !hasLendsName) { return scope; }  [CLASS] TypeInference BooleanOutcomePair [METHOD] traverseObjectLiteral [RETURN_TYPE] FlowScope  Node n FlowScope scope [VARIABLES] ReverseAbstractInterpreter reverseInterpreter JSType oldType rawValueType type valueType Var var Node n name value BooleanLiteralSet booleanValues toBooleanOutcomes String memberName qKeyName qObjName ObjectType objectType AbstractCompiler compiler JSTypeRegistry registry boolean hasLendsName Scope functionScope syntacticScope DiagnosticType FUNCTION_LITERAL_UNDEFINED_THIS TEMPLATE_TYPE_NOT_OBJECT_TYPE TEMPLATE_TYPE_OF_THIS_EXPECTED Map assertionFunctionsMap FlowScope bottomScope conditionFlowScope functionScope informed input joinedScope leftScope newScope output rightScope scope  	projects/Closure25/src/com/google/javascript/jscomp/TypeInference.java	0.2773500981126146	662	662	1	add	
47	[BUG] [BUGGY] if (objectType == null) { [FE] ComparisonFailure [CONTEXT] scope = traverse(name.getFirstChild(), scope); }       ObjectType objectType = ObjectType.cast(type); [BUGGY] if (objectType == null) { [BUGGY] return scope; } boolean hasLendsName = n.getJSDocInfo() != null && n.getJSDocInfo().getLendsName() != null; if (objectType.hasReferenceName() && !hasLendsName) { return scope; } String qObjName = NodeUtil.getBestLValueName( [CLASS] TypeInference BooleanOutcomePair [METHOD] traverseObjectLiteral [RETURN_TYPE] FlowScope  Node n FlowScope scope [VARIABLES] ReverseAbstractInterpreter reverseInterpreter JSType oldType rawValueType type valueType Var var Node n name value BooleanLiteralSet booleanValues toBooleanOutcomes String memberName qKeyName qObjName ObjectType objectType AbstractCompiler compiler JSTypeRegistry registry boolean hasLendsName Scope functionScope syntacticScope DiagnosticType FUNCTION_LITERAL_UNDEFINED_THIS TEMPLATE_TYPE_NOT_OBJECT_TYPE TEMPLATE_TYPE_OF_THIS_EXPECTED Map assertionFunctionsMap FlowScope bottomScope conditionFlowScope functionScope informed input joinedScope leftScope newScope output rightScope scope  	projects/Closure25/src/com/google/javascript/jscomp/TypeInference.java	0.2773500981126146	663	663	1	replace	
48	[BUG] [BUGGY] [FE] ComparisonFailure [CONTEXT] scope = traverse(name.getFirstChild(), scope); }       ObjectType objectType = ObjectType.cast(type); [BUGGY] [BUGGY] if (objectType == null) { return scope; } boolean hasLendsName = n.getJSDocInfo() != null && n.getJSDocInfo().getLendsName() != null; if (objectType.hasReferenceName() && !hasLendsName) { return scope; } String qObjName = NodeUtil.getBestLValueName( [CLASS] TypeInference BooleanOutcomePair [METHOD] traverseObjectLiteral [RETURN_TYPE] FlowScope  Node n FlowScope scope [VARIABLES] ReverseAbstractInterpreter reverseInterpreter JSType oldType rawValueType type valueType Var var Node n name value BooleanLiteralSet booleanValues toBooleanOutcomes String memberName qKeyName qObjName ObjectType objectType AbstractCompiler compiler JSTypeRegistry registry boolean hasLendsName Scope functionScope syntacticScope DiagnosticType FUNCTION_LITERAL_UNDEFINED_THIS TEMPLATE_TYPE_NOT_OBJECT_TYPE TEMPLATE_TYPE_OF_THIS_EXPECTED Map assertionFunctionsMap FlowScope bottomScope conditionFlowScope functionScope informed input joinedScope leftScope newScope output rightScope scope  	projects/Closure25/src/com/google/javascript/jscomp/TypeInference.java	0.2773500981126146	663	663	1	add	
49	[BUG] [BUGGY] boolean hasLendsName = n.getJSDocInfo() != null && n.getJSDocInfo().getLendsName() != null; [FE] ComparisonFailure [CONTEXT]      ObjectType objectType = ObjectType.cast(type); if (objectType == null) { return scope; } [BUGGY] boolean hasLendsName = n.getJSDocInfo() != null &&  n.getJSDocInfo().getLendsName() != null; [BUGGY] n.getJSDocInfo().getLendsName() != null; if (objectType.hasReferenceName() && !hasLendsName) { return scope; } String qObjName = NodeUtil.getBestLValueName( NodeUtil.getBestLValue(n)); for (Node name = n.getFirstChild(); name != null; name = name.getNext()) { Node value = name.getFirstChild(); [CLASS] TypeInference BooleanOutcomePair [METHOD] traverseObjectLiteral [RETURN_TYPE] FlowScope  Node n FlowScope scope [VARIABLES] ReverseAbstractInterpreter reverseInterpreter JSType oldType rawValueType type valueType Var var Node n name value BooleanLiteralSet booleanValues toBooleanOutcomes String memberName qKeyName qObjName ObjectType objectType AbstractCompiler compiler JSTypeRegistry registry boolean hasLendsName Scope functionScope syntacticScope DiagnosticType FUNCTION_LITERAL_UNDEFINED_THIS TEMPLATE_TYPE_NOT_OBJECT_TYPE TEMPLATE_TYPE_OF_THIS_EXPECTED Map assertionFunctionsMap FlowScope bottomScope conditionFlowScope functionScope informed input joinedScope leftScope newScope output rightScope scope  	projects/Closure25/src/com/google/javascript/jscomp/TypeInference.java	0.2773500981126146	667	668	1	replace	
50	[BUG] [BUGGY] [FE] ComparisonFailure [CONTEXT]      ObjectType objectType = ObjectType.cast(type); if (objectType == null) { return scope; } [BUGGY] [BUGGY] boolean hasLendsName = n.getJSDocInfo() != null &&  n.getJSDocInfo().getLendsName() != null; n.getJSDocInfo().getLendsName() != null; if (objectType.hasReferenceName() && !hasLendsName) { return scope; } String qObjName = NodeUtil.getBestLValueName( NodeUtil.getBestLValue(n)); for (Node name = n.getFirstChild(); name != null; name = name.getNext()) { Node value = name.getFirstChild(); [CLASS] TypeInference BooleanOutcomePair [METHOD] traverseObjectLiteral [RETURN_TYPE] FlowScope  Node n FlowScope scope [VARIABLES] ReverseAbstractInterpreter reverseInterpreter JSType oldType rawValueType type valueType Var var Node n name value BooleanLiteralSet booleanValues toBooleanOutcomes String memberName qKeyName qObjName ObjectType objectType AbstractCompiler compiler JSTypeRegistry registry boolean hasLendsName Scope functionScope syntacticScope DiagnosticType FUNCTION_LITERAL_UNDEFINED_THIS TEMPLATE_TYPE_NOT_OBJECT_TYPE TEMPLATE_TYPE_OF_THIS_EXPECTED Map assertionFunctionsMap FlowScope bottomScope conditionFlowScope functionScope informed input joinedScope leftScope newScope output rightScope scope  	projects/Closure25/src/com/google/javascript/jscomp/TypeInference.java	0.2773500981126146	667	668	1	add	
51	[BUG] [BUGGY] if (objectType.hasReferenceName() && !hasLendsName) { [FE] ComparisonFailure [CONTEXT]    ObjectType objectType = ObjectType.cast(type); if (objectType == null) { return scope; } boolean hasLendsName = n.getJSDocInfo() != null && n.getJSDocInfo().getLendsName() != null; [BUGGY] if (objectType.hasReferenceName() && !hasLendsName) { [BUGGY] return scope; } String qObjName = NodeUtil.getBestLValueName( NodeUtil.getBestLValue(n)); for (Node name = n.getFirstChild(); name != null; name = name.getNext()) { Node value = name.getFirstChild(); String memberName = NodeUtil.getObjectLitKeyName(name); if (memberName != null) { [CLASS] TypeInference BooleanOutcomePair [METHOD] traverseObjectLiteral [RETURN_TYPE] FlowScope  Node n FlowScope scope [VARIABLES] ReverseAbstractInterpreter reverseInterpreter JSType oldType rawValueType type valueType Var var Node n name value BooleanLiteralSet booleanValues toBooleanOutcomes String memberName qKeyName qObjName ObjectType objectType AbstractCompiler compiler JSTypeRegistry registry boolean hasLendsName Scope functionScope syntacticScope DiagnosticType FUNCTION_LITERAL_UNDEFINED_THIS TEMPLATE_TYPE_NOT_OBJECT_TYPE TEMPLATE_TYPE_OF_THIS_EXPECTED Map assertionFunctionsMap FlowScope bottomScope conditionFlowScope functionScope informed input joinedScope leftScope newScope output rightScope scope  	projects/Closure25/src/com/google/javascript/jscomp/TypeInference.java	0.2773500981126146	669	669	1	replace	
52	[BUG] [BUGGY] [FE] ComparisonFailure [CONTEXT]    ObjectType objectType = ObjectType.cast(type); if (objectType == null) { return scope; } boolean hasLendsName = n.getJSDocInfo() != null && n.getJSDocInfo().getLendsName() != null; [BUGGY] [BUGGY] if (objectType.hasReferenceName() && !hasLendsName) { return scope; } String qObjName = NodeUtil.getBestLValueName( NodeUtil.getBestLValue(n)); for (Node name = n.getFirstChild(); name != null; name = name.getNext()) { Node value = name.getFirstChild(); String memberName = NodeUtil.getObjectLitKeyName(name); if (memberName != null) { [CLASS] TypeInference BooleanOutcomePair [METHOD] traverseObjectLiteral [RETURN_TYPE] FlowScope  Node n FlowScope scope [VARIABLES] ReverseAbstractInterpreter reverseInterpreter JSType oldType rawValueType type valueType Var var Node n name value BooleanLiteralSet booleanValues toBooleanOutcomes String memberName qKeyName qObjName ObjectType objectType AbstractCompiler compiler JSTypeRegistry registry boolean hasLendsName Scope functionScope syntacticScope DiagnosticType FUNCTION_LITERAL_UNDEFINED_THIS TEMPLATE_TYPE_NOT_OBJECT_TYPE TEMPLATE_TYPE_OF_THIS_EXPECTED Map assertionFunctionsMap FlowScope bottomScope conditionFlowScope functionScope informed input joinedScope leftScope newScope output rightScope scope  	projects/Closure25/src/com/google/javascript/jscomp/TypeInference.java	0.2773500981126146	669	669	1	add	
53	[BUG] [BUGGY] String qObjName = NodeUtil.getBestLValueName( NodeUtil.getBestLValue(n)); [FE] ComparisonFailure [CONTEXT] if (objectType == null) { return scope; } boolean hasLendsName = n.getJSDocInfo() != null && n.getJSDocInfo().getLendsName() != null; if (objectType.hasReferenceName() && !hasLendsName) { return scope; } [BUGGY] String qObjName = NodeUtil.getBestLValueName(  NodeUtil.getBestLValue(n)); [BUGGY] NodeUtil.getBestLValue(n)); for (Node name = n.getFirstChild(); name != null; name = name.getNext()) { Node value = name.getFirstChild(); String memberName = NodeUtil.getObjectLitKeyName(name); if (memberName != null) { JSType rawValueType =name.getFirstChild().getJSType(); JSType valueType = NodeUtil.getObjectLitKeyTypeFromValueType( name, rawValueType); if (valueType == null) { [CLASS] TypeInference BooleanOutcomePair [METHOD] traverseObjectLiteral [RETURN_TYPE] FlowScope  Node n FlowScope scope [VARIABLES] ReverseAbstractInterpreter reverseInterpreter JSType oldType rawValueType type valueType Var var Node n name value BooleanLiteralSet booleanValues toBooleanOutcomes String memberName qKeyName qObjName ObjectType objectType AbstractCompiler compiler JSTypeRegistry registry boolean hasLendsName Scope functionScope syntacticScope DiagnosticType FUNCTION_LITERAL_UNDEFINED_THIS TEMPLATE_TYPE_NOT_OBJECT_TYPE TEMPLATE_TYPE_OF_THIS_EXPECTED Map assertionFunctionsMap FlowScope bottomScope conditionFlowScope functionScope informed input joinedScope leftScope newScope output rightScope scope  	projects/Closure25/src/com/google/javascript/jscomp/TypeInference.java	0.2773500981126146	673	674	1	replace	
54	[BUG] [BUGGY] [FE] ComparisonFailure [CONTEXT] if (objectType == null) { return scope; } boolean hasLendsName = n.getJSDocInfo() != null && n.getJSDocInfo().getLendsName() != null; if (objectType.hasReferenceName() && !hasLendsName) { return scope; } [BUGGY] [BUGGY] String qObjName = NodeUtil.getBestLValueName(  NodeUtil.getBestLValue(n)); NodeUtil.getBestLValue(n)); for (Node name = n.getFirstChild(); name != null; name = name.getNext()) { Node value = name.getFirstChild(); String memberName = NodeUtil.getObjectLitKeyName(name); if (memberName != null) { JSType rawValueType =name.getFirstChild().getJSType(); JSType valueType = NodeUtil.getObjectLitKeyTypeFromValueType( name, rawValueType); if (valueType == null) { [CLASS] TypeInference BooleanOutcomePair [METHOD] traverseObjectLiteral [RETURN_TYPE] FlowScope  Node n FlowScope scope [VARIABLES] ReverseAbstractInterpreter reverseInterpreter JSType oldType rawValueType type valueType Var var Node n name value BooleanLiteralSet booleanValues toBooleanOutcomes String memberName qKeyName qObjName ObjectType objectType AbstractCompiler compiler JSTypeRegistry registry boolean hasLendsName Scope functionScope syntacticScope DiagnosticType FUNCTION_LITERAL_UNDEFINED_THIS TEMPLATE_TYPE_NOT_OBJECT_TYPE TEMPLATE_TYPE_OF_THIS_EXPECTED Map assertionFunctionsMap FlowScope bottomScope conditionFlowScope functionScope informed input joinedScope leftScope newScope output rightScope scope  	projects/Closure25/src/com/google/javascript/jscomp/TypeInference.java	0.2773500981126146	673	674	1	add	
55	[BUG] [BUGGY] for (Node name = n.getFirstChild(); name != null; [FE] ComparisonFailure [CONTEXT] } boolean hasLendsName = n.getJSDocInfo() != null && n.getJSDocInfo().getLendsName() != null; if (objectType.hasReferenceName() && !hasLendsName) { return scope; } String qObjName = NodeUtil.getBestLValueName( NodeUtil.getBestLValue(n)); [BUGGY] for (Node name = n.getFirstChild(); name != null; [BUGGY] name = name.getNext()) { Node value = name.getFirstChild(); String memberName = NodeUtil.getObjectLitKeyName(name); if (memberName != null) { JSType rawValueType =name.getFirstChild().getJSType(); JSType valueType = NodeUtil.getObjectLitKeyTypeFromValueType( name, rawValueType); if (valueType == null) { valueType = getNativeType(UNKNOWN_TYPE); } [CLASS] TypeInference BooleanOutcomePair [METHOD] traverseObjectLiteral [RETURN_TYPE] FlowScope  Node n FlowScope scope [VARIABLES] ReverseAbstractInterpreter reverseInterpreter JSType oldType rawValueType type valueType Var var Node n name value BooleanLiteralSet booleanValues toBooleanOutcomes String memberName qKeyName qObjName ObjectType objectType AbstractCompiler compiler JSTypeRegistry registry boolean hasLendsName Scope functionScope syntacticScope DiagnosticType FUNCTION_LITERAL_UNDEFINED_THIS TEMPLATE_TYPE_NOT_OBJECT_TYPE TEMPLATE_TYPE_OF_THIS_EXPECTED Map assertionFunctionsMap FlowScope bottomScope conditionFlowScope functionScope informed input joinedScope leftScope newScope output rightScope scope  	projects/Closure25/src/com/google/javascript/jscomp/TypeInference.java	0.2773500981126146	675	675	1	replace	
56	[BUG] [BUGGY] [FE] ComparisonFailure [CONTEXT] } boolean hasLendsName = n.getJSDocInfo() != null && n.getJSDocInfo().getLendsName() != null; if (objectType.hasReferenceName() && !hasLendsName) { return scope; } String qObjName = NodeUtil.getBestLValueName( NodeUtil.getBestLValue(n)); [BUGGY] [BUGGY] for (Node name = n.getFirstChild(); name != null; name = name.getNext()) { Node value = name.getFirstChild(); String memberName = NodeUtil.getObjectLitKeyName(name); if (memberName != null) { JSType rawValueType =name.getFirstChild().getJSType(); JSType valueType = NodeUtil.getObjectLitKeyTypeFromValueType( name, rawValueType); if (valueType == null) { valueType = getNativeType(UNKNOWN_TYPE); } [CLASS] TypeInference BooleanOutcomePair [METHOD] traverseObjectLiteral [RETURN_TYPE] FlowScope  Node n FlowScope scope [VARIABLES] ReverseAbstractInterpreter reverseInterpreter JSType oldType rawValueType type valueType Var var Node n name value BooleanLiteralSet booleanValues toBooleanOutcomes String memberName qKeyName qObjName ObjectType objectType AbstractCompiler compiler JSTypeRegistry registry boolean hasLendsName Scope functionScope syntacticScope DiagnosticType FUNCTION_LITERAL_UNDEFINED_THIS TEMPLATE_TYPE_NOT_OBJECT_TYPE TEMPLATE_TYPE_OF_THIS_EXPECTED Map assertionFunctionsMap FlowScope bottomScope conditionFlowScope functionScope informed input joinedScope leftScope newScope output rightScope scope  	projects/Closure25/src/com/google/javascript/jscomp/TypeInference.java	0.2773500981126146	675	675	1	add	
57	[BUG] [BUGGY] return scope; [FE] ComparisonFailure [CONTEXT] } scope.inferQualifiedSlot(name, qKeyName, oldType == null ? getNativeType(UNKNOWN_TYPE) : oldType, valueType); } } else { n.setJSType(getNativeType(UNKNOWN_TYPE)); } } [BUGGY] return scope; [BUGGY] } [CLASS] TypeInference BooleanOutcomePair [METHOD] traverseObjectLiteral [RETURN_TYPE] FlowScope  Node n FlowScope scope [VARIABLES] ReverseAbstractInterpreter reverseInterpreter JSType oldType rawValueType type valueType Var var Node n name value BooleanLiteralSet booleanValues toBooleanOutcomes String memberName qKeyName qObjName ObjectType objectType AbstractCompiler compiler JSTypeRegistry registry boolean hasLendsName Scope functionScope syntacticScope DiagnosticType FUNCTION_LITERAL_UNDEFINED_THIS TEMPLATE_TYPE_NOT_OBJECT_TYPE TEMPLATE_TYPE_OF_THIS_EXPECTED Map assertionFunctionsMap FlowScope bottomScope conditionFlowScope functionScope informed input joinedScope leftScope newScope output rightScope scope  	projects/Closure25/src/com/google/javascript/jscomp/TypeInference.java	0.2773500981126146	706	706	1	replace	
58	[BUG] [BUGGY] [FE] ComparisonFailure [CONTEXT] } scope.inferQualifiedSlot(name, qKeyName, oldType == null ? getNativeType(UNKNOWN_TYPE) : oldType, valueType); } } else { n.setJSType(getNativeType(UNKNOWN_TYPE)); } } [BUGGY] [BUGGY] return scope; } [CLASS] TypeInference BooleanOutcomePair [METHOD] traverseObjectLiteral [RETURN_TYPE] FlowScope  Node n FlowScope scope [VARIABLES] ReverseAbstractInterpreter reverseInterpreter JSType oldType rawValueType type valueType Var var Node n name value BooleanLiteralSet booleanValues toBooleanOutcomes String memberName qKeyName qObjName ObjectType objectType AbstractCompiler compiler JSTypeRegistry registry boolean hasLendsName Scope functionScope syntacticScope DiagnosticType FUNCTION_LITERAL_UNDEFINED_THIS TEMPLATE_TYPE_NOT_OBJECT_TYPE TEMPLATE_TYPE_OF_THIS_EXPECTED Map assertionFunctionsMap FlowScope bottomScope conditionFlowScope functionScope informed input joinedScope leftScope newScope output rightScope scope  	projects/Closure25/src/com/google/javascript/jscomp/TypeInference.java	0.2773500981126146	706	706	1	add	
