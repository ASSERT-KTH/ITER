bugid	buggy	buggy_class	suspiciousness	buggy_line	endbuggycode	failing_test_number	action	patch
1	[BUG] [BUGGY] break; [FE] AssertionFailedError testWith3 [CONTEXT]  int i = 0; DurationField unitField = fieldType.getDurationType().getField(iChronology); if (unitField.isSupported()) { for (; i < iTypes.length; i++) { DateTimeFieldType loopType = iTypes[i]; DurationField loopUnitField = loopType.getDurationType().getField(iChronology); if (loopUnitField.isSupported()) { int compare = unitField.compareTo(loopUnitField); if (compare > 0) { [BUGGY] break; [BUGGY] } else if (compare == 0) { DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology); DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology); if (rangeField.compareTo(loopRangeField) > 0) { break; } } } } } [CLASS] Partial Property [METHOD] with [RETURN_TYPE] Partial  DateTimeFieldType fieldType int value [VARIABLES] boolean DateTimeFieldType[] iTypes newTypes types Partial iPartial newPartial partial DateTimeFieldType fieldType loopType int[] iValues newValues values Chronology chrono chronology iChronology newChronology DurationField loopRangeField loopUnitField rangeField unitField long serialVersionUID DateTimeFormatter[] iFormatter int compare fieldIndex i iFieldIndex index value  	projects/Time4/src/main/java/org/joda/time/Partial.java	0.7071067811865475	445	445	1	replace	
2	[BUG] [BUGGY] [FE] AssertionFailedError testWith3 [CONTEXT]  int i = 0; DurationField unitField = fieldType.getDurationType().getField(iChronology); if (unitField.isSupported()) { for (; i < iTypes.length; i++) { DateTimeFieldType loopType = iTypes[i]; DurationField loopUnitField = loopType.getDurationType().getField(iChronology); if (loopUnitField.isSupported()) { int compare = unitField.compareTo(loopUnitField); if (compare > 0) { [BUGGY] [BUGGY] break; } else if (compare == 0) { DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology); DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology); if (rangeField.compareTo(loopRangeField) > 0) { break; } } } } } [CLASS] Partial Property [METHOD] with [RETURN_TYPE] Partial  DateTimeFieldType fieldType int value [VARIABLES] boolean DateTimeFieldType[] iTypes newTypes types Partial iPartial newPartial partial DateTimeFieldType fieldType loopType int[] iValues newValues values Chronology chrono chronology iChronology newChronology DurationField loopRangeField loopUnitField rangeField unitField long serialVersionUID DateTimeFormatter[] iFormatter int compare fieldIndex i iFieldIndex index value  	projects/Time4/src/main/java/org/joda/time/Partial.java	0.7071067811865475	445	445	1	add	
3	[BUG] [BUGGY] DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology); [FE] AssertionFailedError testWith3 [CONTEXT] DurationField unitField = fieldType.getDurationType().getField(iChronology); if (unitField.isSupported()) { for (; i < iTypes.length; i++) { DateTimeFieldType loopType = iTypes[i]; DurationField loopUnitField = loopType.getDurationType().getField(iChronology); if (loopUnitField.isSupported()) { int compare = unitField.compareTo(loopUnitField); if (compare > 0) { break; } else if (compare == 0) { [BUGGY] DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology); [BUGGY] DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology); if (rangeField.compareTo(loopRangeField) > 0) { break; } } } } } System.arraycopy(iTypes, 0, newTypes, 0, i); System.arraycopy(iValues, 0, newValues, 0, i); [CLASS] Partial Property [METHOD] with [RETURN_TYPE] Partial  DateTimeFieldType fieldType int value [VARIABLES] boolean DateTimeFieldType[] iTypes newTypes types Partial iPartial newPartial partial DateTimeFieldType fieldType loopType int[] iValues newValues values Chronology chrono chronology iChronology newChronology DurationField loopRangeField loopUnitField rangeField unitField long serialVersionUID DateTimeFormatter[] iFormatter int compare fieldIndex i iFieldIndex index value  	projects/Time4/src/main/java/org/joda/time/Partial.java	0.5	447	447	1	replace	
4	[BUG] [BUGGY] [FE] AssertionFailedError testWith3 [CONTEXT] DurationField unitField = fieldType.getDurationType().getField(iChronology); if (unitField.isSupported()) { for (; i < iTypes.length; i++) { DateTimeFieldType loopType = iTypes[i]; DurationField loopUnitField = loopType.getDurationType().getField(iChronology); if (loopUnitField.isSupported()) { int compare = unitField.compareTo(loopUnitField); if (compare > 0) { break; } else if (compare == 0) { [BUGGY] [BUGGY] DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology); DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology); if (rangeField.compareTo(loopRangeField) > 0) { break; } } } } } System.arraycopy(iTypes, 0, newTypes, 0, i); System.arraycopy(iValues, 0, newValues, 0, i); [CLASS] Partial Property [METHOD] with [RETURN_TYPE] Partial  DateTimeFieldType fieldType int value [VARIABLES] boolean DateTimeFieldType[] iTypes newTypes types Partial iPartial newPartial partial DateTimeFieldType fieldType loopType int[] iValues newValues values Chronology chrono chronology iChronology newChronology DurationField loopRangeField loopUnitField rangeField unitField long serialVersionUID DateTimeFormatter[] iFormatter int compare fieldIndex i iFieldIndex index value  	projects/Time4/src/main/java/org/joda/time/Partial.java	0.5	447	447	1	add	
5	[BUG] [BUGGY] DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology); [FE] AssertionFailedError testWith3 [CONTEXT] if (unitField.isSupported()) { for (; i < iTypes.length; i++) { DateTimeFieldType loopType = iTypes[i]; DurationField loopUnitField = loopType.getDurationType().getField(iChronology); if (loopUnitField.isSupported()) { int compare = unitField.compareTo(loopUnitField); if (compare > 0) { break; } else if (compare == 0) { DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology); [BUGGY] DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology); [BUGGY] if (rangeField.compareTo(loopRangeField) > 0) { break; } } } } } System.arraycopy(iTypes, 0, newTypes, 0, i); System.arraycopy(iValues, 0, newValues, 0, i); newTypes[i] = fieldType; [CLASS] Partial Property [METHOD] with [RETURN_TYPE] Partial  DateTimeFieldType fieldType int value [VARIABLES] boolean DateTimeFieldType[] iTypes newTypes types Partial iPartial newPartial partial DateTimeFieldType fieldType loopType int[] iValues newValues values Chronology chrono chronology iChronology newChronology DurationField loopRangeField loopUnitField rangeField unitField long serialVersionUID DateTimeFormatter[] iFormatter int compare fieldIndex i iFieldIndex index value  	projects/Time4/src/main/java/org/joda/time/Partial.java	0.5	448	448	1	replace	
6	[BUG] [BUGGY] [FE] AssertionFailedError testWith3 [CONTEXT] if (unitField.isSupported()) { for (; i < iTypes.length; i++) { DateTimeFieldType loopType = iTypes[i]; DurationField loopUnitField = loopType.getDurationType().getField(iChronology); if (loopUnitField.isSupported()) { int compare = unitField.compareTo(loopUnitField); if (compare > 0) { break; } else if (compare == 0) { DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology); [BUGGY] [BUGGY] DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology); if (rangeField.compareTo(loopRangeField) > 0) { break; } } } } } System.arraycopy(iTypes, 0, newTypes, 0, i); System.arraycopy(iValues, 0, newValues, 0, i); newTypes[i] = fieldType; [CLASS] Partial Property [METHOD] with [RETURN_TYPE] Partial  DateTimeFieldType fieldType int value [VARIABLES] boolean DateTimeFieldType[] iTypes newTypes types Partial iPartial newPartial partial DateTimeFieldType fieldType loopType int[] iValues newValues values Chronology chrono chronology iChronology newChronology DurationField loopRangeField loopUnitField rangeField unitField long serialVersionUID DateTimeFormatter[] iFormatter int compare fieldIndex i iFieldIndex index value  	projects/Time4/src/main/java/org/joda/time/Partial.java	0.5	448	448	1	add	
7	[BUG] [BUGGY] if (rangeField.compareTo(loopRangeField) > 0) { [FE] AssertionFailedError testWith3 [CONTEXT] for (; i < iTypes.length; i++) { DateTimeFieldType loopType = iTypes[i]; DurationField loopUnitField = loopType.getDurationType().getField(iChronology); if (loopUnitField.isSupported()) { int compare = unitField.compareTo(loopUnitField); if (compare > 0) { break; } else if (compare == 0) { DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology); DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology); [BUGGY] if (rangeField.compareTo(loopRangeField) > 0) { [BUGGY] break; } } } } } System.arraycopy(iTypes, 0, newTypes, 0, i); System.arraycopy(iValues, 0, newValues, 0, i); newTypes[i] = fieldType; newValues[i] = value; [CLASS] Partial Property [METHOD] with [RETURN_TYPE] Partial  DateTimeFieldType fieldType int value [VARIABLES] boolean DateTimeFieldType[] iTypes newTypes types Partial iPartial newPartial partial DateTimeFieldType fieldType loopType int[] iValues newValues values Chronology chrono chronology iChronology newChronology DurationField loopRangeField loopUnitField rangeField unitField long serialVersionUID DateTimeFormatter[] iFormatter int compare fieldIndex i iFieldIndex index value  	projects/Time4/src/main/java/org/joda/time/Partial.java	0.5	449	449	1	replace	
8	[BUG] [BUGGY] [FE] AssertionFailedError testWith3 [CONTEXT] for (; i < iTypes.length; i++) { DateTimeFieldType loopType = iTypes[i]; DurationField loopUnitField = loopType.getDurationType().getField(iChronology); if (loopUnitField.isSupported()) { int compare = unitField.compareTo(loopUnitField); if (compare > 0) { break; } else if (compare == 0) { DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology); DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology); [BUGGY] [BUGGY] if (rangeField.compareTo(loopRangeField) > 0) { break; } } } } } System.arraycopy(iTypes, 0, newTypes, 0, i); System.arraycopy(iValues, 0, newValues, 0, i); newTypes[i] = fieldType; newValues[i] = value; [CLASS] Partial Property [METHOD] with [RETURN_TYPE] Partial  DateTimeFieldType fieldType int value [VARIABLES] boolean DateTimeFieldType[] iTypes newTypes types Partial iPartial newPartial partial DateTimeFieldType fieldType loopType int[] iValues newValues values Chronology chrono chronology iChronology newChronology DurationField loopRangeField loopUnitField rangeField unitField long serialVersionUID DateTimeFormatter[] iFormatter int compare fieldIndex i iFieldIndex index value  	projects/Time4/src/main/java/org/joda/time/Partial.java	0.5	449	449	1	add	
9	[BUG] [BUGGY] } else if (compare == 0) { [FE] AssertionFailedError testWith3 [CONTEXT] int i = 0; DurationField unitField = fieldType.getDurationType().getField(iChronology); if (unitField.isSupported()) { for (; i < iTypes.length; i++) { DateTimeFieldType loopType = iTypes[i]; DurationField loopUnitField = loopType.getDurationType().getField(iChronology); if (loopUnitField.isSupported()) { int compare = unitField.compareTo(loopUnitField); if (compare > 0) { break; [BUGGY] } else if (compare == 0) { [BUGGY] DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology); DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology); if (rangeField.compareTo(loopRangeField) > 0) { break; } } } } } System.arraycopy(iTypes, 0, newTypes, 0, i); [CLASS] Partial Property [METHOD] with [RETURN_TYPE] Partial  DateTimeFieldType fieldType int value [VARIABLES] boolean DateTimeFieldType[] iTypes newTypes types Partial iPartial newPartial partial DateTimeFieldType fieldType loopType int[] iValues newValues values Chronology chrono chronology iChronology newChronology DurationField loopRangeField loopUnitField rangeField unitField long serialVersionUID DateTimeFormatter[] iFormatter int compare fieldIndex i iFieldIndex index value  	projects/Time4/src/main/java/org/joda/time/Partial.java	0.35355339059327373	446	446	1	replace	
10	[BUG] [BUGGY] [FE] AssertionFailedError testWith3 [CONTEXT] int i = 0; DurationField unitField = fieldType.getDurationType().getField(iChronology); if (unitField.isSupported()) { for (; i < iTypes.length; i++) { DateTimeFieldType loopType = iTypes[i]; DurationField loopUnitField = loopType.getDurationType().getField(iChronology); if (loopUnitField.isSupported()) { int compare = unitField.compareTo(loopUnitField); if (compare > 0) { break; [BUGGY] [BUGGY] } else if (compare == 0) { DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology); DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology); if (rangeField.compareTo(loopRangeField) > 0) { break; } } } } } System.arraycopy(iTypes, 0, newTypes, 0, i); [CLASS] Partial Property [METHOD] with [RETURN_TYPE] Partial  DateTimeFieldType fieldType int value [VARIABLES] boolean DateTimeFieldType[] iTypes newTypes types Partial iPartial newPartial partial DateTimeFieldType fieldType loopType int[] iValues newValues values Chronology chrono chronology iChronology newChronology DurationField loopRangeField loopUnitField rangeField unitField long serialVersionUID DateTimeFormatter[] iFormatter int compare fieldIndex i iFieldIndex index value  	projects/Time4/src/main/java/org/joda/time/Partial.java	0.35355339059327373	446	446	1	add	
11	[BUG] [BUGGY] int compare = unitField.compareTo(loopUnitField); [FE] AssertionFailedError testWith3 [CONTEXT] int[] newValues = new int[newTypes.length];  int i = 0; DurationField unitField = fieldType.getDurationType().getField(iChronology); if (unitField.isSupported()) { for (; i < iTypes.length; i++) { DateTimeFieldType loopType = iTypes[i]; DurationField loopUnitField = loopType.getDurationType().getField(iChronology); if (loopUnitField.isSupported()) { [BUGGY] int compare = unitField.compareTo(loopUnitField); [BUGGY] if (compare > 0) { break; } else if (compare == 0) { DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology); DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology); if (rangeField.compareTo(loopRangeField) > 0) { break; } } } [CLASS] Partial Property [METHOD] with [RETURN_TYPE] Partial  DateTimeFieldType fieldType int value [VARIABLES] boolean DateTimeFieldType[] iTypes newTypes types Partial iPartial newPartial partial DateTimeFieldType fieldType loopType int[] iValues newValues values Chronology chrono chronology iChronology newChronology DurationField loopRangeField loopUnitField rangeField unitField long serialVersionUID DateTimeFormatter[] iFormatter int compare fieldIndex i iFieldIndex index value  	projects/Time4/src/main/java/org/joda/time/Partial.java	0.3333333333333333	443	443	1	replace	
12	[BUG] [BUGGY] [FE] AssertionFailedError testWith3 [CONTEXT] int[] newValues = new int[newTypes.length];  int i = 0; DurationField unitField = fieldType.getDurationType().getField(iChronology); if (unitField.isSupported()) { for (; i < iTypes.length; i++) { DateTimeFieldType loopType = iTypes[i]; DurationField loopUnitField = loopType.getDurationType().getField(iChronology); if (loopUnitField.isSupported()) { [BUGGY] [BUGGY] int compare = unitField.compareTo(loopUnitField); if (compare > 0) { break; } else if (compare == 0) { DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology); DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology); if (rangeField.compareTo(loopRangeField) > 0) { break; } } } [CLASS] Partial Property [METHOD] with [RETURN_TYPE] Partial  DateTimeFieldType fieldType int value [VARIABLES] boolean DateTimeFieldType[] iTypes newTypes types Partial iPartial newPartial partial DateTimeFieldType fieldType loopType int[] iValues newValues values Chronology chrono chronology iChronology newChronology DurationField loopRangeField loopUnitField rangeField unitField long serialVersionUID DateTimeFormatter[] iFormatter int compare fieldIndex i iFieldIndex index value  	projects/Time4/src/main/java/org/joda/time/Partial.java	0.3333333333333333	443	443	1	add	
13	[BUG] [BUGGY] if (compare > 0) { [FE] AssertionFailedError testWith3 [CONTEXT]  int i = 0; DurationField unitField = fieldType.getDurationType().getField(iChronology); if (unitField.isSupported()) { for (; i < iTypes.length; i++) { DateTimeFieldType loopType = iTypes[i]; DurationField loopUnitField = loopType.getDurationType().getField(iChronology); if (loopUnitField.isSupported()) { int compare = unitField.compareTo(loopUnitField); [BUGGY] if (compare > 0) { [BUGGY] break; } else if (compare == 0) { DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology); DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology); if (rangeField.compareTo(loopRangeField) > 0) { break; } } } } [CLASS] Partial Property [METHOD] with [RETURN_TYPE] Partial  DateTimeFieldType fieldType int value [VARIABLES] boolean DateTimeFieldType[] iTypes newTypes types Partial iPartial newPartial partial DateTimeFieldType fieldType loopType int[] iValues newValues values Chronology chrono chronology iChronology newChronology DurationField loopRangeField loopUnitField rangeField unitField long serialVersionUID DateTimeFormatter[] iFormatter int compare fieldIndex i iFieldIndex index value  	projects/Time4/src/main/java/org/joda/time/Partial.java	0.3333333333333333	444	444	1	replace	
14	[BUG] [BUGGY] [FE] AssertionFailedError testWith3 [CONTEXT]  int i = 0; DurationField unitField = fieldType.getDurationType().getField(iChronology); if (unitField.isSupported()) { for (; i < iTypes.length; i++) { DateTimeFieldType loopType = iTypes[i]; DurationField loopUnitField = loopType.getDurationType().getField(iChronology); if (loopUnitField.isSupported()) { int compare = unitField.compareTo(loopUnitField); [BUGGY] [BUGGY] if (compare > 0) { break; } else if (compare == 0) { DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology); DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology); if (rangeField.compareTo(loopRangeField) > 0) { break; } } } } [CLASS] Partial Property [METHOD] with [RETURN_TYPE] Partial  DateTimeFieldType fieldType int value [VARIABLES] boolean DateTimeFieldType[] iTypes newTypes types Partial iPartial newPartial partial DateTimeFieldType fieldType loopType int[] iValues newValues values Chronology chrono chronology iChronology newChronology DurationField loopRangeField loopUnitField rangeField unitField long serialVersionUID DateTimeFormatter[] iFormatter int compare fieldIndex i iFieldIndex index value  	projects/Time4/src/main/java/org/joda/time/Partial.java	0.3333333333333333	444	444	1	add	
