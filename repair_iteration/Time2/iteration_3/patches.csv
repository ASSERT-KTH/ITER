bugid	buggy	buggy_class	suspiciousness	buggy_line	endbuggycode	original_failing_test_number	action	patch	original_buggy	execution_result	diagnosis	previous_bug_id	new_failing_test_number	this_action134	[BUG]  [BUGGY]  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange  [CONTEXT]        public  Partial(DateTimeFieldType  type,  int  value,  Chronology  chronology)  {  super();        [BUGGY]  if(chronology  ==  null)  {  chronology  =  DateTimeUtils.getChronology(chronology);  chronology  =  DateTimeUtils.getChronology(chronology);  }  else  {  throw  new  IllegalArgumentException( "The  field  must  not  be  null   ");  }  [BUGGY]        chronology  =  DateTimeUtils.getChronology(chronology).withUTC();  iChronology  =  chronology;  if  (type  ==  null)  {  throw  new  IllegalArgumentException(       "The  field  type  must  not  be  null       ");  }  iTypes  =  new  DateTimeFieldType[]  {type};  iValues  =  new  int[]  {value};  chronology.validate(this,  iValues);  }  [CLASS]  Partial  Property  [METHOD]  <init>  [RETURN_TYPE]  Chronology)  DateTimeFieldType  type  int  value  Chronology  chronology  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  Partial  iPartial  DateTimeFieldType  type  int[]  iValues  Chronology  chrono  chronology  iChronology  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  iFieldIndex  value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.2886751345948129	154	154	1	add	if(chronology  ==  null)  {  chronology  =  DateTimeUtils.getChronology(chronology);  chronology  =  DateTimeUtils.getChronology(chronology);  }  else  {  throw  new  IllegalArgumentException( "The  field  must  not  be  null   ");  }	  if(chronology    ==    null)    {    chronology    =    DateTimeUtils.getChronology(chronology);    chronology    =    DateTimeUtils.getChronology(chronology);    }    else    {    throw    new    IllegalArgumentException(   "   ");    }    	compilable	  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange	214	1	replace
135	[BUG]  [BUGGY]  if(chronology  ==  null)  {  chronology  =  DateTimeUtils.getChronology(chronology);  chronology  =  DateTimeUtils.getChronology(chronology);  }  else  {  throw  new  IllegalArgumentException( "The  field  must  not  be  null   ");  }  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange  [CONTEXT]        public  Partial(DateTimeFieldType  type,  int  value,  Chronology  chronology)  {  super();        [BUGGY]  if(chronology  ==  null)  {  chronology  =  DateTimeUtils.getChronology(chronology);  chronology  =  DateTimeUtils.getChronology(chronology);  }  else  {  throw  new  IllegalArgumentException( "The  field  must  not  be  null   ");  }  [BUGGY]        chronology  =  DateTimeUtils.getChronology(chronology).withUTC();  iChronology  =  chronology;  if  (type  ==  null)  {  throw  new  IllegalArgumentException(       "The  field  type  must  not  be  null       ");  }  iTypes  =  new  DateTimeFieldType[]  {type};  iValues  =  new  int[]  {value};  chronology.validate(this,  iValues);  }  [CLASS]  Partial  Property  [METHOD]  <init>  [RETURN_TYPE]  Chronology)  DateTimeFieldType  type  int  value  Chronology  chronology  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  Partial  iPartial  DateTimeFieldType  type  int[]  iValues  Chronology  chrono  chronology  iChronology  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  iFieldIndex  value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.2886751345948129	154	154	1	replace	if(chronology  ==  null)  {  chronology  =  DateTimeUtils.getChronology(chronology);  chronology  =  DateTimeUtils.getChronology(chronology);  }  else  {  throw  new  IllegalArgumentException( "The  field  must  not  be  null   ");  }	  if(chronology    ==    null)    {    chronology    =    DateTimeUtils.getChronology(chronology);    chronology    =    DateTimeUtils.getChronology(chronology);    }    else    {    throw    new    IllegalArgumentException(   "   ");    }    	compilable	  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange	214	1	replace
141	[BUG]  [BUGGY]  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange  [CONTEXT]        DateTimeFieldType  loopType  =  types[i];  DurationField  loopUnitField  =  loopType.getDurationType().getField(iChronology);  if  (i  >  0)  {  int  compare  =  lastUnitField.compareTo(loopUnitField);  if  (compare  <  0  ||  (compare  !=  0  &&  loopUnitField.isSupported()  ==  false))  {  throw  new  IllegalArgumentException(       "Types  array  must  be  in  order  largest-smallest:         "  +  types[i  -  1].getName()  +         "  <         "  +  loopType.getName());  }  else  if  (compare  ==  0)  {  if  (types[i  -  1].getRangeDurationType()  ==  null)  {  if  (loopType.getRangeDurationType()  ==  null)  {        [BUGGY]  if(types[i    -    1].getRangeDurationType()    ==    null)    {    throw    new    IllegalArgumentException(     "     ");    }    if(loopType.getRangeDurationType().getField(iChronology)  ==  null)  {  throw  new  IllegalArgumentException(   "     ");  }  if(loopType.getRangeDurationType().getField(iChronology)  ==  null)  {  throw  new  IllegalArgumentException( " ");  }  [BUGGY]        throw  new  IllegalArgumentException(       "Types  array  must  not  contain  duplicate:         "  +            types[i  -  1].getName()  +         "  and         "  +  loopType.getName());  types[i  -  1].getName()  +         "  and         "  +  loopType.getName());  }  }  else  {  if  (loopType.getRangeDurationType()  ==  null)  {  throw  new  IllegalArgumentException(       "Types  array  must  be  in  order  largest-smallest:         "  +  types[i  -  1].getName()  +         "  <         "  +  loopType.getName());  }  DurationField  lastRangeField  =  types[i  -  1].getRangeDurationType().getField(iChronology);  DurationField  loopRangeField  =  loopType.getRangeDurationType().getField(iChronology);  if  (lastRangeField.compareTo(loopRangeField)  <  0)  {  [CLASS]  Partial  Property  [METHOD]  <init>  [RETURN_TYPE]  Chronology)  DateTimeFieldType[]  types  int[]  values  Chronology  chronology  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  types  Partial  iPartial  DateTimeFieldType  loopType  int[]  iValues  values  Chronology  chrono  chronology  iChronology  DurationField  lastRangeField  lastUnitField  loopRangeField  loopUnitField  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  compare  i  iFieldIndex  value  	projects/Time2/src/main/java/org/joda/time/Partial.java	1.0	224	225	1	add	if(types[i        -        1].getRangeDurationType()        ==        null)        {        throw        new        IllegalArgumentException(       "       ");        }        if(loopType.getRangeDurationType().getField(iChronology)    ==    null)    {    throw    new    IllegalArgumentException(   "       ");    }    if(loopType.getRangeDurationType().getField(iChronology)  ==  null)  {  throw  new  IllegalArgumentException( " ");  }	  	compilable	  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange	175	1	add
142	[BUG]  [BUGGY]  if(types[i    -    1].getRangeDurationType()    ==    null)    {    throw    new    IllegalArgumentException(     "     ");    }    if(loopType.getRangeDurationType().getField(iChronology)  ==  null)  {  throw  new  IllegalArgumentException(   "     ");  }  if(loopType.getRangeDurationType().getField(iChronology)  ==  null)  {  throw  new  IllegalArgumentException( " ");  }  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange  [CONTEXT]        DateTimeFieldType  loopType  =  types[i];  DurationField  loopUnitField  =  loopType.getDurationType().getField(iChronology);  if  (i  >  0)  {  int  compare  =  lastUnitField.compareTo(loopUnitField);  if  (compare  <  0  ||  (compare  !=  0  &&  loopUnitField.isSupported()  ==  false))  {  throw  new  IllegalArgumentException(       "Types  array  must  be  in  order  largest-smallest:         "  +  types[i  -  1].getName()  +         "  <         "  +  loopType.getName());  }  else  if  (compare  ==  0)  {  if  (types[i  -  1].getRangeDurationType()  ==  null)  {  if  (loopType.getRangeDurationType()  ==  null)  {        [BUGGY]  if(types[i    -    1].getRangeDurationType()    ==    null)    {    throw    new    IllegalArgumentException(     "     ");    }    if(loopType.getRangeDurationType().getField(iChronology)  ==  null)  {  throw  new  IllegalArgumentException(   "     ");  }  if(loopType.getRangeDurationType().getField(iChronology)  ==  null)  {  throw  new  IllegalArgumentException( " ");  }  [BUGGY]        throw  new  IllegalArgumentException(       "Types  array  must  not  contain  duplicate:         "  +            types[i  -  1].getName()  +         "  and         "  +  loopType.getName());  types[i  -  1].getName()  +         "  and         "  +  loopType.getName());  }  }  else  {  if  (loopType.getRangeDurationType()  ==  null)  {  throw  new  IllegalArgumentException(       "Types  array  must  be  in  order  largest-smallest:         "  +  types[i  -  1].getName()  +         "  <         "  +  loopType.getName());  }  DurationField  lastRangeField  =  types[i  -  1].getRangeDurationType().getField(iChronology);  DurationField  loopRangeField  =  loopType.getRangeDurationType().getField(iChronology);  if  (lastRangeField.compareTo(loopRangeField)  <  0)  {  [CLASS]  Partial  Property  [METHOD]  <init>  [RETURN_TYPE]  Chronology)  DateTimeFieldType[]  types  int[]  values  Chronology  chronology  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  types  Partial  iPartial  DateTimeFieldType  loopType  int[]  iValues  values  Chronology  chrono  chronology  iChronology  DurationField  lastRangeField  lastUnitField  loopRangeField  loopUnitField  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  compare  i  iFieldIndex  value  	projects/Time2/src/main/java/org/joda/time/Partial.java	1.0	224	225	1	replace	if(types[i        -        1].getRangeDurationType()        ==        null)        {        throw        new        IllegalArgumentException(       "       ");        }        if(loopType.getRangeDurationType().getField(iChronology)    ==    null)    {    throw    new    IllegalArgumentException(   "       ");    }    if(loopType.getRangeDurationType().getField(iChronology)  ==  null)  {  throw  new  IllegalArgumentException( " ");  }	  	compilable	  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange	175	1	add
142	[BUG]  [BUGGY]  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange  [CONTEXT]        DateTimeFieldType  loopType  =  types[i];  DurationField  loopUnitField  =  loopType.getDurationType().getField(iChronology);  if  (i  >  0)  {  int  compare  =  lastUnitField.compareTo(loopUnitField);  if  (compare  <  0  ||  (compare  !=  0  &&  loopUnitField.isSupported()  ==  false))  {  throw  new  IllegalArgumentException(       "Types  array  must  be  in  order  largest-smallest:         "  +  types[i  -  1].getName()  +         "  <         "  +  loopType.getName());  }  else  if  (compare  ==  0)  {  if  (types[i  -  1].getRangeDurationType()  ==  null)  {  if  (loopType.getRangeDurationType()  ==  null)  {        [BUGGY]  if(types[i    -    1].getRangeDurationType()    ==    null)    {    throw    new    IllegalArgumentException(     "     ");    }    if(loopType.getRangeDurationType().getField(iChronology)  ==  null)  {  throw  new  IllegalArgumentException(   "     ");  }  if(loopType.getRangeDurationType().getField(iChronology)!=  null)  {  throw  new  IllegalArgumentException( " ");  }  [BUGGY]        throw  new  IllegalArgumentException(       "Types  array  must  not  contain  duplicate:         "  +            types[i  -  1].getName()  +         "  and         "  +  loopType.getName());  types[i  -  1].getName()  +         "  and         "  +  loopType.getName());  }  }  else  {  if  (loopType.getRangeDurationType()  ==  null)  {  throw  new  IllegalArgumentException(       "Types  array  must  be  in  order  largest-smallest:         "  +  types[i  -  1].getName()  +         "  <         "  +  loopType.getName());  }  DurationField  lastRangeField  =  types[i  -  1].getRangeDurationType().getField(iChronology);  DurationField  loopRangeField  =  loopType.getRangeDurationType().getField(iChronology);  if  (lastRangeField.compareTo(loopRangeField)  <  0)  {  [CLASS]  Partial  Property  [METHOD]  <init>  [RETURN_TYPE]  Chronology)  DateTimeFieldType[]  types  int[]  values  Chronology  chronology  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  types  Partial  iPartial  DateTimeFieldType  loopType  int[]  iValues  values  Chronology  chrono  chronology  iChronology  DurationField  lastRangeField  lastUnitField  loopRangeField  loopUnitField  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  compare  i  iFieldIndex  value  	projects/Time2/src/main/java/org/joda/time/Partial.java	1.0	224	225	1	add	if(types[i        -        1].getRangeDurationType()        ==        null)        {        throw        new        IllegalArgumentException(       "       ");        }        if(loopType.getRangeDurationType().getField(iChronology)    ==    null)    {    throw    new    IllegalArgumentException(   "       ");    }    if(loopType.getRangeDurationType().getField(iChronology)!=  null)  {  throw  new  IllegalArgumentException( " ");  }	  	compilable	  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange	175	1	add
143	[BUG]  [BUGGY]  if(types[i    -    1].getRangeDurationType()    ==    null)    {    throw    new    IllegalArgumentException(     "     ");    }    if(loopType.getRangeDurationType().getField(iChronology)  ==  null)  {  throw  new  IllegalArgumentException(   "     ");  }  if(loopType.getRangeDurationType().getField(iChronology)!=  null)  {  throw  new  IllegalArgumentException( " ");  }  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange  [CONTEXT]        DateTimeFieldType  loopType  =  types[i];  DurationField  loopUnitField  =  loopType.getDurationType().getField(iChronology);  if  (i  >  0)  {  int  compare  =  lastUnitField.compareTo(loopUnitField);  if  (compare  <  0  ||  (compare  !=  0  &&  loopUnitField.isSupported()  ==  false))  {  throw  new  IllegalArgumentException(       "Types  array  must  be  in  order  largest-smallest:         "  +  types[i  -  1].getName()  +         "  <         "  +  loopType.getName());  }  else  if  (compare  ==  0)  {  if  (types[i  -  1].getRangeDurationType()  ==  null)  {  if  (loopType.getRangeDurationType()  ==  null)  {        [BUGGY]  if(types[i    -    1].getRangeDurationType()    ==    null)    {    throw    new    IllegalArgumentException(     "     ");    }    if(loopType.getRangeDurationType().getField(iChronology)  ==  null)  {  throw  new  IllegalArgumentException(   "     ");  }  if(loopType.getRangeDurationType().getField(iChronology)!=  null)  {  throw  new  IllegalArgumentException( " ");  }  [BUGGY]        throw  new  IllegalArgumentException(       "Types  array  must  not  contain  duplicate:         "  +            types[i  -  1].getName()  +         "  and         "  +  loopType.getName());  types[i  -  1].getName()  +         "  and         "  +  loopType.getName());  }  }  else  {  if  (loopType.getRangeDurationType()  ==  null)  {  throw  new  IllegalArgumentException(       "Types  array  must  be  in  order  largest-smallest:         "  +  types[i  -  1].getName()  +         "  <         "  +  loopType.getName());  }  DurationField  lastRangeField  =  types[i  -  1].getRangeDurationType().getField(iChronology);  DurationField  loopRangeField  =  loopType.getRangeDurationType().getField(iChronology);  if  (lastRangeField.compareTo(loopRangeField)  <  0)  {  [CLASS]  Partial  Property  [METHOD]  <init>  [RETURN_TYPE]  Chronology)  DateTimeFieldType[]  types  int[]  values  Chronology  chronology  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  types  Partial  iPartial  DateTimeFieldType  loopType  int[]  iValues  values  Chronology  chrono  chronology  iChronology  DurationField  lastRangeField  lastUnitField  loopRangeField  loopUnitField  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  compare  i  iFieldIndex  value  	projects/Time2/src/main/java/org/joda/time/Partial.java	1.0	224	225	1	replace	if(types[i        -        1].getRangeDurationType()        ==        null)        {        throw        new        IllegalArgumentException(       "       ");        }        if(loopType.getRangeDurationType().getField(iChronology)    ==    null)    {    throw    new    IllegalArgumentException(   "       ");    }    if(loopType.getRangeDurationType().getField(iChronology)!=  null)  {  throw  new  IllegalArgumentException( " ");  }	  	compilable	  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange	175	1	add
194	[BUG]  [BUGGY]  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange  [CONTEXT]        public  Partial(DateTimeFieldType  type,  int  value,  Chronology  chronology)  {  super();        [BUGGY]  if(chronology  ==  null)  {  chronology  =  DateTimeUtils.getChronology(chronology).withUTC();  }  [BUGGY]        chronology  =  DateTimeUtils.getChronology(chronology).withUTC();  iChronology  =  chronology;  if  (type  ==  null)  {  throw  new  IllegalArgumentException(       "The  field  type  must  not  be  null       ");  }  iTypes  =  new  DateTimeFieldType[]  {type};  iValues  =  new  int[]  {value};  chronology.validate(this,  iValues);  }  [CLASS]  Partial  Property  [METHOD]  <init>  [RETURN_TYPE]  Chronology)  DateTimeFieldType  type  int  value  Chronology  chronology  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  Partial  iPartial  DateTimeFieldType  type  int[]  iValues  Chronology  chrono  chronology  iChronology  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  iFieldIndex  value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.2886751345948129	154	154	1	add	if(chronology  ==  null)  {  chronology  =  DateTimeUtils.getChronology(chronology).withUTC();  }	  if(chronology    ==    null)    {    chronology    =    DateTimeUtils.getChronology(chronology);    }    	compilable	  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange	385	1	replace
195	[BUG]  [BUGGY]  if(chronology  ==  null)  {  chronology  =  DateTimeUtils.getChronology(chronology).withUTC();  }  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange  [CONTEXT]        public  Partial(DateTimeFieldType  type,  int  value,  Chronology  chronology)  {  super();        [BUGGY]  if(chronology  ==  null)  {  chronology  =  DateTimeUtils.getChronology(chronology).withUTC();  }  [BUGGY]        chronology  =  DateTimeUtils.getChronology(chronology).withUTC();  iChronology  =  chronology;  if  (type  ==  null)  {  throw  new  IllegalArgumentException(       "The  field  type  must  not  be  null       ");  }  iTypes  =  new  DateTimeFieldType[]  {type};  iValues  =  new  int[]  {value};  chronology.validate(this,  iValues);  }  [CLASS]  Partial  Property  [METHOD]  <init>  [RETURN_TYPE]  Chronology)  DateTimeFieldType  type  int  value  Chronology  chronology  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  Partial  iPartial  DateTimeFieldType  type  int[]  iValues  Chronology  chrono  chronology  iChronology  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  iFieldIndex  value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.2886751345948129	154	154	1	replace	if(chronology  ==  null)  {  chronology  =  DateTimeUtils.getChronology(chronology).withUTC();  }	  if(chronology    ==    null)    {    chronology    =    DateTimeUtils.getChronology(chronology);    }    	compilable	  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange	385	1	replace
201	[BUG]  [BUGGY]  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange  [CONTEXT]        public  Partial(DateTimeFieldType  type,  int  value,  Chronology  chronology)  {  super();        [BUGGY]  if(chronology  ==  null)  {  chronology  =  DateTimeUtils.getChronology(chronology);  chronology  =  DateTimeUtils.getChronology(chronology);  chronology  =  DateTimeUtils.getChronology(chronology).withUTC();  }  [BUGGY]        chronology  =  DateTimeUtils.getChronology(chronology).withUTC();  iChronology  =  chronology;  if  (type  ==  null)  {  throw  new  IllegalArgumentException(       "The  field  type  must  not  be  null       ");  }  iTypes  =  new  DateTimeFieldType[]  {type};  iValues  =  new  int[]  {value};  chronology.validate(this,  iValues);  }  [CLASS]  Partial  Property  [METHOD]  <init>  [RETURN_TYPE]  Chronology)  DateTimeFieldType  type  int  value  Chronology  chronology  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  Partial  iPartial  DateTimeFieldType  type  int[]  iValues  Chronology  chrono  chronology  iChronology  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  iFieldIndex  value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.2886751345948129	154	154	1	add	if(chronology  ==  null)  {  chronology  =  DateTimeUtils.getChronology(chronology);  chronology  =  DateTimeUtils.getChronology(chronology);  chronology  =  DateTimeUtils.getChronology(chronology).withUTC();  }	                  chronology        =        DateTimeUtils.getChronology(chronology);        chronology    =    DateTimeUtils.getChronology(chronology);    chronology    =    DateTimeUtils.getChronology(chronology).withUTC();    	compilable	  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange	53	1	replace
202	[BUG]  [BUGGY]  if(chronology  ==  null)  {  chronology  =  DateTimeUtils.getChronology(chronology);  chronology  =  DateTimeUtils.getChronology(chronology);  chronology  =  DateTimeUtils.getChronology(chronology).withUTC();  }  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange  [CONTEXT]        public  Partial(DateTimeFieldType  type,  int  value,  Chronology  chronology)  {  super();        [BUGGY]  if(chronology  ==  null)  {  chronology  =  DateTimeUtils.getChronology(chronology);  chronology  =  DateTimeUtils.getChronology(chronology);  chronology  =  DateTimeUtils.getChronology(chronology).withUTC();  }  [BUGGY]        chronology  =  DateTimeUtils.getChronology(chronology).withUTC();  iChronology  =  chronology;  if  (type  ==  null)  {  throw  new  IllegalArgumentException(       "The  field  type  must  not  be  null       ");  }  iTypes  =  new  DateTimeFieldType[]  {type};  iValues  =  new  int[]  {value};  chronology.validate(this,  iValues);  }  [CLASS]  Partial  Property  [METHOD]  <init>  [RETURN_TYPE]  Chronology)  DateTimeFieldType  type  int  value  Chronology  chronology  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  Partial  iPartial  DateTimeFieldType  type  int[]  iValues  Chronology  chrono  chronology  iChronology  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  iFieldIndex  value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.2886751345948129	154	154	1	replace	if(chronology  ==  null)  {  chronology  =  DateTimeUtils.getChronology(chronology);  chronology  =  DateTimeUtils.getChronology(chronology);  chronology  =  DateTimeUtils.getChronology(chronology).withUTC();  }	                  chronology        =        DateTimeUtils.getChronology(chronology);        chronology    =    DateTimeUtils.getChronology(chronology);    chronology    =    DateTimeUtils.getChronology(chronology).withUTC();    	compilable	  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange	53	1	replace
211	[BUG]  [BUGGY]  [FE]  NullPointerException  testWith_baseAndArgHaveNoRange  [CONTEXT]        DateTimeFieldType  loopType  =  types[i];  DurationField  loopUnitField  =  loopType.getDurationType().getField(iChronology);  if  (i  >  0)  {  int  compare  =  lastUnitField.compareTo(loopUnitField);  if  (compare  <  0  ||  (compare  !=  0  &&  loopUnitField.isSupported()  ==  false))  {  throw  new  IllegalArgumentException(       "Types  array  must  be  in  order  largest-smallest:         "  +  types[i  -  1].getName()  +         "  <         "  +  loopType.getName());  }  else  if  (compare  ==  0)  {  if  (types[i  -  1].getRangeDurationType()  ==  null)  {  if  (loopType.getRangeDurationType()  ==  null)  {        [BUGGY]  DurationField  lastRangeField  =  loopType.getRangeDurationType().getField(iChronology);  [BUGGY]        throw  new  IllegalArgumentException(       "Types  array  must  not  contain  duplicate:         "  +            types[i  -  1].getName()  +         "  and         "  +  loopType.getName());  types[i  -  1].getName()  +         "  and         "  +  loopType.getName());  }  }  else  {  if  (loopType.getRangeDurationType()  ==  null)  {  throw  new  IllegalArgumentException(       "Types  array  must  be  in  order  largest-smallest:         "  +  types[i  -  1].getName()  +         "  <         "  +  loopType.getName());  }  DurationField  lastRangeField  =  types[i  -  1].getRangeDurationType().getField(iChronology);  DurationField  loopRangeField  =  loopType.getRangeDurationType().getField(iChronology);  if  (lastRangeField.compareTo(loopRangeField)  <  0)  {  [CLASS]  Partial  Property  [METHOD]  <init>  [RETURN_TYPE]  Chronology)  DateTimeFieldType[]  types  int[]  values  Chronology  chronology  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  types  Partial  iPartial  DateTimeFieldType  loopType  int[]  iValues  values  Chronology  chrono  chronology  iChronology  DurationField  lastRangeField  lastUnitField  loopRangeField  loopUnitField  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  compare  i  iFieldIndex  value  	projects/Time2/src/main/java/org/joda/time/Partial.java	1.0	224	225	1	add	DurationField  lastRangeField  =  loopType.getRangeDurationType().getField(iChronology);	  if(types[i    -    1].getRangeDurationType().getField(iChronology)!=    null)    {    throw    new    IllegalArgumentException(       "       ");    }    if(compare    <    0)    {    throw    new    IllegalArgumentException(   "   ");    }    	compilable	  [FE]  NullPointerException  testWith_baseAndArgHaveNoRange	483	1	replace
212	[BUG]  [BUGGY]  DurationField  lastRangeField  =  loopType.getRangeDurationType().getField(iChronology);  [FE]  NullPointerException  testWith_baseAndArgHaveNoRange  [CONTEXT]        DateTimeFieldType  loopType  =  types[i];  DurationField  loopUnitField  =  loopType.getDurationType().getField(iChronology);  if  (i  >  0)  {  int  compare  =  lastUnitField.compareTo(loopUnitField);  if  (compare  <  0  ||  (compare  !=  0  &&  loopUnitField.isSupported()  ==  false))  {  throw  new  IllegalArgumentException(       "Types  array  must  be  in  order  largest-smallest:         "  +  types[i  -  1].getName()  +         "  <         "  +  loopType.getName());  }  else  if  (compare  ==  0)  {  if  (types[i  -  1].getRangeDurationType()  ==  null)  {  if  (loopType.getRangeDurationType()  ==  null)  {        [BUGGY]  DurationField  lastRangeField  =  loopType.getRangeDurationType().getField(iChronology);  [BUGGY]        throw  new  IllegalArgumentException(       "Types  array  must  not  contain  duplicate:         "  +            types[i  -  1].getName()  +         "  and         "  +  loopType.getName());  types[i  -  1].getName()  +         "  and         "  +  loopType.getName());  }  }  else  {  if  (loopType.getRangeDurationType()  ==  null)  {  throw  new  IllegalArgumentException(       "Types  array  must  be  in  order  largest-smallest:         "  +  types[i  -  1].getName()  +         "  <         "  +  loopType.getName());  }  DurationField  lastRangeField  =  types[i  -  1].getRangeDurationType().getField(iChronology);  DurationField  loopRangeField  =  loopType.getRangeDurationType().getField(iChronology);  if  (lastRangeField.compareTo(loopRangeField)  <  0)  {  [CLASS]  Partial  Property  [METHOD]  <init>  [RETURN_TYPE]  Chronology)  DateTimeFieldType[]  types  int[]  values  Chronology  chronology  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  types  Partial  iPartial  DateTimeFieldType  loopType  int[]  iValues  values  Chronology  chrono  chronology  iChronology  DurationField  lastRangeField  lastUnitField  loopRangeField  loopUnitField  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  compare  i  iFieldIndex  value  	projects/Time2/src/main/java/org/joda/time/Partial.java	1.0	224	225	1	replace	DurationField  lastRangeField  =  loopType.getRangeDurationType().getField(iChronology);	  if(types[i    -    1].getRangeDurationType().getField(iChronology)!=    null)    {    throw    new    IllegalArgumentException(       "       ");    }    if(compare    <    0)    {    throw    new    IllegalArgumentException(   "   ");    }    	compilable	  [FE]  NullPointerException  testWith_baseAndArgHaveNoRange	483	1	replace
