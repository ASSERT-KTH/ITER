bugid	buggy	buggy_class	suspiciousness	buggy_line	endbuggycode	original_failing_test_number	action	patch	original_buggy	execution_result	diagnosis	previous_bug_id	new_failing_test_number	this_action1	[BUG]  [BUGGY]  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange  [CONTEXT]  DateTimeFieldType  loopType  =  types[i];  DurationField  loopUnitField  =  loopType.getDurationType().getField(iChronology);  if  (i  >  0)  {  int  compare  =  lastUnitField.compareTo(loopUnitField);  if  (compare  <  0  ||  (compare  !=  0  &&  loopUnitField.isSupported()  ==  false))  {  throw  new  IllegalArgumentException( "Types  array  must  be  in  order  largest-smallest:   "  +  types[i  -  1].getName()  +   "  <   "  +  loopType.getName());  }  else  if  (compare  ==  0)  {  if  (types[i  -  1].getRangeDurationType()  ==  null)  {  if  (loopType.getRangeDurationType()  ==  null)  {  [BUGGY]  throw  new  IllegalArgumentException( "Types  array  must  not  contain  duplicate: "  +  types[i  -  1].getName()  + "  &   "  +  loopType.getName());  [BUGGY]  types[i  -  1].getName()  +   "  and   "  +  loopType.getName());  }  }  else  {  if  (loopType.getRangeDurationType()  ==  null)  {  throw  new  IllegalArgumentException( "Types  array  must  be  in  order  largest-smallest:   "  +  types[i  -  1].getName()  +   "  <   "  +  loopType.getName());  }  DurationField  lastRangeField  =  types[i  -  1].getRangeDurationType().getField(iChronology);  DurationField  loopRangeField  =  loopType.getRangeDurationType().getField(iChronology);  if  (lastRangeField.compareTo(loopRangeField)  <  0)  {  [CLASS]  Partial  Property  [METHOD]  <init>  [RETURN_TYPE]  Chronology)  DateTimeFieldType[]  types  int[]  values  Chronology  chronology  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  types  Partial  iPartial  DateTimeFieldType  loopType  int[]  iValues  values  Chronology  chrono  chronology  iChronology  DurationField  lastRangeField  lastUnitField  loopRangeField  loopUnitField  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  compare  i  iFieldIndex  value  	projects/Time2/src/main/java/org/joda/time/Partial.java	1.0	224	225	1	add	throw  new  IllegalArgumentException( "Types  array  must  not  contain  duplicate: "  +  types[i  -  1].getName()  + "  &   "  +  loopType.getName());	throw  new  IllegalArgumentException( "Types  array  must  not  contain  duplicate:   "  +      types[i  -  1].getName()  +   "  and   "  +  loopType.getName());  	compilable	  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange	1	1	replace
2	[BUG]  [BUGGY]  throw  new  IllegalArgumentException( "Types  array  must  not  contain  duplicate: "  +  types[i  -  1].getName()  + "  &   "  +  loopType.getName());  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange  [CONTEXT]  DateTimeFieldType  loopType  =  types[i];  DurationField  loopUnitField  =  loopType.getDurationType().getField(iChronology);  if  (i  >  0)  {  int  compare  =  lastUnitField.compareTo(loopUnitField);  if  (compare  <  0  ||  (compare  !=  0  &&  loopUnitField.isSupported()  ==  false))  {  throw  new  IllegalArgumentException( "Types  array  must  be  in  order  largest-smallest:   "  +  types[i  -  1].getName()  +   "  <   "  +  loopType.getName());  }  else  if  (compare  ==  0)  {  if  (types[i  -  1].getRangeDurationType()  ==  null)  {  if  (loopType.getRangeDurationType()  ==  null)  {  [BUGGY]  throw  new  IllegalArgumentException( "Types  array  must  not  contain  duplicate: "  +  types[i  -  1].getName()  + "  &   "  +  loopType.getName());  [BUGGY]  types[i  -  1].getName()  +   "  and   "  +  loopType.getName());  }  }  else  {  if  (loopType.getRangeDurationType()  ==  null)  {  throw  new  IllegalArgumentException( "Types  array  must  be  in  order  largest-smallest:   "  +  types[i  -  1].getName()  +   "  <   "  +  loopType.getName());  }  DurationField  lastRangeField  =  types[i  -  1].getRangeDurationType().getField(iChronology);  DurationField  loopRangeField  =  loopType.getRangeDurationType().getField(iChronology);  if  (lastRangeField.compareTo(loopRangeField)  <  0)  {  [CLASS]  Partial  Property  [METHOD]  <init>  [RETURN_TYPE]  Chronology)  DateTimeFieldType[]  types  int[]  values  Chronology  chronology  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  types  Partial  iPartial  DateTimeFieldType  loopType  int[]  iValues  values  Chronology  chrono  chronology  iChronology  DurationField  lastRangeField  lastUnitField  loopRangeField  loopUnitField  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  compare  i  iFieldIndex  value  	projects/Time2/src/main/java/org/joda/time/Partial.java	1.0	224	225	1	replace	throw  new  IllegalArgumentException( "Types  array  must  not  contain  duplicate: "  +  types[i  -  1].getName()  + "  &   "  +  loopType.getName());	throw  new  IllegalArgumentException( "Types  array  must  not  contain  duplicate:   "  +      types[i  -  1].getName()  +   "  and   "  +  loopType.getName());  	compilable	  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange	1	1	replace
4	[BUG]  [BUGGY]  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange  [CONTEXT]  DateTimeFieldType  loopType  =  types[i];  DurationField  loopUnitField  =  loopType.getDurationType().getField(iChronology);  if  (i  >  0)  {  int  compare  =  lastUnitField.compareTo(loopUnitField);  if  (compare  <  0  ||  (compare  !=  0  &&  loopUnitField.isSupported()  ==  false))  {  throw  new  IllegalArgumentException( "Types  array  must  be  in  order  largest-smallest:   "  +  types[i  -  1].getName()  +   "  <   "  +  loopType.getName());  }  else  if  (compare  ==  0)  {  if  (types[i  -  1].getRangeDurationType()  ==  null)  {  if  (loopType.getRangeDurationType()  ==  null)  {  [BUGGY]  throw  new  IllegalArgumentException( "Types  array  must  not  contain  duplicate: "  +  types[i  -  1].getName()  + "  consulted   "  +  loopType.getName());  [BUGGY]  types[i  -  1].getName()  +   "  and   "  +  loopType.getName());  }  }  else  {  if  (loopType.getRangeDurationType()  ==  null)  {  throw  new  IllegalArgumentException( "Types  array  must  be  in  order  largest-smallest:   "  +  types[i  -  1].getName()  +   "  <   "  +  loopType.getName());  }  DurationField  lastRangeField  =  types[i  -  1].getRangeDurationType().getField(iChronology);  DurationField  loopRangeField  =  loopType.getRangeDurationType().getField(iChronology);  if  (lastRangeField.compareTo(loopRangeField)  <  0)  {  [CLASS]  Partial  Property  [METHOD]  <init>  [RETURN_TYPE]  Chronology)  DateTimeFieldType[]  types  int[]  values  Chronology  chronology  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  types  Partial  iPartial  DateTimeFieldType  loopType  int[]  iValues  values  Chronology  chrono  chronology  iChronology  DurationField  lastRangeField  lastUnitField  loopRangeField  loopUnitField  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  compare  i  iFieldIndex  value  	projects/Time2/src/main/java/org/joda/time/Partial.java	1.0	224	225	1	add	throw  new  IllegalArgumentException( "Types  array  must  not  contain  duplicate: "  +  types[i  -  1].getName()  + "  consulted   "  +  loopType.getName());	throw  new  IllegalArgumentException( "Types  array  must  not  contain  duplicate:   "  +      types[i  -  1].getName()  +   "  and   "  +  loopType.getName());  	compilable	  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange	1	1	replace
5	[BUG]  [BUGGY]  throw  new  IllegalArgumentException( "Types  array  must  not  contain  duplicate: "  +  types[i  -  1].getName()  + "  consulted   "  +  loopType.getName());  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange  [CONTEXT]  DateTimeFieldType  loopType  =  types[i];  DurationField  loopUnitField  =  loopType.getDurationType().getField(iChronology);  if  (i  >  0)  {  int  compare  =  lastUnitField.compareTo(loopUnitField);  if  (compare  <  0  ||  (compare  !=  0  &&  loopUnitField.isSupported()  ==  false))  {  throw  new  IllegalArgumentException( "Types  array  must  be  in  order  largest-smallest:   "  +  types[i  -  1].getName()  +   "  <   "  +  loopType.getName());  }  else  if  (compare  ==  0)  {  if  (types[i  -  1].getRangeDurationType()  ==  null)  {  if  (loopType.getRangeDurationType()  ==  null)  {  [BUGGY]  throw  new  IllegalArgumentException( "Types  array  must  not  contain  duplicate: "  +  types[i  -  1].getName()  + "  consulted   "  +  loopType.getName());  [BUGGY]  types[i  -  1].getName()  +   "  and   "  +  loopType.getName());  }  }  else  {  if  (loopType.getRangeDurationType()  ==  null)  {  throw  new  IllegalArgumentException( "Types  array  must  be  in  order  largest-smallest:   "  +  types[i  -  1].getName()  +   "  <   "  +  loopType.getName());  }  DurationField  lastRangeField  =  types[i  -  1].getRangeDurationType().getField(iChronology);  DurationField  loopRangeField  =  loopType.getRangeDurationType().getField(iChronology);  if  (lastRangeField.compareTo(loopRangeField)  <  0)  {  [CLASS]  Partial  Property  [METHOD]  <init>  [RETURN_TYPE]  Chronology)  DateTimeFieldType[]  types  int[]  values  Chronology  chronology  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  types  Partial  iPartial  DateTimeFieldType  loopType  int[]  iValues  values  Chronology  chrono  chronology  iChronology  DurationField  lastRangeField  lastUnitField  loopRangeField  loopUnitField  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  compare  i  iFieldIndex  value  	projects/Time2/src/main/java/org/joda/time/Partial.java	1.0	224	225	1	replace	throw  new  IllegalArgumentException( "Types  array  must  not  contain  duplicate: "  +  types[i  -  1].getName()  + "  consulted   "  +  loopType.getName());	throw  new  IllegalArgumentException( "Types  array  must  not  contain  duplicate:   "  +      types[i  -  1].getName()  +   "  and   "  +  loopType.getName());  	compilable	  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange	1	1	replace
61	[BUG]  [BUGGY]  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange  [CONTEXT]  public  Partial(DateTimeFieldType  type,  int  value,  Chronology  chronology)  {  super();  chronology  =  DateTimeUtils.getChronology(chronology).withUTC();  [BUGGY]    chronology  =  DateTimeUtils.getChronology(chronology);  [BUGGY]  iChronology  =  chronology;  if  (type  ==  null)  {  throw  new  IllegalArgumentException( "The  field  type  must  not  be  null ");  }  iTypes  =  new  DateTimeFieldType[]  {type};  iValues  =  new  int[]  {value};  chronology.validate(this,  iValues);  }  [CLASS]  Partial  Property  [METHOD]  <init>  [RETURN_TYPE]  Chronology)  DateTimeFieldType  type  int  value  Chronology  chronology  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  Partial  iPartial  DateTimeFieldType  type  int[]  iValues  Chronology  chrono  chronology  iChronology  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  iFieldIndex  value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.2886751345948129	155	155	1	add	    chronology  =  DateTimeUtils.getChronology(chronology);		compilable	  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange	18	1	add
62	[BUG]  [BUGGY]    chronology  =  DateTimeUtils.getChronology(chronology);  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange  [CONTEXT]  public  Partial(DateTimeFieldType  type,  int  value,  Chronology  chronology)  {  super();  chronology  =  DateTimeUtils.getChronology(chronology).withUTC();  [BUGGY]    chronology  =  DateTimeUtils.getChronology(chronology);  [BUGGY]  iChronology  =  chronology;  if  (type  ==  null)  {  throw  new  IllegalArgumentException( "The  field  type  must  not  be  null ");  }  iTypes  =  new  DateTimeFieldType[]  {type};  iValues  =  new  int[]  {value};  chronology.validate(this,  iValues);  }  [CLASS]  Partial  Property  [METHOD]  <init>  [RETURN_TYPE]  Chronology)  DateTimeFieldType  type  int  value  Chronology  chronology  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  Partial  iPartial  DateTimeFieldType  type  int[]  iValues  Chronology  chrono  chronology  iChronology  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  iFieldIndex  value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.2886751345948129	155	155	1	replace	    chronology  =  DateTimeUtils.getChronology(chronology);		compilable	  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange	18	1	add
62	[BUG]  [BUGGY]  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange  [CONTEXT]  public  Partial(DateTimeFieldType  type,  int  value,  Chronology  chronology)  {  super();  chronology  =  DateTimeUtils.getChronology(chronology).withUTC();  [BUGGY]    chronology  =  DateTimeUtils.getChronology(chronology).withUTC();  [BUGGY]  iChronology  =  chronology;  if  (type  ==  null)  {  throw  new  IllegalArgumentException( "The  field  type  must  not  be  null ");  }  iTypes  =  new  DateTimeFieldType[]  {type};  iValues  =  new  int[]  {value};  chronology.validate(this,  iValues);  }  [CLASS]  Partial  Property  [METHOD]  <init>  [RETURN_TYPE]  Chronology)  DateTimeFieldType  type  int  value  Chronology  chronology  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  Partial  iPartial  DateTimeFieldType  type  int[]  iValues  Chronology  chrono  chronology  iChronology  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  iFieldIndex  value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.2886751345948129	155	155	1	add	    chronology  =  DateTimeUtils.getChronology(chronology).withUTC();		compilable	  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange	18	1	add
63	[BUG]  [BUGGY]    chronology  =  DateTimeUtils.getChronology(chronology).withUTC();  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange  [CONTEXT]  public  Partial(DateTimeFieldType  type,  int  value,  Chronology  chronology)  {  super();  chronology  =  DateTimeUtils.getChronology(chronology).withUTC();  [BUGGY]    chronology  =  DateTimeUtils.getChronology(chronology).withUTC();  [BUGGY]  iChronology  =  chronology;  if  (type  ==  null)  {  throw  new  IllegalArgumentException( "The  field  type  must  not  be  null ");  }  iTypes  =  new  DateTimeFieldType[]  {type};  iValues  =  new  int[]  {value};  chronology.validate(this,  iValues);  }  [CLASS]  Partial  Property  [METHOD]  <init>  [RETURN_TYPE]  Chronology)  DateTimeFieldType  type  int  value  Chronology  chronology  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  Partial  iPartial  DateTimeFieldType  type  int[]  iValues  Chronology  chrono  chronology  iChronology  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  iFieldIndex  value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.2886751345948129	155	155	1	replace	    chronology  =  DateTimeUtils.getChronology(chronology).withUTC();		compilable	  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange	18	1	add
92	[BUG]  [BUGGY]  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange  [CONTEXT]  public  Partial(DateTimeFieldType  type,  int  value,  Chronology  chronology)  {  super();  [BUGGY]    chronology  =  DateTimeUtils.getChronology(chronology);  [BUGGY]  chronology  =  DateTimeUtils.getChronology(chronology).withUTC();  iChronology  =  chronology;  if  (type  ==  null)  {  throw  new  IllegalArgumentException( "The  field  type  must  not  be  null ");  }  iTypes  =  new  DateTimeFieldType[]  {type};  iValues  =  new  int[]  {value};  chronology.validate(this,  iValues);  }  [CLASS]  Partial  Property  [METHOD]  <init>  [RETURN_TYPE]  Chronology)  DateTimeFieldType  type  int  value  Chronology  chronology  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  Partial  iPartial  DateTimeFieldType  type  int[]  iValues  Chronology  chrono  chronology  iChronology  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  iFieldIndex  value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.2886751345948129	154	154	1	add	    chronology  =  DateTimeUtils.getChronology(chronology);		compilable	  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange	16	1	add
93	[BUG]  [BUGGY]    chronology  =  DateTimeUtils.getChronology(chronology);  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange  [CONTEXT]  public  Partial(DateTimeFieldType  type,  int  value,  Chronology  chronology)  {  super();  [BUGGY]    chronology  =  DateTimeUtils.getChronology(chronology);  [BUGGY]  chronology  =  DateTimeUtils.getChronology(chronology).withUTC();  iChronology  =  chronology;  if  (type  ==  null)  {  throw  new  IllegalArgumentException( "The  field  type  must  not  be  null ");  }  iTypes  =  new  DateTimeFieldType[]  {type};  iValues  =  new  int[]  {value};  chronology.validate(this,  iValues);  }  [CLASS]  Partial  Property  [METHOD]  <init>  [RETURN_TYPE]  Chronology)  DateTimeFieldType  type  int  value  Chronology  chronology  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  Partial  iPartial  DateTimeFieldType  type  int[]  iValues  Chronology  chrono  chronology  iChronology  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  iFieldIndex  value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.2886751345948129	154	154	1	replace	    chronology  =  DateTimeUtils.getChronology(chronology);		compilable	  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange	16	1	add
131	[BUG]  [BUGGY]  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange  [CONTEXT]  public  Partial(DateTimeFieldType  type,  int  value,  Chronology  chronology)  {  super();  chronology  =  DateTimeUtils.getChronology(chronology).withUTC();  [BUGGY]  iChronology  =  chronology.withUTC();  [BUGGY]  if  (type  ==  null)  {  throw  new  IllegalArgumentException( "The  field  type  must  not  be  null ");  }  iTypes  =  new  DateTimeFieldType[]  {type};  iValues  =  new  int[]  {value};  chronology.validate(this,  iValues);  }  [CLASS]  Partial  Property  [METHOD]  <init>  [RETURN_TYPE]  Chronology)  DateTimeFieldType  type  int  value  Chronology  chronology  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  Partial  iPartial  DateTimeFieldType  type  int[]  iValues  Chronology  chrono  chronology  iChronology  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  iFieldIndex  value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.2886751345948129	155	155	1	add	iChronology  =  chronology.withUTC();	iChronology  =  chronology;  	compilable	  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange	17	1	replace
132	[BUG]  [BUGGY]  iChronology  =  chronology.withUTC();  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange  [CONTEXT]  public  Partial(DateTimeFieldType  type,  int  value,  Chronology  chronology)  {  super();  chronology  =  DateTimeUtils.getChronology(chronology).withUTC();  [BUGGY]  iChronology  =  chronology.withUTC();  [BUGGY]  if  (type  ==  null)  {  throw  new  IllegalArgumentException( "The  field  type  must  not  be  null ");  }  iTypes  =  new  DateTimeFieldType[]  {type};  iValues  =  new  int[]  {value};  chronology.validate(this,  iValues);  }  [CLASS]  Partial  Property  [METHOD]  <init>  [RETURN_TYPE]  Chronology)  DateTimeFieldType  type  int  value  Chronology  chronology  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  Partial  iPartial  DateTimeFieldType  type  int[]  iValues  Chronology  chrono  chronology  iChronology  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  iFieldIndex  value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.2886751345948129	155	155	1	replace	iChronology  =  chronology.withUTC();	iChronology  =  chronology;  	compilable	  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange	17	1	replace
133	[BUG]  [BUGGY]  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange  [CONTEXT]  public  Partial(DateTimeFieldType  type,  int  value,  Chronology  chronology)  {  super();  chronology  =  DateTimeUtils.getChronology(chronology).withUTC();  [BUGGY]  iChronology  =  DateTimeUtils.getChronology(chronology);  [BUGGY]  if  (type  ==  null)  {  throw  new  IllegalArgumentException( "The  field  type  must  not  be  null ");  }  iTypes  =  new  DateTimeFieldType[]  {type};  iValues  =  new  int[]  {value};  chronology.validate(this,  iValues);  }  [CLASS]  Partial  Property  [METHOD]  <init>  [RETURN_TYPE]  Chronology)  DateTimeFieldType  type  int  value  Chronology  chronology  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  Partial  iPartial  DateTimeFieldType  type  int[]  iValues  Chronology  chrono  chronology  iChronology  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  iFieldIndex  value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.2886751345948129	155	155	1	add	iChronology  =  DateTimeUtils.getChronology(chronology);	iChronology  =  chronology;  	compilable	  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange	17	1	replace
134	[BUG]  [BUGGY]  iChronology  =  DateTimeUtils.getChronology(chronology);  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange  [CONTEXT]  public  Partial(DateTimeFieldType  type,  int  value,  Chronology  chronology)  {  super();  chronology  =  DateTimeUtils.getChronology(chronology).withUTC();  [BUGGY]  iChronology  =  DateTimeUtils.getChronology(chronology);  [BUGGY]  if  (type  ==  null)  {  throw  new  IllegalArgumentException( "The  field  type  must  not  be  null ");  }  iTypes  =  new  DateTimeFieldType[]  {type};  iValues  =  new  int[]  {value};  chronology.validate(this,  iValues);  }  [CLASS]  Partial  Property  [METHOD]  <init>  [RETURN_TYPE]  Chronology)  DateTimeFieldType  type  int  value  Chronology  chronology  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  Partial  iPartial  DateTimeFieldType  type  int[]  iValues  Chronology  chrono  chronology  iChronology  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  iFieldIndex  value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.2886751345948129	155	155	1	replace	iChronology  =  DateTimeUtils.getChronology(chronology);	iChronology  =  chronology;  	compilable	  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange	17	1	replace
171	[BUG]  [BUGGY]  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange  [CONTEXT]  public  Partial(DateTimeFieldType  type,  int  value,  Chronology  chronology)  {  super();  chronology  =  DateTimeUtils.getChronology(chronology).withUTC();  iChronology  =  chronology;  [BUGGY]  if(type  ==  null  ||  value  <  0)  {  [BUGGY]  throw  new  IllegalArgumentException( "The  field  type  must  not  be  null ");  }  iTypes  =  new  DateTimeFieldType[]  {type};  iValues  =  new  int[]  {value};  chronology.validate(this,  iValues);  }  [CLASS]  Partial  Property  [METHOD]  <init>  [RETURN_TYPE]  Chronology)  DateTimeFieldType  type  int  value  Chronology  chronology  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  Partial  iPartial  DateTimeFieldType  type  int[]  iValues  Chronology  chrono  chronology  iChronology  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  iFieldIndex  value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.2886751345948129	156	156	1	add	if(type  ==  null  ||  value  <  0)  {	if  (type  ==  null)  {  	compilable	  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange	19	1	replace
172	[BUG]  [BUGGY]  if(type  ==  null  ||  value  <  0)  {  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange  [CONTEXT]  public  Partial(DateTimeFieldType  type,  int  value,  Chronology  chronology)  {  super();  chronology  =  DateTimeUtils.getChronology(chronology).withUTC();  iChronology  =  chronology;  [BUGGY]  if(type  ==  null  ||  value  <  0)  {  [BUGGY]  throw  new  IllegalArgumentException( "The  field  type  must  not  be  null ");  }  iTypes  =  new  DateTimeFieldType[]  {type};  iValues  =  new  int[]  {value};  chronology.validate(this,  iValues);  }  [CLASS]  Partial  Property  [METHOD]  <init>  [RETURN_TYPE]  Chronology)  DateTimeFieldType  type  int  value  Chronology  chronology  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  Partial  iPartial  DateTimeFieldType  type  int[]  iValues  Chronology  chrono  chronology  iChronology  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  iFieldIndex  value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.2886751345948129	156	156	1	replace	if(type  ==  null  ||  value  <  0)  {	if  (type  ==  null)  {  	compilable	  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange	19	1	replace
181	[BUG]  [BUGGY]  [FE]  NullPointerException  testWith_baseAndArgHaveNoRange  [CONTEXT]  DateTimeFieldType  loopType  =  types[i];  DurationField  loopUnitField  =  loopType.getDurationType().getField(iChronology);  if  (i  >  0)  {  int  compare  =  lastUnitField.compareTo(loopUnitField);  if  (compare  <  0  ||  (compare  !=  0  &&  loopUnitField.isSupported()  ==  false))  {  throw  new  IllegalArgumentException( "Types  array  must  be  in  order  largest-smallest:   "  +  types[i  -  1].getName()  +   "  <   "  +  loopType.getName());  }  else  if  (compare  ==  0)  {  if  (types[i  -  1].getRangeDurationType()  ==  null)  {  if  (loopType.getRangeDurationType()  ==  null)  {  [BUGGY]    if(loopType.getRangeDurationType().getField(iChronology)  ==  null)  {  throw  new  IllegalArgumentException( " ");  }  [BUGGY]  throw  new  IllegalArgumentException( "Types  array  must  not  contain  duplicate:   "  +            types[i  -  1].getName()  +   "  and   "  +  loopType.getName());  types[i  -  1].getName()  +   "  and   "  +  loopType.getName());  }  }  else  {  if  (loopType.getRangeDurationType()  ==  null)  {  throw  new  IllegalArgumentException( "Types  array  must  be  in  order  largest-smallest:   "  +  types[i  -  1].getName()  +   "  <   "  +  loopType.getName());  }  DurationField  lastRangeField  =  types[i  -  1].getRangeDurationType().getField(iChronology);  DurationField  loopRangeField  =  loopType.getRangeDurationType().getField(iChronology);  if  (lastRangeField.compareTo(loopRangeField)  <  0)  {  [CLASS]  Partial  Property  [METHOD]  <init>  [RETURN_TYPE]  Chronology)  DateTimeFieldType[]  types  int[]  values  Chronology  chronology  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  types  Partial  iPartial  DateTimeFieldType  loopType  int[]  iValues  values  Chronology  chrono  chronology  iChronology  DurationField  lastRangeField  lastUnitField  loopRangeField  loopUnitField  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  compare  i  iFieldIndex  value  	projects/Time2/src/main/java/org/joda/time/Partial.java	1.0	224	225	1	add	    if(loopType.getRangeDurationType().getField(iChronology)  ==  null)  {  throw  new  IllegalArgumentException( " ");  }		compilable	  [FE]  NullPointerException  testWith_baseAndArgHaveNoRange	2	1	add
182	[BUG]  [BUGGY]    if(loopType.getRangeDurationType().getField(iChronology)  ==  null)  {  throw  new  IllegalArgumentException( " ");  }  [FE]  NullPointerException  testWith_baseAndArgHaveNoRange  [CONTEXT]  DateTimeFieldType  loopType  =  types[i];  DurationField  loopUnitField  =  loopType.getDurationType().getField(iChronology);  if  (i  >  0)  {  int  compare  =  lastUnitField.compareTo(loopUnitField);  if  (compare  <  0  ||  (compare  !=  0  &&  loopUnitField.isSupported()  ==  false))  {  throw  new  IllegalArgumentException( "Types  array  must  be  in  order  largest-smallest:   "  +  types[i  -  1].getName()  +   "  <   "  +  loopType.getName());  }  else  if  (compare  ==  0)  {  if  (types[i  -  1].getRangeDurationType()  ==  null)  {  if  (loopType.getRangeDurationType()  ==  null)  {  [BUGGY]    if(loopType.getRangeDurationType().getField(iChronology)  ==  null)  {  throw  new  IllegalArgumentException( " ");  }  [BUGGY]  throw  new  IllegalArgumentException( "Types  array  must  not  contain  duplicate:   "  +            types[i  -  1].getName()  +   "  and   "  +  loopType.getName());  types[i  -  1].getName()  +   "  and   "  +  loopType.getName());  }  }  else  {  if  (loopType.getRangeDurationType()  ==  null)  {  throw  new  IllegalArgumentException( "Types  array  must  be  in  order  largest-smallest:   "  +  types[i  -  1].getName()  +   "  <   "  +  loopType.getName());  }  DurationField  lastRangeField  =  types[i  -  1].getRangeDurationType().getField(iChronology);  DurationField  loopRangeField  =  loopType.getRangeDurationType().getField(iChronology);  if  (lastRangeField.compareTo(loopRangeField)  <  0)  {  [CLASS]  Partial  Property  [METHOD]  <init>  [RETURN_TYPE]  Chronology)  DateTimeFieldType[]  types  int[]  values  Chronology  chronology  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  types  Partial  iPartial  DateTimeFieldType  loopType  int[]  iValues  values  Chronology  chrono  chronology  iChronology  DurationField  lastRangeField  lastUnitField  loopRangeField  loopUnitField  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  compare  i  iFieldIndex  value  	projects/Time2/src/main/java/org/joda/time/Partial.java	1.0	224	225	1	replace	    if(loopType.getRangeDurationType().getField(iChronology)  ==  null)  {  throw  new  IllegalArgumentException( " ");  }		compilable	  [FE]  NullPointerException  testWith_baseAndArgHaveNoRange	2	1	add
182	[BUG]  [BUGGY]  [FE]  NullPointerException  testWith_baseAndArgHaveNoRange  [CONTEXT]  DateTimeFieldType  loopType  =  types[i];  DurationField  loopUnitField  =  loopType.getDurationType().getField(iChronology);  if  (i  >  0)  {  int  compare  =  lastUnitField.compareTo(loopUnitField);  if  (compare  <  0  ||  (compare  !=  0  &&  loopUnitField.isSupported()  ==  false))  {  throw  new  IllegalArgumentException( "Types  array  must  be  in  order  largest-smallest:   "  +  types[i  -  1].getName()  +   "  <   "  +  loopType.getName());  }  else  if  (compare  ==  0)  {  if  (types[i  -  1].getRangeDurationType()  ==  null)  {  if  (loopType.getRangeDurationType()  ==  null)  {  [BUGGY]    if(loopType.getRangeDurationType().getField(iChronology)!=  null)  {  throw  new  IllegalArgumentException( " ");  }  [BUGGY]  throw  new  IllegalArgumentException( "Types  array  must  not  contain  duplicate:   "  +            types[i  -  1].getName()  +   "  and   "  +  loopType.getName());  types[i  -  1].getName()  +   "  and   "  +  loopType.getName());  }  }  else  {  if  (loopType.getRangeDurationType()  ==  null)  {  throw  new  IllegalArgumentException( "Types  array  must  be  in  order  largest-smallest:   "  +  types[i  -  1].getName()  +   "  <   "  +  loopType.getName());  }  DurationField  lastRangeField  =  types[i  -  1].getRangeDurationType().getField(iChronology);  DurationField  loopRangeField  =  loopType.getRangeDurationType().getField(iChronology);  if  (lastRangeField.compareTo(loopRangeField)  <  0)  {  [CLASS]  Partial  Property  [METHOD]  <init>  [RETURN_TYPE]  Chronology)  DateTimeFieldType[]  types  int[]  values  Chronology  chronology  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  types  Partial  iPartial  DateTimeFieldType  loopType  int[]  iValues  values  Chronology  chrono  chronology  iChronology  DurationField  lastRangeField  lastUnitField  loopRangeField  loopUnitField  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  compare  i  iFieldIndex  value  	projects/Time2/src/main/java/org/joda/time/Partial.java	1.0	224	225	1	add	    if(loopType.getRangeDurationType().getField(iChronology)!=  null)  {  throw  new  IllegalArgumentException( " ");  }		compilable	  [FE]  NullPointerException  testWith_baseAndArgHaveNoRange	2	1	add
183	[BUG]  [BUGGY]    if(loopType.getRangeDurationType().getField(iChronology)!=  null)  {  throw  new  IllegalArgumentException( " ");  }  [FE]  NullPointerException  testWith_baseAndArgHaveNoRange  [CONTEXT]  DateTimeFieldType  loopType  =  types[i];  DurationField  loopUnitField  =  loopType.getDurationType().getField(iChronology);  if  (i  >  0)  {  int  compare  =  lastUnitField.compareTo(loopUnitField);  if  (compare  <  0  ||  (compare  !=  0  &&  loopUnitField.isSupported()  ==  false))  {  throw  new  IllegalArgumentException( "Types  array  must  be  in  order  largest-smallest:   "  +  types[i  -  1].getName()  +   "  <   "  +  loopType.getName());  }  else  if  (compare  ==  0)  {  if  (types[i  -  1].getRangeDurationType()  ==  null)  {  if  (loopType.getRangeDurationType()  ==  null)  {  [BUGGY]    if(loopType.getRangeDurationType().getField(iChronology)!=  null)  {  throw  new  IllegalArgumentException( " ");  }  [BUGGY]  throw  new  IllegalArgumentException( "Types  array  must  not  contain  duplicate:   "  +            types[i  -  1].getName()  +   "  and   "  +  loopType.getName());  types[i  -  1].getName()  +   "  and   "  +  loopType.getName());  }  }  else  {  if  (loopType.getRangeDurationType()  ==  null)  {  throw  new  IllegalArgumentException( "Types  array  must  be  in  order  largest-smallest:   "  +  types[i  -  1].getName()  +   "  <   "  +  loopType.getName());  }  DurationField  lastRangeField  =  types[i  -  1].getRangeDurationType().getField(iChronology);  DurationField  loopRangeField  =  loopType.getRangeDurationType().getField(iChronology);  if  (lastRangeField.compareTo(loopRangeField)  <  0)  {  [CLASS]  Partial  Property  [METHOD]  <init>  [RETURN_TYPE]  Chronology)  DateTimeFieldType[]  types  int[]  values  Chronology  chronology  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  types  Partial  iPartial  DateTimeFieldType  loopType  int[]  iValues  values  Chronology  chrono  chronology  iChronology  DurationField  lastRangeField  lastUnitField  loopRangeField  loopUnitField  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  compare  i  iFieldIndex  value  	projects/Time2/src/main/java/org/joda/time/Partial.java	1.0	224	225	1	replace	    if(loopType.getRangeDurationType().getField(iChronology)!=  null)  {  throw  new  IllegalArgumentException( " ");  }		compilable	  [FE]  NullPointerException  testWith_baseAndArgHaveNoRange	2	1	add
193	[BUG]  [BUGGY]  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange  [CONTEXT]  for  (int  i  =  0;  i  <  types.length;  i++)  {  DateTimeFieldType  loopType  =  types[i];  DurationField  loopUnitField  =  loopType.getDurationType().getField(iChronology);  if  (i  >  0)  {  int  compare  =  lastUnitField.compareTo(loopUnitField);  if  (compare  <  0  ||  (compare  !=  0  &&  loopUnitField.isSupported()  ==  false))  {  throw  new  IllegalArgumentException( "Types  array  must  be  in  order  largest-smallest:   "  +  types[i  -  1].getName()  +   "  <   "  +  loopType.getName());  }  else  if  (compare  ==  0)  {  if  (types[i  -  1].getRangeDurationType()  ==  null)  {  [BUGGY]  if(loopType.getRangeDurationType()  ==  null  ||(compare  ==  0  &&  loopUnitField.isSupported()  ==  false))  {  [BUGGY]  throw  new  IllegalArgumentException( "Types  array  must  not  contain  duplicate:   "  +  types[i  -  1].getName()  +   "  and   "  +  loopType.getName());  }  }  else  {  if  (loopType.getRangeDurationType()  ==  null)  {  throw  new  IllegalArgumentException( "Types  array  must  be  in  order  largest-smallest:   "  +  types[i  -  1].getName()  +   "  <   "  +  loopType.getName());  }  DurationField  lastRangeField  =  types[i  -  1].getRangeDurationType().getField(iChronology);  DurationField  loopRangeField  =  loopType.getRangeDurationType().getField(iChronology);  [CLASS]  Partial  Property  [METHOD]  <init>  [RETURN_TYPE]  Chronology)  DateTimeFieldType[]  types  int[]  values  Chronology  chronology  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  types  Partial  iPartial  DateTimeFieldType  loopType  int[]  iValues  values  Chronology  chrono  chronology  iChronology  DurationField  lastRangeField  lastUnitField  loopRangeField  loopUnitField  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  compare  i  iFieldIndex  value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.4472135954999579	223	223	1	add	if(loopType.getRangeDurationType()  ==  null  ||(compare  ==  0  &&  loopUnitField.isSupported()  ==  false))  {	if  (loopType.getRangeDurationType()  ==  null)  {  	compilable	  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange	5	1	replace
194	[BUG]  [BUGGY]  if(loopType.getRangeDurationType()  ==  null  ||(compare  ==  0  &&  loopUnitField.isSupported()  ==  false))  {  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange  [CONTEXT]  for  (int  i  =  0;  i  <  types.length;  i++)  {  DateTimeFieldType  loopType  =  types[i];  DurationField  loopUnitField  =  loopType.getDurationType().getField(iChronology);  if  (i  >  0)  {  int  compare  =  lastUnitField.compareTo(loopUnitField);  if  (compare  <  0  ||  (compare  !=  0  &&  loopUnitField.isSupported()  ==  false))  {  throw  new  IllegalArgumentException( "Types  array  must  be  in  order  largest-smallest:   "  +  types[i  -  1].getName()  +   "  <   "  +  loopType.getName());  }  else  if  (compare  ==  0)  {  if  (types[i  -  1].getRangeDurationType()  ==  null)  {  [BUGGY]  if(loopType.getRangeDurationType()  ==  null  ||(compare  ==  0  &&  loopUnitField.isSupported()  ==  false))  {  [BUGGY]  throw  new  IllegalArgumentException( "Types  array  must  not  contain  duplicate:   "  +  types[i  -  1].getName()  +   "  and   "  +  loopType.getName());  }  }  else  {  if  (loopType.getRangeDurationType()  ==  null)  {  throw  new  IllegalArgumentException( "Types  array  must  be  in  order  largest-smallest:   "  +  types[i  -  1].getName()  +   "  <   "  +  loopType.getName());  }  DurationField  lastRangeField  =  types[i  -  1].getRangeDurationType().getField(iChronology);  DurationField  loopRangeField  =  loopType.getRangeDurationType().getField(iChronology);  [CLASS]  Partial  Property  [METHOD]  <init>  [RETURN_TYPE]  Chronology)  DateTimeFieldType[]  types  int[]  values  Chronology  chronology  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  types  Partial  iPartial  DateTimeFieldType  loopType  int[]  iValues  values  Chronology  chrono  chronology  iChronology  DurationField  lastRangeField  lastUnitField  loopRangeField  loopUnitField  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  compare  i  iFieldIndex  value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.4472135954999579	223	223	1	replace	if(loopType.getRangeDurationType()  ==  null  ||(compare  ==  0  &&  loopUnitField.isSupported()  ==  false))  {	if  (loopType.getRangeDurationType()  ==  null)  {  	compilable	  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange	5	1	replace
194	[BUG]  [BUGGY]  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange  [CONTEXT]  for  (int  i  =  0;  i  <  types.length;  i++)  {  DateTimeFieldType  loopType  =  types[i];  DurationField  loopUnitField  =  loopType.getDurationType().getField(iChronology);  if  (i  >  0)  {  int  compare  =  lastUnitField.compareTo(loopUnitField);  if  (compare  <  0  ||  (compare  !=  0  &&  loopUnitField.isSupported()  ==  false))  {  throw  new  IllegalArgumentException( "Types  array  must  be  in  order  largest-smallest:   "  +  types[i  -  1].getName()  +   "  <   "  +  loopType.getName());  }  else  if  (compare  ==  0)  {  if  (types[i  -  1].getRangeDurationType()  ==  null)  {  [BUGGY]  if(loopType.getRangeDurationType()  ==  null  ||(compare!=  0  &&  loopUnitField.isSupported()  ==  false))  {  [BUGGY]  throw  new  IllegalArgumentException( "Types  array  must  not  contain  duplicate:   "  +  types[i  -  1].getName()  +   "  and   "  +  loopType.getName());  }  }  else  {  if  (loopType.getRangeDurationType()  ==  null)  {  throw  new  IllegalArgumentException( "Types  array  must  be  in  order  largest-smallest:   "  +  types[i  -  1].getName()  +   "  <   "  +  loopType.getName());  }  DurationField  lastRangeField  =  types[i  -  1].getRangeDurationType().getField(iChronology);  DurationField  loopRangeField  =  loopType.getRangeDurationType().getField(iChronology);  [CLASS]  Partial  Property  [METHOD]  <init>  [RETURN_TYPE]  Chronology)  DateTimeFieldType[]  types  int[]  values  Chronology  chronology  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  types  Partial  iPartial  DateTimeFieldType  loopType  int[]  iValues  values  Chronology  chrono  chronology  iChronology  DurationField  lastRangeField  lastUnitField  loopRangeField  loopUnitField  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  compare  i  iFieldIndex  value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.4472135954999579	223	223	1	add	if(loopType.getRangeDurationType()  ==  null  ||(compare!=  0  &&  loopUnitField.isSupported()  ==  false))  {	if  (loopType.getRangeDurationType()  ==  null)  {  	compilable	  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange	5	1	replace
195	[BUG]  [BUGGY]  if(loopType.getRangeDurationType()  ==  null  ||(compare!=  0  &&  loopUnitField.isSupported()  ==  false))  {  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange  [CONTEXT]  for  (int  i  =  0;  i  <  types.length;  i++)  {  DateTimeFieldType  loopType  =  types[i];  DurationField  loopUnitField  =  loopType.getDurationType().getField(iChronology);  if  (i  >  0)  {  int  compare  =  lastUnitField.compareTo(loopUnitField);  if  (compare  <  0  ||  (compare  !=  0  &&  loopUnitField.isSupported()  ==  false))  {  throw  new  IllegalArgumentException( "Types  array  must  be  in  order  largest-smallest:   "  +  types[i  -  1].getName()  +   "  <   "  +  loopType.getName());  }  else  if  (compare  ==  0)  {  if  (types[i  -  1].getRangeDurationType()  ==  null)  {  [BUGGY]  if(loopType.getRangeDurationType()  ==  null  ||(compare!=  0  &&  loopUnitField.isSupported()  ==  false))  {  [BUGGY]  throw  new  IllegalArgumentException( "Types  array  must  not  contain  duplicate:   "  +  types[i  -  1].getName()  +   "  and   "  +  loopType.getName());  }  }  else  {  if  (loopType.getRangeDurationType()  ==  null)  {  throw  new  IllegalArgumentException( "Types  array  must  be  in  order  largest-smallest:   "  +  types[i  -  1].getName()  +   "  <   "  +  loopType.getName());  }  DurationField  lastRangeField  =  types[i  -  1].getRangeDurationType().getField(iChronology);  DurationField  loopRangeField  =  loopType.getRangeDurationType().getField(iChronology);  [CLASS]  Partial  Property  [METHOD]  <init>  [RETURN_TYPE]  Chronology)  DateTimeFieldType[]  types  int[]  values  Chronology  chronology  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  types  Partial  iPartial  DateTimeFieldType  loopType  int[]  iValues  values  Chronology  chrono  chronology  iChronology  DurationField  lastRangeField  lastUnitField  loopRangeField  loopUnitField  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  compare  i  iFieldIndex  value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.4472135954999579	223	223	1	replace	if(loopType.getRangeDurationType()  ==  null  ||(compare!=  0  &&  loopUnitField.isSupported()  ==  false))  {	if  (loopType.getRangeDurationType()  ==  null)  {  	compilable	  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange	5	1	replace
163	[BUG]  [BUGGY]  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange  [CONTEXT]  public  Partial(DateTimeFieldType  type,  int  value,  Chronology  chronology)  {  super();  chronology  =  DateTimeUtils.getChronology(chronology).withUTC();  [BUGGY]  iChronology  =(chronology  ==  null)?  chronology  :  DateTimeUtils.getChronology(chronology).withUTC();  [BUGGY]  if  (type  ==  null)  {  throw  new  IllegalArgumentException( "The  field  type  must  not  be  null ");  }  iTypes  =  new  DateTimeFieldType[]  {type};  iValues  =  new  int[]  {value};  chronology.validate(this,  iValues);  }  [CLASS]  Partial  Property  [METHOD]  <init>  [RETURN_TYPE]  Chronology)  DateTimeFieldType  type  int  value  Chronology  chronology  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  Partial  iPartial  DateTimeFieldType  type  int[]  iValues  Chronology  chrono  chronology  iChronology  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  iFieldIndex  value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.2886751345948129	155	155	1	add	iChronology  =(chronology  ==  null)?  chronology  :  DateTimeUtils.getChronology(chronology).withUTC();	iChronology  =  chronology;  	compilable	  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange	17	1	replace
164	[BUG]  [BUGGY]  iChronology  =(chronology  ==  null)?  chronology  :  DateTimeUtils.getChronology(chronology).withUTC();  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange  [CONTEXT]  public  Partial(DateTimeFieldType  type,  int  value,  Chronology  chronology)  {  super();  chronology  =  DateTimeUtils.getChronology(chronology).withUTC();  [BUGGY]  iChronology  =(chronology  ==  null)?  chronology  :  DateTimeUtils.getChronology(chronology).withUTC();  [BUGGY]  if  (type  ==  null)  {  throw  new  IllegalArgumentException( "The  field  type  must  not  be  null ");  }  iTypes  =  new  DateTimeFieldType[]  {type};  iValues  =  new  int[]  {value};  chronology.validate(this,  iValues);  }  [CLASS]  Partial  Property  [METHOD]  <init>  [RETURN_TYPE]  Chronology)  DateTimeFieldType  type  int  value  Chronology  chronology  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  Partial  iPartial  DateTimeFieldType  type  int[]  iValues  Chronology  chrono  chronology  iChronology  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  iFieldIndex  value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.2886751345948129	155	155	1	replace	iChronology  =(chronology  ==  null)?  chronology  :  DateTimeUtils.getChronology(chronology).withUTC();	iChronology  =  chronology;  	compilable	  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange	17	1	replace
164	[BUG]  [BUGGY]  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange  [CONTEXT]  public  Partial(DateTimeFieldType  type,  int  value,  Chronology  chronology)  {  super();  chronology  =  DateTimeUtils.getChronology(chronology).withUTC();  [BUGGY]  iChronology  =(chronology  ==  null)?  chronology  :  DateTimeUtils.getChronology(chronology);  [BUGGY]  if  (type  ==  null)  {  throw  new  IllegalArgumentException( "The  field  type  must  not  be  null ");  }  iTypes  =  new  DateTimeFieldType[]  {type};  iValues  =  new  int[]  {value};  chronology.validate(this,  iValues);  }  [CLASS]  Partial  Property  [METHOD]  <init>  [RETURN_TYPE]  Chronology)  DateTimeFieldType  type  int  value  Chronology  chronology  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  Partial  iPartial  DateTimeFieldType  type  int[]  iValues  Chronology  chrono  chronology  iChronology  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  iFieldIndex  value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.2886751345948129	155	155	1	add	iChronology  =(chronology  ==  null)?  chronology  :  DateTimeUtils.getChronology(chronology);	iChronology  =  chronology;  	compilable	  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange	17	1	replace
165	[BUG]  [BUGGY]  iChronology  =(chronology  ==  null)?  chronology  :  DateTimeUtils.getChronology(chronology);  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange  [CONTEXT]  public  Partial(DateTimeFieldType  type,  int  value,  Chronology  chronology)  {  super();  chronology  =  DateTimeUtils.getChronology(chronology).withUTC();  [BUGGY]  iChronology  =(chronology  ==  null)?  chronology  :  DateTimeUtils.getChronology(chronology);  [BUGGY]  if  (type  ==  null)  {  throw  new  IllegalArgumentException( "The  field  type  must  not  be  null ");  }  iTypes  =  new  DateTimeFieldType[]  {type};  iValues  =  new  int[]  {value};  chronology.validate(this,  iValues);  }  [CLASS]  Partial  Property  [METHOD]  <init>  [RETURN_TYPE]  Chronology)  DateTimeFieldType  type  int  value  Chronology  chronology  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  Partial  iPartial  DateTimeFieldType  type  int[]  iValues  Chronology  chrono  chronology  iChronology  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  iFieldIndex  value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.2886751345948129	155	155	1	replace	iChronology  =(chronology  ==  null)?  chronology  :  DateTimeUtils.getChronology(chronology);	iChronology  =  chronology;  	compilable	  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange	17	1	replace
281	[BUG]  [BUGGY]  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange  [CONTEXT]  public  Partial(DateTimeFieldType  type,  int  value,  Chronology  chronology)  {  super();  chronology  =  DateTimeUtils.getChronology(chronology).withUTC();  iChronology  =  chronology;  [BUGGY]    type  =  chronology.withUTC();  [BUGGY]  if  (type  ==  null)  {  throw  new  IllegalArgumentException( "The  field  type  must  not  be  null ");  }  iTypes  =  new  DateTimeFieldType[]  {type};  iValues  =  new  int[]  {value};  chronology.validate(this,  iValues);  }  [CLASS]  Partial  Property  [METHOD]  <init>  [RETURN_TYPE]  Chronology)  DateTimeFieldType  type  int  value  Chronology  chronology  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  Partial  iPartial  DateTimeFieldType  type  int[]  iValues  Chronology  chrono  chronology  iChronology  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  iFieldIndex  value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.2886751345948129	156	156	1	add	    type  =  chronology.withUTC();		compilable	  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange	20	1	add
282	[BUG]  [BUGGY]    type  =  chronology.withUTC();  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange  [CONTEXT]  public  Partial(DateTimeFieldType  type,  int  value,  Chronology  chronology)  {  super();  chronology  =  DateTimeUtils.getChronology(chronology).withUTC();  iChronology  =  chronology;  [BUGGY]    type  =  chronology.withUTC();  [BUGGY]  if  (type  ==  null)  {  throw  new  IllegalArgumentException( "The  field  type  must  not  be  null ");  }  iTypes  =  new  DateTimeFieldType[]  {type};  iValues  =  new  int[]  {value};  chronology.validate(this,  iValues);  }  [CLASS]  Partial  Property  [METHOD]  <init>  [RETURN_TYPE]  Chronology)  DateTimeFieldType  type  int  value  Chronology  chronology  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  Partial  iPartial  DateTimeFieldType  type  int[]  iValues  Chronology  chrono  chronology  iChronology  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  iFieldIndex  value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.2886751345948129	156	156	1	replace	    type  =  chronology.withUTC();		compilable	  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange	20	1	add
323	[BUG]  [BUGGY]  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange  [CONTEXT]  for  (int  i  =  0;  i  <  types.length;  i++)  {  DateTimeFieldType  loopType  =  types[i];  DurationField  loopUnitField  =  loopType.getDurationType().getField(iChronology);  if  (i  >  0)  {  int  compare  =  lastUnitField.compareTo(loopUnitField);  if  (compare  <  0  ||  (compare  !=  0  &&  loopUnitField.isSupported()  ==  false))  {  throw  new  IllegalArgumentException( "Types  array  must  be  in  order  largest-smallest:   "  +  types[i  -  1].getName()  +   "  <   "  +  loopType.getName());  }  else  if  (compare  ==  0)  {  if  (types[i  -  1].getRangeDurationType()  ==  null)  {  [BUGGY]  if(loopType.getDurationType()  ==  null)  {  [BUGGY]  throw  new  IllegalArgumentException( "Types  array  must  not  contain  duplicate:   "  +  types[i  -  1].getName()  +   "  and   "  +  loopType.getName());  }  }  else  {  if  (loopType.getRangeDurationType()  ==  null)  {  throw  new  IllegalArgumentException( "Types  array  must  be  in  order  largest-smallest:   "  +  types[i  -  1].getName()  +   "  <   "  +  loopType.getName());  }  DurationField  lastRangeField  =  types[i  -  1].getRangeDurationType().getField(iChronology);  DurationField  loopRangeField  =  loopType.getRangeDurationType().getField(iChronology);  [CLASS]  Partial  Property  [METHOD]  <init>  [RETURN_TYPE]  Chronology)  DateTimeFieldType[]  types  int[]  values  Chronology  chronology  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  types  Partial  iPartial  DateTimeFieldType  loopType  int[]  iValues  values  Chronology  chrono  chronology  iChronology  DurationField  lastRangeField  lastUnitField  loopRangeField  loopUnitField  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  compare  i  iFieldIndex  value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.4472135954999579	223	223	1	add	if(loopType.getDurationType()  ==  null)  {	if  (loopType.getRangeDurationType()  ==  null)  {  	compilable	  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange	5	1	replace
324	[BUG]  [BUGGY]  if(loopType.getDurationType()  ==  null)  {  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange  [CONTEXT]  for  (int  i  =  0;  i  <  types.length;  i++)  {  DateTimeFieldType  loopType  =  types[i];  DurationField  loopUnitField  =  loopType.getDurationType().getField(iChronology);  if  (i  >  0)  {  int  compare  =  lastUnitField.compareTo(loopUnitField);  if  (compare  <  0  ||  (compare  !=  0  &&  loopUnitField.isSupported()  ==  false))  {  throw  new  IllegalArgumentException( "Types  array  must  be  in  order  largest-smallest:   "  +  types[i  -  1].getName()  +   "  <   "  +  loopType.getName());  }  else  if  (compare  ==  0)  {  if  (types[i  -  1].getRangeDurationType()  ==  null)  {  [BUGGY]  if(loopType.getDurationType()  ==  null)  {  [BUGGY]  throw  new  IllegalArgumentException( "Types  array  must  not  contain  duplicate:   "  +  types[i  -  1].getName()  +   "  and   "  +  loopType.getName());  }  }  else  {  if  (loopType.getRangeDurationType()  ==  null)  {  throw  new  IllegalArgumentException( "Types  array  must  be  in  order  largest-smallest:   "  +  types[i  -  1].getName()  +   "  <   "  +  loopType.getName());  }  DurationField  lastRangeField  =  types[i  -  1].getRangeDurationType().getField(iChronology);  DurationField  loopRangeField  =  loopType.getRangeDurationType().getField(iChronology);  [CLASS]  Partial  Property  [METHOD]  <init>  [RETURN_TYPE]  Chronology)  DateTimeFieldType[]  types  int[]  values  Chronology  chronology  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  types  Partial  iPartial  DateTimeFieldType  loopType  int[]  iValues  values  Chronology  chrono  chronology  iChronology  DurationField  lastRangeField  lastUnitField  loopRangeField  loopUnitField  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  compare  i  iFieldIndex  value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.4472135954999579	223	223	1	replace	if(loopType.getDurationType()  ==  null)  {	if  (loopType.getRangeDurationType()  ==  null)  {  	compilable	  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange	5	1	replace
181	[BUG]  [BUGGY]  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange  [CONTEXT]  public  Partial(DateTimeFieldType  type,  int  value,  Chronology  chronology)  {  super();  chronology  =  DateTimeUtils.getChronology(chronology).withUTC();  iChronology  =  chronology;  [BUGGY]    chronology  =  DateTimeUtils.getChronology(chronology).withUTC();  [BUGGY]  if  (type  ==  null)  {  throw  new  IllegalArgumentException( "The  field  type  must  not  be  null ");  }  iTypes  =  new  DateTimeFieldType[]  {type};  iValues  =  new  int[]  {value};  chronology.validate(this,  iValues);  }  [CLASS]  Partial  Property  [METHOD]  <init>  [RETURN_TYPE]  Chronology)  DateTimeFieldType  type  int  value  Chronology  chronology  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  Partial  iPartial  DateTimeFieldType  type  int[]  iValues  Chronology  chrono  chronology  iChronology  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  iFieldIndex  value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.2886751345948129	156	156	1	add	    chronology  =  DateTimeUtils.getChronology(chronology).withUTC();		compilable	  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange	20	1	add
182	[BUG]  [BUGGY]    chronology  =  DateTimeUtils.getChronology(chronology).withUTC();  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange  [CONTEXT]  public  Partial(DateTimeFieldType  type,  int  value,  Chronology  chronology)  {  super();  chronology  =  DateTimeUtils.getChronology(chronology).withUTC();  iChronology  =  chronology;  [BUGGY]    chronology  =  DateTimeUtils.getChronology(chronology).withUTC();  [BUGGY]  if  (type  ==  null)  {  throw  new  IllegalArgumentException( "The  field  type  must  not  be  null ");  }  iTypes  =  new  DateTimeFieldType[]  {type};  iValues  =  new  int[]  {value};  chronology.validate(this,  iValues);  }  [CLASS]  Partial  Property  [METHOD]  <init>  [RETURN_TYPE]  Chronology)  DateTimeFieldType  type  int  value  Chronology  chronology  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  Partial  iPartial  DateTimeFieldType  type  int[]  iValues  Chronology  chrono  chronology  iChronology  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  iFieldIndex  value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.2886751345948129	156	156	1	replace	    chronology  =  DateTimeUtils.getChronology(chronology).withUTC();		compilable	  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange	20	1	add
272	[BUG]  [BUGGY]  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange  [CONTEXT]  for  (int  i  =  0;  i  <  types.length;  i++)  {  DateTimeFieldType  loopType  =  types[i];  DurationField  loopUnitField  =  loopType.getDurationType().getField(iChronology);  if  (i  >  0)  {  int  compare  =  lastUnitField.compareTo(loopUnitField);  if  (compare  <  0  ||  (compare  !=  0  &&  loopUnitField.isSupported()  ==  false))  {  throw  new  IllegalArgumentException( "Types  array  must  be  in  order  largest-smallest:   "  +  types[i  -  1].getName()  +   "  <   "  +  loopType.getName());  }  else  if  (compare  ==  0)  {  if  (types[i  -  1].getRangeDurationType()  ==  null)  {  [BUGGY]  if(loopType.getRangeDurationType()  ==  null  ||  loopType.getRangeDurationType()  ==  null)  {  [BUGGY]  throw  new  IllegalArgumentException( "Types  array  must  not  contain  duplicate:   "  +  types[i  -  1].getName()  +   "  and   "  +  loopType.getName());  }  }  else  {  if  (loopType.getRangeDurationType()  ==  null)  {  throw  new  IllegalArgumentException( "Types  array  must  be  in  order  largest-smallest:   "  +  types[i  -  1].getName()  +   "  <   "  +  loopType.getName());  }  DurationField  lastRangeField  =  types[i  -  1].getRangeDurationType().getField(iChronology);  DurationField  loopRangeField  =  loopType.getRangeDurationType().getField(iChronology);  [CLASS]  Partial  Property  [METHOD]  <init>  [RETURN_TYPE]  Chronology)  DateTimeFieldType[]  types  int[]  values  Chronology  chronology  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  types  Partial  iPartial  DateTimeFieldType  loopType  int[]  iValues  values  Chronology  chrono  chronology  iChronology  DurationField  lastRangeField  lastUnitField  loopRangeField  loopUnitField  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  compare  i  iFieldIndex  value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.4472135954999579	223	223	1	add	if(loopType.getRangeDurationType()  ==  null  ||  loopType.getRangeDurationType()  ==  null)  {	if  (loopType.getRangeDurationType()  ==  null)  {  	compilable	  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange	5	1	replace
273	[BUG]  [BUGGY]  if(loopType.getRangeDurationType()  ==  null  ||  loopType.getRangeDurationType()  ==  null)  {  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange  [CONTEXT]  for  (int  i  =  0;  i  <  types.length;  i++)  {  DateTimeFieldType  loopType  =  types[i];  DurationField  loopUnitField  =  loopType.getDurationType().getField(iChronology);  if  (i  >  0)  {  int  compare  =  lastUnitField.compareTo(loopUnitField);  if  (compare  <  0  ||  (compare  !=  0  &&  loopUnitField.isSupported()  ==  false))  {  throw  new  IllegalArgumentException( "Types  array  must  be  in  order  largest-smallest:   "  +  types[i  -  1].getName()  +   "  <   "  +  loopType.getName());  }  else  if  (compare  ==  0)  {  if  (types[i  -  1].getRangeDurationType()  ==  null)  {  [BUGGY]  if(loopType.getRangeDurationType()  ==  null  ||  loopType.getRangeDurationType()  ==  null)  {  [BUGGY]  throw  new  IllegalArgumentException( "Types  array  must  not  contain  duplicate:   "  +  types[i  -  1].getName()  +   "  and   "  +  loopType.getName());  }  }  else  {  if  (loopType.getRangeDurationType()  ==  null)  {  throw  new  IllegalArgumentException( "Types  array  must  be  in  order  largest-smallest:   "  +  types[i  -  1].getName()  +   "  <   "  +  loopType.getName());  }  DurationField  lastRangeField  =  types[i  -  1].getRangeDurationType().getField(iChronology);  DurationField  loopRangeField  =  loopType.getRangeDurationType().getField(iChronology);  [CLASS]  Partial  Property  [METHOD]  <init>  [RETURN_TYPE]  Chronology)  DateTimeFieldType[]  types  int[]  values  Chronology  chronology  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  types  Partial  iPartial  DateTimeFieldType  loopType  int[]  iValues  values  Chronology  chrono  chronology  iChronology  DurationField  lastRangeField  lastUnitField  loopRangeField  loopUnitField  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  compare  i  iFieldIndex  value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.4472135954999579	223	223	1	replace	if(loopType.getRangeDurationType()  ==  null  ||  loopType.getRangeDurationType()  ==  null)  {	if  (loopType.getRangeDurationType()  ==  null)  {  	compilable	  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange	5	1	replace
361	[BUG]  [BUGGY]  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange  [CONTEXT]  public  Partial(DateTimeFieldType  type,  int  value,  Chronology  chronology)  {  [BUGGY]    this(type,  value,  chronology.withUTC());  [BUGGY]  super();  chronology  =  DateTimeUtils.getChronology(chronology).withUTC();  iChronology  =  chronology;  if  (type  ==  null)  {  throw  new  IllegalArgumentException( "The  field  type  must  not  be  null ");  }  iTypes  =  new  DateTimeFieldType[]  {type};  iValues  =  new  int[]  {value};  chronology.validate(this,  iValues);  }  [CLASS]  Partial  Property  [METHOD]  <init>  [RETURN_TYPE]  Chronology)  DateTimeFieldType  type  int  value  Chronology  chronology  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  Partial  iPartial  DateTimeFieldType  type  int[]  iValues  Chronology  chrono  chronology  iChronology  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  iFieldIndex  value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.2886751345948129	153	153	1	add	    this(type,  value,  chronology.withUTC());		compilable	  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange	14	1	add
362	[BUG]  [BUGGY]    this(type,  value,  chronology.withUTC());  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange  [CONTEXT]  public  Partial(DateTimeFieldType  type,  int  value,  Chronology  chronology)  {  [BUGGY]    this(type,  value,  chronology.withUTC());  [BUGGY]  super();  chronology  =  DateTimeUtils.getChronology(chronology).withUTC();  iChronology  =  chronology;  if  (type  ==  null)  {  throw  new  IllegalArgumentException( "The  field  type  must  not  be  null ");  }  iTypes  =  new  DateTimeFieldType[]  {type};  iValues  =  new  int[]  {value};  chronology.validate(this,  iValues);  }  [CLASS]  Partial  Property  [METHOD]  <init>  [RETURN_TYPE]  Chronology)  DateTimeFieldType  type  int  value  Chronology  chronology  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  Partial  iPartial  DateTimeFieldType  type  int[]  iValues  Chronology  chrono  chronology  iChronology  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  iFieldIndex  value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.2886751345948129	153	153	1	replace	    this(type,  value,  chronology.withUTC());		compilable	  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange	14	1	add
