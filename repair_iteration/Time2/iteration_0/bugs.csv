bugid	buggy	buggy_class	suspiciousness	buggy_line	endbuggycode	failing_test_number	action	patch
1	[BUG] [BUGGY] throw new IllegalArgumentException("Types array must not contain duplicate: " +   types[i - 1].getName() + " and " + loopType.getName()); [FE] IllegalArgumentException testWith_baseAndArgHaveNoRange [CONTEXT] DateTimeFieldType loopType = types[i]; DurationField loopUnitField = loopType.getDurationType().getField(iChronology); if (i > 0) { int compare = lastUnitField.compareTo(loopUnitField); if (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false)) { throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); } else if (compare == 0) { if (types[i - 1].getRangeDurationType() == null) { if (loopType.getRangeDurationType() == null) { [BUGGY] throw new IllegalArgumentException("Types array must not contain duplicate: " +           types[i - 1].getName() + " and " + loopType.getName()); [BUGGY] types[i - 1].getName() + " and " + loopType.getName()); } } else { if (loopType.getRangeDurationType() == null) { throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); } DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology); DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology); if (lastRangeField.compareTo(loopRangeField) < 0) { [CLASS] Partial Property [METHOD] <init> [RETURN_TYPE] Chronology)  DateTimeFieldType[] types int[] values Chronology chronology [VARIABLES] boolean DateTimeFieldType[] iTypes types Partial iPartial DateTimeFieldType loopType int[] iValues values Chronology chrono chronology iChronology DurationField lastRangeField lastUnitField loopRangeField loopUnitField long serialVersionUID DateTimeFormatter[] iFormatter int compare i iFieldIndex value  	projects/Time2/src/main/java/org/joda/time/Partial.java	1.0	224	225	1	replace	
2	[BUG] [BUGGY] [FE] IllegalArgumentException testWith_baseAndArgHaveNoRange [CONTEXT] DateTimeFieldType loopType = types[i]; DurationField loopUnitField = loopType.getDurationType().getField(iChronology); if (i > 0) { int compare = lastUnitField.compareTo(loopUnitField); if (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false)) { throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); } else if (compare == 0) { if (types[i - 1].getRangeDurationType() == null) { if (loopType.getRangeDurationType() == null) { [BUGGY] [BUGGY] throw new IllegalArgumentException("Types array must not contain duplicate: " +           types[i - 1].getName() + " and " + loopType.getName()); types[i - 1].getName() + " and " + loopType.getName()); } } else { if (loopType.getRangeDurationType() == null) { throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); } DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology); DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology); if (lastRangeField.compareTo(loopRangeField) < 0) { [CLASS] Partial Property [METHOD] <init> [RETURN_TYPE] Chronology)  DateTimeFieldType[] types int[] values Chronology chronology [VARIABLES] boolean DateTimeFieldType[] iTypes types Partial iPartial DateTimeFieldType loopType int[] iValues values Chronology chrono chronology iChronology DurationField lastRangeField lastUnitField loopRangeField loopUnitField long serialVersionUID DateTimeFormatter[] iFormatter int compare i iFieldIndex value  	projects/Time2/src/main/java/org/joda/time/Partial.java	1.0	224	225	1	add	
3	[BUG] [BUGGY] return 0; [FE] IllegalArgumentException testWith_baseAndArgHaveNoRange [CONTEXT] public int compareTo(DurationField durationField) { [BUGGY] return 0; [BUGGY] } [CLASS] UnsupportedDurationField [METHOD] compareTo [RETURN_TYPE] int  DurationField durationField [VARIABLES] boolean HashMap cCache DurationField durationField long duration instant minuendInstant serialVersionUID subtrahendInstant value DurationFieldType iType type  	projects/Time2/src/main/java/org/joda/time/field/UnsupportedDurationField.java	0.4472135954999579	227	227	1	replace	
4	[BUG] [BUGGY] [FE] IllegalArgumentException testWith_baseAndArgHaveNoRange [CONTEXT] public int compareTo(DurationField durationField) { [BUGGY] [BUGGY] return 0; } [CLASS] UnsupportedDurationField [METHOD] compareTo [RETURN_TYPE] int  DurationField durationField [VARIABLES] boolean HashMap cCache DurationField durationField long duration instant minuendInstant serialVersionUID subtrahendInstant value DurationFieldType iType type  	projects/Time2/src/main/java/org/joda/time/field/UnsupportedDurationField.java	0.4472135954999579	227	227	1	add	
5	[BUG] [BUGGY] if (loopType.getRangeDurationType() == null) { [FE] IllegalArgumentException testWith_baseAndArgHaveNoRange [CONTEXT] for (int i = 0; i < types.length; i++) { DateTimeFieldType loopType = types[i]; DurationField loopUnitField = loopType.getDurationType().getField(iChronology); if (i > 0) { int compare = lastUnitField.compareTo(loopUnitField); if (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false)) { throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); } else if (compare == 0) { if (types[i - 1].getRangeDurationType() == null) { [BUGGY] if (loopType.getRangeDurationType() == null) { [BUGGY] throw new IllegalArgumentException("Types array must not contain duplicate: " + types[i - 1].getName() + " and " + loopType.getName()); } } else { if (loopType.getRangeDurationType() == null) { throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); } DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology); DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology); [CLASS] Partial Property [METHOD] <init> [RETURN_TYPE] Chronology)  DateTimeFieldType[] types int[] values Chronology chronology [VARIABLES] boolean DateTimeFieldType[] iTypes types Partial iPartial DateTimeFieldType loopType int[] iValues values Chronology chrono chronology iChronology DurationField lastRangeField lastUnitField loopRangeField loopUnitField long serialVersionUID DateTimeFormatter[] iFormatter int compare i iFieldIndex value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.4472135954999579	223	223	1	replace	
6	[BUG] [BUGGY] [FE] IllegalArgumentException testWith_baseAndArgHaveNoRange [CONTEXT] for (int i = 0; i < types.length; i++) { DateTimeFieldType loopType = types[i]; DurationField loopUnitField = loopType.getDurationType().getField(iChronology); if (i > 0) { int compare = lastUnitField.compareTo(loopUnitField); if (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false)) { throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); } else if (compare == 0) { if (types[i - 1].getRangeDurationType() == null) { [BUGGY] [BUGGY] if (loopType.getRangeDurationType() == null) { throw new IllegalArgumentException("Types array must not contain duplicate: " + types[i - 1].getName() + " and " + loopType.getName()); } } else { if (loopType.getRangeDurationType() == null) { throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); } DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology); DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology); [CLASS] Partial Property [METHOD] <init> [RETURN_TYPE] Chronology)  DateTimeFieldType[] types int[] values Chronology chronology [VARIABLES] boolean DateTimeFieldType[] iTypes types Partial iPartial DateTimeFieldType loopType int[] iValues values Chronology chrono chronology iChronology DurationField lastRangeField lastUnitField loopRangeField loopUnitField long serialVersionUID DateTimeFormatter[] iFormatter int compare i iFieldIndex value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.4472135954999579	223	223	1	add	
7	[BUG] [BUGGY] if (types[i - 1].getRangeDurationType() == null) { [FE] IllegalArgumentException testWith_baseAndArgHaveNoRange [CONTEXT] DurationField lastUnitField = null; for (int i = 0; i < types.length; i++) { DateTimeFieldType loopType = types[i]; DurationField loopUnitField = loopType.getDurationType().getField(iChronology); if (i > 0) { int compare = lastUnitField.compareTo(loopUnitField); if (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false)) { throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); } else if (compare == 0) { [BUGGY] if (types[i - 1].getRangeDurationType() == null) { [BUGGY] if (loopType.getRangeDurationType() == null) { throw new IllegalArgumentException("Types array must not contain duplicate: " + types[i - 1].getName() + " and " + loopType.getName()); } } else { if (loopType.getRangeDurationType() == null) { throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); } DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology); [CLASS] Partial Property [METHOD] <init> [RETURN_TYPE] Chronology)  DateTimeFieldType[] types int[] values Chronology chronology [VARIABLES] boolean DateTimeFieldType[] iTypes types Partial iPartial DateTimeFieldType loopType int[] iValues values Chronology chrono chronology iChronology DurationField lastRangeField lastUnitField loopRangeField loopUnitField long serialVersionUID DateTimeFormatter[] iFormatter int compare i iFieldIndex value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.3333333333333333	222	222	1	replace	
8	[BUG] [BUGGY] [FE] IllegalArgumentException testWith_baseAndArgHaveNoRange [CONTEXT] DurationField lastUnitField = null; for (int i = 0; i < types.length; i++) { DateTimeFieldType loopType = types[i]; DurationField loopUnitField = loopType.getDurationType().getField(iChronology); if (i > 0) { int compare = lastUnitField.compareTo(loopUnitField); if (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false)) { throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); } else if (compare == 0) { [BUGGY] [BUGGY] if (types[i - 1].getRangeDurationType() == null) { if (loopType.getRangeDurationType() == null) { throw new IllegalArgumentException("Types array must not contain duplicate: " + types[i - 1].getName() + " and " + loopType.getName()); } } else { if (loopType.getRangeDurationType() == null) { throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); } DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology); [CLASS] Partial Property [METHOD] <init> [RETURN_TYPE] Chronology)  DateTimeFieldType[] types int[] values Chronology chronology [VARIABLES] boolean DateTimeFieldType[] iTypes types Partial iPartial DateTimeFieldType loopType int[] iValues values Chronology chrono chronology iChronology DurationField lastRangeField lastUnitField loopRangeField loopUnitField long serialVersionUID DateTimeFormatter[] iFormatter int compare i iFieldIndex value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.3333333333333333	222	222	1	add	
9	[BUG] [BUGGY] this(type, value, null); [FE] IllegalArgumentException testWith_baseAndArgHaveNoRange [CONTEXT] public Partial(DateTimeFieldType type, int value) { [BUGGY] this(type, value, null); [BUGGY] } [CLASS] Partial Property [METHOD] <init> [RETURN_TYPE] DateTimeFieldType,int)  DateTimeFieldType type int value [VARIABLES] boolean DateTimeFieldType[] iTypes Partial iPartial DateTimeFieldType type int[] iValues Chronology chrono iChronology long serialVersionUID DateTimeFormatter[] iFormatter int iFieldIndex value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.2886751345948129	139	139	1	replace	
10	[BUG] [BUGGY] [FE] IllegalArgumentException testWith_baseAndArgHaveNoRange [CONTEXT] public Partial(DateTimeFieldType type, int value) { [BUGGY] [BUGGY] this(type, value, null); } [CLASS] Partial Property [METHOD] <init> [RETURN_TYPE] DateTimeFieldType,int)  DateTimeFieldType type int value [VARIABLES] boolean DateTimeFieldType[] iTypes Partial iPartial DateTimeFieldType type int[] iValues Chronology chrono iChronology long serialVersionUID DateTimeFormatter[] iFormatter int iFieldIndex value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.2886751345948129	139	139	1	add	
11	[BUG] [BUGGY] } [FE] IllegalArgumentException testWith_baseAndArgHaveNoRange [CONTEXT] public Partial(DateTimeFieldType type, int value) { this(type, value, null); [BUGGY] } [BUGGY]  [CLASS] Partial Property [METHOD] <init> [RETURN_TYPE] DateTimeFieldType,int)  DateTimeFieldType type int value [VARIABLES] boolean DateTimeFieldType[] iTypes Partial iPartial DateTimeFieldType type int[] iValues Chronology chrono iChronology long serialVersionUID DateTimeFormatter[] iFormatter int iFieldIndex value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.2886751345948129	140	140	1	replace	
12	[BUG] [BUGGY] [FE] IllegalArgumentException testWith_baseAndArgHaveNoRange [CONTEXT] public Partial(DateTimeFieldType type, int value) { this(type, value, null); [BUGGY] [BUGGY] } [CLASS] Partial Property [METHOD] <init> [RETURN_TYPE] DateTimeFieldType,int)  DateTimeFieldType type int value [VARIABLES] boolean DateTimeFieldType[] iTypes Partial iPartial DateTimeFieldType type int[] iValues Chronology chrono iChronology long serialVersionUID DateTimeFormatter[] iFormatter int iFieldIndex value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.2886751345948129	140	140	1	add	
13	[BUG] [BUGGY] super(); [FE] IllegalArgumentException testWith_baseAndArgHaveNoRange [CONTEXT] public Partial(DateTimeFieldType type, int value, Chronology chronology) { [BUGGY] super(); [BUGGY] chronology = DateTimeUtils.getChronology(chronology).withUTC(); iChronology = chronology; if (type == null) { throw new IllegalArgumentException("The field type must not be null"); } iTypes = new DateTimeFieldType[] {type}; iValues = new int[] {value}; chronology.validate(this, iValues); } [CLASS] Partial Property [METHOD] <init> [RETURN_TYPE] Chronology)  DateTimeFieldType type int value Chronology chronology [VARIABLES] boolean DateTimeFieldType[] iTypes Partial iPartial DateTimeFieldType type int[] iValues Chronology chrono chronology iChronology long serialVersionUID DateTimeFormatter[] iFormatter int iFieldIndex value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.2886751345948129	153	153	1	replace	
14	[BUG] [BUGGY] [FE] IllegalArgumentException testWith_baseAndArgHaveNoRange [CONTEXT] public Partial(DateTimeFieldType type, int value, Chronology chronology) { [BUGGY] [BUGGY] super(); chronology = DateTimeUtils.getChronology(chronology).withUTC(); iChronology = chronology; if (type == null) { throw new IllegalArgumentException("The field type must not be null"); } iTypes = new DateTimeFieldType[] {type}; iValues = new int[] {value}; chronology.validate(this, iValues); } [CLASS] Partial Property [METHOD] <init> [RETURN_TYPE] Chronology)  DateTimeFieldType type int value Chronology chronology [VARIABLES] boolean DateTimeFieldType[] iTypes Partial iPartial DateTimeFieldType type int[] iValues Chronology chrono chronology iChronology long serialVersionUID DateTimeFormatter[] iFormatter int iFieldIndex value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.2886751345948129	153	153	1	add	
15	[BUG] [BUGGY] chronology = DateTimeUtils.getChronology(chronology).withUTC(); [FE] IllegalArgumentException testWith_baseAndArgHaveNoRange [CONTEXT] public Partial(DateTimeFieldType type, int value, Chronology chronology) { super(); [BUGGY] chronology = DateTimeUtils.getChronology(chronology).withUTC(); [BUGGY] iChronology = chronology; if (type == null) { throw new IllegalArgumentException("The field type must not be null"); } iTypes = new DateTimeFieldType[] {type}; iValues = new int[] {value}; chronology.validate(this, iValues); } [CLASS] Partial Property [METHOD] <init> [RETURN_TYPE] Chronology)  DateTimeFieldType type int value Chronology chronology [VARIABLES] boolean DateTimeFieldType[] iTypes Partial iPartial DateTimeFieldType type int[] iValues Chronology chrono chronology iChronology long serialVersionUID DateTimeFormatter[] iFormatter int iFieldIndex value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.2886751345948129	154	154	1	replace	
16	[BUG] [BUGGY] [FE] IllegalArgumentException testWith_baseAndArgHaveNoRange [CONTEXT] public Partial(DateTimeFieldType type, int value, Chronology chronology) { super(); [BUGGY] [BUGGY] chronology = DateTimeUtils.getChronology(chronology).withUTC(); iChronology = chronology; if (type == null) { throw new IllegalArgumentException("The field type must not be null"); } iTypes = new DateTimeFieldType[] {type}; iValues = new int[] {value}; chronology.validate(this, iValues); } [CLASS] Partial Property [METHOD] <init> [RETURN_TYPE] Chronology)  DateTimeFieldType type int value Chronology chronology [VARIABLES] boolean DateTimeFieldType[] iTypes Partial iPartial DateTimeFieldType type int[] iValues Chronology chrono chronology iChronology long serialVersionUID DateTimeFormatter[] iFormatter int iFieldIndex value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.2886751345948129	154	154	1	add	
17	[BUG] [BUGGY] iChronology = chronology; [FE] IllegalArgumentException testWith_baseAndArgHaveNoRange [CONTEXT] public Partial(DateTimeFieldType type, int value, Chronology chronology) { super(); chronology = DateTimeUtils.getChronology(chronology).withUTC(); [BUGGY] iChronology = chronology; [BUGGY] if (type == null) { throw new IllegalArgumentException("The field type must not be null"); } iTypes = new DateTimeFieldType[] {type}; iValues = new int[] {value}; chronology.validate(this, iValues); } [CLASS] Partial Property [METHOD] <init> [RETURN_TYPE] Chronology)  DateTimeFieldType type int value Chronology chronology [VARIABLES] boolean DateTimeFieldType[] iTypes Partial iPartial DateTimeFieldType type int[] iValues Chronology chrono chronology iChronology long serialVersionUID DateTimeFormatter[] iFormatter int iFieldIndex value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.2886751345948129	155	155	1	replace	
18	[BUG] [BUGGY] [FE] IllegalArgumentException testWith_baseAndArgHaveNoRange [CONTEXT] public Partial(DateTimeFieldType type, int value, Chronology chronology) { super(); chronology = DateTimeUtils.getChronology(chronology).withUTC(); [BUGGY] [BUGGY] iChronology = chronology; if (type == null) { throw new IllegalArgumentException("The field type must not be null"); } iTypes = new DateTimeFieldType[] {type}; iValues = new int[] {value}; chronology.validate(this, iValues); } [CLASS] Partial Property [METHOD] <init> [RETURN_TYPE] Chronology)  DateTimeFieldType type int value Chronology chronology [VARIABLES] boolean DateTimeFieldType[] iTypes Partial iPartial DateTimeFieldType type int[] iValues Chronology chrono chronology iChronology long serialVersionUID DateTimeFormatter[] iFormatter int iFieldIndex value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.2886751345948129	155	155	1	add	
19	[BUG] [BUGGY] if (type == null) { [FE] IllegalArgumentException testWith_baseAndArgHaveNoRange [CONTEXT] public Partial(DateTimeFieldType type, int value, Chronology chronology) { super(); chronology = DateTimeUtils.getChronology(chronology).withUTC(); iChronology = chronology; [BUGGY] if (type == null) { [BUGGY] throw new IllegalArgumentException("The field type must not be null"); } iTypes = new DateTimeFieldType[] {type}; iValues = new int[] {value}; chronology.validate(this, iValues); } [CLASS] Partial Property [METHOD] <init> [RETURN_TYPE] Chronology)  DateTimeFieldType type int value Chronology chronology [VARIABLES] boolean DateTimeFieldType[] iTypes Partial iPartial DateTimeFieldType type int[] iValues Chronology chrono chronology iChronology long serialVersionUID DateTimeFormatter[] iFormatter int iFieldIndex value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.2886751345948129	156	156	1	replace	
20	[BUG] [BUGGY] [FE] IllegalArgumentException testWith_baseAndArgHaveNoRange [CONTEXT] public Partial(DateTimeFieldType type, int value, Chronology chronology) { super(); chronology = DateTimeUtils.getChronology(chronology).withUTC(); iChronology = chronology; [BUGGY] [BUGGY] if (type == null) { throw new IllegalArgumentException("The field type must not be null"); } iTypes = new DateTimeFieldType[] {type}; iValues = new int[] {value}; chronology.validate(this, iValues); } [CLASS] Partial Property [METHOD] <init> [RETURN_TYPE] Chronology)  DateTimeFieldType type int value Chronology chronology [VARIABLES] boolean DateTimeFieldType[] iTypes Partial iPartial DateTimeFieldType type int[] iValues Chronology chrono chronology iChronology long serialVersionUID DateTimeFormatter[] iFormatter int iFieldIndex value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.2886751345948129	156	156	1	add	
