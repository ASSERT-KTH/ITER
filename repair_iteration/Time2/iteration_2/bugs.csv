bugid	buggy	buggy_class	suspiciousness	buggy_line	endbuggycode	original_failing_test_number	action	patch	original_buggy	execution_result	diagnosis	previous_bug_id	new_failing_test_number	this_action2	[BUG]  [BUGGY]  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange  [CONTEXT]    public  Partial(DateTimeFieldType  type,  int  value,  Chronology  chronology)  {  super();  chronology  =  DateTimeUtils.getChronology(chronology).withUTC();    [BUGGY]  iChronology  =(chronology!=  null)?  chronology  :  DateTimeUtils.getChronology(chronology).withUTC();  [BUGGY]    if  (type  ==  null)  {  throw  new  IllegalArgumentException(   "The  field  type  must  not  be  null   ");  }  iTypes  =  new  DateTimeFieldType[]  {type};  iValues  =  new  int[]  {value};  chronology.validate(this,  iValues);  }  [CLASS]  Partial  Property  [METHOD]  <init>  [RETURN_TYPE]  Chronology)  DateTimeFieldType  type  int  value  Chronology  chronology  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  Partial  iPartial  DateTimeFieldType  type  int[]  iValues  Chronology  chrono  chronology  iChronology  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  iFieldIndex  value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.2886751345948129	155	155	1	add	iChronology  =(chronology!=  null)?  chronology  :  DateTimeUtils.getChronology(chronology).withUTC();	  iChronology    =(chronology    ==    null)?    chronology    :    DateTimeUtils.getChronology(chronology).withUTC();    	compilable	  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange	164	1	replace
3	[BUG]  [BUGGY]  iChronology  =(chronology!=  null)?  chronology  :  DateTimeUtils.getChronology(chronology).withUTC();  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange  [CONTEXT]    public  Partial(DateTimeFieldType  type,  int  value,  Chronology  chronology)  {  super();  chronology  =  DateTimeUtils.getChronology(chronology).withUTC();    [BUGGY]  iChronology  =(chronology!=  null)?  chronology  :  DateTimeUtils.getChronology(chronology).withUTC();  [BUGGY]    if  (type  ==  null)  {  throw  new  IllegalArgumentException(   "The  field  type  must  not  be  null   ");  }  iTypes  =  new  DateTimeFieldType[]  {type};  iValues  =  new  int[]  {value};  chronology.validate(this,  iValues);  }  [CLASS]  Partial  Property  [METHOD]  <init>  [RETURN_TYPE]  Chronology)  DateTimeFieldType  type  int  value  Chronology  chronology  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  Partial  iPartial  DateTimeFieldType  type  int[]  iValues  Chronology  chrono  chronology  iChronology  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  iFieldIndex  value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.2886751345948129	155	155	1	replace	iChronology  =(chronology!=  null)?  chronology  :  DateTimeUtils.getChronology(chronology).withUTC();	  iChronology    =(chronology    ==    null)?    chronology    :    DateTimeUtils.getChronology(chronology).withUTC();    	compilable	  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange	164	1	replace
22	[BUG]  [BUGGY]  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange  [CONTEXT]    public  Partial(DateTimeFieldType  type,  int  value,  Chronology  chronology)  {  super();  chronology  =  DateTimeUtils.getChronology(chronology).withUTC();    [BUGGY]  iChronology  =  DateTimeUtils.getChronology(chronology).withUTC();  [BUGGY]    if  (type  ==  null)  {  throw  new  IllegalArgumentException(   "The  field  type  must  not  be  null   ");  }  iTypes  =  new  DateTimeFieldType[]  {type};  iValues  =  new  int[]  {value};  chronology.validate(this,  iValues);  }  [CLASS]  Partial  Property  [METHOD]  <init>  [RETURN_TYPE]  Chronology)  DateTimeFieldType  type  int  value  Chronology  chronology  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  Partial  iPartial  DateTimeFieldType  type  int[]  iValues  Chronology  chrono  chronology  iChronology  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  iFieldIndex  value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.2886751345948129	155	155	1	add	iChronology  =  DateTimeUtils.getChronology(chronology).withUTC();	  iChronology    =    DateTimeUtils.getChronology(chronology);    	compilable	  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange	134	1	replace
23	[BUG]  [BUGGY]  iChronology  =  DateTimeUtils.getChronology(chronology).withUTC();  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange  [CONTEXT]    public  Partial(DateTimeFieldType  type,  int  value,  Chronology  chronology)  {  super();  chronology  =  DateTimeUtils.getChronology(chronology).withUTC();    [BUGGY]  iChronology  =  DateTimeUtils.getChronology(chronology).withUTC();  [BUGGY]    if  (type  ==  null)  {  throw  new  IllegalArgumentException(   "The  field  type  must  not  be  null   ");  }  iTypes  =  new  DateTimeFieldType[]  {type};  iValues  =  new  int[]  {value};  chronology.validate(this,  iValues);  }  [CLASS]  Partial  Property  [METHOD]  <init>  [RETURN_TYPE]  Chronology)  DateTimeFieldType  type  int  value  Chronology  chronology  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  Partial  iPartial  DateTimeFieldType  type  int[]  iValues  Chronology  chrono  chronology  iChronology  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  iFieldIndex  value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.2886751345948129	155	155	1	replace	iChronology  =  DateTimeUtils.getChronology(chronology).withUTC();	  iChronology    =    DateTimeUtils.getChronology(chronology);    	compilable	  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange	134	1	replace
72	[BUG]  [BUGGY]  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange  [CONTEXT]    public  Partial(DateTimeFieldType  type,  int  value,  Chronology  chronology)  {  super();  chronology  =  DateTimeUtils.getChronology(chronology).withUTC();    [BUGGY]  iChronology  =(chronology!=  null)?  chronology  :  DateTimeUtils.getChronology(chronology);  [BUGGY]    if  (type  ==  null)  {  throw  new  IllegalArgumentException(   "The  field  type  must  not  be  null   ");  }  iTypes  =  new  DateTimeFieldType[]  {type};  iValues  =  new  int[]  {value};  chronology.validate(this,  iValues);  }  [CLASS]  Partial  Property  [METHOD]  <init>  [RETURN_TYPE]  Chronology)  DateTimeFieldType  type  int  value  Chronology  chronology  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  Partial  iPartial  DateTimeFieldType  type  int[]  iValues  Chronology  chrono  chronology  iChronology  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  iFieldIndex  value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.2886751345948129	155	155	1	add	iChronology  =(chronology!=  null)?  chronology  :  DateTimeUtils.getChronology(chronology);	  iChronology    =(chronology    ==    null)?    chronology    :    DateTimeUtils.getChronology(chronology);    	compilable	  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange	165	1	replace
73	[BUG]  [BUGGY]  iChronology  =(chronology!=  null)?  chronology  :  DateTimeUtils.getChronology(chronology);  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange  [CONTEXT]    public  Partial(DateTimeFieldType  type,  int  value,  Chronology  chronology)  {  super();  chronology  =  DateTimeUtils.getChronology(chronology).withUTC();    [BUGGY]  iChronology  =(chronology!=  null)?  chronology  :  DateTimeUtils.getChronology(chronology);  [BUGGY]    if  (type  ==  null)  {  throw  new  IllegalArgumentException(   "The  field  type  must  not  be  null   ");  }  iTypes  =  new  DateTimeFieldType[]  {type};  iValues  =  new  int[]  {value};  chronology.validate(this,  iValues);  }  [CLASS]  Partial  Property  [METHOD]  <init>  [RETURN_TYPE]  Chronology)  DateTimeFieldType  type  int  value  Chronology  chronology  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  Partial  iPartial  DateTimeFieldType  type  int[]  iValues  Chronology  chrono  chronology  iChronology  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  iFieldIndex  value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.2886751345948129	155	155	1	replace	iChronology  =(chronology!=  null)?  chronology  :  DateTimeUtils.getChronology(chronology);	  iChronology    =(chronology    ==    null)?    chronology    :    DateTimeUtils.getChronology(chronology);    	compilable	  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange	165	1	replace
141	[BUG]  [BUGGY]  [FE]  NullPointerException  testWith_baseAndArgHaveNoRange  [CONTEXT]    DateTimeFieldType  loopType  =  types[i];  DurationField  loopUnitField  =  loopType.getDurationType().getField(iChronology);  if  (i  >  0)  {  int  compare  =  lastUnitField.compareTo(loopUnitField);  if  (compare  <  0  ||  (compare  !=  0  &&  loopUnitField.isSupported()  ==  false))  {  throw  new  IllegalArgumentException(   "Types  array  must  be  in  order  largest-smallest:     "  +  types[i  -  1].getName()  +     "  <     "  +  loopType.getName());  }  else  if  (compare  ==  0)  {  if  (types[i  -  1].getRangeDurationType()  ==  null)  {  if  (loopType.getRangeDurationType()  ==  null)  {    [BUGGY]      if(loopType.getRangeDurationType().getField(iChronology)  ==  null)  {  throw  new  IllegalArgumentException(   "   ");  }  if(types[i  -  1].getRangeDurationType().getField(iChronology)!=  null)  {  throw  new  IllegalArgumentException( " ");  }  [BUGGY]    throw  new  IllegalArgumentException(   "Types  array  must  not  contain  duplicate:     "  +            types[i  -  1].getName()  +     "  and     "  +  loopType.getName());  types[i  -  1].getName()  +     "  and     "  +  loopType.getName());  }  }  else  {  if  (loopType.getRangeDurationType()  ==  null)  {  throw  new  IllegalArgumentException(   "Types  array  must  be  in  order  largest-smallest:     "  +  types[i  -  1].getName()  +     "  <     "  +  loopType.getName());  }  DurationField  lastRangeField  =  types[i  -  1].getRangeDurationType().getField(iChronology);  DurationField  loopRangeField  =  loopType.getRangeDurationType().getField(iChronology);  if  (lastRangeField.compareTo(loopRangeField)  <  0)  {  [CLASS]  Partial  Property  [METHOD]  <init>  [RETURN_TYPE]  Chronology)  DateTimeFieldType[]  types  int[]  values  Chronology  chronology  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  types  Partial  iPartial  DateTimeFieldType  loopType  int[]  iValues  values  Chronology  chrono  chronology  iChronology  DurationField  lastRangeField  lastUnitField  loopRangeField  loopUnitField  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  compare  i  iFieldIndex  value  	projects/Time2/src/main/java/org/joda/time/Partial.java	1.0	224	225	1	add	        if(loopType.getRangeDurationType().getField(iChronology)    ==    null)    {    throw    new    IllegalArgumentException(   "   ");    }    if(types[i  -  1].getRangeDurationType().getField(iChronology)!=  null)  {  throw  new  IllegalArgumentException( " ");  }	  	compilable	  [FE]  NullPointerException  testWith_baseAndArgHaveNoRange	181	1	add
142	[BUG]  [BUGGY]      if(loopType.getRangeDurationType().getField(iChronology)  ==  null)  {  throw  new  IllegalArgumentException(   "   ");  }  if(types[i  -  1].getRangeDurationType().getField(iChronology)!=  null)  {  throw  new  IllegalArgumentException( " ");  }  [FE]  NullPointerException  testWith_baseAndArgHaveNoRange  [CONTEXT]    DateTimeFieldType  loopType  =  types[i];  DurationField  loopUnitField  =  loopType.getDurationType().getField(iChronology);  if  (i  >  0)  {  int  compare  =  lastUnitField.compareTo(loopUnitField);  if  (compare  <  0  ||  (compare  !=  0  &&  loopUnitField.isSupported()  ==  false))  {  throw  new  IllegalArgumentException(   "Types  array  must  be  in  order  largest-smallest:     "  +  types[i  -  1].getName()  +     "  <     "  +  loopType.getName());  }  else  if  (compare  ==  0)  {  if  (types[i  -  1].getRangeDurationType()  ==  null)  {  if  (loopType.getRangeDurationType()  ==  null)  {    [BUGGY]      if(loopType.getRangeDurationType().getField(iChronology)  ==  null)  {  throw  new  IllegalArgumentException(   "   ");  }  if(types[i  -  1].getRangeDurationType().getField(iChronology)!=  null)  {  throw  new  IllegalArgumentException( " ");  }  [BUGGY]    throw  new  IllegalArgumentException(   "Types  array  must  not  contain  duplicate:     "  +            types[i  -  1].getName()  +     "  and     "  +  loopType.getName());  types[i  -  1].getName()  +     "  and     "  +  loopType.getName());  }  }  else  {  if  (loopType.getRangeDurationType()  ==  null)  {  throw  new  IllegalArgumentException(   "Types  array  must  be  in  order  largest-smallest:     "  +  types[i  -  1].getName()  +     "  <     "  +  loopType.getName());  }  DurationField  lastRangeField  =  types[i  -  1].getRangeDurationType().getField(iChronology);  DurationField  loopRangeField  =  loopType.getRangeDurationType().getField(iChronology);  if  (lastRangeField.compareTo(loopRangeField)  <  0)  {  [CLASS]  Partial  Property  [METHOD]  <init>  [RETURN_TYPE]  Chronology)  DateTimeFieldType[]  types  int[]  values  Chronology  chronology  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  types  Partial  iPartial  DateTimeFieldType  loopType  int[]  iValues  values  Chronology  chrono  chronology  iChronology  DurationField  lastRangeField  lastUnitField  loopRangeField  loopUnitField  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  compare  i  iFieldIndex  value  	projects/Time2/src/main/java/org/joda/time/Partial.java	1.0	224	225	1	replace	        if(loopType.getRangeDurationType().getField(iChronology)    ==    null)    {    throw    new    IllegalArgumentException(   "   ");    }    if(types[i  -  1].getRangeDurationType().getField(iChronology)!=  null)  {  throw  new  IllegalArgumentException( " ");  }	  	compilable	  [FE]  NullPointerException  testWith_baseAndArgHaveNoRange	181	1	add
142	[BUG]  [BUGGY]  [FE]  NullPointerException  testWith_baseAndArgHaveNoRange  [CONTEXT]    DateTimeFieldType  loopType  =  types[i];  DurationField  loopUnitField  =  loopType.getDurationType().getField(iChronology);  if  (i  >  0)  {  int  compare  =  lastUnitField.compareTo(loopUnitField);  if  (compare  <  0  ||  (compare  !=  0  &&  loopUnitField.isSupported()  ==  false))  {  throw  new  IllegalArgumentException(   "Types  array  must  be  in  order  largest-smallest:     "  +  types[i  -  1].getName()  +     "  <     "  +  loopType.getName());  }  else  if  (compare  ==  0)  {  if  (types[i  -  1].getRangeDurationType()  ==  null)  {  if  (loopType.getRangeDurationType()  ==  null)  {    [BUGGY]      if(loopType.getRangeDurationType().getField(iChronology)  ==  null)  {  throw  new  IllegalArgumentException(   "   ");  }  if(types[i  -  1].getRangeDurationType().getField(iChronology)  ==  null)  {  throw  new  IllegalArgumentException( " ");  }  [BUGGY]    throw  new  IllegalArgumentException(   "Types  array  must  not  contain  duplicate:     "  +            types[i  -  1].getName()  +     "  and     "  +  loopType.getName());  types[i  -  1].getName()  +     "  and     "  +  loopType.getName());  }  }  else  {  if  (loopType.getRangeDurationType()  ==  null)  {  throw  new  IllegalArgumentException(   "Types  array  must  be  in  order  largest-smallest:     "  +  types[i  -  1].getName()  +     "  <     "  +  loopType.getName());  }  DurationField  lastRangeField  =  types[i  -  1].getRangeDurationType().getField(iChronology);  DurationField  loopRangeField  =  loopType.getRangeDurationType().getField(iChronology);  if  (lastRangeField.compareTo(loopRangeField)  <  0)  {  [CLASS]  Partial  Property  [METHOD]  <init>  [RETURN_TYPE]  Chronology)  DateTimeFieldType[]  types  int[]  values  Chronology  chronology  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  types  Partial  iPartial  DateTimeFieldType  loopType  int[]  iValues  values  Chronology  chrono  chronology  iChronology  DurationField  lastRangeField  lastUnitField  loopRangeField  loopUnitField  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  compare  i  iFieldIndex  value  	projects/Time2/src/main/java/org/joda/time/Partial.java	1.0	224	225	1	add	        if(loopType.getRangeDurationType().getField(iChronology)    ==    null)    {    throw    new    IllegalArgumentException(   "   ");    }    if(types[i  -  1].getRangeDurationType().getField(iChronology)  ==  null)  {  throw  new  IllegalArgumentException( " ");  }	  	compilable	  [FE]  NullPointerException  testWith_baseAndArgHaveNoRange	181	1	add
143	[BUG]  [BUGGY]      if(loopType.getRangeDurationType().getField(iChronology)  ==  null)  {  throw  new  IllegalArgumentException(   "   ");  }  if(types[i  -  1].getRangeDurationType().getField(iChronology)  ==  null)  {  throw  new  IllegalArgumentException( " ");  }  [FE]  NullPointerException  testWith_baseAndArgHaveNoRange  [CONTEXT]    DateTimeFieldType  loopType  =  types[i];  DurationField  loopUnitField  =  loopType.getDurationType().getField(iChronology);  if  (i  >  0)  {  int  compare  =  lastUnitField.compareTo(loopUnitField);  if  (compare  <  0  ||  (compare  !=  0  &&  loopUnitField.isSupported()  ==  false))  {  throw  new  IllegalArgumentException(   "Types  array  must  be  in  order  largest-smallest:     "  +  types[i  -  1].getName()  +     "  <     "  +  loopType.getName());  }  else  if  (compare  ==  0)  {  if  (types[i  -  1].getRangeDurationType()  ==  null)  {  if  (loopType.getRangeDurationType()  ==  null)  {    [BUGGY]      if(loopType.getRangeDurationType().getField(iChronology)  ==  null)  {  throw  new  IllegalArgumentException(   "   ");  }  if(types[i  -  1].getRangeDurationType().getField(iChronology)  ==  null)  {  throw  new  IllegalArgumentException( " ");  }  [BUGGY]    throw  new  IllegalArgumentException(   "Types  array  must  not  contain  duplicate:     "  +            types[i  -  1].getName()  +     "  and     "  +  loopType.getName());  types[i  -  1].getName()  +     "  and     "  +  loopType.getName());  }  }  else  {  if  (loopType.getRangeDurationType()  ==  null)  {  throw  new  IllegalArgumentException(   "Types  array  must  be  in  order  largest-smallest:     "  +  types[i  -  1].getName()  +     "  <     "  +  loopType.getName());  }  DurationField  lastRangeField  =  types[i  -  1].getRangeDurationType().getField(iChronology);  DurationField  loopRangeField  =  loopType.getRangeDurationType().getField(iChronology);  if  (lastRangeField.compareTo(loopRangeField)  <  0)  {  [CLASS]  Partial  Property  [METHOD]  <init>  [RETURN_TYPE]  Chronology)  DateTimeFieldType[]  types  int[]  values  Chronology  chronology  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  types  Partial  iPartial  DateTimeFieldType  loopType  int[]  iValues  values  Chronology  chrono  chronology  iChronology  DurationField  lastRangeField  lastUnitField  loopRangeField  loopUnitField  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  compare  i  iFieldIndex  value  	projects/Time2/src/main/java/org/joda/time/Partial.java	1.0	224	225	1	replace	        if(loopType.getRangeDurationType().getField(iChronology)    ==    null)    {    throw    new    IllegalArgumentException(   "   ");    }    if(types[i  -  1].getRangeDurationType().getField(iChronology)  ==  null)  {  throw  new  IllegalArgumentException( " ");  }	  	compilable	  [FE]  NullPointerException  testWith_baseAndArgHaveNoRange	181	1	add
143	[BUG]  [BUGGY]  [FE]  NullPointerException  testWith_baseAndArgHaveNoRange  [CONTEXT]    DateTimeFieldType  loopType  =  types[i];  DurationField  loopUnitField  =  loopType.getDurationType().getField(iChronology);  if  (i  >  0)  {  int  compare  =  lastUnitField.compareTo(loopUnitField);  if  (compare  <  0  ||  (compare  !=  0  &&  loopUnitField.isSupported()  ==  false))  {  throw  new  IllegalArgumentException(   "Types  array  must  be  in  order  largest-smallest:     "  +  types[i  -  1].getName()  +     "  <     "  +  loopType.getName());  }  else  if  (compare  ==  0)  {  if  (types[i  -  1].getRangeDurationType()  ==  null)  {  if  (loopType.getRangeDurationType()  ==  null)  {    [BUGGY]      if(loopType.getRangeDurationType().getField(iChronology)  ==  null)  {  throw  new  IllegalArgumentException(   "   ");  }  if(types[i  -  1].getRangeDurationType()  ==  null)  {  throw  new  IllegalArgumentException( " ");  }  [BUGGY]    throw  new  IllegalArgumentException(   "Types  array  must  not  contain  duplicate:     "  +            types[i  -  1].getName()  +     "  and     "  +  loopType.getName());  types[i  -  1].getName()  +     "  and     "  +  loopType.getName());  }  }  else  {  if  (loopType.getRangeDurationType()  ==  null)  {  throw  new  IllegalArgumentException(   "Types  array  must  be  in  order  largest-smallest:     "  +  types[i  -  1].getName()  +     "  <     "  +  loopType.getName());  }  DurationField  lastRangeField  =  types[i  -  1].getRangeDurationType().getField(iChronology);  DurationField  loopRangeField  =  loopType.getRangeDurationType().getField(iChronology);  if  (lastRangeField.compareTo(loopRangeField)  <  0)  {  [CLASS]  Partial  Property  [METHOD]  <init>  [RETURN_TYPE]  Chronology)  DateTimeFieldType[]  types  int[]  values  Chronology  chronology  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  types  Partial  iPartial  DateTimeFieldType  loopType  int[]  iValues  values  Chronology  chrono  chronology  iChronology  DurationField  lastRangeField  lastUnitField  loopRangeField  loopUnitField  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  compare  i  iFieldIndex  value  	projects/Time2/src/main/java/org/joda/time/Partial.java	1.0	224	225	1	add	        if(loopType.getRangeDurationType().getField(iChronology)    ==    null)    {    throw    new    IllegalArgumentException(   "   ");    }    if(types[i  -  1].getRangeDurationType()  ==  null)  {  throw  new  IllegalArgumentException( " ");  }	  	compilable	  [FE]  NullPointerException  testWith_baseAndArgHaveNoRange	181	1	add
144	[BUG]  [BUGGY]      if(loopType.getRangeDurationType().getField(iChronology)  ==  null)  {  throw  new  IllegalArgumentException(   "   ");  }  if(types[i  -  1].getRangeDurationType()  ==  null)  {  throw  new  IllegalArgumentException( " ");  }  [FE]  NullPointerException  testWith_baseAndArgHaveNoRange  [CONTEXT]    DateTimeFieldType  loopType  =  types[i];  DurationField  loopUnitField  =  loopType.getDurationType().getField(iChronology);  if  (i  >  0)  {  int  compare  =  lastUnitField.compareTo(loopUnitField);  if  (compare  <  0  ||  (compare  !=  0  &&  loopUnitField.isSupported()  ==  false))  {  throw  new  IllegalArgumentException(   "Types  array  must  be  in  order  largest-smallest:     "  +  types[i  -  1].getName()  +     "  <     "  +  loopType.getName());  }  else  if  (compare  ==  0)  {  if  (types[i  -  1].getRangeDurationType()  ==  null)  {  if  (loopType.getRangeDurationType()  ==  null)  {    [BUGGY]      if(loopType.getRangeDurationType().getField(iChronology)  ==  null)  {  throw  new  IllegalArgumentException(   "   ");  }  if(types[i  -  1].getRangeDurationType()  ==  null)  {  throw  new  IllegalArgumentException( " ");  }  [BUGGY]    throw  new  IllegalArgumentException(   "Types  array  must  not  contain  duplicate:     "  +            types[i  -  1].getName()  +     "  and     "  +  loopType.getName());  types[i  -  1].getName()  +     "  and     "  +  loopType.getName());  }  }  else  {  if  (loopType.getRangeDurationType()  ==  null)  {  throw  new  IllegalArgumentException(   "Types  array  must  be  in  order  largest-smallest:     "  +  types[i  -  1].getName()  +     "  <     "  +  loopType.getName());  }  DurationField  lastRangeField  =  types[i  -  1].getRangeDurationType().getField(iChronology);  DurationField  loopRangeField  =  loopType.getRangeDurationType().getField(iChronology);  if  (lastRangeField.compareTo(loopRangeField)  <  0)  {  [CLASS]  Partial  Property  [METHOD]  <init>  [RETURN_TYPE]  Chronology)  DateTimeFieldType[]  types  int[]  values  Chronology  chronology  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  types  Partial  iPartial  DateTimeFieldType  loopType  int[]  iValues  values  Chronology  chrono  chronology  iChronology  DurationField  lastRangeField  lastUnitField  loopRangeField  loopUnitField  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  compare  i  iFieldIndex  value  	projects/Time2/src/main/java/org/joda/time/Partial.java	1.0	224	225	1	replace	        if(loopType.getRangeDurationType().getField(iChronology)    ==    null)    {    throw    new    IllegalArgumentException(   "   ");    }    if(types[i  -  1].getRangeDurationType()  ==  null)  {  throw  new  IllegalArgumentException( " ");  }	  	compilable	  [FE]  NullPointerException  testWith_baseAndArgHaveNoRange	181	1	add
144	[BUG]  [BUGGY]  [FE]  NullPointerException  testWith_baseAndArgHaveNoRange  [CONTEXT]    DateTimeFieldType  loopType  =  types[i];  DurationField  loopUnitField  =  loopType.getDurationType().getField(iChronology);  if  (i  >  0)  {  int  compare  =  lastUnitField.compareTo(loopUnitField);  if  (compare  <  0  ||  (compare  !=  0  &&  loopUnitField.isSupported()  ==  false))  {  throw  new  IllegalArgumentException(   "Types  array  must  be  in  order  largest-smallest:     "  +  types[i  -  1].getName()  +     "  <     "  +  loopType.getName());  }  else  if  (compare  ==  0)  {  if  (types[i  -  1].getRangeDurationType()  ==  null)  {  if  (loopType.getRangeDurationType()  ==  null)  {    [BUGGY]      if(loopType.getRangeDurationType().getField(iChronology)  ==  null)  {  throw  new  IllegalArgumentException(   "   ");  }  if(loopType.getRangeDurationType().getField(iChronology)!=  null)  {  throw  new  IllegalArgumentException( " ");  }  [BUGGY]    throw  new  IllegalArgumentException(   "Types  array  must  not  contain  duplicate:     "  +            types[i  -  1].getName()  +     "  and     "  +  loopType.getName());  types[i  -  1].getName()  +     "  and     "  +  loopType.getName());  }  }  else  {  if  (loopType.getRangeDurationType()  ==  null)  {  throw  new  IllegalArgumentException(   "Types  array  must  be  in  order  largest-smallest:     "  +  types[i  -  1].getName()  +     "  <     "  +  loopType.getName());  }  DurationField  lastRangeField  =  types[i  -  1].getRangeDurationType().getField(iChronology);  DurationField  loopRangeField  =  loopType.getRangeDurationType().getField(iChronology);  if  (lastRangeField.compareTo(loopRangeField)  <  0)  {  [CLASS]  Partial  Property  [METHOD]  <init>  [RETURN_TYPE]  Chronology)  DateTimeFieldType[]  types  int[]  values  Chronology  chronology  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  types  Partial  iPartial  DateTimeFieldType  loopType  int[]  iValues  values  Chronology  chrono  chronology  iChronology  DurationField  lastRangeField  lastUnitField  loopRangeField  loopUnitField  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  compare  i  iFieldIndex  value  	projects/Time2/src/main/java/org/joda/time/Partial.java	1.0	224	225	1	add	        if(loopType.getRangeDurationType().getField(iChronology)    ==    null)    {    throw    new    IllegalArgumentException(   "   ");    }    if(loopType.getRangeDurationType().getField(iChronology)!=  null)  {  throw  new  IllegalArgumentException( " ");  }	  	compilable	  [FE]  NullPointerException  testWith_baseAndArgHaveNoRange	181	1	add
145	[BUG]  [BUGGY]      if(loopType.getRangeDurationType().getField(iChronology)  ==  null)  {  throw  new  IllegalArgumentException(   "   ");  }  if(loopType.getRangeDurationType().getField(iChronology)!=  null)  {  throw  new  IllegalArgumentException( " ");  }  [FE]  NullPointerException  testWith_baseAndArgHaveNoRange  [CONTEXT]    DateTimeFieldType  loopType  =  types[i];  DurationField  loopUnitField  =  loopType.getDurationType().getField(iChronology);  if  (i  >  0)  {  int  compare  =  lastUnitField.compareTo(loopUnitField);  if  (compare  <  0  ||  (compare  !=  0  &&  loopUnitField.isSupported()  ==  false))  {  throw  new  IllegalArgumentException(   "Types  array  must  be  in  order  largest-smallest:     "  +  types[i  -  1].getName()  +     "  <     "  +  loopType.getName());  }  else  if  (compare  ==  0)  {  if  (types[i  -  1].getRangeDurationType()  ==  null)  {  if  (loopType.getRangeDurationType()  ==  null)  {    [BUGGY]      if(loopType.getRangeDurationType().getField(iChronology)  ==  null)  {  throw  new  IllegalArgumentException(   "   ");  }  if(loopType.getRangeDurationType().getField(iChronology)!=  null)  {  throw  new  IllegalArgumentException( " ");  }  [BUGGY]    throw  new  IllegalArgumentException(   "Types  array  must  not  contain  duplicate:     "  +            types[i  -  1].getName()  +     "  and     "  +  loopType.getName());  types[i  -  1].getName()  +     "  and     "  +  loopType.getName());  }  }  else  {  if  (loopType.getRangeDurationType()  ==  null)  {  throw  new  IllegalArgumentException(   "Types  array  must  be  in  order  largest-smallest:     "  +  types[i  -  1].getName()  +     "  <     "  +  loopType.getName());  }  DurationField  lastRangeField  =  types[i  -  1].getRangeDurationType().getField(iChronology);  DurationField  loopRangeField  =  loopType.getRangeDurationType().getField(iChronology);  if  (lastRangeField.compareTo(loopRangeField)  <  0)  {  [CLASS]  Partial  Property  [METHOD]  <init>  [RETURN_TYPE]  Chronology)  DateTimeFieldType[]  types  int[]  values  Chronology  chronology  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  types  Partial  iPartial  DateTimeFieldType  loopType  int[]  iValues  values  Chronology  chrono  chronology  iChronology  DurationField  lastRangeField  lastUnitField  loopRangeField  loopUnitField  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  compare  i  iFieldIndex  value  	projects/Time2/src/main/java/org/joda/time/Partial.java	1.0	224	225	1	replace	        if(loopType.getRangeDurationType().getField(iChronology)    ==    null)    {    throw    new    IllegalArgumentException(   "   ");    }    if(loopType.getRangeDurationType().getField(iChronology)!=  null)  {  throw  new  IllegalArgumentException( " ");  }	  	compilable	  [FE]  NullPointerException  testWith_baseAndArgHaveNoRange	181	1	add
201	[BUG]  [BUGGY]  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange  [CONTEXT]    public  Partial(DateTimeFieldType  type,  int  value,  Chronology  chronology)  {  super();  chronology  =  DateTimeUtils.getChronology(chronology).withUTC();    [BUGGY]      chronology  =  DateTimeUtils.getChronology(chronology);  chronology  =  DateTimeUtils.getChronology(chronology);  [BUGGY]    iChronology  =  chronology;  if  (type  ==  null)  {  throw  new  IllegalArgumentException(   "The  field  type  must  not  be  null   ");  }  iTypes  =  new  DateTimeFieldType[]  {type};  iValues  =  new  int[]  {value};  chronology.validate(this,  iValues);  }  [CLASS]  Partial  Property  [METHOD]  <init>  [RETURN_TYPE]  Chronology)  DateTimeFieldType  type  int  value  Chronology  chronology  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  Partial  iPartial  DateTimeFieldType  type  int[]  iValues  Chronology  chrono  chronology  iChronology  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  iFieldIndex  value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.2886751345948129	155	155	1	add	        chronology    =    DateTimeUtils.getChronology(chronology);    chronology  =  DateTimeUtils.getChronology(chronology);	  	compilable	  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange	61	1	add
202	[BUG]  [BUGGY]      chronology  =  DateTimeUtils.getChronology(chronology);  chronology  =  DateTimeUtils.getChronology(chronology);  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange  [CONTEXT]    public  Partial(DateTimeFieldType  type,  int  value,  Chronology  chronology)  {  super();  chronology  =  DateTimeUtils.getChronology(chronology).withUTC();    [BUGGY]      chronology  =  DateTimeUtils.getChronology(chronology);  chronology  =  DateTimeUtils.getChronology(chronology);  [BUGGY]    iChronology  =  chronology;  if  (type  ==  null)  {  throw  new  IllegalArgumentException(   "The  field  type  must  not  be  null   ");  }  iTypes  =  new  DateTimeFieldType[]  {type};  iValues  =  new  int[]  {value};  chronology.validate(this,  iValues);  }  [CLASS]  Partial  Property  [METHOD]  <init>  [RETURN_TYPE]  Chronology)  DateTimeFieldType  type  int  value  Chronology  chronology  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  Partial  iPartial  DateTimeFieldType  type  int[]  iValues  Chronology  chrono  chronology  iChronology  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  iFieldIndex  value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.2886751345948129	155	155	1	replace	        chronology    =    DateTimeUtils.getChronology(chronology);    chronology  =  DateTimeUtils.getChronology(chronology);	  	compilable	  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange	61	1	add
202	[BUG]  [BUGGY]  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange  [CONTEXT]    public  Partial(DateTimeFieldType  type,  int  value,  Chronology  chronology)  {  super();  chronology  =  DateTimeUtils.getChronology(chronology).withUTC();    [BUGGY]      chronology  =  DateTimeUtils.getChronology(chronology);  chronology  =  DateTimeUtils.getChronology(chronology).withUTC();  [BUGGY]    iChronology  =  chronology;  if  (type  ==  null)  {  throw  new  IllegalArgumentException(   "The  field  type  must  not  be  null   ");  }  iTypes  =  new  DateTimeFieldType[]  {type};  iValues  =  new  int[]  {value};  chronology.validate(this,  iValues);  }  [CLASS]  Partial  Property  [METHOD]  <init>  [RETURN_TYPE]  Chronology)  DateTimeFieldType  type  int  value  Chronology  chronology  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  Partial  iPartial  DateTimeFieldType  type  int[]  iValues  Chronology  chrono  chronology  iChronology  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  iFieldIndex  value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.2886751345948129	155	155	1	add	        chronology    =    DateTimeUtils.getChronology(chronology);    chronology  =  DateTimeUtils.getChronology(chronology).withUTC();	  	compilable	  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange	61	1	add
203	[BUG]  [BUGGY]      chronology  =  DateTimeUtils.getChronology(chronology);  chronology  =  DateTimeUtils.getChronology(chronology).withUTC();  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange  [CONTEXT]    public  Partial(DateTimeFieldType  type,  int  value,  Chronology  chronology)  {  super();  chronology  =  DateTimeUtils.getChronology(chronology).withUTC();    [BUGGY]      chronology  =  DateTimeUtils.getChronology(chronology);  chronology  =  DateTimeUtils.getChronology(chronology).withUTC();  [BUGGY]    iChronology  =  chronology;  if  (type  ==  null)  {  throw  new  IllegalArgumentException(   "The  field  type  must  not  be  null   ");  }  iTypes  =  new  DateTimeFieldType[]  {type};  iValues  =  new  int[]  {value};  chronology.validate(this,  iValues);  }  [CLASS]  Partial  Property  [METHOD]  <init>  [RETURN_TYPE]  Chronology)  DateTimeFieldType  type  int  value  Chronology  chronology  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  Partial  iPartial  DateTimeFieldType  type  int[]  iValues  Chronology  chrono  chronology  iChronology  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  iFieldIndex  value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.2886751345948129	155	155	1	replace	        chronology    =    DateTimeUtils.getChronology(chronology);    chronology  =  DateTimeUtils.getChronology(chronology).withUTC();	  	compilable	  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange	61	1	add
211	[BUG]  [BUGGY]  [FE]  NullPointerException  testWith_baseAndArgHaveNoRange  [CONTEXT]    DateTimeFieldType  loopType  =  types[i];  DurationField  loopUnitField  =  loopType.getDurationType().getField(iChronology);  if  (i  >  0)  {  int  compare  =  lastUnitField.compareTo(loopUnitField);  if  (compare  <  0  ||  (compare  !=  0  &&  loopUnitField.isSupported()  ==  false))  {  throw  new  IllegalArgumentException(   "Types  array  must  be  in  order  largest-smallest:     "  +  types[i  -  1].getName()  +     "  <     "  +  loopType.getName());  }  else  if  (compare  ==  0)  {  if  (types[i  -  1].getRangeDurationType()  ==  null)  {  if  (loopType.getRangeDurationType()  ==  null)  {    [BUGGY]      if(loopType.getRangeDurationType().getField(iChronology)  ==  null)  {  throw  new  IllegalArgumentException(   "   ");  }  chronology  =  DateTimeUtils.getChronology(chronology).withUTC();  [BUGGY]    throw  new  IllegalArgumentException(   "Types  array  must  not  contain  duplicate:     "  +            types[i  -  1].getName()  +     "  and     "  +  loopType.getName());  types[i  -  1].getName()  +     "  and     "  +  loopType.getName());  }  }  else  {  if  (loopType.getRangeDurationType()  ==  null)  {  throw  new  IllegalArgumentException(   "Types  array  must  be  in  order  largest-smallest:     "  +  types[i  -  1].getName()  +     "  <     "  +  loopType.getName());  }  DurationField  lastRangeField  =  types[i  -  1].getRangeDurationType().getField(iChronology);  DurationField  loopRangeField  =  loopType.getRangeDurationType().getField(iChronology);  if  (lastRangeField.compareTo(loopRangeField)  <  0)  {  [CLASS]  Partial  Property  [METHOD]  <init>  [RETURN_TYPE]  Chronology)  DateTimeFieldType[]  types  int[]  values  Chronology  chronology  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  types  Partial  iPartial  DateTimeFieldType  loopType  int[]  iValues  values  Chronology  chrono  chronology  iChronology  DurationField  lastRangeField  lastUnitField  loopRangeField  loopUnitField  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  compare  i  iFieldIndex  value  	projects/Time2/src/main/java/org/joda/time/Partial.java	1.0	224	225	1	add	        if(loopType.getRangeDurationType().getField(iChronology)    ==    null)    {    throw    new    IllegalArgumentException(   "   ");    }    chronology  =  DateTimeUtils.getChronology(chronology).withUTC();	  	compilable	  [FE]  NullPointerException  testWith_baseAndArgHaveNoRange	181	1	add
212	[BUG]  [BUGGY]      if(loopType.getRangeDurationType().getField(iChronology)  ==  null)  {  throw  new  IllegalArgumentException(   "   ");  }  chronology  =  DateTimeUtils.getChronology(chronology).withUTC();  [FE]  NullPointerException  testWith_baseAndArgHaveNoRange  [CONTEXT]    DateTimeFieldType  loopType  =  types[i];  DurationField  loopUnitField  =  loopType.getDurationType().getField(iChronology);  if  (i  >  0)  {  int  compare  =  lastUnitField.compareTo(loopUnitField);  if  (compare  <  0  ||  (compare  !=  0  &&  loopUnitField.isSupported()  ==  false))  {  throw  new  IllegalArgumentException(   "Types  array  must  be  in  order  largest-smallest:     "  +  types[i  -  1].getName()  +     "  <     "  +  loopType.getName());  }  else  if  (compare  ==  0)  {  if  (types[i  -  1].getRangeDurationType()  ==  null)  {  if  (loopType.getRangeDurationType()  ==  null)  {    [BUGGY]      if(loopType.getRangeDurationType().getField(iChronology)  ==  null)  {  throw  new  IllegalArgumentException(   "   ");  }  chronology  =  DateTimeUtils.getChronology(chronology).withUTC();  [BUGGY]    throw  new  IllegalArgumentException(   "Types  array  must  not  contain  duplicate:     "  +            types[i  -  1].getName()  +     "  and     "  +  loopType.getName());  types[i  -  1].getName()  +     "  and     "  +  loopType.getName());  }  }  else  {  if  (loopType.getRangeDurationType()  ==  null)  {  throw  new  IllegalArgumentException(   "Types  array  must  be  in  order  largest-smallest:     "  +  types[i  -  1].getName()  +     "  <     "  +  loopType.getName());  }  DurationField  lastRangeField  =  types[i  -  1].getRangeDurationType().getField(iChronology);  DurationField  loopRangeField  =  loopType.getRangeDurationType().getField(iChronology);  if  (lastRangeField.compareTo(loopRangeField)  <  0)  {  [CLASS]  Partial  Property  [METHOD]  <init>  [RETURN_TYPE]  Chronology)  DateTimeFieldType[]  types  int[]  values  Chronology  chronology  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  types  Partial  iPartial  DateTimeFieldType  loopType  int[]  iValues  values  Chronology  chrono  chronology  iChronology  DurationField  lastRangeField  lastUnitField  loopRangeField  loopUnitField  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  compare  i  iFieldIndex  value  	projects/Time2/src/main/java/org/joda/time/Partial.java	1.0	224	225	1	replace	        if(loopType.getRangeDurationType().getField(iChronology)    ==    null)    {    throw    new    IllegalArgumentException(   "   ");    }    chronology  =  DateTimeUtils.getChronology(chronology).withUTC();	  	compilable	  [FE]  NullPointerException  testWith_baseAndArgHaveNoRange	181	1	add
254	[BUG]  [BUGGY]  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange  [CONTEXT]    for  (int  i  =  0;  i  <  types.length;  i++)  {  DateTimeFieldType  loopType  =  types[i];  DurationField  loopUnitField  =  loopType.getDurationType().getField(iChronology);  if  (i  >  0)  {  int  compare  =  lastUnitField.compareTo(loopUnitField);  if  (compare  <  0  ||  (compare  !=  0  &&  loopUnitField.isSupported()  ==  false))  {  throw  new  IllegalArgumentException(   "Types  array  must  be  in  order  largest-smallest:     "  +  types[i  -  1].getName()  +     "  <     "  +  loopType.getName());  }  else  if  (compare  ==  0)  {  if  (types[i  -  1].getRangeDurationType()  ==  null)  {    [BUGGY]  if(loopType.getRangeDurationType()  ==  null  ||  loopType.getRangeDurationType().getField(iChronology)  ==  null)  {  [BUGGY]    throw  new  IllegalArgumentException(   "Types  array  must  not  contain  duplicate:     "  +  types[i  -  1].getName()  +     "  and     "  +  loopType.getName());  }  }  else  {  if  (loopType.getRangeDurationType()  ==  null)  {  throw  new  IllegalArgumentException(   "Types  array  must  be  in  order  largest-smallest:     "  +  types[i  -  1].getName()  +     "  <     "  +  loopType.getName());  }  DurationField  lastRangeField  =  types[i  -  1].getRangeDurationType().getField(iChronology);  DurationField  loopRangeField  =  loopType.getRangeDurationType().getField(iChronology);  [CLASS]  Partial  Property  [METHOD]  <init>  [RETURN_TYPE]  Chronology)  DateTimeFieldType[]  types  int[]  values  Chronology  chronology  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  types  Partial  iPartial  DateTimeFieldType  loopType  int[]  iValues  values  Chronology  chrono  chronology  iChronology  DurationField  lastRangeField  lastUnitField  loopRangeField  loopUnitField  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  compare  i  iFieldIndex  value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.4472135954999579	223	223	1	add	if(loopType.getRangeDurationType()  ==  null  ||  loopType.getRangeDurationType().getField(iChronology)  ==  null)  {	  if(loopType.getRangeDurationType()    ==    null    ||    loopType.getRangeDurationType()    ==    null)    {    	compilable	  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange	273	1	replace
255	[BUG]  [BUGGY]  if(loopType.getRangeDurationType()  ==  null  ||  loopType.getRangeDurationType().getField(iChronology)  ==  null)  {  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange  [CONTEXT]    for  (int  i  =  0;  i  <  types.length;  i++)  {  DateTimeFieldType  loopType  =  types[i];  DurationField  loopUnitField  =  loopType.getDurationType().getField(iChronology);  if  (i  >  0)  {  int  compare  =  lastUnitField.compareTo(loopUnitField);  if  (compare  <  0  ||  (compare  !=  0  &&  loopUnitField.isSupported()  ==  false))  {  throw  new  IllegalArgumentException(   "Types  array  must  be  in  order  largest-smallest:     "  +  types[i  -  1].getName()  +     "  <     "  +  loopType.getName());  }  else  if  (compare  ==  0)  {  if  (types[i  -  1].getRangeDurationType()  ==  null)  {    [BUGGY]  if(loopType.getRangeDurationType()  ==  null  ||  loopType.getRangeDurationType().getField(iChronology)  ==  null)  {  [BUGGY]    throw  new  IllegalArgumentException(   "Types  array  must  not  contain  duplicate:     "  +  types[i  -  1].getName()  +     "  and     "  +  loopType.getName());  }  }  else  {  if  (loopType.getRangeDurationType()  ==  null)  {  throw  new  IllegalArgumentException(   "Types  array  must  be  in  order  largest-smallest:     "  +  types[i  -  1].getName()  +     "  <     "  +  loopType.getName());  }  DurationField  lastRangeField  =  types[i  -  1].getRangeDurationType().getField(iChronology);  DurationField  loopRangeField  =  loopType.getRangeDurationType().getField(iChronology);  [CLASS]  Partial  Property  [METHOD]  <init>  [RETURN_TYPE]  Chronology)  DateTimeFieldType[]  types  int[]  values  Chronology  chronology  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  types  Partial  iPartial  DateTimeFieldType  loopType  int[]  iValues  values  Chronology  chrono  chronology  iChronology  DurationField  lastRangeField  lastUnitField  loopRangeField  loopUnitField  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  compare  i  iFieldIndex  value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.4472135954999579	223	223	1	replace	if(loopType.getRangeDurationType()  ==  null  ||  loopType.getRangeDurationType().getField(iChronology)  ==  null)  {	  if(loopType.getRangeDurationType()    ==    null    ||    loopType.getRangeDurationType()    ==    null)    {    	compilable	  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange	273	1	replace
321	[BUG]  [BUGGY]  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange  [CONTEXT]    public  Partial(DateTimeFieldType  type,  int  value,  Chronology  chronology)  {  super();    [BUGGY]      chronology  =  DateTimeUtils.getChronology(chronology);  chronology  =  DateTimeUtils.getChronology(chronology);  [BUGGY]    chronology  =  DateTimeUtils.getChronology(chronology).withUTC();  iChronology  =  chronology;  if  (type  ==  null)  {  throw  new  IllegalArgumentException(   "The  field  type  must  not  be  null   ");  }  iTypes  =  new  DateTimeFieldType[]  {type};  iValues  =  new  int[]  {value};  chronology.validate(this,  iValues);  }  [CLASS]  Partial  Property  [METHOD]  <init>  [RETURN_TYPE]  Chronology)  DateTimeFieldType  type  int  value  Chronology  chronology  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  Partial  iPartial  DateTimeFieldType  type  int[]  iValues  Chronology  chrono  chronology  iChronology  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  iFieldIndex  value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.2886751345948129	154	154	1	add	        chronology    =    DateTimeUtils.getChronology(chronology);    chronology  =  DateTimeUtils.getChronology(chronology);	  	compilable	  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange	92	1	add
322	[BUG]  [BUGGY]      chronology  =  DateTimeUtils.getChronology(chronology);  chronology  =  DateTimeUtils.getChronology(chronology);  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange  [CONTEXT]    public  Partial(DateTimeFieldType  type,  int  value,  Chronology  chronology)  {  super();    [BUGGY]      chronology  =  DateTimeUtils.getChronology(chronology);  chronology  =  DateTimeUtils.getChronology(chronology);  [BUGGY]    chronology  =  DateTimeUtils.getChronology(chronology).withUTC();  iChronology  =  chronology;  if  (type  ==  null)  {  throw  new  IllegalArgumentException(   "The  field  type  must  not  be  null   ");  }  iTypes  =  new  DateTimeFieldType[]  {type};  iValues  =  new  int[]  {value};  chronology.validate(this,  iValues);  }  [CLASS]  Partial  Property  [METHOD]  <init>  [RETURN_TYPE]  Chronology)  DateTimeFieldType  type  int  value  Chronology  chronology  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  Partial  iPartial  DateTimeFieldType  type  int[]  iValues  Chronology  chrono  chronology  iChronology  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  iFieldIndex  value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.2886751345948129	154	154	1	replace	        chronology    =    DateTimeUtils.getChronology(chronology);    chronology  =  DateTimeUtils.getChronology(chronology);	  	compilable	  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange	92	1	add
322	[BUG]  [BUGGY]  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange  [CONTEXT]    public  Partial(DateTimeFieldType  type,  int  value,  Chronology  chronology)  {  super();    [BUGGY]      chronology  =  DateTimeUtils.getChronology(chronology);  chronology  =  DateTimeUtils.getChronology(chronology).withUTC();  [BUGGY]    chronology  =  DateTimeUtils.getChronology(chronology).withUTC();  iChronology  =  chronology;  if  (type  ==  null)  {  throw  new  IllegalArgumentException(   "The  field  type  must  not  be  null   ");  }  iTypes  =  new  DateTimeFieldType[]  {type};  iValues  =  new  int[]  {value};  chronology.validate(this,  iValues);  }  [CLASS]  Partial  Property  [METHOD]  <init>  [RETURN_TYPE]  Chronology)  DateTimeFieldType  type  int  value  Chronology  chronology  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  Partial  iPartial  DateTimeFieldType  type  int[]  iValues  Chronology  chrono  chronology  iChronology  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  iFieldIndex  value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.2886751345948129	154	154	1	add	        chronology    =    DateTimeUtils.getChronology(chronology);    chronology  =  DateTimeUtils.getChronology(chronology).withUTC();	  	compilable	  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange	92	1	add
323	[BUG]  [BUGGY]      chronology  =  DateTimeUtils.getChronology(chronology);  chronology  =  DateTimeUtils.getChronology(chronology).withUTC();  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange  [CONTEXT]    public  Partial(DateTimeFieldType  type,  int  value,  Chronology  chronology)  {  super();    [BUGGY]      chronology  =  DateTimeUtils.getChronology(chronology);  chronology  =  DateTimeUtils.getChronology(chronology).withUTC();  [BUGGY]    chronology  =  DateTimeUtils.getChronology(chronology).withUTC();  iChronology  =  chronology;  if  (type  ==  null)  {  throw  new  IllegalArgumentException(   "The  field  type  must  not  be  null   ");  }  iTypes  =  new  DateTimeFieldType[]  {type};  iValues  =  new  int[]  {value};  chronology.validate(this,  iValues);  }  [CLASS]  Partial  Property  [METHOD]  <init>  [RETURN_TYPE]  Chronology)  DateTimeFieldType  type  int  value  Chronology  chronology  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  Partial  iPartial  DateTimeFieldType  type  int[]  iValues  Chronology  chrono  chronology  iChronology  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  iFieldIndex  value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.2886751345948129	154	154	1	replace	        chronology    =    DateTimeUtils.getChronology(chronology);    chronology  =  DateTimeUtils.getChronology(chronology).withUTC();	  	compilable	  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange	92	1	add
341	[BUG]  [BUGGY]  [FE]  NullPointerException  testWith_baseAndArgHaveNoRange  [CONTEXT]    DateTimeFieldType  loopType  =  types[i];  DurationField  loopUnitField  =  loopType.getDurationType().getField(iChronology);  if  (i  >  0)  {  int  compare  =  lastUnitField.compareTo(loopUnitField);  if  (compare  <  0  ||  (compare  !=  0  &&  loopUnitField.isSupported()  ==  false))  {  throw  new  IllegalArgumentException(   "Types  array  must  be  in  order  largest-smallest:     "  +  types[i  -  1].getName()  +     "  <     "  +  loopType.getName());  }  else  if  (compare  ==  0)  {  if  (types[i  -  1].getRangeDurationType()  ==  null)  {  if  (loopType.getRangeDurationType()  ==  null)  {    [BUGGY]  if(types[i  -  1].getRangeDurationType().getField(iChronology)!=  null)  {  throw  new  IllegalArgumentException( " ");  }  [BUGGY]    throw  new  IllegalArgumentException(   "Types  array  must  not  contain  duplicate:     "  +            types[i  -  1].getName()  +     "  and     "  +  loopType.getName());  types[i  -  1].getName()  +     "  and     "  +  loopType.getName());  }  }  else  {  if  (loopType.getRangeDurationType()  ==  null)  {  throw  new  IllegalArgumentException(   "Types  array  must  be  in  order  largest-smallest:     "  +  types[i  -  1].getName()  +     "  <     "  +  loopType.getName());  }  DurationField  lastRangeField  =  types[i  -  1].getRangeDurationType().getField(iChronology);  DurationField  loopRangeField  =  loopType.getRangeDurationType().getField(iChronology);  if  (lastRangeField.compareTo(loopRangeField)  <  0)  {  [CLASS]  Partial  Property  [METHOD]  <init>  [RETURN_TYPE]  Chronology)  DateTimeFieldType[]  types  int[]  values  Chronology  chronology  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  types  Partial  iPartial  DateTimeFieldType  loopType  int[]  iValues  values  Chronology  chrono  chronology  iChronology  DurationField  lastRangeField  lastUnitField  loopRangeField  loopUnitField  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  compare  i  iFieldIndex  value  	projects/Time2/src/main/java/org/joda/time/Partial.java	1.0	224	225	1	add	if(types[i  -  1].getRangeDurationType().getField(iChronology)!=  null)  {  throw  new  IllegalArgumentException( " ");  }	      if(loopType.getRangeDurationType().getField(iChronology)    ==    null)    {    throw    new    IllegalArgumentException(   "   ");    }    	compilable	  [FE]  NullPointerException  testWith_baseAndArgHaveNoRange	182	1	replace
342	[BUG]  [BUGGY]  if(types[i  -  1].getRangeDurationType().getField(iChronology)!=  null)  {  throw  new  IllegalArgumentException( " ");  }  [FE]  NullPointerException  testWith_baseAndArgHaveNoRange  [CONTEXT]    DateTimeFieldType  loopType  =  types[i];  DurationField  loopUnitField  =  loopType.getDurationType().getField(iChronology);  if  (i  >  0)  {  int  compare  =  lastUnitField.compareTo(loopUnitField);  if  (compare  <  0  ||  (compare  !=  0  &&  loopUnitField.isSupported()  ==  false))  {  throw  new  IllegalArgumentException(   "Types  array  must  be  in  order  largest-smallest:     "  +  types[i  -  1].getName()  +     "  <     "  +  loopType.getName());  }  else  if  (compare  ==  0)  {  if  (types[i  -  1].getRangeDurationType()  ==  null)  {  if  (loopType.getRangeDurationType()  ==  null)  {    [BUGGY]  if(types[i  -  1].getRangeDurationType().getField(iChronology)!=  null)  {  throw  new  IllegalArgumentException( " ");  }  [BUGGY]    throw  new  IllegalArgumentException(   "Types  array  must  not  contain  duplicate:     "  +            types[i  -  1].getName()  +     "  and     "  +  loopType.getName());  types[i  -  1].getName()  +     "  and     "  +  loopType.getName());  }  }  else  {  if  (loopType.getRangeDurationType()  ==  null)  {  throw  new  IllegalArgumentException(   "Types  array  must  be  in  order  largest-smallest:     "  +  types[i  -  1].getName()  +     "  <     "  +  loopType.getName());  }  DurationField  lastRangeField  =  types[i  -  1].getRangeDurationType().getField(iChronology);  DurationField  loopRangeField  =  loopType.getRangeDurationType().getField(iChronology);  if  (lastRangeField.compareTo(loopRangeField)  <  0)  {  [CLASS]  Partial  Property  [METHOD]  <init>  [RETURN_TYPE]  Chronology)  DateTimeFieldType[]  types  int[]  values  Chronology  chronology  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  types  Partial  iPartial  DateTimeFieldType  loopType  int[]  iValues  values  Chronology  chrono  chronology  iChronology  DurationField  lastRangeField  lastUnitField  loopRangeField  loopUnitField  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  compare  i  iFieldIndex  value  	projects/Time2/src/main/java/org/joda/time/Partial.java	1.0	224	225	1	replace	if(types[i  -  1].getRangeDurationType().getField(iChronology)!=  null)  {  throw  new  IllegalArgumentException( " ");  }	      if(loopType.getRangeDurationType().getField(iChronology)    ==    null)    {    throw    new    IllegalArgumentException(   "   ");    }    	compilable	  [FE]  NullPointerException  testWith_baseAndArgHaveNoRange	182	1	replace
344	[BUG]  [BUGGY]  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange  [CONTEXT]    DateTimeFieldType  loopType  =  types[i];  DurationField  loopUnitField  =  loopType.getDurationType().getField(iChronology);  if  (i  >  0)  {  int  compare  =  lastUnitField.compareTo(loopUnitField);  if  (compare  <  0  ||  (compare  !=  0  &&  loopUnitField.isSupported()  ==  false))  {  throw  new  IllegalArgumentException(   "Types  array  must  be  in  order  largest-smallest:     "  +  types[i  -  1].getName()  +     "  <     "  +  loopType.getName());  }  else  if  (compare  ==  0)  {  if  (types[i  -  1].getRangeDurationType()  ==  null)  {  if  (loopType.getRangeDurationType()  ==  null)  {    [BUGGY]  if(types[i  -  1].getRangeDurationType()  ==  null)  {  throw  new  IllegalArgumentException( " ");  }  [BUGGY]    throw  new  IllegalArgumentException(   "Types  array  must  not  contain  duplicate:     "  +            types[i  -  1].getName()  +     "  and     "  +  loopType.getName());  types[i  -  1].getName()  +     "  and     "  +  loopType.getName());  }  }  else  {  if  (loopType.getRangeDurationType()  ==  null)  {  throw  new  IllegalArgumentException(   "Types  array  must  be  in  order  largest-smallest:     "  +  types[i  -  1].getName()  +     "  <     "  +  loopType.getName());  }  DurationField  lastRangeField  =  types[i  -  1].getRangeDurationType().getField(iChronology);  DurationField  loopRangeField  =  loopType.getRangeDurationType().getField(iChronology);  if  (lastRangeField.compareTo(loopRangeField)  <  0)  {  [CLASS]  Partial  Property  [METHOD]  <init>  [RETURN_TYPE]  Chronology)  DateTimeFieldType[]  types  int[]  values  Chronology  chronology  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  types  Partial  iPartial  DateTimeFieldType  loopType  int[]  iValues  values  Chronology  chrono  chronology  iChronology  DurationField  lastRangeField  lastUnitField  loopRangeField  loopUnitField  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  compare  i  iFieldIndex  value  	projects/Time2/src/main/java/org/joda/time/Partial.java	1.0	224	225	1	add	if(types[i  -  1].getRangeDurationType()  ==  null)  {  throw  new  IllegalArgumentException( " ");  }	      if(loopType.getRangeDurationType().getField(iChronology)    ==    null)    {    throw    new    IllegalArgumentException(   "   ");    }    	compilable	  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange	182	1	replace
345	[BUG]  [BUGGY]  if(types[i  -  1].getRangeDurationType()  ==  null)  {  throw  new  IllegalArgumentException( " ");  }  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange  [CONTEXT]    DateTimeFieldType  loopType  =  types[i];  DurationField  loopUnitField  =  loopType.getDurationType().getField(iChronology);  if  (i  >  0)  {  int  compare  =  lastUnitField.compareTo(loopUnitField);  if  (compare  <  0  ||  (compare  !=  0  &&  loopUnitField.isSupported()  ==  false))  {  throw  new  IllegalArgumentException(   "Types  array  must  be  in  order  largest-smallest:     "  +  types[i  -  1].getName()  +     "  <     "  +  loopType.getName());  }  else  if  (compare  ==  0)  {  if  (types[i  -  1].getRangeDurationType()  ==  null)  {  if  (loopType.getRangeDurationType()  ==  null)  {    [BUGGY]  if(types[i  -  1].getRangeDurationType()  ==  null)  {  throw  new  IllegalArgumentException( " ");  }  [BUGGY]    throw  new  IllegalArgumentException(   "Types  array  must  not  contain  duplicate:     "  +            types[i  -  1].getName()  +     "  and     "  +  loopType.getName());  types[i  -  1].getName()  +     "  and     "  +  loopType.getName());  }  }  else  {  if  (loopType.getRangeDurationType()  ==  null)  {  throw  new  IllegalArgumentException(   "Types  array  must  be  in  order  largest-smallest:     "  +  types[i  -  1].getName()  +     "  <     "  +  loopType.getName());  }  DurationField  lastRangeField  =  types[i  -  1].getRangeDurationType().getField(iChronology);  DurationField  loopRangeField  =  loopType.getRangeDurationType().getField(iChronology);  if  (lastRangeField.compareTo(loopRangeField)  <  0)  {  [CLASS]  Partial  Property  [METHOD]  <init>  [RETURN_TYPE]  Chronology)  DateTimeFieldType[]  types  int[]  values  Chronology  chronology  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  types  Partial  iPartial  DateTimeFieldType  loopType  int[]  iValues  values  Chronology  chrono  chronology  iChronology  DurationField  lastRangeField  lastUnitField  loopRangeField  loopUnitField  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  compare  i  iFieldIndex  value  	projects/Time2/src/main/java/org/joda/time/Partial.java	1.0	224	225	1	replace	if(types[i  -  1].getRangeDurationType()  ==  null)  {  throw  new  IllegalArgumentException( " ");  }	      if(loopType.getRangeDurationType().getField(iChronology)    ==    null)    {    throw    new    IllegalArgumentException(   "   ");    }    	compilable	  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange	182	1	replace
362	[BUG]  [BUGGY]  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange  [CONTEXT]    public  Partial(DateTimeFieldType  type,  int  value,  Chronology  chronology)  {  super();    [BUGGY]  if(chronology  ==  null)  {  chronology  =  DateTimeUtils.getChronology(chronology);  }  else  {  throw  new  IllegalArgumentException( " ");  }  [BUGGY]    chronology  =  DateTimeUtils.getChronology(chronology).withUTC();  iChronology  =  chronology;  if  (type  ==  null)  {  throw  new  IllegalArgumentException(   "The  field  type  must  not  be  null   ");  }  iTypes  =  new  DateTimeFieldType[]  {type};  iValues  =  new  int[]  {value};  chronology.validate(this,  iValues);  }  [CLASS]  Partial  Property  [METHOD]  <init>  [RETURN_TYPE]  Chronology)  DateTimeFieldType  type  int  value  Chronology  chronology  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  Partial  iPartial  DateTimeFieldType  type  int[]  iValues  Chronology  chrono  chronology  iChronology  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  iFieldIndex  value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.2886751345948129	154	154	1	add	if(chronology  ==  null)  {  chronology  =  DateTimeUtils.getChronology(chronology);  }  else  {  throw  new  IllegalArgumentException( " ");  }	      chronology    =    DateTimeUtils.getChronology(chronology);    	compilable	  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange	93	1	replace
363	[BUG]  [BUGGY]  if(chronology  ==  null)  {  chronology  =  DateTimeUtils.getChronology(chronology);  }  else  {  throw  new  IllegalArgumentException( " ");  }  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange  [CONTEXT]    public  Partial(DateTimeFieldType  type,  int  value,  Chronology  chronology)  {  super();    [BUGGY]  if(chronology  ==  null)  {  chronology  =  DateTimeUtils.getChronology(chronology);  }  else  {  throw  new  IllegalArgumentException( " ");  }  [BUGGY]    chronology  =  DateTimeUtils.getChronology(chronology).withUTC();  iChronology  =  chronology;  if  (type  ==  null)  {  throw  new  IllegalArgumentException(   "The  field  type  must  not  be  null   ");  }  iTypes  =  new  DateTimeFieldType[]  {type};  iValues  =  new  int[]  {value};  chronology.validate(this,  iValues);  }  [CLASS]  Partial  Property  [METHOD]  <init>  [RETURN_TYPE]  Chronology)  DateTimeFieldType  type  int  value  Chronology  chronology  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  Partial  iPartial  DateTimeFieldType  type  int[]  iValues  Chronology  chrono  chronology  iChronology  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  iFieldIndex  value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.2886751345948129	154	154	1	replace	if(chronology  ==  null)  {  chronology  =  DateTimeUtils.getChronology(chronology);  }  else  {  throw  new  IllegalArgumentException( " ");  }	      chronology    =    DateTimeUtils.getChronology(chronology);    	compilable	  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange	93	1	replace
363	[BUG]  [BUGGY]  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange  [CONTEXT]    public  Partial(DateTimeFieldType  type,  int  value,  Chronology  chronology)  {  super();    [BUGGY]  if(chronology  ==  null)  {  chronology  =  DateTimeUtils.getChronology(chronology);  }  else  {  throw  new  IllegalArgumentException( "The  field  type  must  not  be  null ");  }  [BUGGY]    chronology  =  DateTimeUtils.getChronology(chronology).withUTC();  iChronology  =  chronology;  if  (type  ==  null)  {  throw  new  IllegalArgumentException(   "The  field  type  must  not  be  null   ");  }  iTypes  =  new  DateTimeFieldType[]  {type};  iValues  =  new  int[]  {value};  chronology.validate(this,  iValues);  }  [CLASS]  Partial  Property  [METHOD]  <init>  [RETURN_TYPE]  Chronology)  DateTimeFieldType  type  int  value  Chronology  chronology  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  Partial  iPartial  DateTimeFieldType  type  int[]  iValues  Chronology  chrono  chronology  iChronology  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  iFieldIndex  value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.2886751345948129	154	154	1	add	if(chronology  ==  null)  {  chronology  =  DateTimeUtils.getChronology(chronology);  }  else  {  throw  new  IllegalArgumentException( "The  field  type  must  not  be  null ");  }	      chronology    =    DateTimeUtils.getChronology(chronology);    	compilable	  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange	93	1	replace
364	[BUG]  [BUGGY]  if(chronology  ==  null)  {  chronology  =  DateTimeUtils.getChronology(chronology);  }  else  {  throw  new  IllegalArgumentException( "The  field  type  must  not  be  null ");  }  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange  [CONTEXT]    public  Partial(DateTimeFieldType  type,  int  value,  Chronology  chronology)  {  super();    [BUGGY]  if(chronology  ==  null)  {  chronology  =  DateTimeUtils.getChronology(chronology);  }  else  {  throw  new  IllegalArgumentException( "The  field  type  must  not  be  null ");  }  [BUGGY]    chronology  =  DateTimeUtils.getChronology(chronology).withUTC();  iChronology  =  chronology;  if  (type  ==  null)  {  throw  new  IllegalArgumentException(   "The  field  type  must  not  be  null   ");  }  iTypes  =  new  DateTimeFieldType[]  {type};  iValues  =  new  int[]  {value};  chronology.validate(this,  iValues);  }  [CLASS]  Partial  Property  [METHOD]  <init>  [RETURN_TYPE]  Chronology)  DateTimeFieldType  type  int  value  Chronology  chronology  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  Partial  iPartial  DateTimeFieldType  type  int[]  iValues  Chronology  chrono  chronology  iChronology  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  iFieldIndex  value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.2886751345948129	154	154	1	replace	if(chronology  ==  null)  {  chronology  =  DateTimeUtils.getChronology(chronology);  }  else  {  throw  new  IllegalArgumentException( "The  field  type  must  not  be  null ");  }	      chronology    =    DateTimeUtils.getChronology(chronology);    	compilable	  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange	93	1	replace
364	[BUG]  [BUGGY]  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange  [CONTEXT]    public  Partial(DateTimeFieldType  type,  int  value,  Chronology  chronology)  {  super();    [BUGGY]  if(chronology  ==  null)  {  chronology  =  DateTimeUtils.getChronology(chronology);  }  else  {  throw  new  IllegalArgumentException( "The  field  type  must  not  be  null. ");  }  [BUGGY]    chronology  =  DateTimeUtils.getChronology(chronology).withUTC();  iChronology  =  chronology;  if  (type  ==  null)  {  throw  new  IllegalArgumentException(   "The  field  type  must  not  be  null   ");  }  iTypes  =  new  DateTimeFieldType[]  {type};  iValues  =  new  int[]  {value};  chronology.validate(this,  iValues);  }  [CLASS]  Partial  Property  [METHOD]  <init>  [RETURN_TYPE]  Chronology)  DateTimeFieldType  type  int  value  Chronology  chronology  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  Partial  iPartial  DateTimeFieldType  type  int[]  iValues  Chronology  chrono  chronology  iChronology  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  iFieldIndex  value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.2886751345948129	154	154	1	add	if(chronology  ==  null)  {  chronology  =  DateTimeUtils.getChronology(chronology);  }  else  {  throw  new  IllegalArgumentException( "The  field  type  must  not  be  null. ");  }	      chronology    =    DateTimeUtils.getChronology(chronology);    	compilable	  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange	93	1	replace
365	[BUG]  [BUGGY]  if(chronology  ==  null)  {  chronology  =  DateTimeUtils.getChronology(chronology);  }  else  {  throw  new  IllegalArgumentException( "The  field  type  must  not  be  null. ");  }  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange  [CONTEXT]    public  Partial(DateTimeFieldType  type,  int  value,  Chronology  chronology)  {  super();    [BUGGY]  if(chronology  ==  null)  {  chronology  =  DateTimeUtils.getChronology(chronology);  }  else  {  throw  new  IllegalArgumentException( "The  field  type  must  not  be  null. ");  }  [BUGGY]    chronology  =  DateTimeUtils.getChronology(chronology).withUTC();  iChronology  =  chronology;  if  (type  ==  null)  {  throw  new  IllegalArgumentException(   "The  field  type  must  not  be  null   ");  }  iTypes  =  new  DateTimeFieldType[]  {type};  iValues  =  new  int[]  {value};  chronology.validate(this,  iValues);  }  [CLASS]  Partial  Property  [METHOD]  <init>  [RETURN_TYPE]  Chronology)  DateTimeFieldType  type  int  value  Chronology  chronology  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  Partial  iPartial  DateTimeFieldType  type  int[]  iValues  Chronology  chrono  chronology  iChronology  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  iFieldIndex  value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.2886751345948129	154	154	1	replace	if(chronology  ==  null)  {  chronology  =  DateTimeUtils.getChronology(chronology);  }  else  {  throw  new  IllegalArgumentException( "The  field  type  must  not  be  null. ");  }	      chronology    =    DateTimeUtils.getChronology(chronology);    	compilable	  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange	93	1	replace
243	[BUG]  [BUGGY]  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange  [CONTEXT]    DateTimeFieldType  loopType  =  types[i];  DurationField  loopUnitField  =  loopType.getDurationType().getField(iChronology);  if  (i  >  0)  {  int  compare  =  lastUnitField.compareTo(loopUnitField);  if  (compare  <  0  ||  (compare  !=  0  &&  loopUnitField.isSupported()  ==  false))  {  throw  new  IllegalArgumentException(   "Types  array  must  be  in  order  largest-smallest:     "  +  types[i  -  1].getName()  +     "  <     "  +  loopType.getName());  }  else  if  (compare  ==  0)  {  if  (types[i  -  1].getRangeDurationType()  ==  null)  {  if  (loopType.getRangeDurationType()  ==  null)  {    [BUGGY]  throw  new  IllegalArgumentException( "Types  array  must  not  contain  duplicate: "  +  types[i  -  1].getName()  + "  consulted  with   "  +  loopType.getName());  [BUGGY]    types[i  -  1].getName()  +     "  and     "  +  loopType.getName());  }  }  else  {  if  (loopType.getRangeDurationType()  ==  null)  {  throw  new  IllegalArgumentException(   "Types  array  must  be  in  order  largest-smallest:     "  +  types[i  -  1].getName()  +     "  <     "  +  loopType.getName());  }  DurationField  lastRangeField  =  types[i  -  1].getRangeDurationType().getField(iChronology);  DurationField  loopRangeField  =  loopType.getRangeDurationType().getField(iChronology);  if  (lastRangeField.compareTo(loopRangeField)  <  0)  {  [CLASS]  Partial  Property  [METHOD]  <init>  [RETURN_TYPE]  Chronology)  DateTimeFieldType[]  types  int[]  values  Chronology  chronology  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  types  Partial  iPartial  DateTimeFieldType  loopType  int[]  iValues  values  Chronology  chrono  chronology  iChronology  DurationField  lastRangeField  lastUnitField  loopRangeField  loopUnitField  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  compare  i  iFieldIndex  value  	projects/Time2/src/main/java/org/joda/time/Partial.java	1.0	224	225	1	add	throw  new  IllegalArgumentException( "Types  array  must  not  contain  duplicate: "  +  types[i  -  1].getName()  + "  consulted  with   "  +  loopType.getName());	  throw    new    IllegalArgumentException(   "Types    array    must    not    contain    duplicate:   "    +    types[i    -    1].getName()    +   "    consulted       "    +    loopType.getName());    	compilable	  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange	5	1	replace
244	[BUG]  [BUGGY]  throw  new  IllegalArgumentException( "Types  array  must  not  contain  duplicate: "  +  types[i  -  1].getName()  + "  consulted  with   "  +  loopType.getName());  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange  [CONTEXT]    DateTimeFieldType  loopType  =  types[i];  DurationField  loopUnitField  =  loopType.getDurationType().getField(iChronology);  if  (i  >  0)  {  int  compare  =  lastUnitField.compareTo(loopUnitField);  if  (compare  <  0  ||  (compare  !=  0  &&  loopUnitField.isSupported()  ==  false))  {  throw  new  IllegalArgumentException(   "Types  array  must  be  in  order  largest-smallest:     "  +  types[i  -  1].getName()  +     "  <     "  +  loopType.getName());  }  else  if  (compare  ==  0)  {  if  (types[i  -  1].getRangeDurationType()  ==  null)  {  if  (loopType.getRangeDurationType()  ==  null)  {    [BUGGY]  throw  new  IllegalArgumentException( "Types  array  must  not  contain  duplicate: "  +  types[i  -  1].getName()  + "  consulted  with   "  +  loopType.getName());  [BUGGY]    types[i  -  1].getName()  +     "  and     "  +  loopType.getName());  }  }  else  {  if  (loopType.getRangeDurationType()  ==  null)  {  throw  new  IllegalArgumentException(   "Types  array  must  be  in  order  largest-smallest:     "  +  types[i  -  1].getName()  +     "  <     "  +  loopType.getName());  }  DurationField  lastRangeField  =  types[i  -  1].getRangeDurationType().getField(iChronology);  DurationField  loopRangeField  =  loopType.getRangeDurationType().getField(iChronology);  if  (lastRangeField.compareTo(loopRangeField)  <  0)  {  [CLASS]  Partial  Property  [METHOD]  <init>  [RETURN_TYPE]  Chronology)  DateTimeFieldType[]  types  int[]  values  Chronology  chronology  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  types  Partial  iPartial  DateTimeFieldType  loopType  int[]  iValues  values  Chronology  chrono  chronology  iChronology  DurationField  lastRangeField  lastUnitField  loopRangeField  loopUnitField  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  compare  i  iFieldIndex  value  	projects/Time2/src/main/java/org/joda/time/Partial.java	1.0	224	225	1	replace	throw  new  IllegalArgumentException( "Types  array  must  not  contain  duplicate: "  +  types[i  -  1].getName()  + "  consulted  with   "  +  loopType.getName());	  throw    new    IllegalArgumentException(   "Types    array    must    not    contain    duplicate:   "    +    types[i    -    1].getName()    +   "    consulted       "    +    loopType.getName());    	compilable	  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange	5	1	replace
632	[BUG]  [BUGGY]  [FE]  NullPointerException  testWith_baseAndArgHaveNoRange  [CONTEXT]    DateTimeFieldType  loopType  =  types[i];  DurationField  loopUnitField  =  loopType.getDurationType().getField(iChronology);  if  (i  >  0)  {  int  compare  =  lastUnitField.compareTo(loopUnitField);  if  (compare  <  0  ||  (compare  !=  0  &&  loopUnitField.isSupported()  ==  false))  {  throw  new  IllegalArgumentException(   "Types  array  must  be  in  order  largest-smallest:     "  +  types[i  -  1].getName()  +     "  <     "  +  loopType.getName());  }  else  if  (compare  ==  0)  {  if  (types[i  -  1].getRangeDurationType()  ==  null)  {  if  (loopType.getRangeDurationType()  ==  null)  {    [BUGGY]  if(types[i  -  1].getRangeDurationType().getField(iChronology)  ==  null)  {  throw  new  IllegalArgumentException( " ");  }  [BUGGY]    throw  new  IllegalArgumentException(   "Types  array  must  not  contain  duplicate:     "  +            types[i  -  1].getName()  +     "  and     "  +  loopType.getName());  types[i  -  1].getName()  +     "  and     "  +  loopType.getName());  }  }  else  {  if  (loopType.getRangeDurationType()  ==  null)  {  throw  new  IllegalArgumentException(   "Types  array  must  be  in  order  largest-smallest:     "  +  types[i  -  1].getName()  +     "  <     "  +  loopType.getName());  }  DurationField  lastRangeField  =  types[i  -  1].getRangeDurationType().getField(iChronology);  DurationField  loopRangeField  =  loopType.getRangeDurationType().getField(iChronology);  if  (lastRangeField.compareTo(loopRangeField)  <  0)  {  [CLASS]  Partial  Property  [METHOD]  <init>  [RETURN_TYPE]  Chronology)  DateTimeFieldType[]  types  int[]  values  Chronology  chronology  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  types  Partial  iPartial  DateTimeFieldType  loopType  int[]  iValues  values  Chronology  chrono  chronology  iChronology  DurationField  lastRangeField  lastUnitField  loopRangeField  loopUnitField  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  compare  i  iFieldIndex  value  	projects/Time2/src/main/java/org/joda/time/Partial.java	1.0	224	225	1	add	if(types[i  -  1].getRangeDurationType().getField(iChronology)  ==  null)  {  throw  new  IllegalArgumentException( " ");  }	      if(loopType.getRangeDurationType().getField(iChronology)    ==    null)    {    throw    new    IllegalArgumentException(   "   ");    }    	compilable	  [FE]  NullPointerException  testWith_baseAndArgHaveNoRange	182	1	replace
633	[BUG]  [BUGGY]  if(types[i  -  1].getRangeDurationType().getField(iChronology)  ==  null)  {  throw  new  IllegalArgumentException( " ");  }  [FE]  NullPointerException  testWith_baseAndArgHaveNoRange  [CONTEXT]    DateTimeFieldType  loopType  =  types[i];  DurationField  loopUnitField  =  loopType.getDurationType().getField(iChronology);  if  (i  >  0)  {  int  compare  =  lastUnitField.compareTo(loopUnitField);  if  (compare  <  0  ||  (compare  !=  0  &&  loopUnitField.isSupported()  ==  false))  {  throw  new  IllegalArgumentException(   "Types  array  must  be  in  order  largest-smallest:     "  +  types[i  -  1].getName()  +     "  <     "  +  loopType.getName());  }  else  if  (compare  ==  0)  {  if  (types[i  -  1].getRangeDurationType()  ==  null)  {  if  (loopType.getRangeDurationType()  ==  null)  {    [BUGGY]  if(types[i  -  1].getRangeDurationType().getField(iChronology)  ==  null)  {  throw  new  IllegalArgumentException( " ");  }  [BUGGY]    throw  new  IllegalArgumentException(   "Types  array  must  not  contain  duplicate:     "  +            types[i  -  1].getName()  +     "  and     "  +  loopType.getName());  types[i  -  1].getName()  +     "  and     "  +  loopType.getName());  }  }  else  {  if  (loopType.getRangeDurationType()  ==  null)  {  throw  new  IllegalArgumentException(   "Types  array  must  be  in  order  largest-smallest:     "  +  types[i  -  1].getName()  +     "  <     "  +  loopType.getName());  }  DurationField  lastRangeField  =  types[i  -  1].getRangeDurationType().getField(iChronology);  DurationField  loopRangeField  =  loopType.getRangeDurationType().getField(iChronology);  if  (lastRangeField.compareTo(loopRangeField)  <  0)  {  [CLASS]  Partial  Property  [METHOD]  <init>  [RETURN_TYPE]  Chronology)  DateTimeFieldType[]  types  int[]  values  Chronology  chronology  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  types  Partial  iPartial  DateTimeFieldType  loopType  int[]  iValues  values  Chronology  chrono  chronology  iChronology  DurationField  lastRangeField  lastUnitField  loopRangeField  loopUnitField  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  compare  i  iFieldIndex  value  	projects/Time2/src/main/java/org/joda/time/Partial.java	1.0	224	225	1	replace	if(types[i  -  1].getRangeDurationType().getField(iChronology)  ==  null)  {  throw  new  IllegalArgumentException( " ");  }	      if(loopType.getRangeDurationType().getField(iChronology)    ==    null)    {    throw    new    IllegalArgumentException(   "   ");    }    	compilable	  [FE]  NullPointerException  testWith_baseAndArgHaveNoRange	182	1	replace
814	[BUG]  [BUGGY]  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange  [CONTEXT]    DateTimeFieldType  loopType  =  types[i];  DurationField  loopUnitField  =  loopType.getDurationType().getField(iChronology);  if  (i  >  0)  {  int  compare  =  lastUnitField.compareTo(loopUnitField);  if  (compare  <  0  ||  (compare  !=  0  &&  loopUnitField.isSupported()  ==  false))  {  throw  new  IllegalArgumentException(   "Types  array  must  be  in  order  largest-smallest:     "  +  types[i  -  1].getName()  +     "  <     "  +  loopType.getName());  }  else  if  (compare  ==  0)  {  if  (types[i  -  1].getRangeDurationType()  ==  null)  {  if  (loopType.getRangeDurationType()  ==  null)  {    [BUGGY]  throw  new  IllegalArgumentException( "Types  array  must  not  contain  duplicate:   "  +  types[i  -  1].getName()  + ",  consulted   "  +  loopType.getName());  [BUGGY]    types[i  -  1].getName()  +     "  and     "  +  loopType.getName());  }  }  else  {  if  (loopType.getRangeDurationType()  ==  null)  {  throw  new  IllegalArgumentException(   "Types  array  must  be  in  order  largest-smallest:     "  +  types[i  -  1].getName()  +     "  <     "  +  loopType.getName());  }  DurationField  lastRangeField  =  types[i  -  1].getRangeDurationType().getField(iChronology);  DurationField  loopRangeField  =  loopType.getRangeDurationType().getField(iChronology);  if  (lastRangeField.compareTo(loopRangeField)  <  0)  {  [CLASS]  Partial  Property  [METHOD]  <init>  [RETURN_TYPE]  Chronology)  DateTimeFieldType[]  types  int[]  values  Chronology  chronology  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  types  Partial  iPartial  DateTimeFieldType  loopType  int[]  iValues  values  Chronology  chrono  chronology  iChronology  DurationField  lastRangeField  lastUnitField  loopRangeField  loopUnitField  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  compare  i  iFieldIndex  value  	projects/Time2/src/main/java/org/joda/time/Partial.java	1.0	224	225	1	add	throw  new  IllegalArgumentException( "Types  array  must  not  contain  duplicate:   "  +  types[i  -  1].getName()  + ",  consulted   "  +  loopType.getName());	  throw    new    IllegalArgumentException(   "Types    array    must    not    contain    duplicate:   "    +    types[i    -    1].getName()    +   "    consulted       "    +    loopType.getName());    	compilable	  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange	5	1	replace
815	[BUG]  [BUGGY]  throw  new  IllegalArgumentException( "Types  array  must  not  contain  duplicate:   "  +  types[i  -  1].getName()  + ",  consulted   "  +  loopType.getName());  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange  [CONTEXT]    DateTimeFieldType  loopType  =  types[i];  DurationField  loopUnitField  =  loopType.getDurationType().getField(iChronology);  if  (i  >  0)  {  int  compare  =  lastUnitField.compareTo(loopUnitField);  if  (compare  <  0  ||  (compare  !=  0  &&  loopUnitField.isSupported()  ==  false))  {  throw  new  IllegalArgumentException(   "Types  array  must  be  in  order  largest-smallest:     "  +  types[i  -  1].getName()  +     "  <     "  +  loopType.getName());  }  else  if  (compare  ==  0)  {  if  (types[i  -  1].getRangeDurationType()  ==  null)  {  if  (loopType.getRangeDurationType()  ==  null)  {    [BUGGY]  throw  new  IllegalArgumentException( "Types  array  must  not  contain  duplicate:   "  +  types[i  -  1].getName()  + ",  consulted   "  +  loopType.getName());  [BUGGY]    types[i  -  1].getName()  +     "  and     "  +  loopType.getName());  }  }  else  {  if  (loopType.getRangeDurationType()  ==  null)  {  throw  new  IllegalArgumentException(   "Types  array  must  be  in  order  largest-smallest:     "  +  types[i  -  1].getName()  +     "  <     "  +  loopType.getName());  }  DurationField  lastRangeField  =  types[i  -  1].getRangeDurationType().getField(iChronology);  DurationField  loopRangeField  =  loopType.getRangeDurationType().getField(iChronology);  if  (lastRangeField.compareTo(loopRangeField)  <  0)  {  [CLASS]  Partial  Property  [METHOD]  <init>  [RETURN_TYPE]  Chronology)  DateTimeFieldType[]  types  int[]  values  Chronology  chronology  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  types  Partial  iPartial  DateTimeFieldType  loopType  int[]  iValues  values  Chronology  chrono  chronology  iChronology  DurationField  lastRangeField  lastUnitField  loopRangeField  loopUnitField  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  compare  i  iFieldIndex  value  	projects/Time2/src/main/java/org/joda/time/Partial.java	1.0	224	225	1	replace	throw  new  IllegalArgumentException( "Types  array  must  not  contain  duplicate:   "  +  types[i  -  1].getName()  + ",  consulted   "  +  loopType.getName());	  throw    new    IllegalArgumentException(   "Types    array    must    not    contain    duplicate:   "    +    types[i    -    1].getName()    +   "    consulted       "    +    loopType.getName());    	compilable	  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange	5	1	replace
843	[BUG]  [BUGGY]  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange  [CONTEXT]    for  (int  i  =  0;  i  <  types.length;  i++)  {  DateTimeFieldType  loopType  =  types[i];  DurationField  loopUnitField  =  loopType.getDurationType().getField(iChronology);  if  (i  >  0)  {  int  compare  =  lastUnitField.compareTo(loopUnitField);  if  (compare  <  0  ||  (compare  !=  0  &&  loopUnitField.isSupported()  ==  false))  {  throw  new  IllegalArgumentException(   "Types  array  must  be  in  order  largest-smallest:     "  +  types[i  -  1].getName()  +     "  <     "  +  loopType.getName());  }  else  if  (compare  ==  0)  {  if  (types[i  -  1].getRangeDurationType()  ==  null)  {    [BUGGY]  if(loopType.getDurationType()  ==  null  ||  loopType.getRangeDurationType()  ==  null)  {  [BUGGY]    throw  new  IllegalArgumentException(   "Types  array  must  not  contain  duplicate:     "  +  types[i  -  1].getName()  +     "  and     "  +  loopType.getName());  }  }  else  {  if  (loopType.getRangeDurationType()  ==  null)  {  throw  new  IllegalArgumentException(   "Types  array  must  be  in  order  largest-smallest:     "  +  types[i  -  1].getName()  +     "  <     "  +  loopType.getName());  }  DurationField  lastRangeField  =  types[i  -  1].getRangeDurationType().getField(iChronology);  DurationField  loopRangeField  =  loopType.getRangeDurationType().getField(iChronology);  [CLASS]  Partial  Property  [METHOD]  <init>  [RETURN_TYPE]  Chronology)  DateTimeFieldType[]  types  int[]  values  Chronology  chronology  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  types  Partial  iPartial  DateTimeFieldType  loopType  int[]  iValues  values  Chronology  chrono  chronology  iChronology  DurationField  lastRangeField  lastUnitField  loopRangeField  loopUnitField  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  compare  i  iFieldIndex  value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.4472135954999579	223	223	1	add	if(loopType.getDurationType()  ==  null  ||  loopType.getRangeDurationType()  ==  null)  {	  if(loopType.getDurationType()    ==    null)    {    	compilable	  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange	324	1	replace
844	[BUG]  [BUGGY]  if(loopType.getDurationType()  ==  null  ||  loopType.getRangeDurationType()  ==  null)  {  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange  [CONTEXT]    for  (int  i  =  0;  i  <  types.length;  i++)  {  DateTimeFieldType  loopType  =  types[i];  DurationField  loopUnitField  =  loopType.getDurationType().getField(iChronology);  if  (i  >  0)  {  int  compare  =  lastUnitField.compareTo(loopUnitField);  if  (compare  <  0  ||  (compare  !=  0  &&  loopUnitField.isSupported()  ==  false))  {  throw  new  IllegalArgumentException(   "Types  array  must  be  in  order  largest-smallest:     "  +  types[i  -  1].getName()  +     "  <     "  +  loopType.getName());  }  else  if  (compare  ==  0)  {  if  (types[i  -  1].getRangeDurationType()  ==  null)  {    [BUGGY]  if(loopType.getDurationType()  ==  null  ||  loopType.getRangeDurationType()  ==  null)  {  [BUGGY]    throw  new  IllegalArgumentException(   "Types  array  must  not  contain  duplicate:     "  +  types[i  -  1].getName()  +     "  and     "  +  loopType.getName());  }  }  else  {  if  (loopType.getRangeDurationType()  ==  null)  {  throw  new  IllegalArgumentException(   "Types  array  must  be  in  order  largest-smallest:     "  +  types[i  -  1].getName()  +     "  <     "  +  loopType.getName());  }  DurationField  lastRangeField  =  types[i  -  1].getRangeDurationType().getField(iChronology);  DurationField  loopRangeField  =  loopType.getRangeDurationType().getField(iChronology);  [CLASS]  Partial  Property  [METHOD]  <init>  [RETURN_TYPE]  Chronology)  DateTimeFieldType[]  types  int[]  values  Chronology  chronology  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  types  Partial  iPartial  DateTimeFieldType  loopType  int[]  iValues  values  Chronology  chrono  chronology  iChronology  DurationField  lastRangeField  lastUnitField  loopRangeField  loopUnitField  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  compare  i  iFieldIndex  value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.4472135954999579	223	223	1	replace	if(loopType.getDurationType()  ==  null  ||  loopType.getRangeDurationType()  ==  null)  {	  if(loopType.getDurationType()    ==    null)    {    	compilable	  [FE]  IllegalArgumentException  testWith_baseAndArgHaveNoRange	324	1	replace
