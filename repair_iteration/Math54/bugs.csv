bugid	buggy	buggy_class	suspiciousness	buggy_line	endbuggycode	failing_test_number	action	patch
1	[BUG] [BUGGY] return new Dfp(getField(), x); [FE] AssertionError [CONTEXT] public Dfp newInstance(final long x) { [BUGGY] return new Dfp(getField(), x); [BUGGY] } [CLASS] Dfp [METHOD] newInstance [RETURN_TYPE] Dfp  final long x [VARIABLES] boolean byte FINITE INFINITE QNAN SNAN nans sign x DfpField field int[] mant String ADD_TRAP ALIGN_TRAP DIVIDE_TRAP GREATER_THAN_TRAP LESS_THAN_TRAP MULTIPLY_TRAP NAN_STRING NEG_INFINITY_STRING NEW_INSTANCE_TRAP NEXT_AFTER_TRAP POS_INFINITY_STRING SQRT_TRAP TRUNC_TRAP fpdecimal fpexp s int ERR_SCALE MAX_EXP MIN_EXP RADIX decimalPos exp exponent i offset p q rsize sciexp significantDigits trailingZeros x long x  	projects/Math54/src/main/java/org/apache/commons/math/dfp/Dfp.java	1.0	576	576	1	replace	
2	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] public Dfp newInstance(final long x) { [BUGGY] [BUGGY] return new Dfp(getField(), x); } [CLASS] Dfp [METHOD] newInstance [RETURN_TYPE] Dfp  final long x [VARIABLES] boolean byte FINITE INFINITE QNAN SNAN nans sign x DfpField field int[] mant String ADD_TRAP ALIGN_TRAP DIVIDE_TRAP GREATER_THAN_TRAP LESS_THAN_TRAP MULTIPLY_TRAP NAN_STRING NEG_INFINITY_STRING NEW_INSTANCE_TRAP NEXT_AFTER_TRAP POS_INFINITY_STRING SQRT_TRAP TRUNC_TRAP fpdecimal fpexp s int ERR_SCALE MAX_EXP MIN_EXP RADIX decimalPos exp exponent i offset p q rsize sciexp significantDigits trailingZeros x long x  	projects/Math54/src/main/java/org/apache/commons/math/dfp/Dfp.java	1.0	576	576	1	add	
3	[BUG] [BUGGY] return field.getTwo(); [FE] AssertionError [CONTEXT] public Dfp getTwo() { [BUGGY] return field.getTwo(); [BUGGY] } [CLASS] Dfp [METHOD] getTwo [RETURN_TYPE] Dfp  [VARIABLES] DfpField field int[] mant String ADD_TRAP ALIGN_TRAP DIVIDE_TRAP GREATER_THAN_TRAP LESS_THAN_TRAP MULTIPLY_TRAP NAN_STRING NEG_INFINITY_STRING NEW_INSTANCE_TRAP NEXT_AFTER_TRAP POS_INFINITY_STRING SQRT_TRAP TRUNC_TRAP fpdecimal fpexp s boolean byte FINITE INFINITE QNAN SNAN code nans sig sign x int ERR_SCALE MAX_EXP MIN_EXP RADIX decimalPos exp exponent i offset p q rsize sciexp significantDigits trailingZeros x  	projects/Math54/src/main/java/org/apache/commons/math/dfp/Dfp.java	1.0	661	661	1	replace	
4	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] public Dfp getTwo() { [BUGGY] [BUGGY] return field.getTwo(); } [CLASS] Dfp [METHOD] getTwo [RETURN_TYPE] Dfp  [VARIABLES] DfpField field int[] mant String ADD_TRAP ALIGN_TRAP DIVIDE_TRAP GREATER_THAN_TRAP LESS_THAN_TRAP MULTIPLY_TRAP NAN_STRING NEG_INFINITY_STRING NEW_INSTANCE_TRAP NEXT_AFTER_TRAP POS_INFINITY_STRING SQRT_TRAP TRUNC_TRAP fpdecimal fpexp s boolean byte FINITE INFINITE QNAN SNAN code nans sig sign x int ERR_SCALE MAX_EXP MIN_EXP RADIX decimalPos exp exponent i offset p q rsize sciexp significantDigits trailingZeros x  	projects/Math54/src/main/java/org/apache/commons/math/dfp/Dfp.java	1.0	661	661	1	add	
5	[BUG] [BUGGY] return nans == INFINITE; [FE] AssertionError [CONTEXT] public boolean isInfinite() { [BUGGY] return nans == INFINITE; [BUGGY] } [CLASS] Dfp [METHOD] isInfinite [RETURN_TYPE] boolean  [VARIABLES] DfpField field int[] mant String ADD_TRAP ALIGN_TRAP DIVIDE_TRAP GREATER_THAN_TRAP LESS_THAN_TRAP MULTIPLY_TRAP NAN_STRING NEG_INFINITY_STRING NEW_INSTANCE_TRAP NEXT_AFTER_TRAP POS_INFINITY_STRING SQRT_TRAP TRUNC_TRAP fpdecimal fpexp s boolean byte FINITE INFINITE QNAN SNAN code nans sig sign x int ERR_SCALE MAX_EXP MIN_EXP RADIX adiff decimalPos diff e exp exponent i lostdigit offset p q rsize sciexp significantDigits trailingZeros x  	projects/Math54/src/main/java/org/apache/commons/math/dfp/Dfp.java	1.0	801	801	1	replace	
6	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] public boolean isInfinite() { [BUGGY] [BUGGY] return nans == INFINITE; } [CLASS] Dfp [METHOD] isInfinite [RETURN_TYPE] boolean  [VARIABLES] DfpField field int[] mant String ADD_TRAP ALIGN_TRAP DIVIDE_TRAP GREATER_THAN_TRAP LESS_THAN_TRAP MULTIPLY_TRAP NAN_STRING NEG_INFINITY_STRING NEW_INSTANCE_TRAP NEXT_AFTER_TRAP POS_INFINITY_STRING SQRT_TRAP TRUNC_TRAP fpdecimal fpexp s boolean byte FINITE INFINITE QNAN SNAN code nans sig sign x int ERR_SCALE MAX_EXP MIN_EXP RADIX adiff decimalPos diff e exp exponent i lostdigit offset p q rsize sciexp significantDigits trailingZeros x  	projects/Math54/src/main/java/org/apache/commons/math/dfp/Dfp.java	1.0	801	801	1	add	
7	[BUG] [BUGGY] if (isInfinite()) { [FE] AssertionError [CONTEXT] public double toDouble() { [BUGGY] if (isInfinite()) { [BUGGY] if (lessThan(getZero())) { return Double.NEGATIVE_INFINITY; } else { return Double.POSITIVE_INFINITY; } } if (isNaN()) { return Double.NaN; } [CLASS] Dfp [METHOD] toDouble [RETURN_TYPE] double  [VARIABLES] boolean negate byte FINITE INFINITE QNAN SNAN asign bsign code nans rsign sig sign x double x DfpField field int[] dividend mant product quotient remainder String ADD_TRAP ALIGN_TRAP DIVIDE_TRAP GREATER_THAN_TRAP LESS_THAN_TRAP MULTIPLY_TRAP NAN_STRING NEG_INFINITY_STRING NEW_INSTANCE_TRAP NEXT_AFTER_TRAP POS_INFINITY_STRING SQRT_TRAP TRUNC_TRAP fpdecimal fpexp s str what int ERR_SCALE MAX_EXP MIN_EXP RADIX adiff ae aextradigit bextradigit decimalPos diff divMsb divisor dm e excp exp exponent extra i j lostdigit max md min minadj n nsqd offset p q qd r result rh rl rsize sciexp shf significantDigits trailingZeros trial type x long bits mantissa Dfp tempDfp y  	projects/Math54/src/main/java/org/apache/commons/math/dfp/Dfp.java	1.0	2305	2305	1	replace	
8	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] public double toDouble() { [BUGGY] [BUGGY] if (isInfinite()) { if (lessThan(getZero())) { return Double.NEGATIVE_INFINITY; } else { return Double.POSITIVE_INFINITY; } } if (isNaN()) { return Double.NaN; } [CLASS] Dfp [METHOD] toDouble [RETURN_TYPE] double  [VARIABLES] boolean negate byte FINITE INFINITE QNAN SNAN asign bsign code nans rsign sig sign x double x DfpField field int[] dividend mant product quotient remainder String ADD_TRAP ALIGN_TRAP DIVIDE_TRAP GREATER_THAN_TRAP LESS_THAN_TRAP MULTIPLY_TRAP NAN_STRING NEG_INFINITY_STRING NEW_INSTANCE_TRAP NEXT_AFTER_TRAP POS_INFINITY_STRING SQRT_TRAP TRUNC_TRAP fpdecimal fpexp s str what int ERR_SCALE MAX_EXP MIN_EXP RADIX adiff ae aextradigit bextradigit decimalPos diff divMsb divisor dm e excp exp exponent extra i j lostdigit max md min minadj n nsqd offset p q qd r result rh rl rsize sciexp shf significantDigits trailingZeros trial type x long bits mantissa Dfp tempDfp y  	projects/Math54/src/main/java/org/apache/commons/math/dfp/Dfp.java	1.0	2305	2305	1	add	
9	[BUG] [BUGGY] if (isNaN()) { [FE] AssertionError [CONTEXT] public double toDouble() { if (isInfinite()) { if (lessThan(getZero())) { return Double.NEGATIVE_INFINITY; } else { return Double.POSITIVE_INFINITY; } } [BUGGY] if (isNaN()) { [BUGGY] return Double.NaN; } Dfp y = this; boolean negate = false; if (lessThan(getZero())) { y = negate(); negate = true; }  [CLASS] Dfp [METHOD] toDouble [RETURN_TYPE] double  [VARIABLES] boolean negate byte FINITE INFINITE QNAN SNAN asign bsign code nans rsign sig sign x double x DfpField field int[] dividend mant product quotient remainder String ADD_TRAP ALIGN_TRAP DIVIDE_TRAP GREATER_THAN_TRAP LESS_THAN_TRAP MULTIPLY_TRAP NAN_STRING NEG_INFINITY_STRING NEW_INSTANCE_TRAP NEXT_AFTER_TRAP POS_INFINITY_STRING SQRT_TRAP TRUNC_TRAP fpdecimal fpexp s str what int ERR_SCALE MAX_EXP MIN_EXP RADIX adiff ae aextradigit bextradigit decimalPos diff divMsb divisor dm e excp exp exponent extra i j lostdigit max md min minadj n nsqd offset p q qd r result rh rl rsize sciexp shf significantDigits trailingZeros trial type x long bits mantissa Dfp tempDfp y  	projects/Math54/src/main/java/org/apache/commons/math/dfp/Dfp.java	1.0	2313	2313	1	replace	
10	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] public double toDouble() { if (isInfinite()) { if (lessThan(getZero())) { return Double.NEGATIVE_INFINITY; } else { return Double.POSITIVE_INFINITY; } } [BUGGY] [BUGGY] if (isNaN()) { return Double.NaN; } Dfp y = this; boolean negate = false; if (lessThan(getZero())) { y = negate(); negate = true; }  [CLASS] Dfp [METHOD] toDouble [RETURN_TYPE] double  [VARIABLES] boolean negate byte FINITE INFINITE QNAN SNAN asign bsign code nans rsign sig sign x double x DfpField field int[] dividend mant product quotient remainder String ADD_TRAP ALIGN_TRAP DIVIDE_TRAP GREATER_THAN_TRAP LESS_THAN_TRAP MULTIPLY_TRAP NAN_STRING NEG_INFINITY_STRING NEW_INSTANCE_TRAP NEXT_AFTER_TRAP POS_INFINITY_STRING SQRT_TRAP TRUNC_TRAP fpdecimal fpexp s str what int ERR_SCALE MAX_EXP MIN_EXP RADIX adiff ae aextradigit bextradigit decimalPos diff divMsb divisor dm e excp exp exponent extra i j lostdigit max md min minadj n nsqd offset p q qd r result rh rl rsize sciexp shf significantDigits trailingZeros trial type x long bits mantissa Dfp tempDfp y  	projects/Math54/src/main/java/org/apache/commons/math/dfp/Dfp.java	1.0	2313	2313	1	add	
11	[BUG] [BUGGY] Dfp y = this; [FE] AssertionError [CONTEXT] return Double.NEGATIVE_INFINITY; } else { return Double.POSITIVE_INFINITY; } } if (isNaN()) { return Double.NaN; } [BUGGY] Dfp y = this; [BUGGY] boolean negate = false; if (lessThan(getZero())) { y = negate(); negate = true; }  Should be faster than doing a natural logarithm.*/ int exponent = (int)(y.log10() * 3.32); if (exponent < 0) { [CLASS] Dfp [METHOD] toDouble [RETURN_TYPE] double  [VARIABLES] boolean negate byte FINITE INFINITE QNAN SNAN asign bsign code nans rsign sig sign x double x DfpField field int[] dividend mant product quotient remainder String ADD_TRAP ALIGN_TRAP DIVIDE_TRAP GREATER_THAN_TRAP LESS_THAN_TRAP MULTIPLY_TRAP NAN_STRING NEG_INFINITY_STRING NEW_INSTANCE_TRAP NEXT_AFTER_TRAP POS_INFINITY_STRING SQRT_TRAP TRUNC_TRAP fpdecimal fpexp s str what int ERR_SCALE MAX_EXP MIN_EXP RADIX adiff ae aextradigit bextradigit decimalPos diff divMsb divisor dm e excp exp exponent extra i j lostdigit max md min minadj n nsqd offset p q qd r result rh rl rsize sciexp shf significantDigits trailingZeros trial type x long bits mantissa Dfp tempDfp y  	projects/Math54/src/main/java/org/apache/commons/math/dfp/Dfp.java	1.0	2317	2317	1	replace	
12	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] return Double.NEGATIVE_INFINITY; } else { return Double.POSITIVE_INFINITY; } } if (isNaN()) { return Double.NaN; } [BUGGY] [BUGGY] Dfp y = this; boolean negate = false; if (lessThan(getZero())) { y = negate(); negate = true; }  Should be faster than doing a natural logarithm.*/ int exponent = (int)(y.log10() * 3.32); if (exponent < 0) { [CLASS] Dfp [METHOD] toDouble [RETURN_TYPE] double  [VARIABLES] boolean negate byte FINITE INFINITE QNAN SNAN asign bsign code nans rsign sig sign x double x DfpField field int[] dividend mant product quotient remainder String ADD_TRAP ALIGN_TRAP DIVIDE_TRAP GREATER_THAN_TRAP LESS_THAN_TRAP MULTIPLY_TRAP NAN_STRING NEG_INFINITY_STRING NEW_INSTANCE_TRAP NEXT_AFTER_TRAP POS_INFINITY_STRING SQRT_TRAP TRUNC_TRAP fpdecimal fpexp s str what int ERR_SCALE MAX_EXP MIN_EXP RADIX adiff ae aextradigit bextradigit decimalPos diff divMsb divisor dm e excp exp exponent extra i j lostdigit max md min minadj n nsqd offset p q qd r result rh rl rsize sciexp shf significantDigits trailingZeros trial type x long bits mantissa Dfp tempDfp y  	projects/Math54/src/main/java/org/apache/commons/math/dfp/Dfp.java	1.0	2317	2317	1	add	
13	[BUG] [BUGGY] boolean negate = false; [FE] AssertionError [CONTEXT] } else { return Double.POSITIVE_INFINITY; } } if (isNaN()) { return Double.NaN; } Dfp y = this; [BUGGY] boolean negate = false; [BUGGY] if (lessThan(getZero())) { y = negate(); negate = true; }  Should be faster than doing a natural logarithm.*/ int exponent = (int)(y.log10() * 3.32); if (exponent < 0) { exponent--; [CLASS] Dfp [METHOD] toDouble [RETURN_TYPE] double  [VARIABLES] boolean negate byte FINITE INFINITE QNAN SNAN asign bsign code nans rsign sig sign x double x DfpField field int[] dividend mant product quotient remainder String ADD_TRAP ALIGN_TRAP DIVIDE_TRAP GREATER_THAN_TRAP LESS_THAN_TRAP MULTIPLY_TRAP NAN_STRING NEG_INFINITY_STRING NEW_INSTANCE_TRAP NEXT_AFTER_TRAP POS_INFINITY_STRING SQRT_TRAP TRUNC_TRAP fpdecimal fpexp s str what int ERR_SCALE MAX_EXP MIN_EXP RADIX adiff ae aextradigit bextradigit decimalPos diff divMsb divisor dm e excp exp exponent extra i j lostdigit max md min minadj n nsqd offset p q qd r result rh rl rsize sciexp shf significantDigits trailingZeros trial type x long bits mantissa Dfp tempDfp y  	projects/Math54/src/main/java/org/apache/commons/math/dfp/Dfp.java	1.0	2318	2318	1	replace	
14	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] } else { return Double.POSITIVE_INFINITY; } } if (isNaN()) { return Double.NaN; } Dfp y = this; [BUGGY] [BUGGY] boolean negate = false; if (lessThan(getZero())) { y = negate(); negate = true; }  Should be faster than doing a natural logarithm.*/ int exponent = (int)(y.log10() * 3.32); if (exponent < 0) { exponent--; [CLASS] Dfp [METHOD] toDouble [RETURN_TYPE] double  [VARIABLES] boolean negate byte FINITE INFINITE QNAN SNAN asign bsign code nans rsign sig sign x double x DfpField field int[] dividend mant product quotient remainder String ADD_TRAP ALIGN_TRAP DIVIDE_TRAP GREATER_THAN_TRAP LESS_THAN_TRAP MULTIPLY_TRAP NAN_STRING NEG_INFINITY_STRING NEW_INSTANCE_TRAP NEXT_AFTER_TRAP POS_INFINITY_STRING SQRT_TRAP TRUNC_TRAP fpdecimal fpexp s str what int ERR_SCALE MAX_EXP MIN_EXP RADIX adiff ae aextradigit bextradigit decimalPos diff divMsb divisor dm e excp exp exponent extra i j lostdigit max md min minadj n nsqd offset p q qd r result rh rl rsize sciexp shf significantDigits trailingZeros trial type x long bits mantissa Dfp tempDfp y  	projects/Math54/src/main/java/org/apache/commons/math/dfp/Dfp.java	1.0	2318	2318	1	add	
15	[BUG] [BUGGY] if (lessThan(getZero())) { [FE] AssertionError [CONTEXT] return Double.POSITIVE_INFINITY; } } if (isNaN()) { return Double.NaN; } Dfp y = this; boolean negate = false; [BUGGY] if (lessThan(getZero())) { [BUGGY] y = negate(); negate = true; }  Should be faster than doing a natural logarithm.*/ int exponent = (int)(y.log10() * 3.32); if (exponent < 0) { exponent--; } [CLASS] Dfp [METHOD] toDouble [RETURN_TYPE] double  [VARIABLES] boolean negate byte FINITE INFINITE QNAN SNAN asign bsign code nans rsign sig sign x double x DfpField field int[] dividend mant product quotient remainder String ADD_TRAP ALIGN_TRAP DIVIDE_TRAP GREATER_THAN_TRAP LESS_THAN_TRAP MULTIPLY_TRAP NAN_STRING NEG_INFINITY_STRING NEW_INSTANCE_TRAP NEXT_AFTER_TRAP POS_INFINITY_STRING SQRT_TRAP TRUNC_TRAP fpdecimal fpexp s str what int ERR_SCALE MAX_EXP MIN_EXP RADIX adiff ae aextradigit bextradigit decimalPos diff divMsb divisor dm e excp exp exponent extra i j lostdigit max md min minadj n nsqd offset p q qd r result rh rl rsize sciexp shf significantDigits trailingZeros trial type x long bits mantissa Dfp tempDfp y  	projects/Math54/src/main/java/org/apache/commons/math/dfp/Dfp.java	1.0	2319	2319	1	replace	
16	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] return Double.POSITIVE_INFINITY; } } if (isNaN()) { return Double.NaN; } Dfp y = this; boolean negate = false; [BUGGY] [BUGGY] if (lessThan(getZero())) { y = negate(); negate = true; }  Should be faster than doing a natural logarithm.*/ int exponent = (int)(y.log10() * 3.32); if (exponent < 0) { exponent--; } [CLASS] Dfp [METHOD] toDouble [RETURN_TYPE] double  [VARIABLES] boolean negate byte FINITE INFINITE QNAN SNAN asign bsign code nans rsign sig sign x double x DfpField field int[] dividend mant product quotient remainder String ADD_TRAP ALIGN_TRAP DIVIDE_TRAP GREATER_THAN_TRAP LESS_THAN_TRAP MULTIPLY_TRAP NAN_STRING NEG_INFINITY_STRING NEW_INSTANCE_TRAP NEXT_AFTER_TRAP POS_INFINITY_STRING SQRT_TRAP TRUNC_TRAP fpdecimal fpexp s str what int ERR_SCALE MAX_EXP MIN_EXP RADIX adiff ae aextradigit bextradigit decimalPos diff divMsb divisor dm e excp exp exponent extra i j lostdigit max md min minadj n nsqd offset p q qd r result rh rl rsize sciexp shf significantDigits trailingZeros trial type x long bits mantissa Dfp tempDfp y  	projects/Math54/src/main/java/org/apache/commons/math/dfp/Dfp.java	1.0	2319	2319	1	add	
17	[BUG] [BUGGY] int exponent = (int)(y.log10() * 3.32); [FE] AssertionError [CONTEXT] Dfp y = this; boolean negate = false; if (lessThan(getZero())) { y = negate(); negate = true; }  Should be faster than doing a natural logarithm.*/ [BUGGY] int exponent = (int)(y.log10() * 3.32); [BUGGY] if (exponent < 0) { exponent--; } Dfp tempDfp = DfpMath.pow(getTwo(), exponent); while (tempDfp.lessThan(y) || tempDfp.equals(y)) { tempDfp = tempDfp.multiply(2); exponent++; } exponent--; [CLASS] Dfp [METHOD] toDouble [RETURN_TYPE] double  [VARIABLES] boolean negate byte FINITE INFINITE QNAN SNAN asign bsign code nans rsign sig sign x double x DfpField field int[] dividend mant product quotient remainder String ADD_TRAP ALIGN_TRAP DIVIDE_TRAP GREATER_THAN_TRAP LESS_THAN_TRAP MULTIPLY_TRAP NAN_STRING NEG_INFINITY_STRING NEW_INSTANCE_TRAP NEXT_AFTER_TRAP POS_INFINITY_STRING SQRT_TRAP TRUNC_TRAP fpdecimal fpexp s str what int ERR_SCALE MAX_EXP MIN_EXP RADIX adiff ae aextradigit bextradigit decimalPos diff divMsb divisor dm e excp exp exponent extra i j lostdigit max md min minadj n nsqd offset p q qd r result rh rl rsize sciexp shf significantDigits trailingZeros trial type x long bits mantissa Dfp tempDfp y  	projects/Math54/src/main/java/org/apache/commons/math/dfp/Dfp.java	1.0	2326	2326	1	replace	
18	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] Dfp y = this; boolean negate = false; if (lessThan(getZero())) { y = negate(); negate = true; }  Should be faster than doing a natural logarithm.*/ [BUGGY] [BUGGY] int exponent = (int)(y.log10() * 3.32); if (exponent < 0) { exponent--; } Dfp tempDfp = DfpMath.pow(getTwo(), exponent); while (tempDfp.lessThan(y) || tempDfp.equals(y)) { tempDfp = tempDfp.multiply(2); exponent++; } exponent--; [CLASS] Dfp [METHOD] toDouble [RETURN_TYPE] double  [VARIABLES] boolean negate byte FINITE INFINITE QNAN SNAN asign bsign code nans rsign sig sign x double x DfpField field int[] dividend mant product quotient remainder String ADD_TRAP ALIGN_TRAP DIVIDE_TRAP GREATER_THAN_TRAP LESS_THAN_TRAP MULTIPLY_TRAP NAN_STRING NEG_INFINITY_STRING NEW_INSTANCE_TRAP NEXT_AFTER_TRAP POS_INFINITY_STRING SQRT_TRAP TRUNC_TRAP fpdecimal fpexp s str what int ERR_SCALE MAX_EXP MIN_EXP RADIX adiff ae aextradigit bextradigit decimalPos diff divMsb divisor dm e excp exp exponent extra i j lostdigit max md min minadj n nsqd offset p q qd r result rh rl rsize sciexp shf significantDigits trailingZeros trial type x long bits mantissa Dfp tempDfp y  	projects/Math54/src/main/java/org/apache/commons/math/dfp/Dfp.java	1.0	2326	2326	1	add	
19	[BUG] [BUGGY] if (exponent < 0) { [FE] AssertionError [CONTEXT] Dfp y = this; boolean negate = false; if (lessThan(getZero())) { y = negate(); negate = true; }  Should be faster than doing a natural logarithm.*/ int exponent = (int)(y.log10() * 3.32); [BUGGY] if (exponent < 0) { [BUGGY] exponent--; } Dfp tempDfp = DfpMath.pow(getTwo(), exponent); while (tempDfp.lessThan(y) || tempDfp.equals(y)) { tempDfp = tempDfp.multiply(2); exponent++; } exponent--;  [CLASS] Dfp [METHOD] toDouble [RETURN_TYPE] double  [VARIABLES] boolean negate byte FINITE INFINITE QNAN SNAN asign bsign code nans rsign sig sign x double x DfpField field int[] dividend mant product quotient remainder String ADD_TRAP ALIGN_TRAP DIVIDE_TRAP GREATER_THAN_TRAP LESS_THAN_TRAP MULTIPLY_TRAP NAN_STRING NEG_INFINITY_STRING NEW_INSTANCE_TRAP NEXT_AFTER_TRAP POS_INFINITY_STRING SQRT_TRAP TRUNC_TRAP fpdecimal fpexp s str what int ERR_SCALE MAX_EXP MIN_EXP RADIX adiff ae aextradigit bextradigit decimalPos diff divMsb divisor dm e excp exp exponent extra i j lostdigit max md min minadj n nsqd offset p q qd r result rh rl rsize sciexp shf significantDigits trailingZeros trial type x long bits mantissa Dfp tempDfp y  	projects/Math54/src/main/java/org/apache/commons/math/dfp/Dfp.java	1.0	2327	2327	1	replace	
20	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] Dfp y = this; boolean negate = false; if (lessThan(getZero())) { y = negate(); negate = true; }  Should be faster than doing a natural logarithm.*/ int exponent = (int)(y.log10() * 3.32); [BUGGY] [BUGGY] if (exponent < 0) { exponent--; } Dfp tempDfp = DfpMath.pow(getTwo(), exponent); while (tempDfp.lessThan(y) || tempDfp.equals(y)) { tempDfp = tempDfp.multiply(2); exponent++; } exponent--;  [CLASS] Dfp [METHOD] toDouble [RETURN_TYPE] double  [VARIABLES] boolean negate byte FINITE INFINITE QNAN SNAN asign bsign code nans rsign sig sign x double x DfpField field int[] dividend mant product quotient remainder String ADD_TRAP ALIGN_TRAP DIVIDE_TRAP GREATER_THAN_TRAP LESS_THAN_TRAP MULTIPLY_TRAP NAN_STRING NEG_INFINITY_STRING NEW_INSTANCE_TRAP NEXT_AFTER_TRAP POS_INFINITY_STRING SQRT_TRAP TRUNC_TRAP fpdecimal fpexp s str what int ERR_SCALE MAX_EXP MIN_EXP RADIX adiff ae aextradigit bextradigit decimalPos diff divMsb divisor dm e excp exp exponent extra i j lostdigit max md min minadj n nsqd offset p q qd r result rh rl rsize sciexp shf significantDigits trailingZeros trial type x long bits mantissa Dfp tempDfp y  	projects/Math54/src/main/java/org/apache/commons/math/dfp/Dfp.java	1.0	2327	2327	1	add	
21	[BUG] [BUGGY] exponent--; [FE] AssertionError [CONTEXT] boolean negate = false; if (lessThan(getZero())) { y = negate(); negate = true; }  Should be faster than doing a natural logarithm.*/ int exponent = (int)(y.log10() * 3.32); if (exponent < 0) { [BUGGY] exponent--; [BUGGY] } Dfp tempDfp = DfpMath.pow(getTwo(), exponent); while (tempDfp.lessThan(y) || tempDfp.equals(y)) { tempDfp = tempDfp.multiply(2); exponent++; } exponent--;   [CLASS] Dfp [METHOD] toDouble [RETURN_TYPE] double  [VARIABLES] boolean negate byte FINITE INFINITE QNAN SNAN asign bsign code nans rsign sig sign x double x DfpField field int[] dividend mant product quotient remainder String ADD_TRAP ALIGN_TRAP DIVIDE_TRAP GREATER_THAN_TRAP LESS_THAN_TRAP MULTIPLY_TRAP NAN_STRING NEG_INFINITY_STRING NEW_INSTANCE_TRAP NEXT_AFTER_TRAP POS_INFINITY_STRING SQRT_TRAP TRUNC_TRAP fpdecimal fpexp s str what int ERR_SCALE MAX_EXP MIN_EXP RADIX adiff ae aextradigit bextradigit decimalPos diff divMsb divisor dm e excp exp exponent extra i j lostdigit max md min minadj n nsqd offset p q qd r result rh rl rsize sciexp shf significantDigits trailingZeros trial type x long bits mantissa Dfp tempDfp y  	projects/Math54/src/main/java/org/apache/commons/math/dfp/Dfp.java	1.0	2328	2328	1	replace	
22	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] boolean negate = false; if (lessThan(getZero())) { y = negate(); negate = true; }  Should be faster than doing a natural logarithm.*/ int exponent = (int)(y.log10() * 3.32); if (exponent < 0) { [BUGGY] [BUGGY] exponent--; } Dfp tempDfp = DfpMath.pow(getTwo(), exponent); while (tempDfp.lessThan(y) || tempDfp.equals(y)) { tempDfp = tempDfp.multiply(2); exponent++; } exponent--;   [CLASS] Dfp [METHOD] toDouble [RETURN_TYPE] double  [VARIABLES] boolean negate byte FINITE INFINITE QNAN SNAN asign bsign code nans rsign sig sign x double x DfpField field int[] dividend mant product quotient remainder String ADD_TRAP ALIGN_TRAP DIVIDE_TRAP GREATER_THAN_TRAP LESS_THAN_TRAP MULTIPLY_TRAP NAN_STRING NEG_INFINITY_STRING NEW_INSTANCE_TRAP NEXT_AFTER_TRAP POS_INFINITY_STRING SQRT_TRAP TRUNC_TRAP fpdecimal fpexp s str what int ERR_SCALE MAX_EXP MIN_EXP RADIX adiff ae aextradigit bextradigit decimalPos diff divMsb divisor dm e excp exp exponent extra i j lostdigit max md min minadj n nsqd offset p q qd r result rh rl rsize sciexp shf significantDigits trailingZeros trial type x long bits mantissa Dfp tempDfp y  	projects/Math54/src/main/java/org/apache/commons/math/dfp/Dfp.java	1.0	2328	2328	1	add	
23	[BUG] [BUGGY] Dfp tempDfp = DfpMath.pow(getTwo(), exponent); [FE] AssertionError [CONTEXT] negate = true; }  Should be faster than doing a natural logarithm.*/ int exponent = (int)(y.log10() * 3.32); if (exponent < 0) { exponent--; } [BUGGY] Dfp tempDfp = DfpMath.pow(getTwo(), exponent); [BUGGY] while (tempDfp.lessThan(y) || tempDfp.equals(y)) { tempDfp = tempDfp.multiply(2); exponent++; } exponent--;   y = y.divide(DfpMath.pow(getTwo(), exponent)); if (exponent > -1023) { [CLASS] Dfp [METHOD] toDouble [RETURN_TYPE] double  [VARIABLES] boolean negate byte FINITE INFINITE QNAN SNAN asign bsign code nans rsign sig sign x double x DfpField field int[] dividend mant product quotient remainder String ADD_TRAP ALIGN_TRAP DIVIDE_TRAP GREATER_THAN_TRAP LESS_THAN_TRAP MULTIPLY_TRAP NAN_STRING NEG_INFINITY_STRING NEW_INSTANCE_TRAP NEXT_AFTER_TRAP POS_INFINITY_STRING SQRT_TRAP TRUNC_TRAP fpdecimal fpexp s str what int ERR_SCALE MAX_EXP MIN_EXP RADIX adiff ae aextradigit bextradigit decimalPos diff divMsb divisor dm e excp exp exponent extra i j lostdigit max md min minadj n nsqd offset p q qd r result rh rl rsize sciexp shf significantDigits trailingZeros trial type x long bits mantissa Dfp tempDfp y  	projects/Math54/src/main/java/org/apache/commons/math/dfp/Dfp.java	1.0	2331	2331	1	replace	
24	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] negate = true; }  Should be faster than doing a natural logarithm.*/ int exponent = (int)(y.log10() * 3.32); if (exponent < 0) { exponent--; } [BUGGY] [BUGGY] Dfp tempDfp = DfpMath.pow(getTwo(), exponent); while (tempDfp.lessThan(y) || tempDfp.equals(y)) { tempDfp = tempDfp.multiply(2); exponent++; } exponent--;   y = y.divide(DfpMath.pow(getTwo(), exponent)); if (exponent > -1023) { [CLASS] Dfp [METHOD] toDouble [RETURN_TYPE] double  [VARIABLES] boolean negate byte FINITE INFINITE QNAN SNAN asign bsign code nans rsign sig sign x double x DfpField field int[] dividend mant product quotient remainder String ADD_TRAP ALIGN_TRAP DIVIDE_TRAP GREATER_THAN_TRAP LESS_THAN_TRAP MULTIPLY_TRAP NAN_STRING NEG_INFINITY_STRING NEW_INSTANCE_TRAP NEXT_AFTER_TRAP POS_INFINITY_STRING SQRT_TRAP TRUNC_TRAP fpdecimal fpexp s str what int ERR_SCALE MAX_EXP MIN_EXP RADIX adiff ae aextradigit bextradigit decimalPos diff divMsb divisor dm e excp exp exponent extra i j lostdigit max md min minadj n nsqd offset p q qd r result rh rl rsize sciexp shf significantDigits trailingZeros trial type x long bits mantissa Dfp tempDfp y  	projects/Math54/src/main/java/org/apache/commons/math/dfp/Dfp.java	1.0	2331	2331	1	add	
25	[BUG] [BUGGY] while (tempDfp.lessThan(y) || tempDfp.equals(y)) { [FE] AssertionError [CONTEXT] }  Should be faster than doing a natural logarithm.*/ int exponent = (int)(y.log10() * 3.32); if (exponent < 0) { exponent--; } Dfp tempDfp = DfpMath.pow(getTwo(), exponent); [BUGGY] while (tempDfp.lessThan(y) || tempDfp.equals(y)) { [BUGGY] tempDfp = tempDfp.multiply(2); exponent++; } exponent--;   y = y.divide(DfpMath.pow(getTwo(), exponent)); if (exponent > -1023) { y = y.subtract(getOne()); [CLASS] Dfp [METHOD] toDouble [RETURN_TYPE] double  [VARIABLES] boolean negate byte FINITE INFINITE QNAN SNAN asign bsign code nans rsign sig sign x double x DfpField field int[] dividend mant product quotient remainder String ADD_TRAP ALIGN_TRAP DIVIDE_TRAP GREATER_THAN_TRAP LESS_THAN_TRAP MULTIPLY_TRAP NAN_STRING NEG_INFINITY_STRING NEW_INSTANCE_TRAP NEXT_AFTER_TRAP POS_INFINITY_STRING SQRT_TRAP TRUNC_TRAP fpdecimal fpexp s str what int ERR_SCALE MAX_EXP MIN_EXP RADIX adiff ae aextradigit bextradigit decimalPos diff divMsb divisor dm e excp exp exponent extra i j lostdigit max md min minadj n nsqd offset p q qd r result rh rl rsize sciexp shf significantDigits trailingZeros trial type x long bits mantissa Dfp tempDfp y  	projects/Math54/src/main/java/org/apache/commons/math/dfp/Dfp.java	1.0	2332	2332	1	replace	
26	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] }  Should be faster than doing a natural logarithm.*/ int exponent = (int)(y.log10() * 3.32); if (exponent < 0) { exponent--; } Dfp tempDfp = DfpMath.pow(getTwo(), exponent); [BUGGY] [BUGGY] while (tempDfp.lessThan(y) || tempDfp.equals(y)) { tempDfp = tempDfp.multiply(2); exponent++; } exponent--;   y = y.divide(DfpMath.pow(getTwo(), exponent)); if (exponent > -1023) { y = y.subtract(getOne()); [CLASS] Dfp [METHOD] toDouble [RETURN_TYPE] double  [VARIABLES] boolean negate byte FINITE INFINITE QNAN SNAN asign bsign code nans rsign sig sign x double x DfpField field int[] dividend mant product quotient remainder String ADD_TRAP ALIGN_TRAP DIVIDE_TRAP GREATER_THAN_TRAP LESS_THAN_TRAP MULTIPLY_TRAP NAN_STRING NEG_INFINITY_STRING NEW_INSTANCE_TRAP NEXT_AFTER_TRAP POS_INFINITY_STRING SQRT_TRAP TRUNC_TRAP fpdecimal fpexp s str what int ERR_SCALE MAX_EXP MIN_EXP RADIX adiff ae aextradigit bextradigit decimalPos diff divMsb divisor dm e excp exp exponent extra i j lostdigit max md min minadj n nsqd offset p q qd r result rh rl rsize sciexp shf significantDigits trailingZeros trial type x long bits mantissa Dfp tempDfp y  	projects/Math54/src/main/java/org/apache/commons/math/dfp/Dfp.java	1.0	2332	2332	1	add	
28	[BUG] [BUGGY] y = y.divide(DfpMath.pow(getTwo(), exponent)); [FE] AssertionError [CONTEXT] Dfp tempDfp = DfpMath.pow(getTwo(), exponent); while (tempDfp.lessThan(y) || tempDfp.equals(y)) { tempDfp = tempDfp.multiply(2); exponent++; } exponent--;   [BUGGY] y = y.divide(DfpMath.pow(getTwo(), exponent)); [BUGGY] if (exponent > -1023) { y = y.subtract(getOne()); } if (exponent < -1074) { return 0; } if (exponent > 1023) { return negate ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY; [CLASS] Dfp [METHOD] toDouble [RETURN_TYPE] double  [VARIABLES] boolean negate byte FINITE INFINITE QNAN SNAN asign bsign code nans rsign sig sign x double x DfpField field int[] dividend mant product quotient remainder String ADD_TRAP ALIGN_TRAP DIVIDE_TRAP GREATER_THAN_TRAP LESS_THAN_TRAP MULTIPLY_TRAP NAN_STRING NEG_INFINITY_STRING NEW_INSTANCE_TRAP NEXT_AFTER_TRAP POS_INFINITY_STRING SQRT_TRAP TRUNC_TRAP fpdecimal fpexp s str what int ERR_SCALE MAX_EXP MIN_EXP RADIX adiff ae aextradigit bextradigit decimalPos diff divMsb divisor dm e excp exp exponent extra i j lostdigit max md min minadj n nsqd offset p q qd r result rh rl rsize sciexp shf significantDigits trailingZeros trial type x long bits mantissa Dfp tempDfp y  	projects/Math54/src/main/java/org/apache/commons/math/dfp/Dfp.java	1.0	2340	2340	1	replace	
29	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] Dfp tempDfp = DfpMath.pow(getTwo(), exponent); while (tempDfp.lessThan(y) || tempDfp.equals(y)) { tempDfp = tempDfp.multiply(2); exponent++; } exponent--;   [BUGGY] [BUGGY] y = y.divide(DfpMath.pow(getTwo(), exponent)); if (exponent > -1023) { y = y.subtract(getOne()); } if (exponent < -1074) { return 0; } if (exponent > 1023) { return negate ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY; [CLASS] Dfp [METHOD] toDouble [RETURN_TYPE] double  [VARIABLES] boolean negate byte FINITE INFINITE QNAN SNAN asign bsign code nans rsign sig sign x double x DfpField field int[] dividend mant product quotient remainder String ADD_TRAP ALIGN_TRAP DIVIDE_TRAP GREATER_THAN_TRAP LESS_THAN_TRAP MULTIPLY_TRAP NAN_STRING NEG_INFINITY_STRING NEW_INSTANCE_TRAP NEXT_AFTER_TRAP POS_INFINITY_STRING SQRT_TRAP TRUNC_TRAP fpdecimal fpexp s str what int ERR_SCALE MAX_EXP MIN_EXP RADIX adiff ae aextradigit bextradigit decimalPos diff divMsb divisor dm e excp exp exponent extra i j lostdigit max md min minadj n nsqd offset p q qd r result rh rl rsize sciexp shf significantDigits trailingZeros trial type x long bits mantissa Dfp tempDfp y  	projects/Math54/src/main/java/org/apache/commons/math/dfp/Dfp.java	1.0	2340	2340	1	add	
30	[BUG] [BUGGY] if (exponent > -1023) { [FE] AssertionError [CONTEXT] Dfp tempDfp = DfpMath.pow(getTwo(), exponent); while (tempDfp.lessThan(y) || tempDfp.equals(y)) { tempDfp = tempDfp.multiply(2); exponent++; } exponent--;   y = y.divide(DfpMath.pow(getTwo(), exponent)); [BUGGY] if (exponent > -1023) { [BUGGY] y = y.subtract(getOne()); } if (exponent < -1074) { return 0; } if (exponent > 1023) { return negate ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY; } [CLASS] Dfp [METHOD] toDouble [RETURN_TYPE] double  [VARIABLES] boolean negate byte FINITE INFINITE QNAN SNAN asign bsign code nans rsign sig sign x double x DfpField field int[] dividend mant product quotient remainder String ADD_TRAP ALIGN_TRAP DIVIDE_TRAP GREATER_THAN_TRAP LESS_THAN_TRAP MULTIPLY_TRAP NAN_STRING NEG_INFINITY_STRING NEW_INSTANCE_TRAP NEXT_AFTER_TRAP POS_INFINITY_STRING SQRT_TRAP TRUNC_TRAP fpdecimal fpexp s str what int ERR_SCALE MAX_EXP MIN_EXP RADIX adiff ae aextradigit bextradigit decimalPos diff divMsb divisor dm e excp exp exponent extra i j lostdigit max md min minadj n nsqd offset p q qd r result rh rl rsize sciexp shf significantDigits trailingZeros trial type x long bits mantissa Dfp tempDfp y  	projects/Math54/src/main/java/org/apache/commons/math/dfp/Dfp.java	1.0	2341	2341	1	replace	
31	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] Dfp tempDfp = DfpMath.pow(getTwo(), exponent); while (tempDfp.lessThan(y) || tempDfp.equals(y)) { tempDfp = tempDfp.multiply(2); exponent++; } exponent--;   y = y.divide(DfpMath.pow(getTwo(), exponent)); [BUGGY] [BUGGY] if (exponent > -1023) { y = y.subtract(getOne()); } if (exponent < -1074) { return 0; } if (exponent > 1023) { return negate ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY; } [CLASS] Dfp [METHOD] toDouble [RETURN_TYPE] double  [VARIABLES] boolean negate byte FINITE INFINITE QNAN SNAN asign bsign code nans rsign sig sign x double x DfpField field int[] dividend mant product quotient remainder String ADD_TRAP ALIGN_TRAP DIVIDE_TRAP GREATER_THAN_TRAP LESS_THAN_TRAP MULTIPLY_TRAP NAN_STRING NEG_INFINITY_STRING NEW_INSTANCE_TRAP NEXT_AFTER_TRAP POS_INFINITY_STRING SQRT_TRAP TRUNC_TRAP fpdecimal fpexp s str what int ERR_SCALE MAX_EXP MIN_EXP RADIX adiff ae aextradigit bextradigit decimalPos diff divMsb divisor dm e excp exp exponent extra i j lostdigit max md min minadj n nsqd offset p q qd r result rh rl rsize sciexp shf significantDigits trailingZeros trial type x long bits mantissa Dfp tempDfp y  	projects/Math54/src/main/java/org/apache/commons/math/dfp/Dfp.java	1.0	2341	2341	1	add	
32	[BUG] [BUGGY] y = y.subtract(getOne()); [FE] AssertionError [CONTEXT] while (tempDfp.lessThan(y) || tempDfp.equals(y)) { tempDfp = tempDfp.multiply(2); exponent++; } exponent--;   y = y.divide(DfpMath.pow(getTwo(), exponent)); if (exponent > -1023) { [BUGGY] y = y.subtract(getOne()); [BUGGY] } if (exponent < -1074) { return 0; } if (exponent > 1023) { return negate ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY; }  [CLASS] Dfp [METHOD] toDouble [RETURN_TYPE] double  [VARIABLES] boolean negate byte FINITE INFINITE QNAN SNAN asign bsign code nans rsign sig sign x double x DfpField field int[] dividend mant product quotient remainder String ADD_TRAP ALIGN_TRAP DIVIDE_TRAP GREATER_THAN_TRAP LESS_THAN_TRAP MULTIPLY_TRAP NAN_STRING NEG_INFINITY_STRING NEW_INSTANCE_TRAP NEXT_AFTER_TRAP POS_INFINITY_STRING SQRT_TRAP TRUNC_TRAP fpdecimal fpexp s str what int ERR_SCALE MAX_EXP MIN_EXP RADIX adiff ae aextradigit bextradigit decimalPos diff divMsb divisor dm e excp exp exponent extra i j lostdigit max md min minadj n nsqd offset p q qd r result rh rl rsize sciexp shf significantDigits trailingZeros trial type x long bits mantissa Dfp tempDfp y  	projects/Math54/src/main/java/org/apache/commons/math/dfp/Dfp.java	1.0	2342	2342	1	replace	
33	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] while (tempDfp.lessThan(y) || tempDfp.equals(y)) { tempDfp = tempDfp.multiply(2); exponent++; } exponent--;   y = y.divide(DfpMath.pow(getTwo(), exponent)); if (exponent > -1023) { [BUGGY] [BUGGY] y = y.subtract(getOne()); } if (exponent < -1074) { return 0; } if (exponent > 1023) { return negate ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY; }  [CLASS] Dfp [METHOD] toDouble [RETURN_TYPE] double  [VARIABLES] boolean negate byte FINITE INFINITE QNAN SNAN asign bsign code nans rsign sig sign x double x DfpField field int[] dividend mant product quotient remainder String ADD_TRAP ALIGN_TRAP DIVIDE_TRAP GREATER_THAN_TRAP LESS_THAN_TRAP MULTIPLY_TRAP NAN_STRING NEG_INFINITY_STRING NEW_INSTANCE_TRAP NEXT_AFTER_TRAP POS_INFINITY_STRING SQRT_TRAP TRUNC_TRAP fpdecimal fpexp s str what int ERR_SCALE MAX_EXP MIN_EXP RADIX adiff ae aextradigit bextradigit decimalPos diff divMsb divisor dm e excp exp exponent extra i j lostdigit max md min minadj n nsqd offset p q qd r result rh rl rsize sciexp shf significantDigits trailingZeros trial type x long bits mantissa Dfp tempDfp y  	projects/Math54/src/main/java/org/apache/commons/math/dfp/Dfp.java	1.0	2342	2342	1	add	
34	[BUG] [BUGGY] if (exponent < -1074) { [FE] AssertionError [CONTEXT] } exponent--;   y = y.divide(DfpMath.pow(getTwo(), exponent)); if (exponent > -1023) { y = y.subtract(getOne()); } [BUGGY] if (exponent < -1074) { [BUGGY] return 0; } if (exponent > 1023) { return negate ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY; }  y = y.multiply(newInstance(4503599627370496l)).rint(); String str = y.toString(); [CLASS] Dfp [METHOD] toDouble [RETURN_TYPE] double  [VARIABLES] boolean negate byte FINITE INFINITE QNAN SNAN asign bsign code nans rsign sig sign x double x DfpField field int[] dividend mant product quotient remainder String ADD_TRAP ALIGN_TRAP DIVIDE_TRAP GREATER_THAN_TRAP LESS_THAN_TRAP MULTIPLY_TRAP NAN_STRING NEG_INFINITY_STRING NEW_INSTANCE_TRAP NEXT_AFTER_TRAP POS_INFINITY_STRING SQRT_TRAP TRUNC_TRAP fpdecimal fpexp s str what int ERR_SCALE MAX_EXP MIN_EXP RADIX adiff ae aextradigit bextradigit decimalPos diff divMsb divisor dm e excp exp exponent extra i j lostdigit max md min minadj n nsqd offset p q qd r result rh rl rsize sciexp shf significantDigits trailingZeros trial type x long bits mantissa Dfp tempDfp y  	projects/Math54/src/main/java/org/apache/commons/math/dfp/Dfp.java	1.0	2345	2345	1	replace	
35	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] } exponent--;   y = y.divide(DfpMath.pow(getTwo(), exponent)); if (exponent > -1023) { y = y.subtract(getOne()); } [BUGGY] [BUGGY] if (exponent < -1074) { return 0; } if (exponent > 1023) { return negate ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY; }  y = y.multiply(newInstance(4503599627370496l)).rint(); String str = y.toString(); [CLASS] Dfp [METHOD] toDouble [RETURN_TYPE] double  [VARIABLES] boolean negate byte FINITE INFINITE QNAN SNAN asign bsign code nans rsign sig sign x double x DfpField field int[] dividend mant product quotient remainder String ADD_TRAP ALIGN_TRAP DIVIDE_TRAP GREATER_THAN_TRAP LESS_THAN_TRAP MULTIPLY_TRAP NAN_STRING NEG_INFINITY_STRING NEW_INSTANCE_TRAP NEXT_AFTER_TRAP POS_INFINITY_STRING SQRT_TRAP TRUNC_TRAP fpdecimal fpexp s str what int ERR_SCALE MAX_EXP MIN_EXP RADIX adiff ae aextradigit bextradigit decimalPos diff divMsb divisor dm e excp exp exponent extra i j lostdigit max md min minadj n nsqd offset p q qd r result rh rl rsize sciexp shf significantDigits trailingZeros trial type x long bits mantissa Dfp tempDfp y  	projects/Math54/src/main/java/org/apache/commons/math/dfp/Dfp.java	1.0	2345	2345	1	add	
36	[BUG] [BUGGY] if (exponent > 1023) { [FE] AssertionError [CONTEXT] y = y.divide(DfpMath.pow(getTwo(), exponent)); if (exponent > -1023) { y = y.subtract(getOne()); } if (exponent < -1074) { return 0; } [BUGGY] if (exponent > 1023) { [BUGGY] return negate ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY; }  y = y.multiply(newInstance(4503599627370496l)).rint(); String str = y.toString(); str = str.substring(0, str.length()-1); long mantissa = Long.parseLong(str); if (mantissa == 4503599627370496L) { [CLASS] Dfp [METHOD] toDouble [RETURN_TYPE] double  [VARIABLES] boolean negate byte FINITE INFINITE QNAN SNAN asign bsign code nans rsign sig sign x double x DfpField field int[] dividend mant product quotient remainder String ADD_TRAP ALIGN_TRAP DIVIDE_TRAP GREATER_THAN_TRAP LESS_THAN_TRAP MULTIPLY_TRAP NAN_STRING NEG_INFINITY_STRING NEW_INSTANCE_TRAP NEXT_AFTER_TRAP POS_INFINITY_STRING SQRT_TRAP TRUNC_TRAP fpdecimal fpexp s str what int ERR_SCALE MAX_EXP MIN_EXP RADIX adiff ae aextradigit bextradigit decimalPos diff divMsb divisor dm e excp exp exponent extra i j lostdigit max md min minadj n nsqd offset p q qd r result rh rl rsize sciexp shf significantDigits trailingZeros trial type x long bits mantissa Dfp tempDfp y  	projects/Math54/src/main/java/org/apache/commons/math/dfp/Dfp.java	1.0	2349	2349	1	replace	
37	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] y = y.divide(DfpMath.pow(getTwo(), exponent)); if (exponent > -1023) { y = y.subtract(getOne()); } if (exponent < -1074) { return 0; } [BUGGY] [BUGGY] if (exponent > 1023) { return negate ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY; }  y = y.multiply(newInstance(4503599627370496l)).rint(); String str = y.toString(); str = str.substring(0, str.length()-1); long mantissa = Long.parseLong(str); if (mantissa == 4503599627370496L) { [CLASS] Dfp [METHOD] toDouble [RETURN_TYPE] double  [VARIABLES] boolean negate byte FINITE INFINITE QNAN SNAN asign bsign code nans rsign sig sign x double x DfpField field int[] dividend mant product quotient remainder String ADD_TRAP ALIGN_TRAP DIVIDE_TRAP GREATER_THAN_TRAP LESS_THAN_TRAP MULTIPLY_TRAP NAN_STRING NEG_INFINITY_STRING NEW_INSTANCE_TRAP NEXT_AFTER_TRAP POS_INFINITY_STRING SQRT_TRAP TRUNC_TRAP fpdecimal fpexp s str what int ERR_SCALE MAX_EXP MIN_EXP RADIX adiff ae aextradigit bextradigit decimalPos diff divMsb divisor dm e excp exp exponent extra i j lostdigit max md min minadj n nsqd offset p q qd r result rh rl rsize sciexp shf significantDigits trailingZeros trial type x long bits mantissa Dfp tempDfp y  	projects/Math54/src/main/java/org/apache/commons/math/dfp/Dfp.java	1.0	2349	2349	1	add	
38	[BUG] [BUGGY] y = y.multiply(newInstance(4503599627370496l)).rint(); [FE] AssertionError [CONTEXT] if (exponent < -1074) { return 0; } if (exponent > 1023) { return negate ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY; }  [BUGGY] y = y.multiply(newInstance(4503599627370496l)).rint(); [BUGGY] String str = y.toString(); str = str.substring(0, str.length()-1); long mantissa = Long.parseLong(str); if (mantissa == 4503599627370496L) {  mantissa = 0; exponent++; }  [CLASS] Dfp [METHOD] toDouble [RETURN_TYPE] double  [VARIABLES] boolean negate byte FINITE INFINITE QNAN SNAN asign bsign code nans rsign sig sign x double x DfpField field int[] dividend mant product quotient remainder String ADD_TRAP ALIGN_TRAP DIVIDE_TRAP GREATER_THAN_TRAP LESS_THAN_TRAP MULTIPLY_TRAP NAN_STRING NEG_INFINITY_STRING NEW_INSTANCE_TRAP NEXT_AFTER_TRAP POS_INFINITY_STRING SQRT_TRAP TRUNC_TRAP fpdecimal fpexp s str what int ERR_SCALE MAX_EXP MIN_EXP RADIX adiff ae aextradigit bextradigit decimalPos diff divMsb divisor dm e excp exp exponent extra i j lostdigit max md min minadj n nsqd offset p q qd r result rh rl rsize sciexp shf significantDigits trailingZeros trial type x long bits mantissa Dfp tempDfp y  	projects/Math54/src/main/java/org/apache/commons/math/dfp/Dfp.java	1.0	2354	2354	1	replace	
39	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] if (exponent < -1074) { return 0; } if (exponent > 1023) { return negate ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY; }  [BUGGY] [BUGGY] y = y.multiply(newInstance(4503599627370496l)).rint(); String str = y.toString(); str = str.substring(0, str.length()-1); long mantissa = Long.parseLong(str); if (mantissa == 4503599627370496L) {  mantissa = 0; exponent++; }  [CLASS] Dfp [METHOD] toDouble [RETURN_TYPE] double  [VARIABLES] boolean negate byte FINITE INFINITE QNAN SNAN asign bsign code nans rsign sig sign x double x DfpField field int[] dividend mant product quotient remainder String ADD_TRAP ALIGN_TRAP DIVIDE_TRAP GREATER_THAN_TRAP LESS_THAN_TRAP MULTIPLY_TRAP NAN_STRING NEG_INFINITY_STRING NEW_INSTANCE_TRAP NEXT_AFTER_TRAP POS_INFINITY_STRING SQRT_TRAP TRUNC_TRAP fpdecimal fpexp s str what int ERR_SCALE MAX_EXP MIN_EXP RADIX adiff ae aextradigit bextradigit decimalPos diff divMsb divisor dm e excp exp exponent extra i j lostdigit max md min minadj n nsqd offset p q qd r result rh rl rsize sciexp shf significantDigits trailingZeros trial type x long bits mantissa Dfp tempDfp y  	projects/Math54/src/main/java/org/apache/commons/math/dfp/Dfp.java	1.0	2354	2354	1	add	
40	[BUG] [BUGGY] String str = y.toString(); [FE] AssertionError [CONTEXT] if (exponent < -1074) { return 0; } if (exponent > 1023) { return negate ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY; }  y = y.multiply(newInstance(4503599627370496l)).rint(); [BUGGY] String str = y.toString(); [BUGGY] str = str.substring(0, str.length()-1); long mantissa = Long.parseLong(str); if (mantissa == 4503599627370496L) {  mantissa = 0; exponent++; }   [CLASS] Dfp [METHOD] toDouble [RETURN_TYPE] double  [VARIABLES] boolean negate byte FINITE INFINITE QNAN SNAN asign bsign code nans rsign sig sign x double x DfpField field int[] dividend mant product quotient remainder String ADD_TRAP ALIGN_TRAP DIVIDE_TRAP GREATER_THAN_TRAP LESS_THAN_TRAP MULTIPLY_TRAP NAN_STRING NEG_INFINITY_STRING NEW_INSTANCE_TRAP NEXT_AFTER_TRAP POS_INFINITY_STRING SQRT_TRAP TRUNC_TRAP fpdecimal fpexp s str what int ERR_SCALE MAX_EXP MIN_EXP RADIX adiff ae aextradigit bextradigit decimalPos diff divMsb divisor dm e excp exp exponent extra i j lostdigit max md min minadj n nsqd offset p q qd r result rh rl rsize sciexp shf significantDigits trailingZeros trial type x long bits mantissa Dfp tempDfp y  	projects/Math54/src/main/java/org/apache/commons/math/dfp/Dfp.java	1.0	2355	2355	1	replace	
41	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] if (exponent < -1074) { return 0; } if (exponent > 1023) { return negate ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY; }  y = y.multiply(newInstance(4503599627370496l)).rint(); [BUGGY] [BUGGY] String str = y.toString(); str = str.substring(0, str.length()-1); long mantissa = Long.parseLong(str); if (mantissa == 4503599627370496L) {  mantissa = 0; exponent++; }   [CLASS] Dfp [METHOD] toDouble [RETURN_TYPE] double  [VARIABLES] boolean negate byte FINITE INFINITE QNAN SNAN asign bsign code nans rsign sig sign x double x DfpField field int[] dividend mant product quotient remainder String ADD_TRAP ALIGN_TRAP DIVIDE_TRAP GREATER_THAN_TRAP LESS_THAN_TRAP MULTIPLY_TRAP NAN_STRING NEG_INFINITY_STRING NEW_INSTANCE_TRAP NEXT_AFTER_TRAP POS_INFINITY_STRING SQRT_TRAP TRUNC_TRAP fpdecimal fpexp s str what int ERR_SCALE MAX_EXP MIN_EXP RADIX adiff ae aextradigit bextradigit decimalPos diff divMsb divisor dm e excp exp exponent extra i j lostdigit max md min minadj n nsqd offset p q qd r result rh rl rsize sciexp shf significantDigits trailingZeros trial type x long bits mantissa Dfp tempDfp y  	projects/Math54/src/main/java/org/apache/commons/math/dfp/Dfp.java	1.0	2355	2355	1	add	
42	[BUG] [BUGGY] str = str.substring(0, str.length()-1); [FE] AssertionError [CONTEXT] return 0; } if (exponent > 1023) { return negate ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY; }  y = y.multiply(newInstance(4503599627370496l)).rint(); String str = y.toString(); [BUGGY] str = str.substring(0, str.length()-1); [BUGGY] long mantissa = Long.parseLong(str); if (mantissa == 4503599627370496L) {  mantissa = 0; exponent++; }  if (exponent <= -1023) { [CLASS] Dfp [METHOD] toDouble [RETURN_TYPE] double  [VARIABLES] boolean negate byte FINITE INFINITE QNAN SNAN asign bsign code nans rsign sig sign x double x DfpField field int[] dividend mant product quotient remainder String ADD_TRAP ALIGN_TRAP DIVIDE_TRAP GREATER_THAN_TRAP LESS_THAN_TRAP MULTIPLY_TRAP NAN_STRING NEG_INFINITY_STRING NEW_INSTANCE_TRAP NEXT_AFTER_TRAP POS_INFINITY_STRING SQRT_TRAP TRUNC_TRAP fpdecimal fpexp s str what int ERR_SCALE MAX_EXP MIN_EXP RADIX adiff ae aextradigit bextradigit decimalPos diff divMsb divisor dm e excp exp exponent extra i j lostdigit max md min minadj n nsqd offset p q qd r result rh rl rsize sciexp shf significantDigits trailingZeros trial type x long bits mantissa Dfp tempDfp y  	projects/Math54/src/main/java/org/apache/commons/math/dfp/Dfp.java	1.0	2356	2356	1	replace	
43	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] return 0; } if (exponent > 1023) { return negate ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY; }  y = y.multiply(newInstance(4503599627370496l)).rint(); String str = y.toString(); [BUGGY] [BUGGY] str = str.substring(0, str.length()-1); long mantissa = Long.parseLong(str); if (mantissa == 4503599627370496L) {  mantissa = 0; exponent++; }  if (exponent <= -1023) { [CLASS] Dfp [METHOD] toDouble [RETURN_TYPE] double  [VARIABLES] boolean negate byte FINITE INFINITE QNAN SNAN asign bsign code nans rsign sig sign x double x DfpField field int[] dividend mant product quotient remainder String ADD_TRAP ALIGN_TRAP DIVIDE_TRAP GREATER_THAN_TRAP LESS_THAN_TRAP MULTIPLY_TRAP NAN_STRING NEG_INFINITY_STRING NEW_INSTANCE_TRAP NEXT_AFTER_TRAP POS_INFINITY_STRING SQRT_TRAP TRUNC_TRAP fpdecimal fpexp s str what int ERR_SCALE MAX_EXP MIN_EXP RADIX adiff ae aextradigit bextradigit decimalPos diff divMsb divisor dm e excp exp exponent extra i j lostdigit max md min minadj n nsqd offset p q qd r result rh rl rsize sciexp shf significantDigits trailingZeros trial type x long bits mantissa Dfp tempDfp y  	projects/Math54/src/main/java/org/apache/commons/math/dfp/Dfp.java	1.0	2356	2356	1	add	
44	[BUG] [BUGGY] long mantissa = Long.parseLong(str); [FE] AssertionError [CONTEXT] } if (exponent > 1023) { return negate ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY; }  y = y.multiply(newInstance(4503599627370496l)).rint(); String str = y.toString(); str = str.substring(0, str.length()-1); [BUGGY] long mantissa = Long.parseLong(str); [BUGGY]  if (mantissa == 4503599627370496L) {  mantissa = 0; exponent++; }  if (exponent <= -1023) { exponent--; [CLASS] Dfp [METHOD] toDouble [RETURN_TYPE] double  [VARIABLES] boolean negate byte FINITE INFINITE QNAN SNAN asign bsign code nans rsign sig sign x double x DfpField field int[] dividend mant product quotient remainder String ADD_TRAP ALIGN_TRAP DIVIDE_TRAP GREATER_THAN_TRAP LESS_THAN_TRAP MULTIPLY_TRAP NAN_STRING NEG_INFINITY_STRING NEW_INSTANCE_TRAP NEXT_AFTER_TRAP POS_INFINITY_STRING SQRT_TRAP TRUNC_TRAP fpdecimal fpexp s str what int ERR_SCALE MAX_EXP MIN_EXP RADIX adiff ae aextradigit bextradigit decimalPos diff divMsb divisor dm e excp exp exponent extra i j lostdigit max md min minadj n nsqd offset p q qd r result rh rl rsize sciexp shf significantDigits trailingZeros trial type x long bits mantissa Dfp tempDfp y  	projects/Math54/src/main/java/org/apache/commons/math/dfp/Dfp.java	1.0	2357	2357	1	replace	
45	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] } if (exponent > 1023) { return negate ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY; }  y = y.multiply(newInstance(4503599627370496l)).rint(); String str = y.toString(); str = str.substring(0, str.length()-1); [BUGGY] [BUGGY] long mantissa = Long.parseLong(str); if (mantissa == 4503599627370496L) {  mantissa = 0; exponent++; }  if (exponent <= -1023) { exponent--; [CLASS] Dfp [METHOD] toDouble [RETURN_TYPE] double  [VARIABLES] boolean negate byte FINITE INFINITE QNAN SNAN asign bsign code nans rsign sig sign x double x DfpField field int[] dividend mant product quotient remainder String ADD_TRAP ALIGN_TRAP DIVIDE_TRAP GREATER_THAN_TRAP LESS_THAN_TRAP MULTIPLY_TRAP NAN_STRING NEG_INFINITY_STRING NEW_INSTANCE_TRAP NEXT_AFTER_TRAP POS_INFINITY_STRING SQRT_TRAP TRUNC_TRAP fpdecimal fpexp s str what int ERR_SCALE MAX_EXP MIN_EXP RADIX adiff ae aextradigit bextradigit decimalPos diff divMsb divisor dm e excp exp exponent extra i j lostdigit max md min minadj n nsqd offset p q qd r result rh rl rsize sciexp shf significantDigits trailingZeros trial type x long bits mantissa Dfp tempDfp y  	projects/Math54/src/main/java/org/apache/commons/math/dfp/Dfp.java	1.0	2357	2357	1	add	
46	[BUG] [BUGGY] if (mantissa == 4503599627370496L) { [FE] AssertionError [CONTEXT] if (exponent > 1023) { return negate ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY; }  y = y.multiply(newInstance(4503599627370496l)).rint(); String str = y.toString(); str = str.substring(0, str.length()-1); long mantissa = Long.parseLong(str); [BUGGY] if (mantissa == 4503599627370496L) { [BUGGY]  mantissa = 0; exponent++; }  if (exponent <= -1023) { exponent--; }  [CLASS] Dfp [METHOD] toDouble [RETURN_TYPE] double  [VARIABLES] boolean negate byte FINITE INFINITE QNAN SNAN asign bsign code nans rsign sig sign x double x DfpField field int[] dividend mant product quotient remainder String ADD_TRAP ALIGN_TRAP DIVIDE_TRAP GREATER_THAN_TRAP LESS_THAN_TRAP MULTIPLY_TRAP NAN_STRING NEG_INFINITY_STRING NEW_INSTANCE_TRAP NEXT_AFTER_TRAP POS_INFINITY_STRING SQRT_TRAP TRUNC_TRAP fpdecimal fpexp s str what int ERR_SCALE MAX_EXP MIN_EXP RADIX adiff ae aextradigit bextradigit decimalPos diff divMsb divisor dm e excp exp exponent extra i j lostdigit max md min minadj n nsqd offset p q qd r result rh rl rsize sciexp shf significantDigits trailingZeros trial type x long bits mantissa Dfp tempDfp y  	projects/Math54/src/main/java/org/apache/commons/math/dfp/Dfp.java	1.0	2359	2359	1	replace	
47	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] if (exponent > 1023) { return negate ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY; }  y = y.multiply(newInstance(4503599627370496l)).rint(); String str = y.toString(); str = str.substring(0, str.length()-1); long mantissa = Long.parseLong(str); [BUGGY] [BUGGY] if (mantissa == 4503599627370496L) {  mantissa = 0; exponent++; }  if (exponent <= -1023) { exponent--; }  [CLASS] Dfp [METHOD] toDouble [RETURN_TYPE] double  [VARIABLES] boolean negate byte FINITE INFINITE QNAN SNAN asign bsign code nans rsign sig sign x double x DfpField field int[] dividend mant product quotient remainder String ADD_TRAP ALIGN_TRAP DIVIDE_TRAP GREATER_THAN_TRAP LESS_THAN_TRAP MULTIPLY_TRAP NAN_STRING NEG_INFINITY_STRING NEW_INSTANCE_TRAP NEXT_AFTER_TRAP POS_INFINITY_STRING SQRT_TRAP TRUNC_TRAP fpdecimal fpexp s str what int ERR_SCALE MAX_EXP MIN_EXP RADIX adiff ae aextradigit bextradigit decimalPos diff divMsb divisor dm e excp exp exponent extra i j lostdigit max md min minadj n nsqd offset p q qd r result rh rl rsize sciexp shf significantDigits trailingZeros trial type x long bits mantissa Dfp tempDfp y  	projects/Math54/src/main/java/org/apache/commons/math/dfp/Dfp.java	1.0	2359	2359	1	add	
48	[BUG] [BUGGY] if (exponent <= -1023) { [FE] AssertionError [CONTEXT] str = str.substring(0, str.length()-1); long mantissa = Long.parseLong(str); if (mantissa == 4503599627370496L) {  mantissa = 0; exponent++; }  [BUGGY] if (exponent <= -1023) { [BUGGY] exponent--; } while (exponent < -1023) { exponent++; mantissa >>>= 1; } long bits = mantissa | ((exponent + 1023L) << 52); double x = Double.longBitsToDouble(bits); [CLASS] Dfp [METHOD] toDouble [RETURN_TYPE] double  [VARIABLES] boolean negate byte FINITE INFINITE QNAN SNAN asign bsign code nans rsign sig sign x double x DfpField field int[] dividend mant product quotient remainder String ADD_TRAP ALIGN_TRAP DIVIDE_TRAP GREATER_THAN_TRAP LESS_THAN_TRAP MULTIPLY_TRAP NAN_STRING NEG_INFINITY_STRING NEW_INSTANCE_TRAP NEXT_AFTER_TRAP POS_INFINITY_STRING SQRT_TRAP TRUNC_TRAP fpdecimal fpexp s str what int ERR_SCALE MAX_EXP MIN_EXP RADIX adiff ae aextradigit bextradigit decimalPos diff divMsb divisor dm e excp exp exponent extra i j lostdigit max md min minadj n nsqd offset p q qd r result rh rl rsize sciexp shf significantDigits trailingZeros trial type x long bits mantissa Dfp tempDfp y  	projects/Math54/src/main/java/org/apache/commons/math/dfp/Dfp.java	1.0	2366	2366	1	replace	
49	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] str = str.substring(0, str.length()-1); long mantissa = Long.parseLong(str); if (mantissa == 4503599627370496L) {  mantissa = 0; exponent++; }  [BUGGY] [BUGGY] if (exponent <= -1023) { exponent--; } while (exponent < -1023) { exponent++; mantissa >>>= 1; } long bits = mantissa | ((exponent + 1023L) << 52); double x = Double.longBitsToDouble(bits); [CLASS] Dfp [METHOD] toDouble [RETURN_TYPE] double  [VARIABLES] boolean negate byte FINITE INFINITE QNAN SNAN asign bsign code nans rsign sig sign x double x DfpField field int[] dividend mant product quotient remainder String ADD_TRAP ALIGN_TRAP DIVIDE_TRAP GREATER_THAN_TRAP LESS_THAN_TRAP MULTIPLY_TRAP NAN_STRING NEG_INFINITY_STRING NEW_INSTANCE_TRAP NEXT_AFTER_TRAP POS_INFINITY_STRING SQRT_TRAP TRUNC_TRAP fpdecimal fpexp s str what int ERR_SCALE MAX_EXP MIN_EXP RADIX adiff ae aextradigit bextradigit decimalPos diff divMsb divisor dm e excp exp exponent extra i j lostdigit max md min minadj n nsqd offset p q qd r result rh rl rsize sciexp shf significantDigits trailingZeros trial type x long bits mantissa Dfp tempDfp y  	projects/Math54/src/main/java/org/apache/commons/math/dfp/Dfp.java	1.0	2366	2366	1	add	
50	[BUG] [BUGGY] while (exponent < -1023) { [FE] AssertionError [CONTEXT]  mantissa = 0; exponent++; }  if (exponent <= -1023) { exponent--; } [BUGGY] while (exponent < -1023) { [BUGGY] exponent++; mantissa >>>= 1; } long bits = mantissa | ((exponent + 1023L) << 52); double x = Double.longBitsToDouble(bits); if (negate) { x = -x; } [CLASS] Dfp [METHOD] toDouble [RETURN_TYPE] double  [VARIABLES] boolean negate byte FINITE INFINITE QNAN SNAN asign bsign code nans rsign sig sign x double x DfpField field int[] dividend mant product quotient remainder String ADD_TRAP ALIGN_TRAP DIVIDE_TRAP GREATER_THAN_TRAP LESS_THAN_TRAP MULTIPLY_TRAP NAN_STRING NEG_INFINITY_STRING NEW_INSTANCE_TRAP NEXT_AFTER_TRAP POS_INFINITY_STRING SQRT_TRAP TRUNC_TRAP fpdecimal fpexp s str what int ERR_SCALE MAX_EXP MIN_EXP RADIX adiff ae aextradigit bextradigit decimalPos diff divMsb divisor dm e excp exp exponent extra i j lostdigit max md min minadj n nsqd offset p q qd r result rh rl rsize sciexp shf significantDigits trailingZeros trial type x long bits mantissa Dfp tempDfp y  	projects/Math54/src/main/java/org/apache/commons/math/dfp/Dfp.java	1.0	2370	2370	1	replace	
51	[BUG] [BUGGY] [FE] AssertionError [CONTEXT]  mantissa = 0; exponent++; }  if (exponent <= -1023) { exponent--; } [BUGGY] [BUGGY] while (exponent < -1023) { exponent++; mantissa >>>= 1; } long bits = mantissa | ((exponent + 1023L) << 52); double x = Double.longBitsToDouble(bits); if (negate) { x = -x; } [CLASS] Dfp [METHOD] toDouble [RETURN_TYPE] double  [VARIABLES] boolean negate byte FINITE INFINITE QNAN SNAN asign bsign code nans rsign sig sign x double x DfpField field int[] dividend mant product quotient remainder String ADD_TRAP ALIGN_TRAP DIVIDE_TRAP GREATER_THAN_TRAP LESS_THAN_TRAP MULTIPLY_TRAP NAN_STRING NEG_INFINITY_STRING NEW_INSTANCE_TRAP NEXT_AFTER_TRAP POS_INFINITY_STRING SQRT_TRAP TRUNC_TRAP fpdecimal fpexp s str what int ERR_SCALE MAX_EXP MIN_EXP RADIX adiff ae aextradigit bextradigit decimalPos diff divMsb divisor dm e excp exp exponent extra i j lostdigit max md min minadj n nsqd offset p q qd r result rh rl rsize sciexp shf significantDigits trailingZeros trial type x long bits mantissa Dfp tempDfp y  	projects/Math54/src/main/java/org/apache/commons/math/dfp/Dfp.java	1.0	2370	2370	1	add	
52	[BUG] [BUGGY] long bits = mantissa | ((exponent + 1023L) << 52); [FE] AssertionError [CONTEXT]  if (exponent <= -1023) { exponent--; } while (exponent < -1023) { exponent++; mantissa >>>= 1; } [BUGGY] long bits = mantissa | ((exponent + 1023L) << 52); [BUGGY] double x = Double.longBitsToDouble(bits); if (negate) { x = -x; } return x; } [CLASS] Dfp [METHOD] toDouble [RETURN_TYPE] double  [VARIABLES] boolean negate byte FINITE INFINITE QNAN SNAN asign bsign code nans rsign sig sign x double x DfpField field int[] dividend mant product quotient remainder String ADD_TRAP ALIGN_TRAP DIVIDE_TRAP GREATER_THAN_TRAP LESS_THAN_TRAP MULTIPLY_TRAP NAN_STRING NEG_INFINITY_STRING NEW_INSTANCE_TRAP NEXT_AFTER_TRAP POS_INFINITY_STRING SQRT_TRAP TRUNC_TRAP fpdecimal fpexp s str what int ERR_SCALE MAX_EXP MIN_EXP RADIX adiff ae aextradigit bextradigit decimalPos diff divMsb divisor dm e excp exp exponent extra i j lostdigit max md min minadj n nsqd offset p q qd r result rh rl rsize sciexp shf significantDigits trailingZeros trial type x long bits mantissa Dfp tempDfp y  	projects/Math54/src/main/java/org/apache/commons/math/dfp/Dfp.java	1.0	2375	2375	1	replace	
53	[BUG] [BUGGY] [FE] AssertionError [CONTEXT]  if (exponent <= -1023) { exponent--; } while (exponent < -1023) { exponent++; mantissa >>>= 1; } [BUGGY] [BUGGY] long bits = mantissa | ((exponent + 1023L) << 52); double x = Double.longBitsToDouble(bits); if (negate) { x = -x; } return x; } [CLASS] Dfp [METHOD] toDouble [RETURN_TYPE] double  [VARIABLES] boolean negate byte FINITE INFINITE QNAN SNAN asign bsign code nans rsign sig sign x double x DfpField field int[] dividend mant product quotient remainder String ADD_TRAP ALIGN_TRAP DIVIDE_TRAP GREATER_THAN_TRAP LESS_THAN_TRAP MULTIPLY_TRAP NAN_STRING NEG_INFINITY_STRING NEW_INSTANCE_TRAP NEXT_AFTER_TRAP POS_INFINITY_STRING SQRT_TRAP TRUNC_TRAP fpdecimal fpexp s str what int ERR_SCALE MAX_EXP MIN_EXP RADIX adiff ae aextradigit bextradigit decimalPos diff divMsb divisor dm e excp exp exponent extra i j lostdigit max md min minadj n nsqd offset p q qd r result rh rl rsize sciexp shf significantDigits trailingZeros trial type x long bits mantissa Dfp tempDfp y  	projects/Math54/src/main/java/org/apache/commons/math/dfp/Dfp.java	1.0	2375	2375	1	add	
54	[BUG] [BUGGY] double x = Double.longBitsToDouble(bits); [FE] AssertionError [CONTEXT] if (exponent <= -1023) { exponent--; } while (exponent < -1023) { exponent++; mantissa >>>= 1; } long bits = mantissa | ((exponent + 1023L) << 52); [BUGGY] double x = Double.longBitsToDouble(bits); [BUGGY]  if (negate) { x = -x; } return x; } [CLASS] Dfp [METHOD] toDouble [RETURN_TYPE] double  [VARIABLES] boolean negate byte FINITE INFINITE QNAN SNAN asign bsign code nans rsign sig sign x double x DfpField field int[] dividend mant product quotient remainder String ADD_TRAP ALIGN_TRAP DIVIDE_TRAP GREATER_THAN_TRAP LESS_THAN_TRAP MULTIPLY_TRAP NAN_STRING NEG_INFINITY_STRING NEW_INSTANCE_TRAP NEXT_AFTER_TRAP POS_INFINITY_STRING SQRT_TRAP TRUNC_TRAP fpdecimal fpexp s str what int ERR_SCALE MAX_EXP MIN_EXP RADIX adiff ae aextradigit bextradigit decimalPos diff divMsb divisor dm e excp exp exponent extra i j lostdigit max md min minadj n nsqd offset p q qd r result rh rl rsize sciexp shf significantDigits trailingZeros trial type x long bits mantissa Dfp tempDfp y  	projects/Math54/src/main/java/org/apache/commons/math/dfp/Dfp.java	1.0	2376	2376	1	replace	
55	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] if (exponent <= -1023) { exponent--; } while (exponent < -1023) { exponent++; mantissa >>>= 1; } long bits = mantissa | ((exponent + 1023L) << 52); [BUGGY] [BUGGY] double x = Double.longBitsToDouble(bits); if (negate) { x = -x; } return x; } [CLASS] Dfp [METHOD] toDouble [RETURN_TYPE] double  [VARIABLES] boolean negate byte FINITE INFINITE QNAN SNAN asign bsign code nans rsign sig sign x double x DfpField field int[] dividend mant product quotient remainder String ADD_TRAP ALIGN_TRAP DIVIDE_TRAP GREATER_THAN_TRAP LESS_THAN_TRAP MULTIPLY_TRAP NAN_STRING NEG_INFINITY_STRING NEW_INSTANCE_TRAP NEXT_AFTER_TRAP POS_INFINITY_STRING SQRT_TRAP TRUNC_TRAP fpdecimal fpexp s str what int ERR_SCALE MAX_EXP MIN_EXP RADIX adiff ae aextradigit bextradigit decimalPos diff divMsb divisor dm e excp exp exponent extra i j lostdigit max md min minadj n nsqd offset p q qd r result rh rl rsize sciexp shf significantDigits trailingZeros trial type x long bits mantissa Dfp tempDfp y  	projects/Math54/src/main/java/org/apache/commons/math/dfp/Dfp.java	1.0	2376	2376	1	add	
56	[BUG] [BUGGY] if (negate) { [FE] AssertionError [CONTEXT] } while (exponent < -1023) { exponent++; mantissa >>>= 1; } long bits = mantissa | ((exponent + 1023L) << 52); double x = Double.longBitsToDouble(bits); [BUGGY] if (negate) { [BUGGY] x = -x; } return x; } [CLASS] Dfp [METHOD] toDouble [RETURN_TYPE] double  [VARIABLES] boolean negate byte FINITE INFINITE QNAN SNAN asign bsign code nans rsign sig sign x double x DfpField field int[] dividend mant product quotient remainder String ADD_TRAP ALIGN_TRAP DIVIDE_TRAP GREATER_THAN_TRAP LESS_THAN_TRAP MULTIPLY_TRAP NAN_STRING NEG_INFINITY_STRING NEW_INSTANCE_TRAP NEXT_AFTER_TRAP POS_INFINITY_STRING SQRT_TRAP TRUNC_TRAP fpdecimal fpexp s str what int ERR_SCALE MAX_EXP MIN_EXP RADIX adiff ae aextradigit bextradigit decimalPos diff divMsb divisor dm e excp exp exponent extra i j lostdigit max md min minadj n nsqd offset p q qd r result rh rl rsize sciexp shf significantDigits trailingZeros trial type x long bits mantissa Dfp tempDfp y  	projects/Math54/src/main/java/org/apache/commons/math/dfp/Dfp.java	1.0	2378	2378	1	replace	
57	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] } while (exponent < -1023) { exponent++; mantissa >>>= 1; } long bits = mantissa | ((exponent + 1023L) << 52); double x = Double.longBitsToDouble(bits); [BUGGY] [BUGGY] if (negate) { x = -x; } return x; } [CLASS] Dfp [METHOD] toDouble [RETURN_TYPE] double  [VARIABLES] boolean negate byte FINITE INFINITE QNAN SNAN asign bsign code nans rsign sig sign x double x DfpField field int[] dividend mant product quotient remainder String ADD_TRAP ALIGN_TRAP DIVIDE_TRAP GREATER_THAN_TRAP LESS_THAN_TRAP MULTIPLY_TRAP NAN_STRING NEG_INFINITY_STRING NEW_INSTANCE_TRAP NEXT_AFTER_TRAP POS_INFINITY_STRING SQRT_TRAP TRUNC_TRAP fpdecimal fpexp s str what int ERR_SCALE MAX_EXP MIN_EXP RADIX adiff ae aextradigit bextradigit decimalPos diff divMsb divisor dm e excp exp exponent extra i j lostdigit max md min minadj n nsqd offset p q qd r result rh rl rsize sciexp shf significantDigits trailingZeros trial type x long bits mantissa Dfp tempDfp y  	projects/Math54/src/main/java/org/apache/commons/math/dfp/Dfp.java	1.0	2378	2378	1	add	
58	[BUG] [BUGGY] return x; [FE] AssertionError [CONTEXT] mantissa >>>= 1; } long bits = mantissa | ((exponent + 1023L) << 52); double x = Double.longBitsToDouble(bits); if (negate) { x = -x; } [BUGGY] return x; [BUGGY]  } [CLASS] Dfp [METHOD] toDouble [RETURN_TYPE] double  [VARIABLES] boolean negate byte FINITE INFINITE QNAN SNAN asign bsign code nans rsign sig sign x double x DfpField field int[] dividend mant product quotient remainder String ADD_TRAP ALIGN_TRAP DIVIDE_TRAP GREATER_THAN_TRAP LESS_THAN_TRAP MULTIPLY_TRAP NAN_STRING NEG_INFINITY_STRING NEW_INSTANCE_TRAP NEXT_AFTER_TRAP POS_INFINITY_STRING SQRT_TRAP TRUNC_TRAP fpdecimal fpexp s str what int ERR_SCALE MAX_EXP MIN_EXP RADIX adiff ae aextradigit bextradigit decimalPos diff divMsb divisor dm e excp exp exponent extra i j lostdigit max md min minadj n nsqd offset p q qd r result rh rl rsize sciexp shf significantDigits trailingZeros trial type x long bits mantissa Dfp tempDfp y  	projects/Math54/src/main/java/org/apache/commons/math/dfp/Dfp.java	1.0	2382	2382	1	replace	
59	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] mantissa >>>= 1; } long bits = mantissa | ((exponent + 1023L) << 52); double x = Double.longBitsToDouble(bits); if (negate) { x = -x; } [BUGGY] [BUGGY] return x; } [CLASS] Dfp [METHOD] toDouble [RETURN_TYPE] double  [VARIABLES] boolean negate byte FINITE INFINITE QNAN SNAN asign bsign code nans rsign sig sign x double x DfpField field int[] dividend mant product quotient remainder String ADD_TRAP ALIGN_TRAP DIVIDE_TRAP GREATER_THAN_TRAP LESS_THAN_TRAP MULTIPLY_TRAP NAN_STRING NEG_INFINITY_STRING NEW_INSTANCE_TRAP NEXT_AFTER_TRAP POS_INFINITY_STRING SQRT_TRAP TRUNC_TRAP fpdecimal fpexp s str what int ERR_SCALE MAX_EXP MIN_EXP RADIX adiff ae aextradigit bextradigit decimalPos diff divMsb divisor dm e excp exp exponent extra i j lostdigit max md min minadj n nsqd offset p q qd r result rh rl rsize sciexp shf significantDigits trailingZeros trial type x long bits mantissa Dfp tempDfp y  	projects/Math54/src/main/java/org/apache/commons/math/dfp/Dfp.java	1.0	2382	2382	1	add	
60	[BUG] [BUGGY] if (mant[mant.length-1] > 1000) { [FE] AssertionError [CONTEXT] public int log10(){ [BUGGY] if (mant[mant.length-1] > 1000) { [BUGGY] return exp * 4 - 1; } if (mant[mant.length-1] > 100) { return exp * 4 - 2; } if (mant[mant.length-1] > 10) { return exp * 4 - 3; } return exp * 4 - 4; } [CLASS] Dfp [METHOD] log10 [RETURN_TYPE] int  [VARIABLES] DfpField field int[] mant String ADD_TRAP ALIGN_TRAP DIVIDE_TRAP GREATER_THAN_TRAP LESS_THAN_TRAP MULTIPLY_TRAP NAN_STRING NEG_INFINITY_STRING NEW_INSTANCE_TRAP NEXT_AFTER_TRAP POS_INFINITY_STRING SQRT_TRAP TRUNC_TRAP fpdecimal fpexp s boolean byte FINITE INFINITE QNAN SNAN code nans sig sign x int ERR_SCALE MAX_EXP MIN_EXP RADIX adiff decimalPos diff e exp exponent i lostdigit offset p q result rsize sciexp significantDigits trailingZeros x  	projects/Math54/src/main/java/org/apache/commons/math/dfp/Dfp.java	0.7071067811865475	1096	1096	1	replace	
61	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] public int log10(){ [BUGGY] [BUGGY] if (mant[mant.length-1] > 1000) { return exp * 4 - 1; } if (mant[mant.length-1] > 100) { return exp * 4 - 2; } if (mant[mant.length-1] > 10) { return exp * 4 - 3; } return exp * 4 - 4; } [CLASS] Dfp [METHOD] log10 [RETURN_TYPE] int  [VARIABLES] DfpField field int[] mant String ADD_TRAP ALIGN_TRAP DIVIDE_TRAP GREATER_THAN_TRAP LESS_THAN_TRAP MULTIPLY_TRAP NAN_STRING NEG_INFINITY_STRING NEW_INSTANCE_TRAP NEXT_AFTER_TRAP POS_INFINITY_STRING SQRT_TRAP TRUNC_TRAP fpdecimal fpexp s boolean byte FINITE INFINITE QNAN SNAN code nans sig sign x int ERR_SCALE MAX_EXP MIN_EXP RADIX adiff decimalPos diff e exp exponent i lostdigit offset p q result rsize sciexp significantDigits trailingZeros x  	projects/Math54/src/main/java/org/apache/commons/math/dfp/Dfp.java	0.7071067811865475	1096	1096	1	add	
62	[BUG] [BUGGY] if (mant[mant.length-1] > 100) { [FE] AssertionError [CONTEXT] public int log10(){ if (mant[mant.length-1] > 1000) { return exp * 4 - 1; } [BUGGY] if (mant[mant.length-1] > 100) { [BUGGY] return exp * 4 - 2; } if (mant[mant.length-1] > 10) { return exp * 4 - 3; } return exp * 4 - 4; } [CLASS] Dfp [METHOD] log10 [RETURN_TYPE] int  [VARIABLES] DfpField field int[] mant String ADD_TRAP ALIGN_TRAP DIVIDE_TRAP GREATER_THAN_TRAP LESS_THAN_TRAP MULTIPLY_TRAP NAN_STRING NEG_INFINITY_STRING NEW_INSTANCE_TRAP NEXT_AFTER_TRAP POS_INFINITY_STRING SQRT_TRAP TRUNC_TRAP fpdecimal fpexp s boolean byte FINITE INFINITE QNAN SNAN code nans sig sign x int ERR_SCALE MAX_EXP MIN_EXP RADIX adiff decimalPos diff e exp exponent i lostdigit offset p q result rsize sciexp significantDigits trailingZeros x  	projects/Math54/src/main/java/org/apache/commons/math/dfp/Dfp.java	0.7071067811865475	1099	1099	1	replace	
63	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] public int log10(){ if (mant[mant.length-1] > 1000) { return exp * 4 - 1; } [BUGGY] [BUGGY] if (mant[mant.length-1] > 100) { return exp * 4 - 2; } if (mant[mant.length-1] > 10) { return exp * 4 - 3; } return exp * 4 - 4; } [CLASS] Dfp [METHOD] log10 [RETURN_TYPE] int  [VARIABLES] DfpField field int[] mant String ADD_TRAP ALIGN_TRAP DIVIDE_TRAP GREATER_THAN_TRAP LESS_THAN_TRAP MULTIPLY_TRAP NAN_STRING NEG_INFINITY_STRING NEW_INSTANCE_TRAP NEXT_AFTER_TRAP POS_INFINITY_STRING SQRT_TRAP TRUNC_TRAP fpdecimal fpexp s boolean byte FINITE INFINITE QNAN SNAN code nans sig sign x int ERR_SCALE MAX_EXP MIN_EXP RADIX adiff decimalPos diff e exp exponent i lostdigit offset p q result rsize sciexp significantDigits trailingZeros x  	projects/Math54/src/main/java/org/apache/commons/math/dfp/Dfp.java	0.7071067811865475	1099	1099	1	add	
64	[BUG] [BUGGY] if (mant[mant.length-1] > 10) { [FE] AssertionError [CONTEXT] public int log10(){ if (mant[mant.length-1] > 1000) { return exp * 4 - 1; } if (mant[mant.length-1] > 100) { return exp * 4 - 2; } [BUGGY] if (mant[mant.length-1] > 10) { [BUGGY] return exp * 4 - 3; } return exp * 4 - 4; } [CLASS] Dfp [METHOD] log10 [RETURN_TYPE] int  [VARIABLES] DfpField field int[] mant String ADD_TRAP ALIGN_TRAP DIVIDE_TRAP GREATER_THAN_TRAP LESS_THAN_TRAP MULTIPLY_TRAP NAN_STRING NEG_INFINITY_STRING NEW_INSTANCE_TRAP NEXT_AFTER_TRAP POS_INFINITY_STRING SQRT_TRAP TRUNC_TRAP fpdecimal fpexp s boolean byte FINITE INFINITE QNAN SNAN code nans sig sign x int ERR_SCALE MAX_EXP MIN_EXP RADIX adiff decimalPos diff e exp exponent i lostdigit offset p q result rsize sciexp significantDigits trailingZeros x  	projects/Math54/src/main/java/org/apache/commons/math/dfp/Dfp.java	0.7071067811865475	1102	1102	1	replace	
65	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] public int log10(){ if (mant[mant.length-1] > 1000) { return exp * 4 - 1; } if (mant[mant.length-1] > 100) { return exp * 4 - 2; } [BUGGY] [BUGGY] if (mant[mant.length-1] > 10) { return exp * 4 - 3; } return exp * 4 - 4; } [CLASS] Dfp [METHOD] log10 [RETURN_TYPE] int  [VARIABLES] DfpField field int[] mant String ADD_TRAP ALIGN_TRAP DIVIDE_TRAP GREATER_THAN_TRAP LESS_THAN_TRAP MULTIPLY_TRAP NAN_STRING NEG_INFINITY_STRING NEW_INSTANCE_TRAP NEXT_AFTER_TRAP POS_INFINITY_STRING SQRT_TRAP TRUNC_TRAP fpdecimal fpexp s boolean byte FINITE INFINITE QNAN SNAN code nans sig sign x int ERR_SCALE MAX_EXP MIN_EXP RADIX adiff decimalPos diff e exp exponent i lostdigit offset p q result rsize sciexp significantDigits trailingZeros x  	projects/Math54/src/main/java/org/apache/commons/math/dfp/Dfp.java	0.7071067811865475	1102	1102	1	add	
66	[BUG] [BUGGY] return exp * 4 - 4; [FE] AssertionError [CONTEXT] public int log10(){ if (mant[mant.length-1] > 1000) { return exp * 4 - 1; } if (mant[mant.length-1] > 100) { return exp * 4 - 2; } if (mant[mant.length-1] > 10) { return exp * 4 - 3; } [BUGGY] return exp * 4 - 4; [BUGGY] } [CLASS] Dfp [METHOD] log10 [RETURN_TYPE] int  [VARIABLES] DfpField field int[] mant String ADD_TRAP ALIGN_TRAP DIVIDE_TRAP GREATER_THAN_TRAP LESS_THAN_TRAP MULTIPLY_TRAP NAN_STRING NEG_INFINITY_STRING NEW_INSTANCE_TRAP NEXT_AFTER_TRAP POS_INFINITY_STRING SQRT_TRAP TRUNC_TRAP fpdecimal fpexp s boolean byte FINITE INFINITE QNAN SNAN code nans sig sign x int ERR_SCALE MAX_EXP MIN_EXP RADIX adiff decimalPos diff e exp exponent i lostdigit offset p q result rsize sciexp significantDigits trailingZeros x  	projects/Math54/src/main/java/org/apache/commons/math/dfp/Dfp.java	0.7071067811865475	1105	1105	1	replace	
67	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] public int log10(){ if (mant[mant.length-1] > 1000) { return exp * 4 - 1; } if (mant[mant.length-1] > 100) { return exp * 4 - 2; } if (mant[mant.length-1] > 10) { return exp * 4 - 3; } [BUGGY] [BUGGY] return exp * 4 - 4; } [CLASS] Dfp [METHOD] log10 [RETURN_TYPE] int  [VARIABLES] DfpField field int[] mant String ADD_TRAP ALIGN_TRAP DIVIDE_TRAP GREATER_THAN_TRAP LESS_THAN_TRAP MULTIPLY_TRAP NAN_STRING NEG_INFINITY_STRING NEW_INSTANCE_TRAP NEXT_AFTER_TRAP POS_INFINITY_STRING SQRT_TRAP TRUNC_TRAP fpdecimal fpexp s boolean byte FINITE INFINITE QNAN SNAN code nans sig sign x int ERR_SCALE MAX_EXP MIN_EXP RADIX adiff decimalPos diff e exp exponent i lostdigit offset p q result rsize sciexp significantDigits trailingZeros x  	projects/Math54/src/main/java/org/apache/commons/math/dfp/Dfp.java	0.7071067811865475	1105	1105	1	add	
68	[BUG] [BUGGY] return result; [FE] AssertionError [CONTEXT] result = result.add(a); } break; } field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);// signal inexact result = dotrap(DfpField.FLAG_INEXACT, TRUNC_TRAP, this, result); return result; } [BUGGY] return result; [BUGGY] } [CLASS] Dfp [METHOD] trunc [RETURN_TYPE] Dfp  RoundingMode rmode [VARIABLES] boolean changed byte FINITE INFINITE QNAN SNAN code nans sig sign x RoundingMode rmode DfpField field int[] mant String ADD_TRAP ALIGN_TRAP DIVIDE_TRAP GREATER_THAN_TRAP LESS_THAN_TRAP MULTIPLY_TRAP NAN_STRING NEG_INFINITY_STRING NEW_INSTANCE_TRAP NEXT_AFTER_TRAP POS_INFINITY_STRING SQRT_TRAP TRUNC_TRAP fpdecimal fpexp s int ERR_SCALE MAX_EXP MIN_EXP RADIX adiff decimalPos diff e exp exponent i lostdigit offset p q rsize sciexp significantDigits trailingZeros x Dfp a half result  	projects/Math54/src/main/java/org/apache/commons/math/dfp/Dfp.java	0.5773502691896258	1041	1041	1	replace	
69	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] result = result.add(a); } break; } field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);// signal inexact result = dotrap(DfpField.FLAG_INEXACT, TRUNC_TRAP, this, result); return result; } [BUGGY] [BUGGY] return result; } [CLASS] Dfp [METHOD] trunc [RETURN_TYPE] Dfp  RoundingMode rmode [VARIABLES] boolean changed byte FINITE INFINITE QNAN SNAN code nans sig sign x RoundingMode rmode DfpField field int[] mant String ADD_TRAP ALIGN_TRAP DIVIDE_TRAP GREATER_THAN_TRAP LESS_THAN_TRAP MULTIPLY_TRAP NAN_STRING NEG_INFINITY_STRING NEW_INSTANCE_TRAP NEXT_AFTER_TRAP POS_INFINITY_STRING SQRT_TRAP TRUNC_TRAP fpdecimal fpexp s int ERR_SCALE MAX_EXP MIN_EXP RADIX adiff decimalPos diff e exp exponent i lostdigit offset p q rsize sciexp significantDigits trailingZeros x Dfp a half result  	projects/Math54/src/main/java/org/apache/commons/math/dfp/Dfp.java	0.5773502691896258	1041	1041	1	add	
70	[BUG] [BUGGY] a.exp = b.exp; [FE] AssertionError [CONTEXT] }  of the zero number equal to the other one.This avoids an alignment which would cause catastropic loss of precision */ if (b.mant[mant.length-1] == 0) { b.exp = a.exp; } if (a.mant[mant.length-1] == 0) { [BUGGY] a.exp = b.exp; [BUGGY] }  int aextradigit = 0; int bextradigit = 0; if (a.exp < b.exp) { aextradigit = a.align(b.exp); } else { bextradigit = b.align(a.exp); } [CLASS] Dfp [METHOD] add [RETURN_TYPE] Dfp  Dfp x [VARIABLES] boolean byte FINITE INFINITE QNAN SNAN asign bsign code nans rsign sig sign x DfpField field int[] mant String ADD_TRAP ALIGN_TRAP DIVIDE_TRAP GREATER_THAN_TRAP LESS_THAN_TRAP MULTIPLY_TRAP NAN_STRING NEG_INFINITY_STRING NEW_INSTANCE_TRAP NEXT_AFTER_TRAP POS_INFINITY_STRING SQRT_TRAP TRUNC_TRAP fpdecimal fpexp s int ERR_SCALE MAX_EXP MIN_EXP RADIX adiff aextradigit bextradigit decimalPos diff e excp exp exponent extra i lostdigit offset p q r result rh rsize sciexp significantDigits trailingZeros x Dfp a b result x  	projects/Math54/src/main/java/org/apache/commons/math/dfp/Dfp.java	0.5773502691896258	1234	1234	1	replace	
71	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] }  of the zero number equal to the other one.This avoids an alignment which would cause catastropic loss of precision */ if (b.mant[mant.length-1] == 0) { b.exp = a.exp; } if (a.mant[mant.length-1] == 0) { [BUGGY] [BUGGY] a.exp = b.exp; }  int aextradigit = 0; int bextradigit = 0; if (a.exp < b.exp) { aextradigit = a.align(b.exp); } else { bextradigit = b.align(a.exp); } [CLASS] Dfp [METHOD] add [RETURN_TYPE] Dfp  Dfp x [VARIABLES] boolean byte FINITE INFINITE QNAN SNAN asign bsign code nans rsign sig sign x DfpField field int[] mant String ADD_TRAP ALIGN_TRAP DIVIDE_TRAP GREATER_THAN_TRAP LESS_THAN_TRAP MULTIPLY_TRAP NAN_STRING NEG_INFINITY_STRING NEW_INSTANCE_TRAP NEXT_AFTER_TRAP POS_INFINITY_STRING SQRT_TRAP TRUNC_TRAP fpdecimal fpexp s int ERR_SCALE MAX_EXP MIN_EXP RADIX adiff aextradigit bextradigit decimalPos diff e excp exp exponent extra i lostdigit offset p q r result rh rsize sciexp significantDigits trailingZeros x Dfp a b result x  	projects/Math54/src/main/java/org/apache/commons/math/dfp/Dfp.java	0.5773502691896258	1234	1234	1	add	
72	[BUG] [BUGGY] return trunc(DfpField.RoundingMode.ROUND_HALF_EVEN); [FE] AssertionError [CONTEXT] public Dfp rint() { [BUGGY] return trunc(DfpField.RoundingMode.ROUND_HALF_EVEN); [BUGGY] } [CLASS] Dfp [METHOD] rint [RETURN_TYPE] Dfp  [VARIABLES] DfpField field int[] mant String ADD_TRAP ALIGN_TRAP DIVIDE_TRAP GREATER_THAN_TRAP LESS_THAN_TRAP MULTIPLY_TRAP NAN_STRING NEG_INFINITY_STRING NEW_INSTANCE_TRAP NEXT_AFTER_TRAP POS_INFINITY_STRING SQRT_TRAP TRUNC_TRAP fpdecimal fpexp s boolean byte FINITE INFINITE QNAN SNAN code nans sig sign x int ERR_SCALE MAX_EXP MIN_EXP RADIX adiff decimalPos diff e exp exponent i lostdigit offset p q rsize sciexp significantDigits trailingZeros x  	projects/Math54/src/main/java/org/apache/commons/math/dfp/Dfp.java	0.5	918	918	1	replace	
73	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] public Dfp rint() { [BUGGY] [BUGGY] return trunc(DfpField.RoundingMode.ROUND_HALF_EVEN); } [CLASS] Dfp [METHOD] rint [RETURN_TYPE] Dfp  [VARIABLES] DfpField field int[] mant String ADD_TRAP ALIGN_TRAP DIVIDE_TRAP GREATER_THAN_TRAP LESS_THAN_TRAP MULTIPLY_TRAP NAN_STRING NEG_INFINITY_STRING NEW_INSTANCE_TRAP NEXT_AFTER_TRAP POS_INFINITY_STRING SQRT_TRAP TRUNC_TRAP fpdecimal fpexp s boolean byte FINITE INFINITE QNAN SNAN code nans sig sign x int ERR_SCALE MAX_EXP MIN_EXP RADIX adiff decimalPos diff e exp exponent i lostdigit offset p q rsize sciexp significantDigits trailingZeros x  	projects/Math54/src/main/java/org/apache/commons/math/dfp/Dfp.java	0.5	918	918	1	add	
74	[BUG] [BUGGY] boolean changed = false; [FE] AssertionError [CONTEXT] protected Dfp trunc(final DfpField.RoundingMode rmode) { [BUGGY] boolean changed = false; [BUGGY]  if (isNaN()) { return newInstance(this); } if (nans == INFINITE) { return newInstance(this); } if (mant[mant.length-1] == 0) { [CLASS] Dfp [METHOD] trunc [RETURN_TYPE] Dfp  RoundingMode rmode [VARIABLES] boolean changed byte FINITE INFINITE QNAN SNAN code nans sig sign x RoundingMode rmode DfpField field int[] mant String ADD_TRAP ALIGN_TRAP DIVIDE_TRAP GREATER_THAN_TRAP LESS_THAN_TRAP MULTIPLY_TRAP NAN_STRING NEG_INFINITY_STRING NEW_INSTANCE_TRAP NEXT_AFTER_TRAP POS_INFINITY_STRING SQRT_TRAP TRUNC_TRAP fpdecimal fpexp s int ERR_SCALE MAX_EXP MIN_EXP RADIX adiff decimalPos diff e exp exponent i lostdigit offset p q rsize sciexp significantDigits trailingZeros x Dfp a half result  	projects/Math54/src/main/java/org/apache/commons/math/dfp/Dfp.java	0.4082482904638631	959	959	1	replace	
75	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] protected Dfp trunc(final DfpField.RoundingMode rmode) { [BUGGY] [BUGGY] boolean changed = false; if (isNaN()) { return newInstance(this); } if (nans == INFINITE) { return newInstance(this); } if (mant[mant.length-1] == 0) { [CLASS] Dfp [METHOD] trunc [RETURN_TYPE] Dfp  RoundingMode rmode [VARIABLES] boolean changed byte FINITE INFINITE QNAN SNAN code nans sig sign x RoundingMode rmode DfpField field int[] mant String ADD_TRAP ALIGN_TRAP DIVIDE_TRAP GREATER_THAN_TRAP LESS_THAN_TRAP MULTIPLY_TRAP NAN_STRING NEG_INFINITY_STRING NEW_INSTANCE_TRAP NEXT_AFTER_TRAP POS_INFINITY_STRING SQRT_TRAP TRUNC_TRAP fpdecimal fpexp s int ERR_SCALE MAX_EXP MIN_EXP RADIX adiff decimalPos diff e exp exponent i lostdigit offset p q rsize sciexp significantDigits trailingZeros x Dfp a half result  	projects/Math54/src/main/java/org/apache/commons/math/dfp/Dfp.java	0.4082482904638631	959	959	1	add	
76	[BUG] [BUGGY] if (isNaN()) { [FE] AssertionError [CONTEXT] protected Dfp trunc(final DfpField.RoundingMode rmode) { boolean changed = false; [BUGGY] if (isNaN()) { [BUGGY] return newInstance(this); } if (nans == INFINITE) { return newInstance(this); } if (mant[mant.length-1] == 0) {  return newInstance(this); [CLASS] Dfp [METHOD] trunc [RETURN_TYPE] Dfp  RoundingMode rmode [VARIABLES] boolean changed byte FINITE INFINITE QNAN SNAN code nans sig sign x RoundingMode rmode DfpField field int[] mant String ADD_TRAP ALIGN_TRAP DIVIDE_TRAP GREATER_THAN_TRAP LESS_THAN_TRAP MULTIPLY_TRAP NAN_STRING NEG_INFINITY_STRING NEW_INSTANCE_TRAP NEXT_AFTER_TRAP POS_INFINITY_STRING SQRT_TRAP TRUNC_TRAP fpdecimal fpexp s int ERR_SCALE MAX_EXP MIN_EXP RADIX adiff decimalPos diff e exp exponent i lostdigit offset p q rsize sciexp significantDigits trailingZeros x Dfp a half result  	projects/Math54/src/main/java/org/apache/commons/math/dfp/Dfp.java	0.4082482904638631	961	961	1	replace	
77	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] protected Dfp trunc(final DfpField.RoundingMode rmode) { boolean changed = false; [BUGGY] [BUGGY] if (isNaN()) { return newInstance(this); } if (nans == INFINITE) { return newInstance(this); } if (mant[mant.length-1] == 0) {  return newInstance(this); [CLASS] Dfp [METHOD] trunc [RETURN_TYPE] Dfp  RoundingMode rmode [VARIABLES] boolean changed byte FINITE INFINITE QNAN SNAN code nans sig sign x RoundingMode rmode DfpField field int[] mant String ADD_TRAP ALIGN_TRAP DIVIDE_TRAP GREATER_THAN_TRAP LESS_THAN_TRAP MULTIPLY_TRAP NAN_STRING NEG_INFINITY_STRING NEW_INSTANCE_TRAP NEXT_AFTER_TRAP POS_INFINITY_STRING SQRT_TRAP TRUNC_TRAP fpdecimal fpexp s int ERR_SCALE MAX_EXP MIN_EXP RADIX adiff decimalPos diff e exp exponent i lostdigit offset p q rsize sciexp significantDigits trailingZeros x Dfp a half result  	projects/Math54/src/main/java/org/apache/commons/math/dfp/Dfp.java	0.4082482904638631	961	961	1	add	
78	[BUG] [BUGGY] if (nans == INFINITE) { [FE] AssertionError [CONTEXT] protected Dfp trunc(final DfpField.RoundingMode rmode) { boolean changed = false; if (isNaN()) { return newInstance(this); } [BUGGY] if (nans == INFINITE) { [BUGGY] return newInstance(this); } if (mant[mant.length-1] == 0) {  return newInstance(this); }    [CLASS] Dfp [METHOD] trunc [RETURN_TYPE] Dfp  RoundingMode rmode [VARIABLES] boolean changed byte FINITE INFINITE QNAN SNAN code nans sig sign x RoundingMode rmode DfpField field int[] mant String ADD_TRAP ALIGN_TRAP DIVIDE_TRAP GREATER_THAN_TRAP LESS_THAN_TRAP MULTIPLY_TRAP NAN_STRING NEG_INFINITY_STRING NEW_INSTANCE_TRAP NEXT_AFTER_TRAP POS_INFINITY_STRING SQRT_TRAP TRUNC_TRAP fpdecimal fpexp s int ERR_SCALE MAX_EXP MIN_EXP RADIX adiff decimalPos diff e exp exponent i lostdigit offset p q rsize sciexp significantDigits trailingZeros x Dfp a half result  	projects/Math54/src/main/java/org/apache/commons/math/dfp/Dfp.java	0.4082482904638631	965	965	1	replace	
79	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] protected Dfp trunc(final DfpField.RoundingMode rmode) { boolean changed = false; if (isNaN()) { return newInstance(this); } [BUGGY] [BUGGY] if (nans == INFINITE) { return newInstance(this); } if (mant[mant.length-1] == 0) {  return newInstance(this); }    [CLASS] Dfp [METHOD] trunc [RETURN_TYPE] Dfp  RoundingMode rmode [VARIABLES] boolean changed byte FINITE INFINITE QNAN SNAN code nans sig sign x RoundingMode rmode DfpField field int[] mant String ADD_TRAP ALIGN_TRAP DIVIDE_TRAP GREATER_THAN_TRAP LESS_THAN_TRAP MULTIPLY_TRAP NAN_STRING NEG_INFINITY_STRING NEW_INSTANCE_TRAP NEXT_AFTER_TRAP POS_INFINITY_STRING SQRT_TRAP TRUNC_TRAP fpdecimal fpexp s int ERR_SCALE MAX_EXP MIN_EXP RADIX adiff decimalPos diff e exp exponent i lostdigit offset p q rsize sciexp significantDigits trailingZeros x Dfp a half result  	projects/Math54/src/main/java/org/apache/commons/math/dfp/Dfp.java	0.4082482904638631	965	965	1	add	
80	[BUG] [BUGGY] if (mant[mant.length-1] == 0) { [FE] AssertionError [CONTEXT] boolean changed = false; if (isNaN()) { return newInstance(this); } if (nans == INFINITE) { return newInstance(this); } [BUGGY] if (mant[mant.length-1] == 0) { [BUGGY]  return newInstance(this); }   if (exp < 0) { field.setIEEEFlagsBits(DfpField.FLAG_INEXACT); Dfp result = newInstance(getZero()); result = dotrap(DfpField.FLAG_INEXACT, TRUNC_TRAP, this, result); [CLASS] Dfp [METHOD] trunc [RETURN_TYPE] Dfp  RoundingMode rmode [VARIABLES] boolean changed byte FINITE INFINITE QNAN SNAN code nans sig sign x RoundingMode rmode DfpField field int[] mant String ADD_TRAP ALIGN_TRAP DIVIDE_TRAP GREATER_THAN_TRAP LESS_THAN_TRAP MULTIPLY_TRAP NAN_STRING NEG_INFINITY_STRING NEW_INSTANCE_TRAP NEXT_AFTER_TRAP POS_INFINITY_STRING SQRT_TRAP TRUNC_TRAP fpdecimal fpexp s int ERR_SCALE MAX_EXP MIN_EXP RADIX adiff decimalPos diff e exp exponent i lostdigit offset p q rsize sciexp significantDigits trailingZeros x Dfp a half result  	projects/Math54/src/main/java/org/apache/commons/math/dfp/Dfp.java	0.4082482904638631	969	969	1	replace	
81	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] boolean changed = false; if (isNaN()) { return newInstance(this); } if (nans == INFINITE) { return newInstance(this); } [BUGGY] [BUGGY] if (mant[mant.length-1] == 0) {  return newInstance(this); }   if (exp < 0) { field.setIEEEFlagsBits(DfpField.FLAG_INEXACT); Dfp result = newInstance(getZero()); result = dotrap(DfpField.FLAG_INEXACT, TRUNC_TRAP, this, result); [CLASS] Dfp [METHOD] trunc [RETURN_TYPE] Dfp  RoundingMode rmode [VARIABLES] boolean changed byte FINITE INFINITE QNAN SNAN code nans sig sign x RoundingMode rmode DfpField field int[] mant String ADD_TRAP ALIGN_TRAP DIVIDE_TRAP GREATER_THAN_TRAP LESS_THAN_TRAP MULTIPLY_TRAP NAN_STRING NEG_INFINITY_STRING NEW_INSTANCE_TRAP NEXT_AFTER_TRAP POS_INFINITY_STRING SQRT_TRAP TRUNC_TRAP fpdecimal fpexp s int ERR_SCALE MAX_EXP MIN_EXP RADIX adiff decimalPos diff e exp exponent i lostdigit offset p q rsize sciexp significantDigits trailingZeros x Dfp a half result  	projects/Math54/src/main/java/org/apache/commons/math/dfp/Dfp.java	0.4082482904638631	969	969	1	add	
82	[BUG] [BUGGY] if (exp < 0) { [FE] AssertionError [CONTEXT] return newInstance(this); } if (mant[mant.length-1] == 0) {  return newInstance(this); }   [BUGGY] if (exp < 0) { [BUGGY] field.setIEEEFlagsBits(DfpField.FLAG_INEXACT); Dfp result = newInstance(getZero()); result = dotrap(DfpField.FLAG_INEXACT, TRUNC_TRAP, this, result); return result; }     [CLASS] Dfp [METHOD] trunc [RETURN_TYPE] Dfp  RoundingMode rmode [VARIABLES] boolean changed byte FINITE INFINITE QNAN SNAN code nans sig sign x RoundingMode rmode DfpField field int[] mant String ADD_TRAP ALIGN_TRAP DIVIDE_TRAP GREATER_THAN_TRAP LESS_THAN_TRAP MULTIPLY_TRAP NAN_STRING NEG_INFINITY_STRING NEW_INSTANCE_TRAP NEXT_AFTER_TRAP POS_INFINITY_STRING SQRT_TRAP TRUNC_TRAP fpdecimal fpexp s int ERR_SCALE MAX_EXP MIN_EXP RADIX adiff decimalPos diff e exp exponent i lostdigit offset p q rsize sciexp significantDigits trailingZeros x Dfp a half result  	projects/Math54/src/main/java/org/apache/commons/math/dfp/Dfp.java	0.4082482904638631	976	976	1	replace	
83	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] return newInstance(this); } if (mant[mant.length-1] == 0) {  return newInstance(this); }   [BUGGY] [BUGGY] if (exp < 0) { field.setIEEEFlagsBits(DfpField.FLAG_INEXACT); Dfp result = newInstance(getZero()); result = dotrap(DfpField.FLAG_INEXACT, TRUNC_TRAP, this, result); return result; }     [CLASS] Dfp [METHOD] trunc [RETURN_TYPE] Dfp  RoundingMode rmode [VARIABLES] boolean changed byte FINITE INFINITE QNAN SNAN code nans sig sign x RoundingMode rmode DfpField field int[] mant String ADD_TRAP ALIGN_TRAP DIVIDE_TRAP GREATER_THAN_TRAP LESS_THAN_TRAP MULTIPLY_TRAP NAN_STRING NEG_INFINITY_STRING NEW_INSTANCE_TRAP NEXT_AFTER_TRAP POS_INFINITY_STRING SQRT_TRAP TRUNC_TRAP fpdecimal fpexp s int ERR_SCALE MAX_EXP MIN_EXP RADIX adiff decimalPos diff e exp exponent i lostdigit offset p q rsize sciexp significantDigits trailingZeros x Dfp a half result  	projects/Math54/src/main/java/org/apache/commons/math/dfp/Dfp.java	0.4082482904638631	976	976	1	add	
84	[BUG] [BUGGY] if (exp >= mant.length) { [FE] AssertionError [CONTEXT] field.setIEEEFlagsBits(DfpField.FLAG_INEXACT); Dfp result = newInstance(getZero()); result = dotrap(DfpField.FLAG_INEXACT, TRUNC_TRAP, this, result); return result; }     [BUGGY] if (exp >= mant.length) { [BUGGY] return newInstance(this); }    Dfp result = newInstance(this); for (int i = 0; i < mant.length-result.exp; i++) { changed |= result.mant[i] != 0; result.mant[i] = 0; [CLASS] Dfp [METHOD] trunc [RETURN_TYPE] Dfp  RoundingMode rmode [VARIABLES] boolean changed byte FINITE INFINITE QNAN SNAN code nans sig sign x RoundingMode rmode DfpField field int[] mant String ADD_TRAP ALIGN_TRAP DIVIDE_TRAP GREATER_THAN_TRAP LESS_THAN_TRAP MULTIPLY_TRAP NAN_STRING NEG_INFINITY_STRING NEW_INSTANCE_TRAP NEXT_AFTER_TRAP POS_INFINITY_STRING SQRT_TRAP TRUNC_TRAP fpdecimal fpexp s int ERR_SCALE MAX_EXP MIN_EXP RADIX adiff decimalPos diff e exp exponent i lostdigit offset p q rsize sciexp significantDigits trailingZeros x Dfp a half result  	projects/Math54/src/main/java/org/apache/commons/math/dfp/Dfp.java	0.4082482904638631	987	987	1	replace	
85	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] field.setIEEEFlagsBits(DfpField.FLAG_INEXACT); Dfp result = newInstance(getZero()); result = dotrap(DfpField.FLAG_INEXACT, TRUNC_TRAP, this, result); return result; }     [BUGGY] [BUGGY] if (exp >= mant.length) { return newInstance(this); }    Dfp result = newInstance(this); for (int i = 0; i < mant.length-result.exp; i++) { changed |= result.mant[i] != 0; result.mant[i] = 0; [CLASS] Dfp [METHOD] trunc [RETURN_TYPE] Dfp  RoundingMode rmode [VARIABLES] boolean changed byte FINITE INFINITE QNAN SNAN code nans sig sign x RoundingMode rmode DfpField field int[] mant String ADD_TRAP ALIGN_TRAP DIVIDE_TRAP GREATER_THAN_TRAP LESS_THAN_TRAP MULTIPLY_TRAP NAN_STRING NEG_INFINITY_STRING NEW_INSTANCE_TRAP NEXT_AFTER_TRAP POS_INFINITY_STRING SQRT_TRAP TRUNC_TRAP fpdecimal fpexp s int ERR_SCALE MAX_EXP MIN_EXP RADIX adiff decimalPos diff e exp exponent i lostdigit offset p q rsize sciexp significantDigits trailingZeros x Dfp a half result  	projects/Math54/src/main/java/org/apache/commons/math/dfp/Dfp.java	0.4082482904638631	987	987	1	add	
86	[BUG] [BUGGY] Dfp result = newInstance(this); [FE] AssertionError [CONTEXT]   if (exp >= mant.length) { return newInstance(this); }    [BUGGY] Dfp result = newInstance(this); [BUGGY] for (int i = 0; i < mant.length-result.exp; i++) { changed |= result.mant[i] != 0; result.mant[i] = 0; } if (changed) { switch (rmode) { case ROUND_FLOOR: if (result.sign == -1) {  [CLASS] Dfp [METHOD] trunc [RETURN_TYPE] Dfp  RoundingMode rmode [VARIABLES] boolean changed byte FINITE INFINITE QNAN SNAN code nans sig sign x RoundingMode rmode DfpField field int[] mant String ADD_TRAP ALIGN_TRAP DIVIDE_TRAP GREATER_THAN_TRAP LESS_THAN_TRAP MULTIPLY_TRAP NAN_STRING NEG_INFINITY_STRING NEW_INSTANCE_TRAP NEXT_AFTER_TRAP POS_INFINITY_STRING SQRT_TRAP TRUNC_TRAP fpdecimal fpexp s int ERR_SCALE MAX_EXP MIN_EXP RADIX adiff decimalPos diff e exp exponent i lostdigit offset p q rsize sciexp significantDigits trailingZeros x Dfp a half result  	projects/Math54/src/main/java/org/apache/commons/math/dfp/Dfp.java	0.4082482904638631	994	994	1	replace	
87	[BUG] [BUGGY] [FE] AssertionError [CONTEXT]   if (exp >= mant.length) { return newInstance(this); }    [BUGGY] [BUGGY] Dfp result = newInstance(this); for (int i = 0; i < mant.length-result.exp; i++) { changed |= result.mant[i] != 0; result.mant[i] = 0; } if (changed) { switch (rmode) { case ROUND_FLOOR: if (result.sign == -1) {  [CLASS] Dfp [METHOD] trunc [RETURN_TYPE] Dfp  RoundingMode rmode [VARIABLES] boolean changed byte FINITE INFINITE QNAN SNAN code nans sig sign x RoundingMode rmode DfpField field int[] mant String ADD_TRAP ALIGN_TRAP DIVIDE_TRAP GREATER_THAN_TRAP LESS_THAN_TRAP MULTIPLY_TRAP NAN_STRING NEG_INFINITY_STRING NEW_INSTANCE_TRAP NEXT_AFTER_TRAP POS_INFINITY_STRING SQRT_TRAP TRUNC_TRAP fpdecimal fpexp s int ERR_SCALE MAX_EXP MIN_EXP RADIX adiff decimalPos diff e exp exponent i lostdigit offset p q rsize sciexp significantDigits trailingZeros x Dfp a half result  	projects/Math54/src/main/java/org/apache/commons/math/dfp/Dfp.java	0.4082482904638631	994	994	1	add	
88	[BUG] [BUGGY] for (int i = 0; i < mant.length-result.exp; i++) { [FE] AssertionError [CONTEXT]  if (exp >= mant.length) { return newInstance(this); }    Dfp result = newInstance(this); [BUGGY] for (int i = 0; i < mant.length-result.exp; i++) { [BUGGY] changed |= result.mant[i] != 0; result.mant[i] = 0; } if (changed) { switch (rmode) { case ROUND_FLOOR: if (result.sign == -1) {  result = result.add(newInstance(-1)); [CLASS] Dfp [METHOD] trunc [RETURN_TYPE] Dfp  RoundingMode rmode [VARIABLES] boolean changed byte FINITE INFINITE QNAN SNAN code nans sig sign x RoundingMode rmode DfpField field int[] mant String ADD_TRAP ALIGN_TRAP DIVIDE_TRAP GREATER_THAN_TRAP LESS_THAN_TRAP MULTIPLY_TRAP NAN_STRING NEG_INFINITY_STRING NEW_INSTANCE_TRAP NEXT_AFTER_TRAP POS_INFINITY_STRING SQRT_TRAP TRUNC_TRAP fpdecimal fpexp s int ERR_SCALE MAX_EXP MIN_EXP RADIX adiff decimalPos diff e exp exponent i lostdigit offset p q rsize sciexp significantDigits trailingZeros x Dfp a half result  	projects/Math54/src/main/java/org/apache/commons/math/dfp/Dfp.java	0.4082482904638631	995	995	1	replace	
89	[BUG] [BUGGY] [FE] AssertionError [CONTEXT]  if (exp >= mant.length) { return newInstance(this); }    Dfp result = newInstance(this); [BUGGY] [BUGGY] for (int i = 0; i < mant.length-result.exp; i++) { changed |= result.mant[i] != 0; result.mant[i] = 0; } if (changed) { switch (rmode) { case ROUND_FLOOR: if (result.sign == -1) {  result = result.add(newInstance(-1)); [CLASS] Dfp [METHOD] trunc [RETURN_TYPE] Dfp  RoundingMode rmode [VARIABLES] boolean changed byte FINITE INFINITE QNAN SNAN code nans sig sign x RoundingMode rmode DfpField field int[] mant String ADD_TRAP ALIGN_TRAP DIVIDE_TRAP GREATER_THAN_TRAP LESS_THAN_TRAP MULTIPLY_TRAP NAN_STRING NEG_INFINITY_STRING NEW_INSTANCE_TRAP NEXT_AFTER_TRAP POS_INFINITY_STRING SQRT_TRAP TRUNC_TRAP fpdecimal fpexp s int ERR_SCALE MAX_EXP MIN_EXP RADIX adiff decimalPos diff e exp exponent i lostdigit offset p q rsize sciexp significantDigits trailingZeros x Dfp a half result  	projects/Math54/src/main/java/org/apache/commons/math/dfp/Dfp.java	0.4082482904638631	995	995	1	add	
90	[BUG] [BUGGY] changed |= result.mant[i] != 0; [FE] AssertionError [CONTEXT] if (exp >= mant.length) { return newInstance(this); }    Dfp result = newInstance(this); for (int i = 0; i < mant.length-result.exp; i++) { [BUGGY] changed |= result.mant[i] != 0; [BUGGY] result.mant[i] = 0; } if (changed) { switch (rmode) { case ROUND_FLOOR: if (result.sign == -1) {  result = result.add(newInstance(-1)); } [CLASS] Dfp [METHOD] trunc [RETURN_TYPE] Dfp  RoundingMode rmode [VARIABLES] boolean changed byte FINITE INFINITE QNAN SNAN code nans sig sign x RoundingMode rmode DfpField field int[] mant String ADD_TRAP ALIGN_TRAP DIVIDE_TRAP GREATER_THAN_TRAP LESS_THAN_TRAP MULTIPLY_TRAP NAN_STRING NEG_INFINITY_STRING NEW_INSTANCE_TRAP NEXT_AFTER_TRAP POS_INFINITY_STRING SQRT_TRAP TRUNC_TRAP fpdecimal fpexp s int ERR_SCALE MAX_EXP MIN_EXP RADIX adiff decimalPos diff e exp exponent i lostdigit offset p q rsize sciexp significantDigits trailingZeros x Dfp a half result  	projects/Math54/src/main/java/org/apache/commons/math/dfp/Dfp.java	0.4082482904638631	996	996	1	replace	
91	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] if (exp >= mant.length) { return newInstance(this); }    Dfp result = newInstance(this); for (int i = 0; i < mant.length-result.exp; i++) { [BUGGY] [BUGGY] changed |= result.mant[i] != 0; result.mant[i] = 0; } if (changed) { switch (rmode) { case ROUND_FLOOR: if (result.sign == -1) {  result = result.add(newInstance(-1)); } [CLASS] Dfp [METHOD] trunc [RETURN_TYPE] Dfp  RoundingMode rmode [VARIABLES] boolean changed byte FINITE INFINITE QNAN SNAN code nans sig sign x RoundingMode rmode DfpField field int[] mant String ADD_TRAP ALIGN_TRAP DIVIDE_TRAP GREATER_THAN_TRAP LESS_THAN_TRAP MULTIPLY_TRAP NAN_STRING NEG_INFINITY_STRING NEW_INSTANCE_TRAP NEXT_AFTER_TRAP POS_INFINITY_STRING SQRT_TRAP TRUNC_TRAP fpdecimal fpexp s int ERR_SCALE MAX_EXP MIN_EXP RADIX adiff decimalPos diff e exp exponent i lostdigit offset p q rsize sciexp significantDigits trailingZeros x Dfp a half result  	projects/Math54/src/main/java/org/apache/commons/math/dfp/Dfp.java	0.4082482904638631	996	996	1	add	
92	[BUG] [BUGGY] result.mant[i] = 0; [FE] AssertionError [CONTEXT] if (exp >= mant.length) { return newInstance(this); }    Dfp result = newInstance(this); for (int i = 0; i < mant.length-result.exp; i++) { changed |= result.mant[i] != 0; [BUGGY] result.mant[i] = 0; [BUGGY] } if (changed) { switch (rmode) { case ROUND_FLOOR: if (result.sign == -1) {  result = result.add(newInstance(-1)); } break; [CLASS] Dfp [METHOD] trunc [RETURN_TYPE] Dfp  RoundingMode rmode [VARIABLES] boolean changed byte FINITE INFINITE QNAN SNAN code nans sig sign x RoundingMode rmode DfpField field int[] mant String ADD_TRAP ALIGN_TRAP DIVIDE_TRAP GREATER_THAN_TRAP LESS_THAN_TRAP MULTIPLY_TRAP NAN_STRING NEG_INFINITY_STRING NEW_INSTANCE_TRAP NEXT_AFTER_TRAP POS_INFINITY_STRING SQRT_TRAP TRUNC_TRAP fpdecimal fpexp s int ERR_SCALE MAX_EXP MIN_EXP RADIX adiff decimalPos diff e exp exponent i lostdigit offset p q rsize sciexp significantDigits trailingZeros x Dfp a half result  	projects/Math54/src/main/java/org/apache/commons/math/dfp/Dfp.java	0.4082482904638631	997	997	1	replace	
93	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] if (exp >= mant.length) { return newInstance(this); }    Dfp result = newInstance(this); for (int i = 0; i < mant.length-result.exp; i++) { changed |= result.mant[i] != 0; [BUGGY] [BUGGY] result.mant[i] = 0; } if (changed) { switch (rmode) { case ROUND_FLOOR: if (result.sign == -1) {  result = result.add(newInstance(-1)); } break; [CLASS] Dfp [METHOD] trunc [RETURN_TYPE] Dfp  RoundingMode rmode [VARIABLES] boolean changed byte FINITE INFINITE QNAN SNAN code nans sig sign x RoundingMode rmode DfpField field int[] mant String ADD_TRAP ALIGN_TRAP DIVIDE_TRAP GREATER_THAN_TRAP LESS_THAN_TRAP MULTIPLY_TRAP NAN_STRING NEG_INFINITY_STRING NEW_INSTANCE_TRAP NEXT_AFTER_TRAP POS_INFINITY_STRING SQRT_TRAP TRUNC_TRAP fpdecimal fpexp s int ERR_SCALE MAX_EXP MIN_EXP RADIX adiff decimalPos diff e exp exponent i lostdigit offset p q rsize sciexp significantDigits trailingZeros x Dfp a half result  	projects/Math54/src/main/java/org/apache/commons/math/dfp/Dfp.java	0.4082482904638631	997	997	1	add	
94	[BUG] [BUGGY] if (changed) { [FE] AssertionError [CONTEXT]    Dfp result = newInstance(this); for (int i = 0; i < mant.length-result.exp; i++) { changed |= result.mant[i] != 0; result.mant[i] = 0; } [BUGGY] if (changed) { [BUGGY] switch (rmode) { case ROUND_FLOOR: if (result.sign == -1) {  result = result.add(newInstance(-1)); } break; case ROUND_CEIL: if (result.sign == 1) { [CLASS] Dfp [METHOD] trunc [RETURN_TYPE] Dfp  RoundingMode rmode [VARIABLES] boolean changed byte FINITE INFINITE QNAN SNAN code nans sig sign x RoundingMode rmode DfpField field int[] mant String ADD_TRAP ALIGN_TRAP DIVIDE_TRAP GREATER_THAN_TRAP LESS_THAN_TRAP MULTIPLY_TRAP NAN_STRING NEG_INFINITY_STRING NEW_INSTANCE_TRAP NEXT_AFTER_TRAP POS_INFINITY_STRING SQRT_TRAP TRUNC_TRAP fpdecimal fpexp s int ERR_SCALE MAX_EXP MIN_EXP RADIX adiff decimalPos diff e exp exponent i lostdigit offset p q rsize sciexp significantDigits trailingZeros x Dfp a half result  	projects/Math54/src/main/java/org/apache/commons/math/dfp/Dfp.java	0.4082482904638631	1000	1000	1	replace	
95	[BUG] [BUGGY] [FE] AssertionError [CONTEXT]    Dfp result = newInstance(this); for (int i = 0; i < mant.length-result.exp; i++) { changed |= result.mant[i] != 0; result.mant[i] = 0; } [BUGGY] [BUGGY] if (changed) { switch (rmode) { case ROUND_FLOOR: if (result.sign == -1) {  result = result.add(newInstance(-1)); } break; case ROUND_CEIL: if (result.sign == 1) { [CLASS] Dfp [METHOD] trunc [RETURN_TYPE] Dfp  RoundingMode rmode [VARIABLES] boolean changed byte FINITE INFINITE QNAN SNAN code nans sig sign x RoundingMode rmode DfpField field int[] mant String ADD_TRAP ALIGN_TRAP DIVIDE_TRAP GREATER_THAN_TRAP LESS_THAN_TRAP MULTIPLY_TRAP NAN_STRING NEG_INFINITY_STRING NEW_INSTANCE_TRAP NEXT_AFTER_TRAP POS_INFINITY_STRING SQRT_TRAP TRUNC_TRAP fpdecimal fpexp s int ERR_SCALE MAX_EXP MIN_EXP RADIX adiff decimalPos diff e exp exponent i lostdigit offset p q rsize sciexp significantDigits trailingZeros x Dfp a half result  	projects/Math54/src/main/java/org/apache/commons/math/dfp/Dfp.java	0.4082482904638631	1000	1000	1	add	
96	[BUG] [BUGGY] return field.getOne(); [FE] AssertionError [CONTEXT] public Dfp getOne() { [BUGGY] return field.getOne(); [BUGGY] } [CLASS] Dfp [METHOD] getOne [RETURN_TYPE] Dfp  [VARIABLES] DfpField field int[] mant String ADD_TRAP ALIGN_TRAP DIVIDE_TRAP GREATER_THAN_TRAP LESS_THAN_TRAP MULTIPLY_TRAP NAN_STRING NEG_INFINITY_STRING NEW_INSTANCE_TRAP NEXT_AFTER_TRAP POS_INFINITY_STRING SQRT_TRAP TRUNC_TRAP fpdecimal fpexp s boolean byte FINITE INFINITE QNAN SNAN code nans sig sign x int ERR_SCALE MAX_EXP MIN_EXP RADIX decimalPos exp exponent i offset p q rsize sciexp significantDigits trailingZeros x  	projects/Math54/src/main/java/org/apache/commons/math/dfp/Dfp.java	0.3779644730092272	654	654	1	replace	
97	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] public Dfp getOne() { [BUGGY] [BUGGY] return field.getOne(); } [CLASS] Dfp [METHOD] getOne [RETURN_TYPE] Dfp  [VARIABLES] DfpField field int[] mant String ADD_TRAP ALIGN_TRAP DIVIDE_TRAP GREATER_THAN_TRAP LESS_THAN_TRAP MULTIPLY_TRAP NAN_STRING NEG_INFINITY_STRING NEW_INSTANCE_TRAP NEXT_AFTER_TRAP POS_INFINITY_STRING SQRT_TRAP TRUNC_TRAP fpdecimal fpexp s boolean byte FINITE INFINITE QNAN SNAN code nans sig sign x int ERR_SCALE MAX_EXP MIN_EXP RADIX decimalPos exp exponent i offset p q rsize sciexp significantDigits trailingZeros x  	projects/Math54/src/main/java/org/apache/commons/math/dfp/Dfp.java	0.3779644730092272	654	654	1	add	
98	[BUG] [BUGGY] buffer[--q] = '-'; [FE] AssertionError [CONTEXT] q--; }  while (buffer[p-1] == '0') { p--; }  if (sign < 0) { [BUGGY] buffer[--q] = '-'; [BUGGY] } return new String(buffer, q, p - q); } [CLASS] Dfp [METHOD] dfp2string [RETURN_TYPE] String  [VARIABLES] boolean pointInserted byte FINITE INFINITE QNAN SNAN asign bsign code nans rsign sig sign x DfpField field int[] dividend mant product quotient remainder String ADD_TRAP ALIGN_TRAP DIVIDE_TRAP GREATER_THAN_TRAP LESS_THAN_TRAP MULTIPLY_TRAP NAN_STRING NEG_INFINITY_STRING NEW_INSTANCE_TRAP NEXT_AFTER_TRAP POS_INFINITY_STRING SQRT_TRAP TRUNC_TRAP fpdecimal fpexp s int ERR_SCALE MAX_EXP MIN_EXP RADIX adiff ae aextradigit bextradigit decimalPos diff divMsb divisor dm e excp exp exponent extra i j lostdigit max md min minadj n nsqd offset p q qd r result rh rl rsize sciexp shf significantDigits trailingZeros trial x char[] buffer  	projects/Math54/src/main/java/org/apache/commons/math/dfp/Dfp.java	0.31622776601683794	2119	2119	1	replace	
99	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] q--; }  while (buffer[p-1] == '0') { p--; }  if (sign < 0) { [BUGGY] [BUGGY] buffer[--q] = '-'; } return new String(buffer, q, p - q); } [CLASS] Dfp [METHOD] dfp2string [RETURN_TYPE] String  [VARIABLES] boolean pointInserted byte FINITE INFINITE QNAN SNAN asign bsign code nans rsign sig sign x DfpField field int[] dividend mant product quotient remainder String ADD_TRAP ALIGN_TRAP DIVIDE_TRAP GREATER_THAN_TRAP LESS_THAN_TRAP MULTIPLY_TRAP NAN_STRING NEG_INFINITY_STRING NEW_INSTANCE_TRAP NEXT_AFTER_TRAP POS_INFINITY_STRING SQRT_TRAP TRUNC_TRAP fpdecimal fpexp s int ERR_SCALE MAX_EXP MIN_EXP RADIX adiff ae aextradigit bextradigit decimalPos diff divMsb divisor dm e excp exp exponent extra i j lostdigit max md min minadj n nsqd offset p q qd r result rh rl rsize sciexp shf significantDigits trailingZeros trial x char[] buffer  	projects/Math54/src/main/java/org/apache/commons/math/dfp/Dfp.java	0.31622776601683794	2119	2119	1	add	
