bugid	buggy	buggy_class	suspiciousness	buggy_line	endbuggycode	failing_test_number	action	patch
1	[BUG] [BUGGY] for (int j = 0; j < solvedCols; ++j) { [FE] AssertionFailedError testMinpackJennrichSampson [CONTEXT] lmPar = 0; return; }    double sum2; double parl = 0; if (rank == solvedCols) { [BUGGY] for (int j = 0; j < solvedCols; ++j) { [BUGGY] int pj = permutation[j]; work1[pj] *= diag[pj] / dxNorm; } sum2 = 0; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; double sum = 0; for (int i = 0; i < j; ++i) { sum += jacobian[i][pj] * work1[permutation[i]]; } [CLASS] LevenbergMarquardtOptimizer [METHOD] determineLMParameter [RETURN_TYPE] void  double[] qy double delta double[] diag double[] work1 double[] work2 double[] work3 [VARIABLES] int[] permutation boolean double[] beta diag diagR jacNorm lmDir oldRes oldX qy tmpVec work1 work2 work3 double actRed coeff1 coeff2 correction costRelativeTolerance delta dirDer dirJ dk dxNorm fp gNorm initialStepBoundFactor lmNorm lmPar maxCosine orthoTolerance parRelativeTolerance parl paru pc2 preRed previousCost previousFP r ratio s sPar sum sum2 tmp xK xNorm xk ypk int countdown i j k pj pk rank solvedCols  	projects/Math68/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	510	510	2	replace	
2	[BUG] [BUGGY] [FE] AssertionFailedError testMinpackJennrichSampson [CONTEXT] lmPar = 0; return; }    double sum2; double parl = 0; if (rank == solvedCols) { [BUGGY] [BUGGY] for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; work1[pj] *= diag[pj] / dxNorm; } sum2 = 0; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; double sum = 0; for (int i = 0; i < j; ++i) { sum += jacobian[i][pj] * work1[permutation[i]]; } [CLASS] LevenbergMarquardtOptimizer [METHOD] determineLMParameter [RETURN_TYPE] void  double[] qy double delta double[] diag double[] work1 double[] work2 double[] work3 [VARIABLES] int[] permutation boolean double[] beta diag diagR jacNorm lmDir oldRes oldX qy tmpVec work1 work2 work3 double actRed coeff1 coeff2 correction costRelativeTolerance delta dirDer dirJ dk dxNorm fp gNorm initialStepBoundFactor lmNorm lmPar maxCosine orthoTolerance parRelativeTolerance parl paru pc2 preRed previousCost previousFP r ratio s sPar sum sum2 tmp xK xNorm xk ypk int countdown i j k pj pk rank solvedCols  	projects/Math68/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	510	510	2	add	
3	[BUG] [BUGGY] int pj = permutation[j]; [FE] AssertionFailedError testMinpackJennrichSampson [CONTEXT] return; }    double sum2; double parl = 0; if (rank == solvedCols) { for (int j = 0; j < solvedCols; ++j) { [BUGGY] int pj = permutation[j]; [BUGGY] work1[pj] *= diag[pj] / dxNorm; } sum2 = 0; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; double sum = 0; for (int i = 0; i < j; ++i) { sum += jacobian[i][pj] * work1[permutation[i]]; } double s = (work1[pj] - sum) / diagR[pj]; [CLASS] LevenbergMarquardtOptimizer [METHOD] determineLMParameter [RETURN_TYPE] void  double[] qy double delta double[] diag double[] work1 double[] work2 double[] work3 [VARIABLES] int[] permutation boolean double[] beta diag diagR jacNorm lmDir oldRes oldX qy tmpVec work1 work2 work3 double actRed coeff1 coeff2 correction costRelativeTolerance delta dirDer dirJ dk dxNorm fp gNorm initialStepBoundFactor lmNorm lmPar maxCosine orthoTolerance parRelativeTolerance parl paru pc2 preRed previousCost previousFP r ratio s sPar sum sum2 tmp xK xNorm xk ypk int countdown i j k pj pk rank solvedCols  	projects/Math68/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	511	511	2	replace	
4	[BUG] [BUGGY] [FE] AssertionFailedError testMinpackJennrichSampson [CONTEXT] return; }    double sum2; double parl = 0; if (rank == solvedCols) { for (int j = 0; j < solvedCols; ++j) { [BUGGY] [BUGGY] int pj = permutation[j]; work1[pj] *= diag[pj] / dxNorm; } sum2 = 0; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; double sum = 0; for (int i = 0; i < j; ++i) { sum += jacobian[i][pj] * work1[permutation[i]]; } double s = (work1[pj] - sum) / diagR[pj]; [CLASS] LevenbergMarquardtOptimizer [METHOD] determineLMParameter [RETURN_TYPE] void  double[] qy double delta double[] diag double[] work1 double[] work2 double[] work3 [VARIABLES] int[] permutation boolean double[] beta diag diagR jacNorm lmDir oldRes oldX qy tmpVec work1 work2 work3 double actRed coeff1 coeff2 correction costRelativeTolerance delta dirDer dirJ dk dxNorm fp gNorm initialStepBoundFactor lmNorm lmPar maxCosine orthoTolerance parRelativeTolerance parl paru pc2 preRed previousCost previousFP r ratio s sPar sum sum2 tmp xK xNorm xk ypk int countdown i j k pj pk rank solvedCols  	projects/Math68/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	511	511	2	add	
5	[BUG] [BUGGY] work1[pj] *= diag[pj] / dxNorm; [FE] AssertionFailedError testMinpackJennrichSampson [CONTEXT] }    double sum2; double parl = 0; if (rank == solvedCols) { for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; [BUGGY] work1[pj] *= diag[pj] / dxNorm; [BUGGY] } sum2 = 0; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; double sum = 0; for (int i = 0; i < j; ++i) { sum += jacobian[i][pj] * work1[permutation[i]]; } double s = (work1[pj] - sum) / diagR[pj]; work1[pj] = s; [CLASS] LevenbergMarquardtOptimizer [METHOD] determineLMParameter [RETURN_TYPE] void  double[] qy double delta double[] diag double[] work1 double[] work2 double[] work3 [VARIABLES] int[] permutation boolean double[] beta diag diagR jacNorm lmDir oldRes oldX qy tmpVec work1 work2 work3 double actRed coeff1 coeff2 correction costRelativeTolerance delta dirDer dirJ dk dxNorm fp gNorm initialStepBoundFactor lmNorm lmPar maxCosine orthoTolerance parRelativeTolerance parl paru pc2 preRed previousCost previousFP r ratio s sPar sum sum2 tmp xK xNorm xk ypk int countdown i j k pj pk rank solvedCols  	projects/Math68/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	512	512	2	replace	
6	[BUG] [BUGGY] [FE] AssertionFailedError testMinpackJennrichSampson [CONTEXT] }    double sum2; double parl = 0; if (rank == solvedCols) { for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; [BUGGY] [BUGGY] work1[pj] *= diag[pj] / dxNorm; } sum2 = 0; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; double sum = 0; for (int i = 0; i < j; ++i) { sum += jacobian[i][pj] * work1[permutation[i]]; } double s = (work1[pj] - sum) / diagR[pj]; work1[pj] = s; [CLASS] LevenbergMarquardtOptimizer [METHOD] determineLMParameter [RETURN_TYPE] void  double[] qy double delta double[] diag double[] work1 double[] work2 double[] work3 [VARIABLES] int[] permutation boolean double[] beta diag diagR jacNorm lmDir oldRes oldX qy tmpVec work1 work2 work3 double actRed coeff1 coeff2 correction costRelativeTolerance delta dirDer dirJ dk dxNorm fp gNorm initialStepBoundFactor lmNorm lmPar maxCosine orthoTolerance parRelativeTolerance parl paru pc2 preRed previousCost previousFP r ratio s sPar sum sum2 tmp xK xNorm xk ypk int countdown i j k pj pk rank solvedCols  	projects/Math68/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	512	512	2	add	
7	[BUG] [BUGGY] sum2 = 0; [FE] AssertionFailedError testMinpackJennrichSampson [CONTEXT]    double sum2; double parl = 0; if (rank == solvedCols) { for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; work1[pj] *= diag[pj] / dxNorm; } [BUGGY] sum2 = 0; [BUGGY] for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; double sum = 0; for (int i = 0; i < j; ++i) { sum += jacobian[i][pj] * work1[permutation[i]]; } double s = (work1[pj] - sum) / diagR[pj]; work1[pj] = s; sum2 += s * s; } [CLASS] LevenbergMarquardtOptimizer [METHOD] determineLMParameter [RETURN_TYPE] void  double[] qy double delta double[] diag double[] work1 double[] work2 double[] work3 [VARIABLES] int[] permutation boolean double[] beta diag diagR jacNorm lmDir oldRes oldX qy tmpVec work1 work2 work3 double actRed coeff1 coeff2 correction costRelativeTolerance delta dirDer dirJ dk dxNorm fp gNorm initialStepBoundFactor lmNorm lmPar maxCosine orthoTolerance parRelativeTolerance parl paru pc2 preRed previousCost previousFP r ratio s sPar sum sum2 tmp xK xNorm xk ypk int countdown i j k pj pk rank solvedCols  	projects/Math68/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	514	514	2	replace	
8	[BUG] [BUGGY] [FE] AssertionFailedError testMinpackJennrichSampson [CONTEXT]    double sum2; double parl = 0; if (rank == solvedCols) { for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; work1[pj] *= diag[pj] / dxNorm; } [BUGGY] [BUGGY] sum2 = 0; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; double sum = 0; for (int i = 0; i < j; ++i) { sum += jacobian[i][pj] * work1[permutation[i]]; } double s = (work1[pj] - sum) / diagR[pj]; work1[pj] = s; sum2 += s * s; } [CLASS] LevenbergMarquardtOptimizer [METHOD] determineLMParameter [RETURN_TYPE] void  double[] qy double delta double[] diag double[] work1 double[] work2 double[] work3 [VARIABLES] int[] permutation boolean double[] beta diag diagR jacNorm lmDir oldRes oldX qy tmpVec work1 work2 work3 double actRed coeff1 coeff2 correction costRelativeTolerance delta dirDer dirJ dk dxNorm fp gNorm initialStepBoundFactor lmNorm lmPar maxCosine orthoTolerance parRelativeTolerance parl paru pc2 preRed previousCost previousFP r ratio s sPar sum sum2 tmp xK xNorm xk ypk int countdown i j k pj pk rank solvedCols  	projects/Math68/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	514	514	2	add	
9	[BUG] [BUGGY] for (int j = 0; j < solvedCols; ++j) { [FE] AssertionFailedError testMinpackJennrichSampson [CONTEXT]   double sum2; double parl = 0; if (rank == solvedCols) { for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; work1[pj] *= diag[pj] / dxNorm; } sum2 = 0; [BUGGY] for (int j = 0; j < solvedCols; ++j) { [BUGGY] int pj = permutation[j]; double sum = 0; for (int i = 0; i < j; ++i) { sum += jacobian[i][pj] * work1[permutation[i]]; } double s = (work1[pj] - sum) / diagR[pj]; work1[pj] = s; sum2 += s * s; } parl = fp / (delta * sum2); [CLASS] LevenbergMarquardtOptimizer [METHOD] determineLMParameter [RETURN_TYPE] void  double[] qy double delta double[] diag double[] work1 double[] work2 double[] work3 [VARIABLES] int[] permutation boolean double[] beta diag diagR jacNorm lmDir oldRes oldX qy tmpVec work1 work2 work3 double actRed coeff1 coeff2 correction costRelativeTolerance delta dirDer dirJ dk dxNorm fp gNorm initialStepBoundFactor lmNorm lmPar maxCosine orthoTolerance parRelativeTolerance parl paru pc2 preRed previousCost previousFP r ratio s sPar sum sum2 tmp xK xNorm xk ypk int countdown i j k pj pk rank solvedCols  	projects/Math68/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	515	515	2	replace	
10	[BUG] [BUGGY] [FE] AssertionFailedError testMinpackJennrichSampson [CONTEXT]   double sum2; double parl = 0; if (rank == solvedCols) { for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; work1[pj] *= diag[pj] / dxNorm; } sum2 = 0; [BUGGY] [BUGGY] for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; double sum = 0; for (int i = 0; i < j; ++i) { sum += jacobian[i][pj] * work1[permutation[i]]; } double s = (work1[pj] - sum) / diagR[pj]; work1[pj] = s; sum2 += s * s; } parl = fp / (delta * sum2); [CLASS] LevenbergMarquardtOptimizer [METHOD] determineLMParameter [RETURN_TYPE] void  double[] qy double delta double[] diag double[] work1 double[] work2 double[] work3 [VARIABLES] int[] permutation boolean double[] beta diag diagR jacNorm lmDir oldRes oldX qy tmpVec work1 work2 work3 double actRed coeff1 coeff2 correction costRelativeTolerance delta dirDer dirJ dk dxNorm fp gNorm initialStepBoundFactor lmNorm lmPar maxCosine orthoTolerance parRelativeTolerance parl paru pc2 preRed previousCost previousFP r ratio s sPar sum sum2 tmp xK xNorm xk ypk int countdown i j k pj pk rank solvedCols  	projects/Math68/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	515	515	2	add	
11	[BUG] [BUGGY] int pj = permutation[j]; [FE] AssertionFailedError testMinpackJennrichSampson [CONTEXT]  double sum2; double parl = 0; if (rank == solvedCols) { for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; work1[pj] *= diag[pj] / dxNorm; } sum2 = 0; for (int j = 0; j < solvedCols; ++j) { [BUGGY] int pj = permutation[j]; [BUGGY] double sum = 0; for (int i = 0; i < j; ++i) { sum += jacobian[i][pj] * work1[permutation[i]]; } double s = (work1[pj] - sum) / diagR[pj]; work1[pj] = s; sum2 += s * s; } parl = fp / (delta * sum2); } [CLASS] LevenbergMarquardtOptimizer [METHOD] determineLMParameter [RETURN_TYPE] void  double[] qy double delta double[] diag double[] work1 double[] work2 double[] work3 [VARIABLES] int[] permutation boolean double[] beta diag diagR jacNorm lmDir oldRes oldX qy tmpVec work1 work2 work3 double actRed coeff1 coeff2 correction costRelativeTolerance delta dirDer dirJ dk dxNorm fp gNorm initialStepBoundFactor lmNorm lmPar maxCosine orthoTolerance parRelativeTolerance parl paru pc2 preRed previousCost previousFP r ratio s sPar sum sum2 tmp xK xNorm xk ypk int countdown i j k pj pk rank solvedCols  	projects/Math68/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	516	516	2	replace	
12	[BUG] [BUGGY] [FE] AssertionFailedError testMinpackJennrichSampson [CONTEXT]  double sum2; double parl = 0; if (rank == solvedCols) { for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; work1[pj] *= diag[pj] / dxNorm; } sum2 = 0; for (int j = 0; j < solvedCols; ++j) { [BUGGY] [BUGGY] int pj = permutation[j]; double sum = 0; for (int i = 0; i < j; ++i) { sum += jacobian[i][pj] * work1[permutation[i]]; } double s = (work1[pj] - sum) / diagR[pj]; work1[pj] = s; sum2 += s * s; } parl = fp / (delta * sum2); } [CLASS] LevenbergMarquardtOptimizer [METHOD] determineLMParameter [RETURN_TYPE] void  double[] qy double delta double[] diag double[] work1 double[] work2 double[] work3 [VARIABLES] int[] permutation boolean double[] beta diag diagR jacNorm lmDir oldRes oldX qy tmpVec work1 work2 work3 double actRed coeff1 coeff2 correction costRelativeTolerance delta dirDer dirJ dk dxNorm fp gNorm initialStepBoundFactor lmNorm lmPar maxCosine orthoTolerance parRelativeTolerance parl paru pc2 preRed previousCost previousFP r ratio s sPar sum sum2 tmp xK xNorm xk ypk int countdown i j k pj pk rank solvedCols  	projects/Math68/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	516	516	2	add	
13	[BUG] [BUGGY] double sum = 0; [FE] AssertionFailedError testMinpackJennrichSampson [CONTEXT] double sum2; double parl = 0; if (rank == solvedCols) { for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; work1[pj] *= diag[pj] / dxNorm; } sum2 = 0; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; [BUGGY] double sum = 0; [BUGGY] for (int i = 0; i < j; ++i) { sum += jacobian[i][pj] * work1[permutation[i]]; } double s = (work1[pj] - sum) / diagR[pj]; work1[pj] = s; sum2 += s * s; } parl = fp / (delta * sum2); }  [CLASS] LevenbergMarquardtOptimizer [METHOD] determineLMParameter [RETURN_TYPE] void  double[] qy double delta double[] diag double[] work1 double[] work2 double[] work3 [VARIABLES] int[] permutation boolean double[] beta diag diagR jacNorm lmDir oldRes oldX qy tmpVec work1 work2 work3 double actRed coeff1 coeff2 correction costRelativeTolerance delta dirDer dirJ dk dxNorm fp gNorm initialStepBoundFactor lmNorm lmPar maxCosine orthoTolerance parRelativeTolerance parl paru pc2 preRed previousCost previousFP r ratio s sPar sum sum2 tmp xK xNorm xk ypk int countdown i j k pj pk rank solvedCols  	projects/Math68/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	517	517	2	replace	
14	[BUG] [BUGGY] [FE] AssertionFailedError testMinpackJennrichSampson [CONTEXT] double sum2; double parl = 0; if (rank == solvedCols) { for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; work1[pj] *= diag[pj] / dxNorm; } sum2 = 0; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; [BUGGY] [BUGGY] double sum = 0; for (int i = 0; i < j; ++i) { sum += jacobian[i][pj] * work1[permutation[i]]; } double s = (work1[pj] - sum) / diagR[pj]; work1[pj] = s; sum2 += s * s; } parl = fp / (delta * sum2); }  [CLASS] LevenbergMarquardtOptimizer [METHOD] determineLMParameter [RETURN_TYPE] void  double[] qy double delta double[] diag double[] work1 double[] work2 double[] work3 [VARIABLES] int[] permutation boolean double[] beta diag diagR jacNorm lmDir oldRes oldX qy tmpVec work1 work2 work3 double actRed coeff1 coeff2 correction costRelativeTolerance delta dirDer dirJ dk dxNorm fp gNorm initialStepBoundFactor lmNorm lmPar maxCosine orthoTolerance parRelativeTolerance parl paru pc2 preRed previousCost previousFP r ratio s sPar sum sum2 tmp xK xNorm xk ypk int countdown i j k pj pk rank solvedCols  	projects/Math68/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	517	517	2	add	
15	[BUG] [BUGGY] for (int i = 0; i < j; ++i) { [FE] AssertionFailedError testMinpackJennrichSampson [CONTEXT] double parl = 0; if (rank == solvedCols) { for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; work1[pj] *= diag[pj] / dxNorm; } sum2 = 0; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; double sum = 0; [BUGGY] for (int i = 0; i < j; ++i) { [BUGGY] sum += jacobian[i][pj] * work1[permutation[i]]; } double s = (work1[pj] - sum) / diagR[pj]; work1[pj] = s; sum2 += s * s; } parl = fp / (delta * sum2); }   [CLASS] LevenbergMarquardtOptimizer [METHOD] determineLMParameter [RETURN_TYPE] void  double[] qy double delta double[] diag double[] work1 double[] work2 double[] work3 [VARIABLES] int[] permutation boolean double[] beta diag diagR jacNorm lmDir oldRes oldX qy tmpVec work1 work2 work3 double actRed coeff1 coeff2 correction costRelativeTolerance delta dirDer dirJ dk dxNorm fp gNorm initialStepBoundFactor lmNorm lmPar maxCosine orthoTolerance parRelativeTolerance parl paru pc2 preRed previousCost previousFP r ratio s sPar sum sum2 tmp xK xNorm xk ypk int countdown i j k pj pk rank solvedCols  	projects/Math68/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	518	518	2	replace	
16	[BUG] [BUGGY] [FE] AssertionFailedError testMinpackJennrichSampson [CONTEXT] double parl = 0; if (rank == solvedCols) { for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; work1[pj] *= diag[pj] / dxNorm; } sum2 = 0; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; double sum = 0; [BUGGY] [BUGGY] for (int i = 0; i < j; ++i) { sum += jacobian[i][pj] * work1[permutation[i]]; } double s = (work1[pj] - sum) / diagR[pj]; work1[pj] = s; sum2 += s * s; } parl = fp / (delta * sum2); }   [CLASS] LevenbergMarquardtOptimizer [METHOD] determineLMParameter [RETURN_TYPE] void  double[] qy double delta double[] diag double[] work1 double[] work2 double[] work3 [VARIABLES] int[] permutation boolean double[] beta diag diagR jacNorm lmDir oldRes oldX qy tmpVec work1 work2 work3 double actRed coeff1 coeff2 correction costRelativeTolerance delta dirDer dirJ dk dxNorm fp gNorm initialStepBoundFactor lmNorm lmPar maxCosine orthoTolerance parRelativeTolerance parl paru pc2 preRed previousCost previousFP r ratio s sPar sum sum2 tmp xK xNorm xk ypk int countdown i j k pj pk rank solvedCols  	projects/Math68/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	518	518	2	add	
17	[BUG] [BUGGY] sum += jacobian[i][pj] * work1[permutation[i]]; [FE] AssertionFailedError testMinpackJennrichSampson [CONTEXT] if (rank == solvedCols) { for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; work1[pj] *= diag[pj] / dxNorm; } sum2 = 0; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; double sum = 0; for (int i = 0; i < j; ++i) { [BUGGY] sum += jacobian[i][pj] * work1[permutation[i]]; [BUGGY] } double s = (work1[pj] - sum) / diagR[pj]; work1[pj] = s; sum2 += s * s; } parl = fp / (delta * sum2); }  sum2 = 0; [CLASS] LevenbergMarquardtOptimizer [METHOD] determineLMParameter [RETURN_TYPE] void  double[] qy double delta double[] diag double[] work1 double[] work2 double[] work3 [VARIABLES] int[] permutation boolean double[] beta diag diagR jacNorm lmDir oldRes oldX qy tmpVec work1 work2 work3 double actRed coeff1 coeff2 correction costRelativeTolerance delta dirDer dirJ dk dxNorm fp gNorm initialStepBoundFactor lmNorm lmPar maxCosine orthoTolerance parRelativeTolerance parl paru pc2 preRed previousCost previousFP r ratio s sPar sum sum2 tmp xK xNorm xk ypk int countdown i j k pj pk rank solvedCols  	projects/Math68/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	519	519	2	replace	
18	[BUG] [BUGGY] [FE] AssertionFailedError testMinpackJennrichSampson [CONTEXT] if (rank == solvedCols) { for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; work1[pj] *= diag[pj] / dxNorm; } sum2 = 0; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; double sum = 0; for (int i = 0; i < j; ++i) { [BUGGY] [BUGGY] sum += jacobian[i][pj] * work1[permutation[i]]; } double s = (work1[pj] - sum) / diagR[pj]; work1[pj] = s; sum2 += s * s; } parl = fp / (delta * sum2); }  sum2 = 0; [CLASS] LevenbergMarquardtOptimizer [METHOD] determineLMParameter [RETURN_TYPE] void  double[] qy double delta double[] diag double[] work1 double[] work2 double[] work3 [VARIABLES] int[] permutation boolean double[] beta diag diagR jacNorm lmDir oldRes oldX qy tmpVec work1 work2 work3 double actRed coeff1 coeff2 correction costRelativeTolerance delta dirDer dirJ dk dxNorm fp gNorm initialStepBoundFactor lmNorm lmPar maxCosine orthoTolerance parRelativeTolerance parl paru pc2 preRed previousCost previousFP r ratio s sPar sum sum2 tmp xK xNorm xk ypk int countdown i j k pj pk rank solvedCols  	projects/Math68/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	519	519	2	add	
19	[BUG] [BUGGY] double s = (work1[pj] - sum) / diagR[pj]; [FE] AssertionFailedError testMinpackJennrichSampson [CONTEXT] int pj = permutation[j]; work1[pj] *= diag[pj] / dxNorm; } sum2 = 0; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; double sum = 0; for (int i = 0; i < j; ++i) { sum += jacobian[i][pj] * work1[permutation[i]]; } [BUGGY] double s = (work1[pj] - sum) / diagR[pj]; [BUGGY] work1[pj] = s; sum2 += s * s; } parl = fp / (delta * sum2); }  sum2 = 0; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; [CLASS] LevenbergMarquardtOptimizer [METHOD] determineLMParameter [RETURN_TYPE] void  double[] qy double delta double[] diag double[] work1 double[] work2 double[] work3 [VARIABLES] int[] permutation boolean double[] beta diag diagR jacNorm lmDir oldRes oldX qy tmpVec work1 work2 work3 double actRed coeff1 coeff2 correction costRelativeTolerance delta dirDer dirJ dk dxNorm fp gNorm initialStepBoundFactor lmNorm lmPar maxCosine orthoTolerance parRelativeTolerance parl paru pc2 preRed previousCost previousFP r ratio s sPar sum sum2 tmp xK xNorm xk ypk int countdown i j k pj pk rank solvedCols  	projects/Math68/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	521	521	2	replace	
20	[BUG] [BUGGY] [FE] AssertionFailedError testMinpackJennrichSampson [CONTEXT] int pj = permutation[j]; work1[pj] *= diag[pj] / dxNorm; } sum2 = 0; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; double sum = 0; for (int i = 0; i < j; ++i) { sum += jacobian[i][pj] * work1[permutation[i]]; } [BUGGY] [BUGGY] double s = (work1[pj] - sum) / diagR[pj]; work1[pj] = s; sum2 += s * s; } parl = fp / (delta * sum2); }  sum2 = 0; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; [CLASS] LevenbergMarquardtOptimizer [METHOD] determineLMParameter [RETURN_TYPE] void  double[] qy double delta double[] diag double[] work1 double[] work2 double[] work3 [VARIABLES] int[] permutation boolean double[] beta diag diagR jacNorm lmDir oldRes oldX qy tmpVec work1 work2 work3 double actRed coeff1 coeff2 correction costRelativeTolerance delta dirDer dirJ dk dxNorm fp gNorm initialStepBoundFactor lmNorm lmPar maxCosine orthoTolerance parRelativeTolerance parl paru pc2 preRed previousCost previousFP r ratio s sPar sum sum2 tmp xK xNorm xk ypk int countdown i j k pj pk rank solvedCols  	projects/Math68/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	521	521	2	add	
