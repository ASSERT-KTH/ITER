bugid	buggy	buggy_class	suspiciousness	buggy_line	endbuggycode	failing_test_number	action	patch
1	[BUG] [BUGGY] for (int j = 0; j < solvedCols; ++j) { [FE] AssertionFailedError [CONTEXT] lmPar = 0; return; }    double sum2; double parl = 0; if (rank == solvedCols) { [BUGGY] for (int j = 0; j < solvedCols; ++j) { [BUGGY] int pj = permutation[j]; work1[pj] *= diag[pj] / dxNorm; } sum2 = 0; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; double sum = 0; for (int i = 0; i < j; ++i) { sum += jacobian[i][pj] * work1[permutation[i]]; } [CLASS] LevenbergMarquardtOptimizer [METHOD] determineLMParameter [RETURN_TYPE] void  double[] qy double delta double[] diag double[] work1 double[] work2 double[] work3 [VARIABLES] int[] permutation boolean double[] beta diag diagR jacNorm lmDir oldRes oldX qy tmpVec work1 work2 work3 double actRed coeff1 coeff2 correction costRelativeTolerance delta dirDer dirJ dk dxNorm fp gNorm initialStepBoundFactor lmNorm lmPar maxCosine orthoTolerance parRelativeTolerance parl paru pc2 preRed previousCost previousFP r ratio s sPar sum sum2 tmp xK xNorm xk ypk int countdown i j k pj pk rank solvedCols  	projects/Math68/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	510	510	2	replace	
2	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] lmPar = 0; return; }    double sum2; double parl = 0; if (rank == solvedCols) { [BUGGY] [BUGGY] for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; work1[pj] *= diag[pj] / dxNorm; } sum2 = 0; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; double sum = 0; for (int i = 0; i < j; ++i) { sum += jacobian[i][pj] * work1[permutation[i]]; } [CLASS] LevenbergMarquardtOptimizer [METHOD] determineLMParameter [RETURN_TYPE] void  double[] qy double delta double[] diag double[] work1 double[] work2 double[] work3 [VARIABLES] int[] permutation boolean double[] beta diag diagR jacNorm lmDir oldRes oldX qy tmpVec work1 work2 work3 double actRed coeff1 coeff2 correction costRelativeTolerance delta dirDer dirJ dk dxNorm fp gNorm initialStepBoundFactor lmNorm lmPar maxCosine orthoTolerance parRelativeTolerance parl paru pc2 preRed previousCost previousFP r ratio s sPar sum sum2 tmp xK xNorm xk ypk int countdown i j k pj pk rank solvedCols  	projects/Math68/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	510	510	2	add	
3	[BUG] [BUGGY] int pj = permutation[j]; [FE] AssertionFailedError [CONTEXT] return; }    double sum2; double parl = 0; if (rank == solvedCols) { for (int j = 0; j < solvedCols; ++j) { [BUGGY] int pj = permutation[j]; [BUGGY] work1[pj] *= diag[pj] / dxNorm; } sum2 = 0; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; double sum = 0; for (int i = 0; i < j; ++i) { sum += jacobian[i][pj] * work1[permutation[i]]; } double s = (work1[pj] - sum) / diagR[pj]; [CLASS] LevenbergMarquardtOptimizer [METHOD] determineLMParameter [RETURN_TYPE] void  double[] qy double delta double[] diag double[] work1 double[] work2 double[] work3 [VARIABLES] int[] permutation boolean double[] beta diag diagR jacNorm lmDir oldRes oldX qy tmpVec work1 work2 work3 double actRed coeff1 coeff2 correction costRelativeTolerance delta dirDer dirJ dk dxNorm fp gNorm initialStepBoundFactor lmNorm lmPar maxCosine orthoTolerance parRelativeTolerance parl paru pc2 preRed previousCost previousFP r ratio s sPar sum sum2 tmp xK xNorm xk ypk int countdown i j k pj pk rank solvedCols  	projects/Math68/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	511	511	2	replace	
4	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] return; }    double sum2; double parl = 0; if (rank == solvedCols) { for (int j = 0; j < solvedCols; ++j) { [BUGGY] [BUGGY] int pj = permutation[j]; work1[pj] *= diag[pj] / dxNorm; } sum2 = 0; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; double sum = 0; for (int i = 0; i < j; ++i) { sum += jacobian[i][pj] * work1[permutation[i]]; } double s = (work1[pj] - sum) / diagR[pj]; [CLASS] LevenbergMarquardtOptimizer [METHOD] determineLMParameter [RETURN_TYPE] void  double[] qy double delta double[] diag double[] work1 double[] work2 double[] work3 [VARIABLES] int[] permutation boolean double[] beta diag diagR jacNorm lmDir oldRes oldX qy tmpVec work1 work2 work3 double actRed coeff1 coeff2 correction costRelativeTolerance delta dirDer dirJ dk dxNorm fp gNorm initialStepBoundFactor lmNorm lmPar maxCosine orthoTolerance parRelativeTolerance parl paru pc2 preRed previousCost previousFP r ratio s sPar sum sum2 tmp xK xNorm xk ypk int countdown i j k pj pk rank solvedCols  	projects/Math68/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	511	511	2	add	
5	[BUG] [BUGGY] work1[pj] *= diag[pj] / dxNorm; [FE] AssertionFailedError [CONTEXT] }    double sum2; double parl = 0; if (rank == solvedCols) { for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; [BUGGY] work1[pj] *= diag[pj] / dxNorm; [BUGGY] } sum2 = 0; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; double sum = 0; for (int i = 0; i < j; ++i) { sum += jacobian[i][pj] * work1[permutation[i]]; } double s = (work1[pj] - sum) / diagR[pj]; work1[pj] = s; [CLASS] LevenbergMarquardtOptimizer [METHOD] determineLMParameter [RETURN_TYPE] void  double[] qy double delta double[] diag double[] work1 double[] work2 double[] work3 [VARIABLES] int[] permutation boolean double[] beta diag diagR jacNorm lmDir oldRes oldX qy tmpVec work1 work2 work3 double actRed coeff1 coeff2 correction costRelativeTolerance delta dirDer dirJ dk dxNorm fp gNorm initialStepBoundFactor lmNorm lmPar maxCosine orthoTolerance parRelativeTolerance parl paru pc2 preRed previousCost previousFP r ratio s sPar sum sum2 tmp xK xNorm xk ypk int countdown i j k pj pk rank solvedCols  	projects/Math68/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	512	512	2	replace	
6	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] }    double sum2; double parl = 0; if (rank == solvedCols) { for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; [BUGGY] [BUGGY] work1[pj] *= diag[pj] / dxNorm; } sum2 = 0; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; double sum = 0; for (int i = 0; i < j; ++i) { sum += jacobian[i][pj] * work1[permutation[i]]; } double s = (work1[pj] - sum) / diagR[pj]; work1[pj] = s; [CLASS] LevenbergMarquardtOptimizer [METHOD] determineLMParameter [RETURN_TYPE] void  double[] qy double delta double[] diag double[] work1 double[] work2 double[] work3 [VARIABLES] int[] permutation boolean double[] beta diag diagR jacNorm lmDir oldRes oldX qy tmpVec work1 work2 work3 double actRed coeff1 coeff2 correction costRelativeTolerance delta dirDer dirJ dk dxNorm fp gNorm initialStepBoundFactor lmNorm lmPar maxCosine orthoTolerance parRelativeTolerance parl paru pc2 preRed previousCost previousFP r ratio s sPar sum sum2 tmp xK xNorm xk ypk int countdown i j k pj pk rank solvedCols  	projects/Math68/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	512	512	2	add	
7	[BUG] [BUGGY] sum2 = 0; [FE] AssertionFailedError [CONTEXT]    double sum2; double parl = 0; if (rank == solvedCols) { for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; work1[pj] *= diag[pj] / dxNorm; } [BUGGY] sum2 = 0; [BUGGY] for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; double sum = 0; for (int i = 0; i < j; ++i) { sum += jacobian[i][pj] * work1[permutation[i]]; } double s = (work1[pj] - sum) / diagR[pj]; work1[pj] = s; sum2 += s * s; } [CLASS] LevenbergMarquardtOptimizer [METHOD] determineLMParameter [RETURN_TYPE] void  double[] qy double delta double[] diag double[] work1 double[] work2 double[] work3 [VARIABLES] int[] permutation boolean double[] beta diag diagR jacNorm lmDir oldRes oldX qy tmpVec work1 work2 work3 double actRed coeff1 coeff2 correction costRelativeTolerance delta dirDer dirJ dk dxNorm fp gNorm initialStepBoundFactor lmNorm lmPar maxCosine orthoTolerance parRelativeTolerance parl paru pc2 preRed previousCost previousFP r ratio s sPar sum sum2 tmp xK xNorm xk ypk int countdown i j k pj pk rank solvedCols  	projects/Math68/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	514	514	2	replace	
8	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT]    double sum2; double parl = 0; if (rank == solvedCols) { for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; work1[pj] *= diag[pj] / dxNorm; } [BUGGY] [BUGGY] sum2 = 0; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; double sum = 0; for (int i = 0; i < j; ++i) { sum += jacobian[i][pj] * work1[permutation[i]]; } double s = (work1[pj] - sum) / diagR[pj]; work1[pj] = s; sum2 += s * s; } [CLASS] LevenbergMarquardtOptimizer [METHOD] determineLMParameter [RETURN_TYPE] void  double[] qy double delta double[] diag double[] work1 double[] work2 double[] work3 [VARIABLES] int[] permutation boolean double[] beta diag diagR jacNorm lmDir oldRes oldX qy tmpVec work1 work2 work3 double actRed coeff1 coeff2 correction costRelativeTolerance delta dirDer dirJ dk dxNorm fp gNorm initialStepBoundFactor lmNorm lmPar maxCosine orthoTolerance parRelativeTolerance parl paru pc2 preRed previousCost previousFP r ratio s sPar sum sum2 tmp xK xNorm xk ypk int countdown i j k pj pk rank solvedCols  	projects/Math68/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	514	514	2	add	
9	[BUG] [BUGGY] for (int j = 0; j < solvedCols; ++j) { [FE] AssertionFailedError [CONTEXT]   double sum2; double parl = 0; if (rank == solvedCols) { for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; work1[pj] *= diag[pj] / dxNorm; } sum2 = 0; [BUGGY] for (int j = 0; j < solvedCols; ++j) { [BUGGY] int pj = permutation[j]; double sum = 0; for (int i = 0; i < j; ++i) { sum += jacobian[i][pj] * work1[permutation[i]]; } double s = (work1[pj] - sum) / diagR[pj]; work1[pj] = s; sum2 += s * s; } parl = fp / (delta * sum2); [CLASS] LevenbergMarquardtOptimizer [METHOD] determineLMParameter [RETURN_TYPE] void  double[] qy double delta double[] diag double[] work1 double[] work2 double[] work3 [VARIABLES] int[] permutation boolean double[] beta diag diagR jacNorm lmDir oldRes oldX qy tmpVec work1 work2 work3 double actRed coeff1 coeff2 correction costRelativeTolerance delta dirDer dirJ dk dxNorm fp gNorm initialStepBoundFactor lmNorm lmPar maxCosine orthoTolerance parRelativeTolerance parl paru pc2 preRed previousCost previousFP r ratio s sPar sum sum2 tmp xK xNorm xk ypk int countdown i j k pj pk rank solvedCols  	projects/Math68/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	515	515	2	replace	
10	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT]   double sum2; double parl = 0; if (rank == solvedCols) { for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; work1[pj] *= diag[pj] / dxNorm; } sum2 = 0; [BUGGY] [BUGGY] for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; double sum = 0; for (int i = 0; i < j; ++i) { sum += jacobian[i][pj] * work1[permutation[i]]; } double s = (work1[pj] - sum) / diagR[pj]; work1[pj] = s; sum2 += s * s; } parl = fp / (delta * sum2); [CLASS] LevenbergMarquardtOptimizer [METHOD] determineLMParameter [RETURN_TYPE] void  double[] qy double delta double[] diag double[] work1 double[] work2 double[] work3 [VARIABLES] int[] permutation boolean double[] beta diag diagR jacNorm lmDir oldRes oldX qy tmpVec work1 work2 work3 double actRed coeff1 coeff2 correction costRelativeTolerance delta dirDer dirJ dk dxNorm fp gNorm initialStepBoundFactor lmNorm lmPar maxCosine orthoTolerance parRelativeTolerance parl paru pc2 preRed previousCost previousFP r ratio s sPar sum sum2 tmp xK xNorm xk ypk int countdown i j k pj pk rank solvedCols  	projects/Math68/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	515	515	2	add	
11	[BUG] [BUGGY] int pj = permutation[j]; [FE] AssertionFailedError [CONTEXT]  double sum2; double parl = 0; if (rank == solvedCols) { for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; work1[pj] *= diag[pj] / dxNorm; } sum2 = 0; for (int j = 0; j < solvedCols; ++j) { [BUGGY] int pj = permutation[j]; [BUGGY] double sum = 0; for (int i = 0; i < j; ++i) { sum += jacobian[i][pj] * work1[permutation[i]]; } double s = (work1[pj] - sum) / diagR[pj]; work1[pj] = s; sum2 += s * s; } parl = fp / (delta * sum2); } [CLASS] LevenbergMarquardtOptimizer [METHOD] determineLMParameter [RETURN_TYPE] void  double[] qy double delta double[] diag double[] work1 double[] work2 double[] work3 [VARIABLES] int[] permutation boolean double[] beta diag diagR jacNorm lmDir oldRes oldX qy tmpVec work1 work2 work3 double actRed coeff1 coeff2 correction costRelativeTolerance delta dirDer dirJ dk dxNorm fp gNorm initialStepBoundFactor lmNorm lmPar maxCosine orthoTolerance parRelativeTolerance parl paru pc2 preRed previousCost previousFP r ratio s sPar sum sum2 tmp xK xNorm xk ypk int countdown i j k pj pk rank solvedCols  	projects/Math68/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	516	516	2	replace	
12	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT]  double sum2; double parl = 0; if (rank == solvedCols) { for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; work1[pj] *= diag[pj] / dxNorm; } sum2 = 0; for (int j = 0; j < solvedCols; ++j) { [BUGGY] [BUGGY] int pj = permutation[j]; double sum = 0; for (int i = 0; i < j; ++i) { sum += jacobian[i][pj] * work1[permutation[i]]; } double s = (work1[pj] - sum) / diagR[pj]; work1[pj] = s; sum2 += s * s; } parl = fp / (delta * sum2); } [CLASS] LevenbergMarquardtOptimizer [METHOD] determineLMParameter [RETURN_TYPE] void  double[] qy double delta double[] diag double[] work1 double[] work2 double[] work3 [VARIABLES] int[] permutation boolean double[] beta diag diagR jacNorm lmDir oldRes oldX qy tmpVec work1 work2 work3 double actRed coeff1 coeff2 correction costRelativeTolerance delta dirDer dirJ dk dxNorm fp gNorm initialStepBoundFactor lmNorm lmPar maxCosine orthoTolerance parRelativeTolerance parl paru pc2 preRed previousCost previousFP r ratio s sPar sum sum2 tmp xK xNorm xk ypk int countdown i j k pj pk rank solvedCols  	projects/Math68/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	516	516	2	add	
13	[BUG] [BUGGY] double sum = 0; [FE] AssertionFailedError [CONTEXT] double sum2; double parl = 0; if (rank == solvedCols) { for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; work1[pj] *= diag[pj] / dxNorm; } sum2 = 0; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; [BUGGY] double sum = 0; [BUGGY] for (int i = 0; i < j; ++i) { sum += jacobian[i][pj] * work1[permutation[i]]; } double s = (work1[pj] - sum) / diagR[pj]; work1[pj] = s; sum2 += s * s; } parl = fp / (delta * sum2); }  [CLASS] LevenbergMarquardtOptimizer [METHOD] determineLMParameter [RETURN_TYPE] void  double[] qy double delta double[] diag double[] work1 double[] work2 double[] work3 [VARIABLES] int[] permutation boolean double[] beta diag diagR jacNorm lmDir oldRes oldX qy tmpVec work1 work2 work3 double actRed coeff1 coeff2 correction costRelativeTolerance delta dirDer dirJ dk dxNorm fp gNorm initialStepBoundFactor lmNorm lmPar maxCosine orthoTolerance parRelativeTolerance parl paru pc2 preRed previousCost previousFP r ratio s sPar sum sum2 tmp xK xNorm xk ypk int countdown i j k pj pk rank solvedCols  	projects/Math68/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	517	517	2	replace	
14	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] double sum2; double parl = 0; if (rank == solvedCols) { for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; work1[pj] *= diag[pj] / dxNorm; } sum2 = 0; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; [BUGGY] [BUGGY] double sum = 0; for (int i = 0; i < j; ++i) { sum += jacobian[i][pj] * work1[permutation[i]]; } double s = (work1[pj] - sum) / diagR[pj]; work1[pj] = s; sum2 += s * s; } parl = fp / (delta * sum2); }  [CLASS] LevenbergMarquardtOptimizer [METHOD] determineLMParameter [RETURN_TYPE] void  double[] qy double delta double[] diag double[] work1 double[] work2 double[] work3 [VARIABLES] int[] permutation boolean double[] beta diag diagR jacNorm lmDir oldRes oldX qy tmpVec work1 work2 work3 double actRed coeff1 coeff2 correction costRelativeTolerance delta dirDer dirJ dk dxNorm fp gNorm initialStepBoundFactor lmNorm lmPar maxCosine orthoTolerance parRelativeTolerance parl paru pc2 preRed previousCost previousFP r ratio s sPar sum sum2 tmp xK xNorm xk ypk int countdown i j k pj pk rank solvedCols  	projects/Math68/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	517	517	2	add	
15	[BUG] [BUGGY] for (int i = 0; i < j; ++i) { [FE] AssertionFailedError [CONTEXT] double parl = 0; if (rank == solvedCols) { for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; work1[pj] *= diag[pj] / dxNorm; } sum2 = 0; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; double sum = 0; [BUGGY] for (int i = 0; i < j; ++i) { [BUGGY] sum += jacobian[i][pj] * work1[permutation[i]]; } double s = (work1[pj] - sum) / diagR[pj]; work1[pj] = s; sum2 += s * s; } parl = fp / (delta * sum2); }   [CLASS] LevenbergMarquardtOptimizer [METHOD] determineLMParameter [RETURN_TYPE] void  double[] qy double delta double[] diag double[] work1 double[] work2 double[] work3 [VARIABLES] int[] permutation boolean double[] beta diag diagR jacNorm lmDir oldRes oldX qy tmpVec work1 work2 work3 double actRed coeff1 coeff2 correction costRelativeTolerance delta dirDer dirJ dk dxNorm fp gNorm initialStepBoundFactor lmNorm lmPar maxCosine orthoTolerance parRelativeTolerance parl paru pc2 preRed previousCost previousFP r ratio s sPar sum sum2 tmp xK xNorm xk ypk int countdown i j k pj pk rank solvedCols  	projects/Math68/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	518	518	2	replace	
16	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] double parl = 0; if (rank == solvedCols) { for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; work1[pj] *= diag[pj] / dxNorm; } sum2 = 0; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; double sum = 0; [BUGGY] [BUGGY] for (int i = 0; i < j; ++i) { sum += jacobian[i][pj] * work1[permutation[i]]; } double s = (work1[pj] - sum) / diagR[pj]; work1[pj] = s; sum2 += s * s; } parl = fp / (delta * sum2); }   [CLASS] LevenbergMarquardtOptimizer [METHOD] determineLMParameter [RETURN_TYPE] void  double[] qy double delta double[] diag double[] work1 double[] work2 double[] work3 [VARIABLES] int[] permutation boolean double[] beta diag diagR jacNorm lmDir oldRes oldX qy tmpVec work1 work2 work3 double actRed coeff1 coeff2 correction costRelativeTolerance delta dirDer dirJ dk dxNorm fp gNorm initialStepBoundFactor lmNorm lmPar maxCosine orthoTolerance parRelativeTolerance parl paru pc2 preRed previousCost previousFP r ratio s sPar sum sum2 tmp xK xNorm xk ypk int countdown i j k pj pk rank solvedCols  	projects/Math68/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	518	518	2	add	
17	[BUG] [BUGGY] sum += jacobian[i][pj] * work1[permutation[i]]; [FE] AssertionFailedError [CONTEXT] if (rank == solvedCols) { for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; work1[pj] *= diag[pj] / dxNorm; } sum2 = 0; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; double sum = 0; for (int i = 0; i < j; ++i) { [BUGGY] sum += jacobian[i][pj] * work1[permutation[i]]; [BUGGY] } double s = (work1[pj] - sum) / diagR[pj]; work1[pj] = s; sum2 += s * s; } parl = fp / (delta * sum2); }  sum2 = 0; [CLASS] LevenbergMarquardtOptimizer [METHOD] determineLMParameter [RETURN_TYPE] void  double[] qy double delta double[] diag double[] work1 double[] work2 double[] work3 [VARIABLES] int[] permutation boolean double[] beta diag diagR jacNorm lmDir oldRes oldX qy tmpVec work1 work2 work3 double actRed coeff1 coeff2 correction costRelativeTolerance delta dirDer dirJ dk dxNorm fp gNorm initialStepBoundFactor lmNorm lmPar maxCosine orthoTolerance parRelativeTolerance parl paru pc2 preRed previousCost previousFP r ratio s sPar sum sum2 tmp xK xNorm xk ypk int countdown i j k pj pk rank solvedCols  	projects/Math68/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	519	519	2	replace	
18	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] if (rank == solvedCols) { for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; work1[pj] *= diag[pj] / dxNorm; } sum2 = 0; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; double sum = 0; for (int i = 0; i < j; ++i) { [BUGGY] [BUGGY] sum += jacobian[i][pj] * work1[permutation[i]]; } double s = (work1[pj] - sum) / diagR[pj]; work1[pj] = s; sum2 += s * s; } parl = fp / (delta * sum2); }  sum2 = 0; [CLASS] LevenbergMarquardtOptimizer [METHOD] determineLMParameter [RETURN_TYPE] void  double[] qy double delta double[] diag double[] work1 double[] work2 double[] work3 [VARIABLES] int[] permutation boolean double[] beta diag diagR jacNorm lmDir oldRes oldX qy tmpVec work1 work2 work3 double actRed coeff1 coeff2 correction costRelativeTolerance delta dirDer dirJ dk dxNorm fp gNorm initialStepBoundFactor lmNorm lmPar maxCosine orthoTolerance parRelativeTolerance parl paru pc2 preRed previousCost previousFP r ratio s sPar sum sum2 tmp xK xNorm xk ypk int countdown i j k pj pk rank solvedCols  	projects/Math68/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	519	519	2	add	
19	[BUG] [BUGGY] double s = (work1[pj] - sum) / diagR[pj]; [FE] AssertionFailedError [CONTEXT] int pj = permutation[j]; work1[pj] *= diag[pj] / dxNorm; } sum2 = 0; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; double sum = 0; for (int i = 0; i < j; ++i) { sum += jacobian[i][pj] * work1[permutation[i]]; } [BUGGY] double s = (work1[pj] - sum) / diagR[pj]; [BUGGY] work1[pj] = s; sum2 += s * s; } parl = fp / (delta * sum2); }  sum2 = 0; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; [CLASS] LevenbergMarquardtOptimizer [METHOD] determineLMParameter [RETURN_TYPE] void  double[] qy double delta double[] diag double[] work1 double[] work2 double[] work3 [VARIABLES] int[] permutation boolean double[] beta diag diagR jacNorm lmDir oldRes oldX qy tmpVec work1 work2 work3 double actRed coeff1 coeff2 correction costRelativeTolerance delta dirDer dirJ dk dxNorm fp gNorm initialStepBoundFactor lmNorm lmPar maxCosine orthoTolerance parRelativeTolerance parl paru pc2 preRed previousCost previousFP r ratio s sPar sum sum2 tmp xK xNorm xk ypk int countdown i j k pj pk rank solvedCols  	projects/Math68/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	521	521	2	replace	
20	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] int pj = permutation[j]; work1[pj] *= diag[pj] / dxNorm; } sum2 = 0; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; double sum = 0; for (int i = 0; i < j; ++i) { sum += jacobian[i][pj] * work1[permutation[i]]; } [BUGGY] [BUGGY] double s = (work1[pj] - sum) / diagR[pj]; work1[pj] = s; sum2 += s * s; } parl = fp / (delta * sum2); }  sum2 = 0; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; [CLASS] LevenbergMarquardtOptimizer [METHOD] determineLMParameter [RETURN_TYPE] void  double[] qy double delta double[] diag double[] work1 double[] work2 double[] work3 [VARIABLES] int[] permutation boolean double[] beta diag diagR jacNorm lmDir oldRes oldX qy tmpVec work1 work2 work3 double actRed coeff1 coeff2 correction costRelativeTolerance delta dirDer dirJ dk dxNorm fp gNorm initialStepBoundFactor lmNorm lmPar maxCosine orthoTolerance parRelativeTolerance parl paru pc2 preRed previousCost previousFP r ratio s sPar sum sum2 tmp xK xNorm xk ypk int countdown i j k pj pk rank solvedCols  	projects/Math68/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	521	521	2	add	
21	[BUG] [BUGGY] work1[pj] = s; [FE] AssertionFailedError [CONTEXT] work1[pj] *= diag[pj] / dxNorm; } sum2 = 0; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; double sum = 0; for (int i = 0; i < j; ++i) { sum += jacobian[i][pj] * work1[permutation[i]]; } double s = (work1[pj] - sum) / diagR[pj]; [BUGGY] work1[pj] = s; [BUGGY] sum2 += s * s; } parl = fp / (delta * sum2); }  sum2 = 0; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; double sum = 0; [CLASS] LevenbergMarquardtOptimizer [METHOD] determineLMParameter [RETURN_TYPE] void  double[] qy double delta double[] diag double[] work1 double[] work2 double[] work3 [VARIABLES] int[] permutation boolean double[] beta diag diagR jacNorm lmDir oldRes oldX qy tmpVec work1 work2 work3 double actRed coeff1 coeff2 correction costRelativeTolerance delta dirDer dirJ dk dxNorm fp gNorm initialStepBoundFactor lmNorm lmPar maxCosine orthoTolerance parRelativeTolerance parl paru pc2 preRed previousCost previousFP r ratio s sPar sum sum2 tmp xK xNorm xk ypk int countdown i j k pj pk rank solvedCols  	projects/Math68/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	522	522	2	replace	
22	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] work1[pj] *= diag[pj] / dxNorm; } sum2 = 0; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; double sum = 0; for (int i = 0; i < j; ++i) { sum += jacobian[i][pj] * work1[permutation[i]]; } double s = (work1[pj] - sum) / diagR[pj]; [BUGGY] [BUGGY] work1[pj] = s; sum2 += s * s; } parl = fp / (delta * sum2); }  sum2 = 0; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; double sum = 0; [CLASS] LevenbergMarquardtOptimizer [METHOD] determineLMParameter [RETURN_TYPE] void  double[] qy double delta double[] diag double[] work1 double[] work2 double[] work3 [VARIABLES] int[] permutation boolean double[] beta diag diagR jacNorm lmDir oldRes oldX qy tmpVec work1 work2 work3 double actRed coeff1 coeff2 correction costRelativeTolerance delta dirDer dirJ dk dxNorm fp gNorm initialStepBoundFactor lmNorm lmPar maxCosine orthoTolerance parRelativeTolerance parl paru pc2 preRed previousCost previousFP r ratio s sPar sum sum2 tmp xK xNorm xk ypk int countdown i j k pj pk rank solvedCols  	projects/Math68/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	522	522	2	add	
23	[BUG] [BUGGY] sum2 += s * s; [FE] AssertionFailedError [CONTEXT] } sum2 = 0; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; double sum = 0; for (int i = 0; i < j; ++i) { sum += jacobian[i][pj] * work1[permutation[i]]; } double s = (work1[pj] - sum) / diagR[pj]; work1[pj] = s; [BUGGY] sum2 += s * s; [BUGGY] } parl = fp / (delta * sum2); }  sum2 = 0; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; double sum = 0; for (int i = 0; i <= j; ++i) { [CLASS] LevenbergMarquardtOptimizer [METHOD] determineLMParameter [RETURN_TYPE] void  double[] qy double delta double[] diag double[] work1 double[] work2 double[] work3 [VARIABLES] int[] permutation boolean double[] beta diag diagR jacNorm lmDir oldRes oldX qy tmpVec work1 work2 work3 double actRed coeff1 coeff2 correction costRelativeTolerance delta dirDer dirJ dk dxNorm fp gNorm initialStepBoundFactor lmNorm lmPar maxCosine orthoTolerance parRelativeTolerance parl paru pc2 preRed previousCost previousFP r ratio s sPar sum sum2 tmp xK xNorm xk ypk int countdown i j k pj pk rank solvedCols  	projects/Math68/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	523	523	2	replace	
24	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] } sum2 = 0; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; double sum = 0; for (int i = 0; i < j; ++i) { sum += jacobian[i][pj] * work1[permutation[i]]; } double s = (work1[pj] - sum) / diagR[pj]; work1[pj] = s; [BUGGY] [BUGGY] sum2 += s * s; } parl = fp / (delta * sum2); }  sum2 = 0; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; double sum = 0; for (int i = 0; i <= j; ++i) { [CLASS] LevenbergMarquardtOptimizer [METHOD] determineLMParameter [RETURN_TYPE] void  double[] qy double delta double[] diag double[] work1 double[] work2 double[] work3 [VARIABLES] int[] permutation boolean double[] beta diag diagR jacNorm lmDir oldRes oldX qy tmpVec work1 work2 work3 double actRed coeff1 coeff2 correction costRelativeTolerance delta dirDer dirJ dk dxNorm fp gNorm initialStepBoundFactor lmNorm lmPar maxCosine orthoTolerance parRelativeTolerance parl paru pc2 preRed previousCost previousFP r ratio s sPar sum sum2 tmp xK xNorm xk ypk int countdown i j k pj pk rank solvedCols  	projects/Math68/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	523	523	2	add	
25	[BUG] [BUGGY] parl = fp / (delta * sum2); [FE] AssertionFailedError [CONTEXT] for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; double sum = 0; for (int i = 0; i < j; ++i) { sum += jacobian[i][pj] * work1[permutation[i]]; } double s = (work1[pj] - sum) / diagR[pj]; work1[pj] = s; sum2 += s * s; } [BUGGY] parl = fp / (delta * sum2); [BUGGY] }  sum2 = 0; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; double sum = 0; for (int i = 0; i <= j; ++i) { sum += jacobian[i][pj] * qy[i]; } [CLASS] LevenbergMarquardtOptimizer [METHOD] determineLMParameter [RETURN_TYPE] void  double[] qy double delta double[] diag double[] work1 double[] work2 double[] work3 [VARIABLES] int[] permutation boolean double[] beta diag diagR jacNorm lmDir oldRes oldX qy tmpVec work1 work2 work3 double actRed coeff1 coeff2 correction costRelativeTolerance delta dirDer dirJ dk dxNorm fp gNorm initialStepBoundFactor lmNorm lmPar maxCosine orthoTolerance parRelativeTolerance parl paru pc2 preRed previousCost previousFP r ratio s sPar sum sum2 tmp xK xNorm xk ypk int countdown i j k pj pk rank solvedCols  	projects/Math68/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	525	525	2	replace	
26	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; double sum = 0; for (int i = 0; i < j; ++i) { sum += jacobian[i][pj] * work1[permutation[i]]; } double s = (work1[pj] - sum) / diagR[pj]; work1[pj] = s; sum2 += s * s; } [BUGGY] [BUGGY] parl = fp / (delta * sum2); }  sum2 = 0; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; double sum = 0; for (int i = 0; i <= j; ++i) { sum += jacobian[i][pj] * qy[i]; } [CLASS] LevenbergMarquardtOptimizer [METHOD] determineLMParameter [RETURN_TYPE] void  double[] qy double delta double[] diag double[] work1 double[] work2 double[] work3 [VARIABLES] int[] permutation boolean double[] beta diag diagR jacNorm lmDir oldRes oldX qy tmpVec work1 work2 work3 double actRed coeff1 coeff2 correction costRelativeTolerance delta dirDer dirJ dk dxNorm fp gNorm initialStepBoundFactor lmNorm lmPar maxCosine orthoTolerance parRelativeTolerance parl paru pc2 preRed previousCost previousFP r ratio s sPar sum sum2 tmp xK xNorm xk ypk int countdown i j k pj pk rank solvedCols  	projects/Math68/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	525	525	2	add	
27	[BUG] [BUGGY] tmp = 0.1; [FE] AssertionFailedError [CONTEXT] double dirDer = -(coeff1 + coeff2);  ratio = (preRed == 0) ? 0 : (actRed / preRed);  if (ratio <= 0.25) { double tmp = (actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5; if ((0.1 * cost >= previousCost) || (tmp < 0.1)) { [BUGGY] tmp = 0.1; [BUGGY] } delta = tmp * Math.min(delta, 10.0 * lmNorm); lmPar /= tmp; } else if ((lmPar == 0) || (ratio >= 0.75)) { delta = 2 * lmNorm; lmPar *= 0.5; }  if (ratio >= 1.0e-4) { [CLASS] LevenbergMarquardtOptimizer [METHOD] doOptimize [RETURN_TYPE] VectorialPointValuePair  [VARIABLES] int[] permutation boolean firstIteration double[] beta diag diagR jacNorm lmDir oldRes oldX tmpVec work1 work2 work3 double actRed coeff1 coeff2 costRelativeTolerance delta dirDer dirJ dk initialStepBoundFactor lmNorm lmPar maxCosine orthoTolerance parRelativeTolerance pc2 preRed previousCost r ratio s sum tmp xK xNorm xk int i j k pj pk rank solvedCols  	projects/Math68/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3779644730092272	381	381	2	replace	
28	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] double dirDer = -(coeff1 + coeff2);  ratio = (preRed == 0) ? 0 : (actRed / preRed);  if (ratio <= 0.25) { double tmp = (actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5; if ((0.1 * cost >= previousCost) || (tmp < 0.1)) { [BUGGY] [BUGGY] tmp = 0.1; } delta = tmp * Math.min(delta, 10.0 * lmNorm); lmPar /= tmp; } else if ((lmPar == 0) || (ratio >= 0.75)) { delta = 2 * lmNorm; lmPar *= 0.5; }  if (ratio >= 1.0e-4) { [CLASS] LevenbergMarquardtOptimizer [METHOD] doOptimize [RETURN_TYPE] VectorialPointValuePair  [VARIABLES] int[] permutation boolean firstIteration double[] beta diag diagR jacNorm lmDir oldRes oldX tmpVec work1 work2 work3 double actRed coeff1 coeff2 costRelativeTolerance delta dirDer dirJ dk initialStepBoundFactor lmNorm lmPar maxCosine orthoTolerance parRelativeTolerance pc2 preRed previousCost r ratio s sum tmp xK xNorm xk int i j k pj pk rank solvedCols  	projects/Math68/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3779644730092272	381	381	2	add	
29	[BUG] [BUGGY] cost = previousCost; [FE] AssertionFailedError [CONTEXT]  firstIteration = false; xNorm = 0; for (int k = 0; k < cols; ++k) { double xK = diag[k] * point[k]; xNorm+= xK * xK; } xNorm = Math.sqrt(xNorm); } else {  [BUGGY] cost = previousCost; [BUGGY] for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; point[pj] = oldX[pj]; } tmpVec= residuals; residuals = oldRes; oldRes= tmpVec; } [CLASS] LevenbergMarquardtOptimizer [METHOD] doOptimize [RETURN_TYPE] VectorialPointValuePair  [VARIABLES] int[] permutation boolean firstIteration double[] beta diag diagR jacNorm lmDir oldRes oldX tmpVec work1 work2 work3 double actRed coeff1 coeff2 costRelativeTolerance delta dirDer dirJ dk initialStepBoundFactor lmNorm lmPar maxCosine orthoTolerance parRelativeTolerance pc2 preRed previousCost r ratio s sum tmp xK xNorm xk int i j k pj pk rank solvedCols  	projects/Math68/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	402	402	2	replace	
30	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT]  firstIteration = false; xNorm = 0; for (int k = 0; k < cols; ++k) { double xK = diag[k] * point[k]; xNorm+= xK * xK; } xNorm = Math.sqrt(xNorm); } else {  [BUGGY] [BUGGY] cost = previousCost; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; point[pj] = oldX[pj]; } tmpVec= residuals; residuals = oldRes; oldRes= tmpVec; } [CLASS] LevenbergMarquardtOptimizer [METHOD] doOptimize [RETURN_TYPE] VectorialPointValuePair  [VARIABLES] int[] permutation boolean firstIteration double[] beta diag diagR jacNorm lmDir oldRes oldX tmpVec work1 work2 work3 double actRed coeff1 coeff2 costRelativeTolerance delta dirDer dirJ dk initialStepBoundFactor lmNorm lmPar maxCosine orthoTolerance parRelativeTolerance pc2 preRed previousCost r ratio s sum tmp xK xNorm xk int i j k pj pk rank solvedCols  	projects/Math68/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	402	402	2	add	
31	[BUG] [BUGGY] for (int j = 0; j < solvedCols; ++j) { [FE] AssertionFailedError [CONTEXT] firstIteration = false; xNorm = 0; for (int k = 0; k < cols; ++k) { double xK = diag[k] * point[k]; xNorm+= xK * xK; } xNorm = Math.sqrt(xNorm); } else {  cost = previousCost; [BUGGY] for (int j = 0; j < solvedCols; ++j) { [BUGGY] int pj = permutation[j]; point[pj] = oldX[pj]; } tmpVec= residuals; residuals = oldRes; oldRes= tmpVec; } [CLASS] LevenbergMarquardtOptimizer [METHOD] doOptimize [RETURN_TYPE] VectorialPointValuePair  [VARIABLES] int[] permutation boolean firstIteration double[] beta diag diagR jacNorm lmDir oldRes oldX tmpVec work1 work2 work3 double actRed coeff1 coeff2 costRelativeTolerance delta dirDer dirJ dk initialStepBoundFactor lmNorm lmPar maxCosine orthoTolerance parRelativeTolerance pc2 preRed previousCost r ratio s sum tmp xK xNorm xk int i j k pj pk rank solvedCols  	projects/Math68/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	403	403	2	replace	
32	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] firstIteration = false; xNorm = 0; for (int k = 0; k < cols; ++k) { double xK = diag[k] * point[k]; xNorm+= xK * xK; } xNorm = Math.sqrt(xNorm); } else {  cost = previousCost; [BUGGY] [BUGGY] for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; point[pj] = oldX[pj]; } tmpVec= residuals; residuals = oldRes; oldRes= tmpVec; } [CLASS] LevenbergMarquardtOptimizer [METHOD] doOptimize [RETURN_TYPE] VectorialPointValuePair  [VARIABLES] int[] permutation boolean firstIteration double[] beta diag diagR jacNorm lmDir oldRes oldX tmpVec work1 work2 work3 double actRed coeff1 coeff2 costRelativeTolerance delta dirDer dirJ dk initialStepBoundFactor lmNorm lmPar maxCosine orthoTolerance parRelativeTolerance pc2 preRed previousCost r ratio s sum tmp xK xNorm xk int i j k pj pk rank solvedCols  	projects/Math68/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	403	403	2	add	
33	[BUG] [BUGGY] int pj = permutation[j]; [FE] AssertionFailedError [CONTEXT] xNorm = 0; for (int k = 0; k < cols; ++k) { double xK = diag[k] * point[k]; xNorm+= xK * xK; } xNorm = Math.sqrt(xNorm); } else {  cost = previousCost; for (int j = 0; j < solvedCols; ++j) { [BUGGY] int pj = permutation[j]; [BUGGY] point[pj] = oldX[pj]; } tmpVec= residuals; residuals = oldRes; oldRes= tmpVec; } [CLASS] LevenbergMarquardtOptimizer [METHOD] doOptimize [RETURN_TYPE] VectorialPointValuePair  [VARIABLES] int[] permutation boolean firstIteration double[] beta diag diagR jacNorm lmDir oldRes oldX tmpVec work1 work2 work3 double actRed coeff1 coeff2 costRelativeTolerance delta dirDer dirJ dk initialStepBoundFactor lmNorm lmPar maxCosine orthoTolerance parRelativeTolerance pc2 preRed previousCost r ratio s sum tmp xK xNorm xk int i j k pj pk rank solvedCols  	projects/Math68/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	404	404	2	replace	
34	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] xNorm = 0; for (int k = 0; k < cols; ++k) { double xK = diag[k] * point[k]; xNorm+= xK * xK; } xNorm = Math.sqrt(xNorm); } else {  cost = previousCost; for (int j = 0; j < solvedCols; ++j) { [BUGGY] [BUGGY] int pj = permutation[j]; point[pj] = oldX[pj]; } tmpVec= residuals; residuals = oldRes; oldRes= tmpVec; } [CLASS] LevenbergMarquardtOptimizer [METHOD] doOptimize [RETURN_TYPE] VectorialPointValuePair  [VARIABLES] int[] permutation boolean firstIteration double[] beta diag diagR jacNorm lmDir oldRes oldX tmpVec work1 work2 work3 double actRed coeff1 coeff2 costRelativeTolerance delta dirDer dirJ dk initialStepBoundFactor lmNorm lmPar maxCosine orthoTolerance parRelativeTolerance pc2 preRed previousCost r ratio s sum tmp xK xNorm xk int i j k pj pk rank solvedCols  	projects/Math68/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	404	404	2	add	
35	[BUG] [BUGGY] point[pj] = oldX[pj]; [FE] AssertionFailedError [CONTEXT] for (int k = 0; k < cols; ++k) { double xK = diag[k] * point[k]; xNorm+= xK * xK; } xNorm = Math.sqrt(xNorm); } else {  cost = previousCost; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; [BUGGY] point[pj] = oldX[pj]; [BUGGY] } tmpVec= residuals; residuals = oldRes; oldRes= tmpVec; } [CLASS] LevenbergMarquardtOptimizer [METHOD] doOptimize [RETURN_TYPE] VectorialPointValuePair  [VARIABLES] int[] permutation boolean firstIteration double[] beta diag diagR jacNorm lmDir oldRes oldX tmpVec work1 work2 work3 double actRed coeff1 coeff2 costRelativeTolerance delta dirDer dirJ dk initialStepBoundFactor lmNorm lmPar maxCosine orthoTolerance parRelativeTolerance pc2 preRed previousCost r ratio s sum tmp xK xNorm xk int i j k pj pk rank solvedCols  	projects/Math68/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	405	405	2	replace	
36	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] for (int k = 0; k < cols; ++k) { double xK = diag[k] * point[k]; xNorm+= xK * xK; } xNorm = Math.sqrt(xNorm); } else {  cost = previousCost; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; [BUGGY] [BUGGY] point[pj] = oldX[pj]; } tmpVec= residuals; residuals = oldRes; oldRes= tmpVec; } [CLASS] LevenbergMarquardtOptimizer [METHOD] doOptimize [RETURN_TYPE] VectorialPointValuePair  [VARIABLES] int[] permutation boolean firstIteration double[] beta diag diagR jacNorm lmDir oldRes oldX tmpVec work1 work2 work3 double actRed coeff1 coeff2 costRelativeTolerance delta dirDer dirJ dk initialStepBoundFactor lmNorm lmPar maxCosine orthoTolerance parRelativeTolerance pc2 preRed previousCost r ratio s sum tmp xK xNorm xk int i j k pj pk rank solvedCols  	projects/Math68/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	405	405	2	add	
37	[BUG] [BUGGY] tmpVec= residuals; [FE] AssertionFailedError [CONTEXT] xNorm+= xK * xK; } xNorm = Math.sqrt(xNorm); } else {  cost = previousCost; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; point[pj] = oldX[pj]; } [BUGGY] tmpVec= residuals; [BUGGY] residuals = oldRes; oldRes= tmpVec; } [CLASS] LevenbergMarquardtOptimizer [METHOD] doOptimize [RETURN_TYPE] VectorialPointValuePair  [VARIABLES] int[] permutation boolean firstIteration double[] beta diag diagR jacNorm lmDir oldRes oldX tmpVec work1 work2 work3 double actRed coeff1 coeff2 costRelativeTolerance delta dirDer dirJ dk initialStepBoundFactor lmNorm lmPar maxCosine orthoTolerance parRelativeTolerance pc2 preRed previousCost r ratio s sum tmp xK xNorm xk int i j k pj pk rank solvedCols  	projects/Math68/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	407	407	2	replace	
38	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] xNorm+= xK * xK; } xNorm = Math.sqrt(xNorm); } else {  cost = previousCost; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; point[pj] = oldX[pj]; } [BUGGY] [BUGGY] tmpVec= residuals; residuals = oldRes; oldRes= tmpVec; } [CLASS] LevenbergMarquardtOptimizer [METHOD] doOptimize [RETURN_TYPE] VectorialPointValuePair  [VARIABLES] int[] permutation boolean firstIteration double[] beta diag diagR jacNorm lmDir oldRes oldX tmpVec work1 work2 work3 double actRed coeff1 coeff2 costRelativeTolerance delta dirDer dirJ dk initialStepBoundFactor lmNorm lmPar maxCosine orthoTolerance parRelativeTolerance pc2 preRed previousCost r ratio s sum tmp xK xNorm xk int i j k pj pk rank solvedCols  	projects/Math68/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	407	407	2	add	
39	[BUG] [BUGGY] residuals = oldRes; [FE] AssertionFailedError [CONTEXT] } xNorm = Math.sqrt(xNorm); } else {  cost = previousCost; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; point[pj] = oldX[pj]; } tmpVec= residuals; [BUGGY] residuals = oldRes; [BUGGY] oldRes= tmpVec; } [CLASS] LevenbergMarquardtOptimizer [METHOD] doOptimize [RETURN_TYPE] VectorialPointValuePair  [VARIABLES] int[] permutation boolean firstIteration double[] beta diag diagR jacNorm lmDir oldRes oldX tmpVec work1 work2 work3 double actRed coeff1 coeff2 costRelativeTolerance delta dirDer dirJ dk initialStepBoundFactor lmNorm lmPar maxCosine orthoTolerance parRelativeTolerance pc2 preRed previousCost r ratio s sum tmp xK xNorm xk int i j k pj pk rank solvedCols  	projects/Math68/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	408	408	2	replace	
40	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] } xNorm = Math.sqrt(xNorm); } else {  cost = previousCost; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; point[pj] = oldX[pj]; } tmpVec= residuals; [BUGGY] [BUGGY] residuals = oldRes; oldRes= tmpVec; } [CLASS] LevenbergMarquardtOptimizer [METHOD] doOptimize [RETURN_TYPE] VectorialPointValuePair  [VARIABLES] int[] permutation boolean firstIteration double[] beta diag diagR jacNorm lmDir oldRes oldX tmpVec work1 work2 work3 double actRed coeff1 coeff2 costRelativeTolerance delta dirDer dirJ dk initialStepBoundFactor lmNorm lmPar maxCosine orthoTolerance parRelativeTolerance pc2 preRed previousCost r ratio s sum tmp xK xNorm xk int i j k pj pk rank solvedCols  	projects/Math68/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	408	408	2	add	
41	[BUG] [BUGGY] oldRes= tmpVec; [FE] AssertionFailedError [CONTEXT] xNorm = Math.sqrt(xNorm); } else {  cost = previousCost; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; point[pj] = oldX[pj]; } tmpVec= residuals; residuals = oldRes; [BUGGY] oldRes= tmpVec; [BUGGY] } [CLASS] LevenbergMarquardtOptimizer [METHOD] doOptimize [RETURN_TYPE] VectorialPointValuePair  [VARIABLES] int[] permutation boolean firstIteration double[] beta diag diagR jacNorm lmDir oldRes oldX tmpVec work1 work2 work3 double actRed coeff1 coeff2 costRelativeTolerance delta dirDer dirJ dk initialStepBoundFactor lmNorm lmPar maxCosine orthoTolerance parRelativeTolerance pc2 preRed previousCost r ratio s sum tmp xK xNorm xk int i j k pj pk rank solvedCols  	projects/Math68/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	409	409	2	replace	
42	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] xNorm = Math.sqrt(xNorm); } else {  cost = previousCost; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; point[pj] = oldX[pj]; } tmpVec= residuals; residuals = oldRes; [BUGGY] [BUGGY] oldRes= tmpVec; } [CLASS] LevenbergMarquardtOptimizer [METHOD] doOptimize [RETURN_TYPE] VectorialPointValuePair  [VARIABLES] int[] permutation boolean firstIteration double[] beta diag diagR jacNorm lmDir oldRes oldX tmpVec work1 work2 work3 double actRed coeff1 coeff2 costRelativeTolerance delta dirDer dirJ dk initialStepBoundFactor lmNorm lmPar maxCosine orthoTolerance parRelativeTolerance pc2 preRed previousCost r ratio s sum tmp xK xNorm xk int i j k pj pk rank solvedCols  	projects/Math68/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	409	409	2	add	
43	[BUG] [BUGGY] double parl = 0; [FE] AssertionFailedError [CONTEXT] double fp = dxNorm - delta; if (fp <= 0.1 * delta) { lmPar = 0; return; }    double sum2; [BUGGY] double parl = 0; [BUGGY] if (rank == solvedCols) { for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; work1[pj] *= diag[pj] / dxNorm; } sum2 = 0; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; double sum = 0; for (int i = 0; i < j; ++i) { [CLASS] LevenbergMarquardtOptimizer [METHOD] determineLMParameter [RETURN_TYPE] void  double[] qy double delta double[] diag double[] work1 double[] work2 double[] work3 [VARIABLES] int[] permutation boolean double[] beta diag diagR jacNorm lmDir oldRes oldX qy tmpVec work1 work2 work3 double actRed coeff1 coeff2 correction costRelativeTolerance delta dirDer dirJ dk dxNorm fp gNorm initialStepBoundFactor lmNorm lmPar maxCosine orthoTolerance parRelativeTolerance parl paru pc2 preRed previousCost previousFP r ratio s sPar sum sum2 tmp xK xNorm xk ypk int countdown i j k pj pk rank solvedCols  	projects/Math68/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	508	508	2	replace	
44	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] double fp = dxNorm - delta; if (fp <= 0.1 * delta) { lmPar = 0; return; }    double sum2; [BUGGY] [BUGGY] double parl = 0; if (rank == solvedCols) { for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; work1[pj] *= diag[pj] / dxNorm; } sum2 = 0; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; double sum = 0; for (int i = 0; i < j; ++i) { [CLASS] LevenbergMarquardtOptimizer [METHOD] determineLMParameter [RETURN_TYPE] void  double[] qy double delta double[] diag double[] work1 double[] work2 double[] work3 [VARIABLES] int[] permutation boolean double[] beta diag diagR jacNorm lmDir oldRes oldX qy tmpVec work1 work2 work3 double actRed coeff1 coeff2 correction costRelativeTolerance delta dirDer dirJ dk dxNorm fp gNorm initialStepBoundFactor lmNorm lmPar maxCosine orthoTolerance parRelativeTolerance parl paru pc2 preRed previousCost previousFP r ratio s sPar sum sum2 tmp xK xNorm xk ypk int countdown i j k pj pk rank solvedCols  	projects/Math68/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	508	508	2	add	
45	[BUG] [BUGGY] if (rank == solvedCols) { [FE] AssertionFailedError [CONTEXT] if (fp <= 0.1 * delta) { lmPar = 0; return; }    double sum2; double parl = 0; [BUGGY] if (rank == solvedCols) { [BUGGY] for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; work1[pj] *= diag[pj] / dxNorm; } sum2 = 0; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; double sum = 0; for (int i = 0; i < j; ++i) { sum += jacobian[i][pj] * work1[permutation[i]]; [CLASS] LevenbergMarquardtOptimizer [METHOD] determineLMParameter [RETURN_TYPE] void  double[] qy double delta double[] diag double[] work1 double[] work2 double[] work3 [VARIABLES] int[] permutation boolean double[] beta diag diagR jacNorm lmDir oldRes oldX qy tmpVec work1 work2 work3 double actRed coeff1 coeff2 correction costRelativeTolerance delta dirDer dirJ dk dxNorm fp gNorm initialStepBoundFactor lmNorm lmPar maxCosine orthoTolerance parRelativeTolerance parl paru pc2 preRed previousCost previousFP r ratio s sPar sum sum2 tmp xK xNorm xk ypk int countdown i j k pj pk rank solvedCols  	projects/Math68/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	509	509	2	replace	
46	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] if (fp <= 0.1 * delta) { lmPar = 0; return; }    double sum2; double parl = 0; [BUGGY] [BUGGY] if (rank == solvedCols) { for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; work1[pj] *= diag[pj] / dxNorm; } sum2 = 0; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; double sum = 0; for (int i = 0; i < j; ++i) { sum += jacobian[i][pj] * work1[permutation[i]]; [CLASS] LevenbergMarquardtOptimizer [METHOD] determineLMParameter [RETURN_TYPE] void  double[] qy double delta double[] diag double[] work1 double[] work2 double[] work3 [VARIABLES] int[] permutation boolean double[] beta diag diagR jacNorm lmDir oldRes oldX qy tmpVec work1 work2 work3 double actRed coeff1 coeff2 correction costRelativeTolerance delta dirDer dirJ dk dxNorm fp gNorm initialStepBoundFactor lmNorm lmPar maxCosine orthoTolerance parRelativeTolerance parl paru pc2 preRed previousCost previousFP r ratio s sPar sum sum2 tmp xK xNorm xk ypk int countdown i j k pj pk rank solvedCols  	projects/Math68/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	509	509	2	add	
47	[BUG] [BUGGY] sum2 = 0; [FE] AssertionFailedError [CONTEXT] sum += jacobian[i][pj] * work1[permutation[i]]; } double s = (work1[pj] - sum) / diagR[pj]; work1[pj] = s; sum2 += s * s; } parl = fp / (delta * sum2); }  [BUGGY] sum2 = 0; [BUGGY] for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; double sum = 0; for (int i = 0; i <= j; ++i) { sum += jacobian[i][pj] * qy[i]; } sum /= diag[pj]; sum2 += sum * sum; } double gNorm = Math.sqrt(sum2); [CLASS] LevenbergMarquardtOptimizer [METHOD] determineLMParameter [RETURN_TYPE] void  double[] qy double delta double[] diag double[] work1 double[] work2 double[] work3 [VARIABLES] int[] permutation boolean double[] beta diag diagR jacNorm lmDir oldRes oldX qy tmpVec work1 work2 work3 double actRed coeff1 coeff2 correction costRelativeTolerance delta dirDer dirJ dk dxNorm fp gNorm initialStepBoundFactor lmNorm lmPar maxCosine orthoTolerance parRelativeTolerance parl paru pc2 preRed previousCost previousFP r ratio s sPar sum sum2 tmp xK xNorm xk ypk int countdown i j k pj pk rank solvedCols  	projects/Math68/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	529	529	2	replace	
48	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] sum += jacobian[i][pj] * work1[permutation[i]]; } double s = (work1[pj] - sum) / diagR[pj]; work1[pj] = s; sum2 += s * s; } parl = fp / (delta * sum2); }  [BUGGY] [BUGGY] sum2 = 0; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; double sum = 0; for (int i = 0; i <= j; ++i) { sum += jacobian[i][pj] * qy[i]; } sum /= diag[pj]; sum2 += sum * sum; } double gNorm = Math.sqrt(sum2); [CLASS] LevenbergMarquardtOptimizer [METHOD] determineLMParameter [RETURN_TYPE] void  double[] qy double delta double[] diag double[] work1 double[] work2 double[] work3 [VARIABLES] int[] permutation boolean double[] beta diag diagR jacNorm lmDir oldRes oldX qy tmpVec work1 work2 work3 double actRed coeff1 coeff2 correction costRelativeTolerance delta dirDer dirJ dk dxNorm fp gNorm initialStepBoundFactor lmNorm lmPar maxCosine orthoTolerance parRelativeTolerance parl paru pc2 preRed previousCost previousFP r ratio s sPar sum sum2 tmp xK xNorm xk ypk int countdown i j k pj pk rank solvedCols  	projects/Math68/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	529	529	2	add	
49	[BUG] [BUGGY] for (int j = 0; j < solvedCols; ++j) { [FE] AssertionFailedError [CONTEXT] } double s = (work1[pj] - sum) / diagR[pj]; work1[pj] = s; sum2 += s * s; } parl = fp / (delta * sum2); }  sum2 = 0; [BUGGY] for (int j = 0; j < solvedCols; ++j) { [BUGGY] int pj = permutation[j]; double sum = 0; for (int i = 0; i <= j; ++i) { sum += jacobian[i][pj] * qy[i]; } sum /= diag[pj]; sum2 += sum * sum; } double gNorm = Math.sqrt(sum2); double paru = gNorm / delta; [CLASS] LevenbergMarquardtOptimizer [METHOD] determineLMParameter [RETURN_TYPE] void  double[] qy double delta double[] diag double[] work1 double[] work2 double[] work3 [VARIABLES] int[] permutation boolean double[] beta diag diagR jacNorm lmDir oldRes oldX qy tmpVec work1 work2 work3 double actRed coeff1 coeff2 correction costRelativeTolerance delta dirDer dirJ dk dxNorm fp gNorm initialStepBoundFactor lmNorm lmPar maxCosine orthoTolerance parRelativeTolerance parl paru pc2 preRed previousCost previousFP r ratio s sPar sum sum2 tmp xK xNorm xk ypk int countdown i j k pj pk rank solvedCols  	projects/Math68/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	530	530	2	replace	
50	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] } double s = (work1[pj] - sum) / diagR[pj]; work1[pj] = s; sum2 += s * s; } parl = fp / (delta * sum2); }  sum2 = 0; [BUGGY] [BUGGY] for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; double sum = 0; for (int i = 0; i <= j; ++i) { sum += jacobian[i][pj] * qy[i]; } sum /= diag[pj]; sum2 += sum * sum; } double gNorm = Math.sqrt(sum2); double paru = gNorm / delta; [CLASS] LevenbergMarquardtOptimizer [METHOD] determineLMParameter [RETURN_TYPE] void  double[] qy double delta double[] diag double[] work1 double[] work2 double[] work3 [VARIABLES] int[] permutation boolean double[] beta diag diagR jacNorm lmDir oldRes oldX qy tmpVec work1 work2 work3 double actRed coeff1 coeff2 correction costRelativeTolerance delta dirDer dirJ dk dxNorm fp gNorm initialStepBoundFactor lmNorm lmPar maxCosine orthoTolerance parRelativeTolerance parl paru pc2 preRed previousCost previousFP r ratio s sPar sum sum2 tmp xK xNorm xk ypk int countdown i j k pj pk rank solvedCols  	projects/Math68/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	530	530	2	add	
51	[BUG] [BUGGY] int pj = permutation[j]; [FE] AssertionFailedError [CONTEXT] double s = (work1[pj] - sum) / diagR[pj]; work1[pj] = s; sum2 += s * s; } parl = fp / (delta * sum2); }  sum2 = 0; for (int j = 0; j < solvedCols; ++j) { [BUGGY] int pj = permutation[j]; [BUGGY] double sum = 0; for (int i = 0; i <= j; ++i) { sum += jacobian[i][pj] * qy[i]; } sum /= diag[pj]; sum2 += sum * sum; } double gNorm = Math.sqrt(sum2); double paru = gNorm / delta; if (paru == 0) { [CLASS] LevenbergMarquardtOptimizer [METHOD] determineLMParameter [RETURN_TYPE] void  double[] qy double delta double[] diag double[] work1 double[] work2 double[] work3 [VARIABLES] int[] permutation boolean double[] beta diag diagR jacNorm lmDir oldRes oldX qy tmpVec work1 work2 work3 double actRed coeff1 coeff2 correction costRelativeTolerance delta dirDer dirJ dk dxNorm fp gNorm initialStepBoundFactor lmNorm lmPar maxCosine orthoTolerance parRelativeTolerance parl paru pc2 preRed previousCost previousFP r ratio s sPar sum sum2 tmp xK xNorm xk ypk int countdown i j k pj pk rank solvedCols  	projects/Math68/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	531	531	2	replace	
52	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] double s = (work1[pj] - sum) / diagR[pj]; work1[pj] = s; sum2 += s * s; } parl = fp / (delta * sum2); }  sum2 = 0; for (int j = 0; j < solvedCols; ++j) { [BUGGY] [BUGGY] int pj = permutation[j]; double sum = 0; for (int i = 0; i <= j; ++i) { sum += jacobian[i][pj] * qy[i]; } sum /= diag[pj]; sum2 += sum * sum; } double gNorm = Math.sqrt(sum2); double paru = gNorm / delta; if (paru == 0) { [CLASS] LevenbergMarquardtOptimizer [METHOD] determineLMParameter [RETURN_TYPE] void  double[] qy double delta double[] diag double[] work1 double[] work2 double[] work3 [VARIABLES] int[] permutation boolean double[] beta diag diagR jacNorm lmDir oldRes oldX qy tmpVec work1 work2 work3 double actRed coeff1 coeff2 correction costRelativeTolerance delta dirDer dirJ dk dxNorm fp gNorm initialStepBoundFactor lmNorm lmPar maxCosine orthoTolerance parRelativeTolerance parl paru pc2 preRed previousCost previousFP r ratio s sPar sum sum2 tmp xK xNorm xk ypk int countdown i j k pj pk rank solvedCols  	projects/Math68/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	531	531	2	add	
53	[BUG] [BUGGY] double sum = 0; [FE] AssertionFailedError [CONTEXT] work1[pj] = s; sum2 += s * s; } parl = fp / (delta * sum2); }  sum2 = 0; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; [BUGGY] double sum = 0; [BUGGY] for (int i = 0; i <= j; ++i) { sum += jacobian[i][pj] * qy[i]; } sum /= diag[pj]; sum2 += sum * sum; } double gNorm = Math.sqrt(sum2); double paru = gNorm / delta; if (paru == 0) {  [CLASS] LevenbergMarquardtOptimizer [METHOD] determineLMParameter [RETURN_TYPE] void  double[] qy double delta double[] diag double[] work1 double[] work2 double[] work3 [VARIABLES] int[] permutation boolean double[] beta diag diagR jacNorm lmDir oldRes oldX qy tmpVec work1 work2 work3 double actRed coeff1 coeff2 correction costRelativeTolerance delta dirDer dirJ dk dxNorm fp gNorm initialStepBoundFactor lmNorm lmPar maxCosine orthoTolerance parRelativeTolerance parl paru pc2 preRed previousCost previousFP r ratio s sPar sum sum2 tmp xK xNorm xk ypk int countdown i j k pj pk rank solvedCols  	projects/Math68/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	532	532	2	replace	
54	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] work1[pj] = s; sum2 += s * s; } parl = fp / (delta * sum2); }  sum2 = 0; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; [BUGGY] [BUGGY] double sum = 0; for (int i = 0; i <= j; ++i) { sum += jacobian[i][pj] * qy[i]; } sum /= diag[pj]; sum2 += sum * sum; } double gNorm = Math.sqrt(sum2); double paru = gNorm / delta; if (paru == 0) {  [CLASS] LevenbergMarquardtOptimizer [METHOD] determineLMParameter [RETURN_TYPE] void  double[] qy double delta double[] diag double[] work1 double[] work2 double[] work3 [VARIABLES] int[] permutation boolean double[] beta diag diagR jacNorm lmDir oldRes oldX qy tmpVec work1 work2 work3 double actRed coeff1 coeff2 correction costRelativeTolerance delta dirDer dirJ dk dxNorm fp gNorm initialStepBoundFactor lmNorm lmPar maxCosine orthoTolerance parRelativeTolerance parl paru pc2 preRed previousCost previousFP r ratio s sPar sum sum2 tmp xK xNorm xk ypk int countdown i j k pj pk rank solvedCols  	projects/Math68/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	532	532	2	add	
55	[BUG] [BUGGY] for (int i = 0; i <= j; ++i) { [FE] AssertionFailedError [CONTEXT] sum2 += s * s; } parl = fp / (delta * sum2); }  sum2 = 0; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; double sum = 0; [BUGGY] for (int i = 0; i <= j; ++i) { [BUGGY] sum += jacobian[i][pj] * qy[i]; } sum /= diag[pj]; sum2 += sum * sum; } double gNorm = Math.sqrt(sum2); double paru = gNorm / delta; if (paru == 0) {  paru = 2.2251e-308 / Math.min(delta, 0.1); [CLASS] LevenbergMarquardtOptimizer [METHOD] determineLMParameter [RETURN_TYPE] void  double[] qy double delta double[] diag double[] work1 double[] work2 double[] work3 [VARIABLES] int[] permutation boolean double[] beta diag diagR jacNorm lmDir oldRes oldX qy tmpVec work1 work2 work3 double actRed coeff1 coeff2 correction costRelativeTolerance delta dirDer dirJ dk dxNorm fp gNorm initialStepBoundFactor lmNorm lmPar maxCosine orthoTolerance parRelativeTolerance parl paru pc2 preRed previousCost previousFP r ratio s sPar sum sum2 tmp xK xNorm xk ypk int countdown i j k pj pk rank solvedCols  	projects/Math68/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	533	533	2	replace	
56	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] sum2 += s * s; } parl = fp / (delta * sum2); }  sum2 = 0; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; double sum = 0; [BUGGY] [BUGGY] for (int i = 0; i <= j; ++i) { sum += jacobian[i][pj] * qy[i]; } sum /= diag[pj]; sum2 += sum * sum; } double gNorm = Math.sqrt(sum2); double paru = gNorm / delta; if (paru == 0) {  paru = 2.2251e-308 / Math.min(delta, 0.1); [CLASS] LevenbergMarquardtOptimizer [METHOD] determineLMParameter [RETURN_TYPE] void  double[] qy double delta double[] diag double[] work1 double[] work2 double[] work3 [VARIABLES] int[] permutation boolean double[] beta diag diagR jacNorm lmDir oldRes oldX qy tmpVec work1 work2 work3 double actRed coeff1 coeff2 correction costRelativeTolerance delta dirDer dirJ dk dxNorm fp gNorm initialStepBoundFactor lmNorm lmPar maxCosine orthoTolerance parRelativeTolerance parl paru pc2 preRed previousCost previousFP r ratio s sPar sum sum2 tmp xK xNorm xk ypk int countdown i j k pj pk rank solvedCols  	projects/Math68/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	533	533	2	add	
57	[BUG] [BUGGY] sum += jacobian[i][pj] * qy[i]; [FE] AssertionFailedError [CONTEXT] } parl = fp / (delta * sum2); }  sum2 = 0; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; double sum = 0; for (int i = 0; i <= j; ++i) { [BUGGY] sum += jacobian[i][pj] * qy[i]; [BUGGY] } sum /= diag[pj]; sum2 += sum * sum; } double gNorm = Math.sqrt(sum2); double paru = gNorm / delta; if (paru == 0) {  paru = 2.2251e-308 / Math.min(delta, 0.1); } [CLASS] LevenbergMarquardtOptimizer [METHOD] determineLMParameter [RETURN_TYPE] void  double[] qy double delta double[] diag double[] work1 double[] work2 double[] work3 [VARIABLES] int[] permutation boolean double[] beta diag diagR jacNorm lmDir oldRes oldX qy tmpVec work1 work2 work3 double actRed coeff1 coeff2 correction costRelativeTolerance delta dirDer dirJ dk dxNorm fp gNorm initialStepBoundFactor lmNorm lmPar maxCosine orthoTolerance parRelativeTolerance parl paru pc2 preRed previousCost previousFP r ratio s sPar sum sum2 tmp xK xNorm xk ypk int countdown i j k pj pk rank solvedCols  	projects/Math68/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	534	534	2	replace	
58	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] } parl = fp / (delta * sum2); }  sum2 = 0; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; double sum = 0; for (int i = 0; i <= j; ++i) { [BUGGY] [BUGGY] sum += jacobian[i][pj] * qy[i]; } sum /= diag[pj]; sum2 += sum * sum; } double gNorm = Math.sqrt(sum2); double paru = gNorm / delta; if (paru == 0) {  paru = 2.2251e-308 / Math.min(delta, 0.1); } [CLASS] LevenbergMarquardtOptimizer [METHOD] determineLMParameter [RETURN_TYPE] void  double[] qy double delta double[] diag double[] work1 double[] work2 double[] work3 [VARIABLES] int[] permutation boolean double[] beta diag diagR jacNorm lmDir oldRes oldX qy tmpVec work1 work2 work3 double actRed coeff1 coeff2 correction costRelativeTolerance delta dirDer dirJ dk dxNorm fp gNorm initialStepBoundFactor lmNorm lmPar maxCosine orthoTolerance parRelativeTolerance parl paru pc2 preRed previousCost previousFP r ratio s sPar sum sum2 tmp xK xNorm xk ypk int countdown i j k pj pk rank solvedCols  	projects/Math68/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	534	534	2	add	
59	[BUG] [BUGGY] sum /= diag[pj]; [FE] AssertionFailedError [CONTEXT] }  sum2 = 0; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; double sum = 0; for (int i = 0; i <= j; ++i) { sum += jacobian[i][pj] * qy[i]; } [BUGGY] sum /= diag[pj]; [BUGGY] sum2 += sum * sum; } double gNorm = Math.sqrt(sum2); double paru = gNorm / delta; if (paru == 0) {  paru = 2.2251e-308 / Math.min(delta, 0.1); }   [CLASS] LevenbergMarquardtOptimizer [METHOD] determineLMParameter [RETURN_TYPE] void  double[] qy double delta double[] diag double[] work1 double[] work2 double[] work3 [VARIABLES] int[] permutation boolean double[] beta diag diagR jacNorm lmDir oldRes oldX qy tmpVec work1 work2 work3 double actRed coeff1 coeff2 correction costRelativeTolerance delta dirDer dirJ dk dxNorm fp gNorm initialStepBoundFactor lmNorm lmPar maxCosine orthoTolerance parRelativeTolerance parl paru pc2 preRed previousCost previousFP r ratio s sPar sum sum2 tmp xK xNorm xk ypk int countdown i j k pj pk rank solvedCols  	projects/Math68/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	536	536	2	replace	
60	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] }  sum2 = 0; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; double sum = 0; for (int i = 0; i <= j; ++i) { sum += jacobian[i][pj] * qy[i]; } [BUGGY] [BUGGY] sum /= diag[pj]; sum2 += sum * sum; } double gNorm = Math.sqrt(sum2); double paru = gNorm / delta; if (paru == 0) {  paru = 2.2251e-308 / Math.min(delta, 0.1); }   [CLASS] LevenbergMarquardtOptimizer [METHOD] determineLMParameter [RETURN_TYPE] void  double[] qy double delta double[] diag double[] work1 double[] work2 double[] work3 [VARIABLES] int[] permutation boolean double[] beta diag diagR jacNorm lmDir oldRes oldX qy tmpVec work1 work2 work3 double actRed coeff1 coeff2 correction costRelativeTolerance delta dirDer dirJ dk dxNorm fp gNorm initialStepBoundFactor lmNorm lmPar maxCosine orthoTolerance parRelativeTolerance parl paru pc2 preRed previousCost previousFP r ratio s sPar sum sum2 tmp xK xNorm xk ypk int countdown i j k pj pk rank solvedCols  	projects/Math68/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	536	536	2	add	
61	[BUG] [BUGGY] sum2 += sum * sum; [FE] AssertionFailedError [CONTEXT]  sum2 = 0; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; double sum = 0; for (int i = 0; i <= j; ++i) { sum += jacobian[i][pj] * qy[i]; } sum /= diag[pj]; [BUGGY] sum2 += sum * sum; [BUGGY] } double gNorm = Math.sqrt(sum2); double paru = gNorm / delta; if (paru == 0) {  paru = 2.2251e-308 / Math.min(delta, 0.1); }    [CLASS] LevenbergMarquardtOptimizer [METHOD] determineLMParameter [RETURN_TYPE] void  double[] qy double delta double[] diag double[] work1 double[] work2 double[] work3 [VARIABLES] int[] permutation boolean double[] beta diag diagR jacNorm lmDir oldRes oldX qy tmpVec work1 work2 work3 double actRed coeff1 coeff2 correction costRelativeTolerance delta dirDer dirJ dk dxNorm fp gNorm initialStepBoundFactor lmNorm lmPar maxCosine orthoTolerance parRelativeTolerance parl paru pc2 preRed previousCost previousFP r ratio s sPar sum sum2 tmp xK xNorm xk ypk int countdown i j k pj pk rank solvedCols  	projects/Math68/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	537	537	2	replace	
62	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT]  sum2 = 0; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; double sum = 0; for (int i = 0; i <= j; ++i) { sum += jacobian[i][pj] * qy[i]; } sum /= diag[pj]; [BUGGY] [BUGGY] sum2 += sum * sum; } double gNorm = Math.sqrt(sum2); double paru = gNorm / delta; if (paru == 0) {  paru = 2.2251e-308 / Math.min(delta, 0.1); }    [CLASS] LevenbergMarquardtOptimizer [METHOD] determineLMParameter [RETURN_TYPE] void  double[] qy double delta double[] diag double[] work1 double[] work2 double[] work3 [VARIABLES] int[] permutation boolean double[] beta diag diagR jacNorm lmDir oldRes oldX qy tmpVec work1 work2 work3 double actRed coeff1 coeff2 correction costRelativeTolerance delta dirDer dirJ dk dxNorm fp gNorm initialStepBoundFactor lmNorm lmPar maxCosine orthoTolerance parRelativeTolerance parl paru pc2 preRed previousCost previousFP r ratio s sPar sum sum2 tmp xK xNorm xk ypk int countdown i j k pj pk rank solvedCols  	projects/Math68/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	537	537	2	add	
63	[BUG] [BUGGY] double gNorm = Math.sqrt(sum2); [FE] AssertionFailedError [CONTEXT] sum2 = 0; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; double sum = 0; for (int i = 0; i <= j; ++i) { sum += jacobian[i][pj] * qy[i]; } sum /= diag[pj]; sum2 += sum * sum; } [BUGGY] double gNorm = Math.sqrt(sum2); [BUGGY] double paru = gNorm / delta; if (paru == 0) {  paru = 2.2251e-308 / Math.min(delta, 0.1); }   lmPar = Math.min(paru, Math.max(lmPar, parl)); if (lmPar == 0) { [CLASS] LevenbergMarquardtOptimizer [METHOD] determineLMParameter [RETURN_TYPE] void  double[] qy double delta double[] diag double[] work1 double[] work2 double[] work3 [VARIABLES] int[] permutation boolean double[] beta diag diagR jacNorm lmDir oldRes oldX qy tmpVec work1 work2 work3 double actRed coeff1 coeff2 correction costRelativeTolerance delta dirDer dirJ dk dxNorm fp gNorm initialStepBoundFactor lmNorm lmPar maxCosine orthoTolerance parRelativeTolerance parl paru pc2 preRed previousCost previousFP r ratio s sPar sum sum2 tmp xK xNorm xk ypk int countdown i j k pj pk rank solvedCols  	projects/Math68/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	539	539	2	replace	
64	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] sum2 = 0; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; double sum = 0; for (int i = 0; i <= j; ++i) { sum += jacobian[i][pj] * qy[i]; } sum /= diag[pj]; sum2 += sum * sum; } [BUGGY] [BUGGY] double gNorm = Math.sqrt(sum2); double paru = gNorm / delta; if (paru == 0) {  paru = 2.2251e-308 / Math.min(delta, 0.1); }   lmPar = Math.min(paru, Math.max(lmPar, parl)); if (lmPar == 0) { [CLASS] LevenbergMarquardtOptimizer [METHOD] determineLMParameter [RETURN_TYPE] void  double[] qy double delta double[] diag double[] work1 double[] work2 double[] work3 [VARIABLES] int[] permutation boolean double[] beta diag diagR jacNorm lmDir oldRes oldX qy tmpVec work1 work2 work3 double actRed coeff1 coeff2 correction costRelativeTolerance delta dirDer dirJ dk dxNorm fp gNorm initialStepBoundFactor lmNorm lmPar maxCosine orthoTolerance parRelativeTolerance parl paru pc2 preRed previousCost previousFP r ratio s sPar sum sum2 tmp xK xNorm xk ypk int countdown i j k pj pk rank solvedCols  	projects/Math68/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	539	539	2	add	
65	[BUG] [BUGGY] double paru = gNorm / delta; [FE] AssertionFailedError [CONTEXT] for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; double sum = 0; for (int i = 0; i <= j; ++i) { sum += jacobian[i][pj] * qy[i]; } sum /= diag[pj]; sum2 += sum * sum; } double gNorm = Math.sqrt(sum2); [BUGGY] double paru = gNorm / delta; [BUGGY] if (paru == 0) {  paru = 2.2251e-308 / Math.min(delta, 0.1); }   lmPar = Math.min(paru, Math.max(lmPar, parl)); if (lmPar == 0) { lmPar = gNorm / dxNorm; [CLASS] LevenbergMarquardtOptimizer [METHOD] determineLMParameter [RETURN_TYPE] void  double[] qy double delta double[] diag double[] work1 double[] work2 double[] work3 [VARIABLES] int[] permutation boolean double[] beta diag diagR jacNorm lmDir oldRes oldX qy tmpVec work1 work2 work3 double actRed coeff1 coeff2 correction costRelativeTolerance delta dirDer dirJ dk dxNorm fp gNorm initialStepBoundFactor lmNorm lmPar maxCosine orthoTolerance parRelativeTolerance parl paru pc2 preRed previousCost previousFP r ratio s sPar sum sum2 tmp xK xNorm xk ypk int countdown i j k pj pk rank solvedCols  	projects/Math68/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	540	540	2	replace	
66	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; double sum = 0; for (int i = 0; i <= j; ++i) { sum += jacobian[i][pj] * qy[i]; } sum /= diag[pj]; sum2 += sum * sum; } double gNorm = Math.sqrt(sum2); [BUGGY] [BUGGY] double paru = gNorm / delta; if (paru == 0) {  paru = 2.2251e-308 / Math.min(delta, 0.1); }   lmPar = Math.min(paru, Math.max(lmPar, parl)); if (lmPar == 0) { lmPar = gNorm / dxNorm; [CLASS] LevenbergMarquardtOptimizer [METHOD] determineLMParameter [RETURN_TYPE] void  double[] qy double delta double[] diag double[] work1 double[] work2 double[] work3 [VARIABLES] int[] permutation boolean double[] beta diag diagR jacNorm lmDir oldRes oldX qy tmpVec work1 work2 work3 double actRed coeff1 coeff2 correction costRelativeTolerance delta dirDer dirJ dk dxNorm fp gNorm initialStepBoundFactor lmNorm lmPar maxCosine orthoTolerance parRelativeTolerance parl paru pc2 preRed previousCost previousFP r ratio s sPar sum sum2 tmp xK xNorm xk ypk int countdown i j k pj pk rank solvedCols  	projects/Math68/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	540	540	2	add	
67	[BUG] [BUGGY] if (paru == 0) { [FE] AssertionFailedError [CONTEXT] int pj = permutation[j]; double sum = 0; for (int i = 0; i <= j; ++i) { sum += jacobian[i][pj] * qy[i]; } sum /= diag[pj]; sum2 += sum * sum; } double gNorm = Math.sqrt(sum2); double paru = gNorm / delta; [BUGGY] if (paru == 0) { [BUGGY]  paru = 2.2251e-308 / Math.min(delta, 0.1); }   lmPar = Math.min(paru, Math.max(lmPar, parl)); if (lmPar == 0) { lmPar = gNorm / dxNorm; } [CLASS] LevenbergMarquardtOptimizer [METHOD] determineLMParameter [RETURN_TYPE] void  double[] qy double delta double[] diag double[] work1 double[] work2 double[] work3 [VARIABLES] int[] permutation boolean double[] beta diag diagR jacNorm lmDir oldRes oldX qy tmpVec work1 work2 work3 double actRed coeff1 coeff2 correction costRelativeTolerance delta dirDer dirJ dk dxNorm fp gNorm initialStepBoundFactor lmNorm lmPar maxCosine orthoTolerance parRelativeTolerance parl paru pc2 preRed previousCost previousFP r ratio s sPar sum sum2 tmp xK xNorm xk ypk int countdown i j k pj pk rank solvedCols  	projects/Math68/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	541	541	2	replace	
68	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] int pj = permutation[j]; double sum = 0; for (int i = 0; i <= j; ++i) { sum += jacobian[i][pj] * qy[i]; } sum /= diag[pj]; sum2 += sum * sum; } double gNorm = Math.sqrt(sum2); double paru = gNorm / delta; [BUGGY] [BUGGY] if (paru == 0) {  paru = 2.2251e-308 / Math.min(delta, 0.1); }   lmPar = Math.min(paru, Math.max(lmPar, parl)); if (lmPar == 0) { lmPar = gNorm / dxNorm; } [CLASS] LevenbergMarquardtOptimizer [METHOD] determineLMParameter [RETURN_TYPE] void  double[] qy double delta double[] diag double[] work1 double[] work2 double[] work3 [VARIABLES] int[] permutation boolean double[] beta diag diagR jacNorm lmDir oldRes oldX qy tmpVec work1 work2 work3 double actRed coeff1 coeff2 correction costRelativeTolerance delta dirDer dirJ dk dxNorm fp gNorm initialStepBoundFactor lmNorm lmPar maxCosine orthoTolerance parRelativeTolerance parl paru pc2 preRed previousCost previousFP r ratio s sPar sum sum2 tmp xK xNorm xk ypk int countdown i j k pj pk rank solvedCols  	projects/Math68/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	541	541	2	add	
69	[BUG] [BUGGY] lmPar = Math.min(paru, Math.max(lmPar, parl)); [FE] AssertionFailedError [CONTEXT] } double gNorm = Math.sqrt(sum2); double paru = gNorm / delta; if (paru == 0) {  paru = 2.2251e-308 / Math.min(delta, 0.1); }   [BUGGY] lmPar = Math.min(paru, Math.max(lmPar, parl)); [BUGGY] if (lmPar == 0) { lmPar = gNorm / dxNorm; } for (int countdown = 10; countdown >= 0; --countdown) {  if (lmPar == 0) { lmPar = Math.max(2.2251e-308, 0.001 * paru); } [CLASS] LevenbergMarquardtOptimizer [METHOD] determineLMParameter [RETURN_TYPE] void  double[] qy double delta double[] diag double[] work1 double[] work2 double[] work3 [VARIABLES] int[] permutation boolean double[] beta diag diagR jacNorm lmDir oldRes oldX qy tmpVec work1 work2 work3 double actRed coeff1 coeff2 correction costRelativeTolerance delta dirDer dirJ dk dxNorm fp gNorm initialStepBoundFactor lmNorm lmPar maxCosine orthoTolerance parRelativeTolerance parl paru pc2 preRed previousCost previousFP r ratio s sPar sum sum2 tmp xK xNorm xk ypk int countdown i j k pj pk rank solvedCols  	projects/Math68/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	548	548	2	replace	
70	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] } double gNorm = Math.sqrt(sum2); double paru = gNorm / delta; if (paru == 0) {  paru = 2.2251e-308 / Math.min(delta, 0.1); }   [BUGGY] [BUGGY] lmPar = Math.min(paru, Math.max(lmPar, parl)); if (lmPar == 0) { lmPar = gNorm / dxNorm; } for (int countdown = 10; countdown >= 0; --countdown) {  if (lmPar == 0) { lmPar = Math.max(2.2251e-308, 0.001 * paru); } [CLASS] LevenbergMarquardtOptimizer [METHOD] determineLMParameter [RETURN_TYPE] void  double[] qy double delta double[] diag double[] work1 double[] work2 double[] work3 [VARIABLES] int[] permutation boolean double[] beta diag diagR jacNorm lmDir oldRes oldX qy tmpVec work1 work2 work3 double actRed coeff1 coeff2 correction costRelativeTolerance delta dirDer dirJ dk dxNorm fp gNorm initialStepBoundFactor lmNorm lmPar maxCosine orthoTolerance parRelativeTolerance parl paru pc2 preRed previousCost previousFP r ratio s sPar sum sum2 tmp xK xNorm xk ypk int countdown i j k pj pk rank solvedCols  	projects/Math68/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	548	548	2	add	
71	[BUG] [BUGGY] if (lmPar == 0) { [FE] AssertionFailedError [CONTEXT] double gNorm = Math.sqrt(sum2); double paru = gNorm / delta; if (paru == 0) {  paru = 2.2251e-308 / Math.min(delta, 0.1); }   lmPar = Math.min(paru, Math.max(lmPar, parl)); [BUGGY] if (lmPar == 0) { [BUGGY] lmPar = gNorm / dxNorm; } for (int countdown = 10; countdown >= 0; --countdown) {  if (lmPar == 0) { lmPar = Math.max(2.2251e-308, 0.001 * paru); } double sPar = Math.sqrt(lmPar); [CLASS] LevenbergMarquardtOptimizer [METHOD] determineLMParameter [RETURN_TYPE] void  double[] qy double delta double[] diag double[] work1 double[] work2 double[] work3 [VARIABLES] int[] permutation boolean double[] beta diag diagR jacNorm lmDir oldRes oldX qy tmpVec work1 work2 work3 double actRed coeff1 coeff2 correction costRelativeTolerance delta dirDer dirJ dk dxNorm fp gNorm initialStepBoundFactor lmNorm lmPar maxCosine orthoTolerance parRelativeTolerance parl paru pc2 preRed previousCost previousFP r ratio s sPar sum sum2 tmp xK xNorm xk ypk int countdown i j k pj pk rank solvedCols  	projects/Math68/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	
72	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] double gNorm = Math.sqrt(sum2); double paru = gNorm / delta; if (paru == 0) {  paru = 2.2251e-308 / Math.min(delta, 0.1); }   lmPar = Math.min(paru, Math.max(lmPar, parl)); [BUGGY] [BUGGY] if (lmPar == 0) { lmPar = gNorm / dxNorm; } for (int countdown = 10; countdown >= 0; --countdown) {  if (lmPar == 0) { lmPar = Math.max(2.2251e-308, 0.001 * paru); } double sPar = Math.sqrt(lmPar); [CLASS] LevenbergMarquardtOptimizer [METHOD] determineLMParameter [RETURN_TYPE] void  double[] qy double delta double[] diag double[] work1 double[] work2 double[] work3 [VARIABLES] int[] permutation boolean double[] beta diag diagR jacNorm lmDir oldRes oldX qy tmpVec work1 work2 work3 double actRed coeff1 coeff2 correction costRelativeTolerance delta dirDer dirJ dk dxNorm fp gNorm initialStepBoundFactor lmNorm lmPar maxCosine orthoTolerance parRelativeTolerance parl paru pc2 preRed previousCost previousFP r ratio s sPar sum sum2 tmp xK xNorm xk ypk int countdown i j k pj pk rank solvedCols  	projects/Math68/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	add	
73	[BUG] [BUGGY] for (int countdown = 10; countdown >= 0; --countdown) { [FE] AssertionFailedError [CONTEXT] paru = 2.2251e-308 / Math.min(delta, 0.1); }   lmPar = Math.min(paru, Math.max(lmPar, parl)); if (lmPar == 0) { lmPar = gNorm / dxNorm; } [BUGGY] for (int countdown = 10; countdown >= 0; --countdown) { [BUGGY]   if (lmPar == 0) { lmPar = Math.max(2.2251e-308, 0.001 * paru); } double sPar = Math.sqrt(lmPar); for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; work1[pj] = sPar * diag[pj]; } [CLASS] LevenbergMarquardtOptimizer [METHOD] determineLMParameter [RETURN_TYPE] void  double[] qy double delta double[] diag double[] work1 double[] work2 double[] work3 [VARIABLES] int[] permutation boolean double[] beta diag diagR jacNorm lmDir oldRes oldX qy tmpVec work1 work2 work3 double actRed coeff1 coeff2 correction costRelativeTolerance delta dirDer dirJ dk dxNorm fp gNorm initialStepBoundFactor lmNorm lmPar maxCosine orthoTolerance parRelativeTolerance parl paru pc2 preRed previousCost previousFP r ratio s sPar sum sum2 tmp xK xNorm xk ypk int countdown i j k pj pk rank solvedCols  	projects/Math68/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	553	553	2	replace	
74	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] paru = 2.2251e-308 / Math.min(delta, 0.1); }   lmPar = Math.min(paru, Math.max(lmPar, parl)); if (lmPar == 0) { lmPar = gNorm / dxNorm; } [BUGGY] [BUGGY] for (int countdown = 10; countdown >= 0; --countdown) {  if (lmPar == 0) { lmPar = Math.max(2.2251e-308, 0.001 * paru); } double sPar = Math.sqrt(lmPar); for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; work1[pj] = sPar * diag[pj]; } [CLASS] LevenbergMarquardtOptimizer [METHOD] determineLMParameter [RETURN_TYPE] void  double[] qy double delta double[] diag double[] work1 double[] work2 double[] work3 [VARIABLES] int[] permutation boolean double[] beta diag diagR jacNorm lmDir oldRes oldX qy tmpVec work1 work2 work3 double actRed coeff1 coeff2 correction costRelativeTolerance delta dirDer dirJ dk dxNorm fp gNorm initialStepBoundFactor lmNorm lmPar maxCosine orthoTolerance parRelativeTolerance parl paru pc2 preRed previousCost previousFP r ratio s sPar sum sum2 tmp xK xNorm xk ypk int countdown i j k pj pk rank solvedCols  	projects/Math68/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	553	553	2	add	
75	[BUG] [BUGGY] if (lmPar == 0) { [FE] AssertionFailedError [CONTEXT]   lmPar = Math.min(paru, Math.max(lmPar, parl)); if (lmPar == 0) { lmPar = gNorm / dxNorm; } for (int countdown = 10; countdown >= 0; --countdown) {  [BUGGY] if (lmPar == 0) { [BUGGY] lmPar = Math.max(2.2251e-308, 0.001 * paru); } double sPar = Math.sqrt(lmPar); for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; work1[pj] = sPar * diag[pj]; } determineLMDirection(qy, work1, work2, work3); dxNorm = 0; [CLASS] LevenbergMarquardtOptimizer [METHOD] determineLMParameter [RETURN_TYPE] void  double[] qy double delta double[] diag double[] work1 double[] work2 double[] work3 [VARIABLES] int[] permutation boolean double[] beta diag diagR jacNorm lmDir oldRes oldX qy tmpVec work1 work2 work3 double actRed coeff1 coeff2 correction costRelativeTolerance delta dirDer dirJ dk dxNorm fp gNorm initialStepBoundFactor lmNorm lmPar maxCosine orthoTolerance parRelativeTolerance parl paru pc2 preRed previousCost previousFP r ratio s sPar sum sum2 tmp xK xNorm xk ypk int countdown i j k pj pk rank solvedCols  	projects/Math68/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	
76	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT]   lmPar = Math.min(paru, Math.max(lmPar, parl)); if (lmPar == 0) { lmPar = gNorm / dxNorm; } for (int countdown = 10; countdown >= 0; --countdown) {  [BUGGY] [BUGGY] if (lmPar == 0) { lmPar = Math.max(2.2251e-308, 0.001 * paru); } double sPar = Math.sqrt(lmPar); for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; work1[pj] = sPar * diag[pj]; } determineLMDirection(qy, work1, work2, work3); dxNorm = 0; [CLASS] LevenbergMarquardtOptimizer [METHOD] determineLMParameter [RETURN_TYPE] void  double[] qy double delta double[] diag double[] work1 double[] work2 double[] work3 [VARIABLES] int[] permutation boolean double[] beta diag diagR jacNorm lmDir oldRes oldX qy tmpVec work1 work2 work3 double actRed coeff1 coeff2 correction costRelativeTolerance delta dirDer dirJ dk dxNorm fp gNorm initialStepBoundFactor lmNorm lmPar maxCosine orthoTolerance parRelativeTolerance parl paru pc2 preRed previousCost previousFP r ratio s sPar sum sum2 tmp xK xNorm xk ypk int countdown i j k pj pk rank solvedCols  	projects/Math68/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	add	
77	[BUG] [BUGGY] double sPar = Math.sqrt(lmPar); [FE] AssertionFailedError [CONTEXT] if (lmPar == 0) { lmPar = gNorm / dxNorm; } for (int countdown = 10; countdown >= 0; --countdown) {  if (lmPar == 0) { lmPar = Math.max(2.2251e-308, 0.001 * paru); } [BUGGY] double sPar = Math.sqrt(lmPar); [BUGGY] for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; work1[pj] = sPar * diag[pj]; } determineLMDirection(qy, work1, work2, work3); dxNorm = 0; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; double s = diag[pj] * lmDir[pj]; [CLASS] LevenbergMarquardtOptimizer [METHOD] determineLMParameter [RETURN_TYPE] void  double[] qy double delta double[] diag double[] work1 double[] work2 double[] work3 [VARIABLES] int[] permutation boolean double[] beta diag diagR jacNorm lmDir oldRes oldX qy tmpVec work1 work2 work3 double actRed coeff1 coeff2 correction costRelativeTolerance delta dirDer dirJ dk dxNorm fp gNorm initialStepBoundFactor lmNorm lmPar maxCosine orthoTolerance parRelativeTolerance parl paru pc2 preRed previousCost previousFP r ratio s sPar sum sum2 tmp xK xNorm xk ypk int countdown i j k pj pk rank solvedCols  	projects/Math68/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	559	559	2	replace	
78	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] if (lmPar == 0) { lmPar = gNorm / dxNorm; } for (int countdown = 10; countdown >= 0; --countdown) {  if (lmPar == 0) { lmPar = Math.max(2.2251e-308, 0.001 * paru); } [BUGGY] [BUGGY] double sPar = Math.sqrt(lmPar); for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; work1[pj] = sPar * diag[pj]; } determineLMDirection(qy, work1, work2, work3); dxNorm = 0; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; double s = diag[pj] * lmDir[pj]; [CLASS] LevenbergMarquardtOptimizer [METHOD] determineLMParameter [RETURN_TYPE] void  double[] qy double delta double[] diag double[] work1 double[] work2 double[] work3 [VARIABLES] int[] permutation boolean double[] beta diag diagR jacNorm lmDir oldRes oldX qy tmpVec work1 work2 work3 double actRed coeff1 coeff2 correction costRelativeTolerance delta dirDer dirJ dk dxNorm fp gNorm initialStepBoundFactor lmNorm lmPar maxCosine orthoTolerance parRelativeTolerance parl paru pc2 preRed previousCost previousFP r ratio s sPar sum sum2 tmp xK xNorm xk ypk int countdown i j k pj pk rank solvedCols  	projects/Math68/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	559	559	2	add	
79	[BUG] [BUGGY] for (int j = 0; j < solvedCols; ++j) { [FE] AssertionFailedError [CONTEXT] lmPar = gNorm / dxNorm; } for (int countdown = 10; countdown >= 0; --countdown) {  if (lmPar == 0) { lmPar = Math.max(2.2251e-308, 0.001 * paru); } double sPar = Math.sqrt(lmPar); [BUGGY] for (int j = 0; j < solvedCols; ++j) { [BUGGY] int pj = permutation[j]; work1[pj] = sPar * diag[pj]; } determineLMDirection(qy, work1, work2, work3); dxNorm = 0; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; double s = diag[pj] * lmDir[pj]; work3[pj] = s; [CLASS] LevenbergMarquardtOptimizer [METHOD] determineLMParameter [RETURN_TYPE] void  double[] qy double delta double[] diag double[] work1 double[] work2 double[] work3 [VARIABLES] int[] permutation boolean double[] beta diag diagR jacNorm lmDir oldRes oldX qy tmpVec work1 work2 work3 double actRed coeff1 coeff2 correction costRelativeTolerance delta dirDer dirJ dk dxNorm fp gNorm initialStepBoundFactor lmNorm lmPar maxCosine orthoTolerance parRelativeTolerance parl paru pc2 preRed previousCost previousFP r ratio s sPar sum sum2 tmp xK xNorm xk ypk int countdown i j k pj pk rank solvedCols  	projects/Math68/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	560	560	2	replace	
80	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] lmPar = gNorm / dxNorm; } for (int countdown = 10; countdown >= 0; --countdown) {  if (lmPar == 0) { lmPar = Math.max(2.2251e-308, 0.001 * paru); } double sPar = Math.sqrt(lmPar); [BUGGY] [BUGGY] for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; work1[pj] = sPar * diag[pj]; } determineLMDirection(qy, work1, work2, work3); dxNorm = 0; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; double s = diag[pj] * lmDir[pj]; work3[pj] = s; [CLASS] LevenbergMarquardtOptimizer [METHOD] determineLMParameter [RETURN_TYPE] void  double[] qy double delta double[] diag double[] work1 double[] work2 double[] work3 [VARIABLES] int[] permutation boolean double[] beta diag diagR jacNorm lmDir oldRes oldX qy tmpVec work1 work2 work3 double actRed coeff1 coeff2 correction costRelativeTolerance delta dirDer dirJ dk dxNorm fp gNorm initialStepBoundFactor lmNorm lmPar maxCosine orthoTolerance parRelativeTolerance parl paru pc2 preRed previousCost previousFP r ratio s sPar sum sum2 tmp xK xNorm xk ypk int countdown i j k pj pk rank solvedCols  	projects/Math68/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	560	560	2	add	
81	[BUG] [BUGGY] int pj = permutation[j]; [FE] AssertionFailedError [CONTEXT] } for (int countdown = 10; countdown >= 0; --countdown) {  if (lmPar == 0) { lmPar = Math.max(2.2251e-308, 0.001 * paru); } double sPar = Math.sqrt(lmPar); for (int j = 0; j < solvedCols; ++j) { [BUGGY] int pj = permutation[j]; [BUGGY] work1[pj] = sPar * diag[pj]; } determineLMDirection(qy, work1, work2, work3); dxNorm = 0; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; double s = diag[pj] * lmDir[pj]; work3[pj] = s; dxNorm += s * s; [CLASS] LevenbergMarquardtOptimizer [METHOD] determineLMParameter [RETURN_TYPE] void  double[] qy double delta double[] diag double[] work1 double[] work2 double[] work3 [VARIABLES] int[] permutation boolean double[] beta diag diagR jacNorm lmDir oldRes oldX qy tmpVec work1 work2 work3 double actRed coeff1 coeff2 correction costRelativeTolerance delta dirDer dirJ dk dxNorm fp gNorm initialStepBoundFactor lmNorm lmPar maxCosine orthoTolerance parRelativeTolerance parl paru pc2 preRed previousCost previousFP r ratio s sPar sum sum2 tmp xK xNorm xk ypk int countdown i j k pj pk rank solvedCols  	projects/Math68/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	
82	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] } for (int countdown = 10; countdown >= 0; --countdown) {  if (lmPar == 0) { lmPar = Math.max(2.2251e-308, 0.001 * paru); } double sPar = Math.sqrt(lmPar); for (int j = 0; j < solvedCols; ++j) { [BUGGY] [BUGGY] int pj = permutation[j]; work1[pj] = sPar * diag[pj]; } determineLMDirection(qy, work1, work2, work3); dxNorm = 0; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; double s = diag[pj] * lmDir[pj]; work3[pj] = s; dxNorm += s * s; [CLASS] LevenbergMarquardtOptimizer [METHOD] determineLMParameter [RETURN_TYPE] void  double[] qy double delta double[] diag double[] work1 double[] work2 double[] work3 [VARIABLES] int[] permutation boolean double[] beta diag diagR jacNorm lmDir oldRes oldX qy tmpVec work1 work2 work3 double actRed coeff1 coeff2 correction costRelativeTolerance delta dirDer dirJ dk dxNorm fp gNorm initialStepBoundFactor lmNorm lmPar maxCosine orthoTolerance parRelativeTolerance parl paru pc2 preRed previousCost previousFP r ratio s sPar sum sum2 tmp xK xNorm xk ypk int countdown i j k pj pk rank solvedCols  	projects/Math68/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	add	
83	[BUG] [BUGGY] work1[pj] = sPar * diag[pj]; [FE] AssertionFailedError [CONTEXT] for (int countdown = 10; countdown >= 0; --countdown) {  if (lmPar == 0) { lmPar = Math.max(2.2251e-308, 0.001 * paru); } double sPar = Math.sqrt(lmPar); for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; [BUGGY] work1[pj] = sPar * diag[pj]; [BUGGY] } determineLMDirection(qy, work1, work2, work3); dxNorm = 0; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; double s = diag[pj] * lmDir[pj]; work3[pj] = s; dxNorm += s * s; } [CLASS] LevenbergMarquardtOptimizer [METHOD] determineLMParameter [RETURN_TYPE] void  double[] qy double delta double[] diag double[] work1 double[] work2 double[] work3 [VARIABLES] int[] permutation boolean double[] beta diag diagR jacNorm lmDir oldRes oldX qy tmpVec work1 work2 work3 double actRed coeff1 coeff2 correction costRelativeTolerance delta dirDer dirJ dk dxNorm fp gNorm initialStepBoundFactor lmNorm lmPar maxCosine orthoTolerance parRelativeTolerance parl paru pc2 preRed previousCost previousFP r ratio s sPar sum sum2 tmp xK xNorm xk ypk int countdown i j k pj pk rank solvedCols  	projects/Math68/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	562	562	2	replace	
84	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] for (int countdown = 10; countdown >= 0; --countdown) {  if (lmPar == 0) { lmPar = Math.max(2.2251e-308, 0.001 * paru); } double sPar = Math.sqrt(lmPar); for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; [BUGGY] [BUGGY] work1[pj] = sPar * diag[pj]; } determineLMDirection(qy, work1, work2, work3); dxNorm = 0; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; double s = diag[pj] * lmDir[pj]; work3[pj] = s; dxNorm += s * s; } [CLASS] LevenbergMarquardtOptimizer [METHOD] determineLMParameter [RETURN_TYPE] void  double[] qy double delta double[] diag double[] work1 double[] work2 double[] work3 [VARIABLES] int[] permutation boolean double[] beta diag diagR jacNorm lmDir oldRes oldX qy tmpVec work1 work2 work3 double actRed coeff1 coeff2 correction costRelativeTolerance delta dirDer dirJ dk dxNorm fp gNorm initialStepBoundFactor lmNorm lmPar maxCosine orthoTolerance parRelativeTolerance parl paru pc2 preRed previousCost previousFP r ratio s sPar sum sum2 tmp xK xNorm xk ypk int countdown i j k pj pk rank solvedCols  	projects/Math68/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	562	562	2	add	
85	[BUG] [BUGGY] determineLMDirection(qy, work1, work2, work3); [FE] AssertionFailedError [CONTEXT]  if (lmPar == 0) { lmPar = Math.max(2.2251e-308, 0.001 * paru); } double sPar = Math.sqrt(lmPar); for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; work1[pj] = sPar * diag[pj]; } [BUGGY] determineLMDirection(qy, work1, work2, work3); [BUGGY]  dxNorm = 0; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; double s = diag[pj] * lmDir[pj]; work3[pj] = s; dxNorm += s * s; } dxNorm = Math.sqrt(dxNorm); double previousFP = fp; [CLASS] LevenbergMarquardtOptimizer [METHOD] determineLMParameter [RETURN_TYPE] void  double[] qy double delta double[] diag double[] work1 double[] work2 double[] work3 [VARIABLES] int[] permutation boolean double[] beta diag diagR jacNorm lmDir oldRes oldX qy tmpVec work1 work2 work3 double actRed coeff1 coeff2 correction costRelativeTolerance delta dirDer dirJ dk dxNorm fp gNorm initialStepBoundFactor lmNorm lmPar maxCosine orthoTolerance parRelativeTolerance parl paru pc2 preRed previousCost previousFP r ratio s sPar sum sum2 tmp xK xNorm xk ypk int countdown i j k pj pk rank solvedCols  	projects/Math68/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	564	564	2	replace	
86	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT]  if (lmPar == 0) { lmPar = Math.max(2.2251e-308, 0.001 * paru); } double sPar = Math.sqrt(lmPar); for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; work1[pj] = sPar * diag[pj]; } [BUGGY] [BUGGY] determineLMDirection(qy, work1, work2, work3); dxNorm = 0; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; double s = diag[pj] * lmDir[pj]; work3[pj] = s; dxNorm += s * s; } dxNorm = Math.sqrt(dxNorm); double previousFP = fp; [CLASS] LevenbergMarquardtOptimizer [METHOD] determineLMParameter [RETURN_TYPE] void  double[] qy double delta double[] diag double[] work1 double[] work2 double[] work3 [VARIABLES] int[] permutation boolean double[] beta diag diagR jacNorm lmDir oldRes oldX qy tmpVec work1 work2 work3 double actRed coeff1 coeff2 correction costRelativeTolerance delta dirDer dirJ dk dxNorm fp gNorm initialStepBoundFactor lmNorm lmPar maxCosine orthoTolerance parRelativeTolerance parl paru pc2 preRed previousCost previousFP r ratio s sPar sum sum2 tmp xK xNorm xk ypk int countdown i j k pj pk rank solvedCols  	projects/Math68/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	564	564	2	add	
87	[BUG] [BUGGY] dxNorm = 0; [FE] AssertionFailedError [CONTEXT] if (lmPar == 0) { lmPar = Math.max(2.2251e-308, 0.001 * paru); } double sPar = Math.sqrt(lmPar); for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; work1[pj] = sPar * diag[pj]; } determineLMDirection(qy, work1, work2, work3); [BUGGY] dxNorm = 0; [BUGGY] for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; double s = diag[pj] * lmDir[pj]; work3[pj] = s; dxNorm += s * s; } dxNorm = Math.sqrt(dxNorm); double previousFP = fp; fp = dxNorm - delta;  [CLASS] LevenbergMarquardtOptimizer [METHOD] determineLMParameter [RETURN_TYPE] void  double[] qy double delta double[] diag double[] work1 double[] work2 double[] work3 [VARIABLES] int[] permutation boolean double[] beta diag diagR jacNorm lmDir oldRes oldX qy tmpVec work1 work2 work3 double actRed coeff1 coeff2 correction costRelativeTolerance delta dirDer dirJ dk dxNorm fp gNorm initialStepBoundFactor lmNorm lmPar maxCosine orthoTolerance parRelativeTolerance parl paru pc2 preRed previousCost previousFP r ratio s sPar sum sum2 tmp xK xNorm xk ypk int countdown i j k pj pk rank solvedCols  	projects/Math68/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	566	566	2	replace	
88	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] if (lmPar == 0) { lmPar = Math.max(2.2251e-308, 0.001 * paru); } double sPar = Math.sqrt(lmPar); for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; work1[pj] = sPar * diag[pj]; } determineLMDirection(qy, work1, work2, work3); [BUGGY] [BUGGY] dxNorm = 0; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; double s = diag[pj] * lmDir[pj]; work3[pj] = s; dxNorm += s * s; } dxNorm = Math.sqrt(dxNorm); double previousFP = fp; fp = dxNorm - delta;  [CLASS] LevenbergMarquardtOptimizer [METHOD] determineLMParameter [RETURN_TYPE] void  double[] qy double delta double[] diag double[] work1 double[] work2 double[] work3 [VARIABLES] int[] permutation boolean double[] beta diag diagR jacNorm lmDir oldRes oldX qy tmpVec work1 work2 work3 double actRed coeff1 coeff2 correction costRelativeTolerance delta dirDer dirJ dk dxNorm fp gNorm initialStepBoundFactor lmNorm lmPar maxCosine orthoTolerance parRelativeTolerance parl paru pc2 preRed previousCost previousFP r ratio s sPar sum sum2 tmp xK xNorm xk ypk int countdown i j k pj pk rank solvedCols  	projects/Math68/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	566	566	2	add	
89	[BUG] [BUGGY] for (int j = 0; j < solvedCols; ++j) { [FE] AssertionFailedError [CONTEXT] lmPar = Math.max(2.2251e-308, 0.001 * paru); } double sPar = Math.sqrt(lmPar); for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; work1[pj] = sPar * diag[pj]; } determineLMDirection(qy, work1, work2, work3); dxNorm = 0; [BUGGY] for (int j = 0; j < solvedCols; ++j) { [BUGGY] int pj = permutation[j]; double s = diag[pj] * lmDir[pj]; work3[pj] = s; dxNorm += s * s; } dxNorm = Math.sqrt(dxNorm); double previousFP = fp; fp = dxNorm - delta;   [CLASS] LevenbergMarquardtOptimizer [METHOD] determineLMParameter [RETURN_TYPE] void  double[] qy double delta double[] diag double[] work1 double[] work2 double[] work3 [VARIABLES] int[] permutation boolean double[] beta diag diagR jacNorm lmDir oldRes oldX qy tmpVec work1 work2 work3 double actRed coeff1 coeff2 correction costRelativeTolerance delta dirDer dirJ dk dxNorm fp gNorm initialStepBoundFactor lmNorm lmPar maxCosine orthoTolerance parRelativeTolerance parl paru pc2 preRed previousCost previousFP r ratio s sPar sum sum2 tmp xK xNorm xk ypk int countdown i j k pj pk rank solvedCols  	projects/Math68/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	567	567	2	replace	
90	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] lmPar = Math.max(2.2251e-308, 0.001 * paru); } double sPar = Math.sqrt(lmPar); for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; work1[pj] = sPar * diag[pj]; } determineLMDirection(qy, work1, work2, work3); dxNorm = 0; [BUGGY] [BUGGY] for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; double s = diag[pj] * lmDir[pj]; work3[pj] = s; dxNorm += s * s; } dxNorm = Math.sqrt(dxNorm); double previousFP = fp; fp = dxNorm - delta;   [CLASS] LevenbergMarquardtOptimizer [METHOD] determineLMParameter [RETURN_TYPE] void  double[] qy double delta double[] diag double[] work1 double[] work2 double[] work3 [VARIABLES] int[] permutation boolean double[] beta diag diagR jacNorm lmDir oldRes oldX qy tmpVec work1 work2 work3 double actRed coeff1 coeff2 correction costRelativeTolerance delta dirDer dirJ dk dxNorm fp gNorm initialStepBoundFactor lmNorm lmPar maxCosine orthoTolerance parRelativeTolerance parl paru pc2 preRed previousCost previousFP r ratio s sPar sum sum2 tmp xK xNorm xk ypk int countdown i j k pj pk rank solvedCols  	projects/Math68/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	567	567	2	add	
91	[BUG] [BUGGY] int pj = permutation[j]; [FE] AssertionFailedError [CONTEXT] } double sPar = Math.sqrt(lmPar); for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; work1[pj] = sPar * diag[pj]; } determineLMDirection(qy, work1, work2, work3); dxNorm = 0; for (int j = 0; j < solvedCols; ++j) { [BUGGY] int pj = permutation[j]; [BUGGY] double s = diag[pj] * lmDir[pj]; work3[pj] = s; dxNorm += s * s; } dxNorm = Math.sqrt(dxNorm); double previousFP = fp; fp = dxNorm - delta;    [CLASS] LevenbergMarquardtOptimizer [METHOD] determineLMParameter [RETURN_TYPE] void  double[] qy double delta double[] diag double[] work1 double[] work2 double[] work3 [VARIABLES] int[] permutation boolean double[] beta diag diagR jacNorm lmDir oldRes oldX qy tmpVec work1 work2 work3 double actRed coeff1 coeff2 correction costRelativeTolerance delta dirDer dirJ dk dxNorm fp gNorm initialStepBoundFactor lmNorm lmPar maxCosine orthoTolerance parRelativeTolerance parl paru pc2 preRed previousCost previousFP r ratio s sPar sum sum2 tmp xK xNorm xk ypk int countdown i j k pj pk rank solvedCols  	projects/Math68/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	568	568	2	replace	
92	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] } double sPar = Math.sqrt(lmPar); for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; work1[pj] = sPar * diag[pj]; } determineLMDirection(qy, work1, work2, work3); dxNorm = 0; for (int j = 0; j < solvedCols; ++j) { [BUGGY] [BUGGY] int pj = permutation[j]; double s = diag[pj] * lmDir[pj]; work3[pj] = s; dxNorm += s * s; } dxNorm = Math.sqrt(dxNorm); double previousFP = fp; fp = dxNorm - delta;    [CLASS] LevenbergMarquardtOptimizer [METHOD] determineLMParameter [RETURN_TYPE] void  double[] qy double delta double[] diag double[] work1 double[] work2 double[] work3 [VARIABLES] int[] permutation boolean double[] beta diag diagR jacNorm lmDir oldRes oldX qy tmpVec work1 work2 work3 double actRed coeff1 coeff2 correction costRelativeTolerance delta dirDer dirJ dk dxNorm fp gNorm initialStepBoundFactor lmNorm lmPar maxCosine orthoTolerance parRelativeTolerance parl paru pc2 preRed previousCost previousFP r ratio s sPar sum sum2 tmp xK xNorm xk ypk int countdown i j k pj pk rank solvedCols  	projects/Math68/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	568	568	2	add	
93	[BUG] [BUGGY] double s = diag[pj] * lmDir[pj]; [FE] AssertionFailedError [CONTEXT] double sPar = Math.sqrt(lmPar); for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; work1[pj] = sPar * diag[pj]; } determineLMDirection(qy, work1, work2, work3); dxNorm = 0; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; [BUGGY] double s = diag[pj] * lmDir[pj]; [BUGGY] work3[pj] = s; dxNorm += s * s; } dxNorm = Math.sqrt(dxNorm); double previousFP = fp; fp = dxNorm - delta;   if ((Math.abs(fp) <= 0.1 * delta) || [CLASS] LevenbergMarquardtOptimizer [METHOD] determineLMParameter [RETURN_TYPE] void  double[] qy double delta double[] diag double[] work1 double[] work2 double[] work3 [VARIABLES] int[] permutation boolean double[] beta diag diagR jacNorm lmDir oldRes oldX qy tmpVec work1 work2 work3 double actRed coeff1 coeff2 correction costRelativeTolerance delta dirDer dirJ dk dxNorm fp gNorm initialStepBoundFactor lmNorm lmPar maxCosine orthoTolerance parRelativeTolerance parl paru pc2 preRed previousCost previousFP r ratio s sPar sum sum2 tmp xK xNorm xk ypk int countdown i j k pj pk rank solvedCols  	projects/Math68/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	replace	
94	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] double sPar = Math.sqrt(lmPar); for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; work1[pj] = sPar * diag[pj]; } determineLMDirection(qy, work1, work2, work3); dxNorm = 0; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; [BUGGY] [BUGGY] double s = diag[pj] * lmDir[pj]; work3[pj] = s; dxNorm += s * s; } dxNorm = Math.sqrt(dxNorm); double previousFP = fp; fp = dxNorm - delta;   if ((Math.abs(fp) <= 0.1 * delta) || [CLASS] LevenbergMarquardtOptimizer [METHOD] determineLMParameter [RETURN_TYPE] void  double[] qy double delta double[] diag double[] work1 double[] work2 double[] work3 [VARIABLES] int[] permutation boolean double[] beta diag diagR jacNorm lmDir oldRes oldX qy tmpVec work1 work2 work3 double actRed coeff1 coeff2 correction costRelativeTolerance delta dirDer dirJ dk dxNorm fp gNorm initialStepBoundFactor lmNorm lmPar maxCosine orthoTolerance parRelativeTolerance parl paru pc2 preRed previousCost previousFP r ratio s sPar sum sum2 tmp xK xNorm xk ypk int countdown i j k pj pk rank solvedCols  	projects/Math68/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	569	569	2	add	
95	[BUG] [BUGGY] work3[pj] = s; [FE] AssertionFailedError [CONTEXT] for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; work1[pj] = sPar * diag[pj]; } determineLMDirection(qy, work1, work2, work3); dxNorm = 0; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; double s = diag[pj] * lmDir[pj]; [BUGGY] work3[pj] = s; [BUGGY] dxNorm += s * s; } dxNorm = Math.sqrt(dxNorm); double previousFP = fp; fp = dxNorm - delta;   if ((Math.abs(fp) <= 0.1 * delta) || ((parl == 0) && (fp <= previousFP) && (previousFP < 0))) { [CLASS] LevenbergMarquardtOptimizer [METHOD] determineLMParameter [RETURN_TYPE] void  double[] qy double delta double[] diag double[] work1 double[] work2 double[] work3 [VARIABLES] int[] permutation boolean double[] beta diag diagR jacNorm lmDir oldRes oldX qy tmpVec work1 work2 work3 double actRed coeff1 coeff2 correction costRelativeTolerance delta dirDer dirJ dk dxNorm fp gNorm initialStepBoundFactor lmNorm lmPar maxCosine orthoTolerance parRelativeTolerance parl paru pc2 preRed previousCost previousFP r ratio s sPar sum sum2 tmp xK xNorm xk ypk int countdown i j k pj pk rank solvedCols  	projects/Math68/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	570	570	2	replace	
96	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; work1[pj] = sPar * diag[pj]; } determineLMDirection(qy, work1, work2, work3); dxNorm = 0; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; double s = diag[pj] * lmDir[pj]; [BUGGY] [BUGGY] work3[pj] = s; dxNorm += s * s; } dxNorm = Math.sqrt(dxNorm); double previousFP = fp; fp = dxNorm - delta;   if ((Math.abs(fp) <= 0.1 * delta) || ((parl == 0) && (fp <= previousFP) && (previousFP < 0))) { [CLASS] LevenbergMarquardtOptimizer [METHOD] determineLMParameter [RETURN_TYPE] void  double[] qy double delta double[] diag double[] work1 double[] work2 double[] work3 [VARIABLES] int[] permutation boolean double[] beta diag diagR jacNorm lmDir oldRes oldX qy tmpVec work1 work2 work3 double actRed coeff1 coeff2 correction costRelativeTolerance delta dirDer dirJ dk dxNorm fp gNorm initialStepBoundFactor lmNorm lmPar maxCosine orthoTolerance parRelativeTolerance parl paru pc2 preRed previousCost previousFP r ratio s sPar sum sum2 tmp xK xNorm xk ypk int countdown i j k pj pk rank solvedCols  	projects/Math68/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	570	570	2	add	
97	[BUG] [BUGGY] dxNorm += s * s; [FE] AssertionFailedError [CONTEXT] int pj = permutation[j]; work1[pj] = sPar * diag[pj]; } determineLMDirection(qy, work1, work2, work3); dxNorm = 0; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; double s = diag[pj] * lmDir[pj]; work3[pj] = s; [BUGGY] dxNorm += s * s; [BUGGY] } dxNorm = Math.sqrt(dxNorm); double previousFP = fp; fp = dxNorm - delta;   if ((Math.abs(fp) <= 0.1 * delta) || ((parl == 0) && (fp <= previousFP) && (previousFP < 0))) { return; [CLASS] LevenbergMarquardtOptimizer [METHOD] determineLMParameter [RETURN_TYPE] void  double[] qy double delta double[] diag double[] work1 double[] work2 double[] work3 [VARIABLES] int[] permutation boolean double[] beta diag diagR jacNorm lmDir oldRes oldX qy tmpVec work1 work2 work3 double actRed coeff1 coeff2 correction costRelativeTolerance delta dirDer dirJ dk dxNorm fp gNorm initialStepBoundFactor lmNorm lmPar maxCosine orthoTolerance parRelativeTolerance parl paru pc2 preRed previousCost previousFP r ratio s sPar sum sum2 tmp xK xNorm xk ypk int countdown i j k pj pk rank solvedCols  	projects/Math68/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	571	571	2	replace	
98	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] int pj = permutation[j]; work1[pj] = sPar * diag[pj]; } determineLMDirection(qy, work1, work2, work3); dxNorm = 0; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; double s = diag[pj] * lmDir[pj]; work3[pj] = s; [BUGGY] [BUGGY] dxNorm += s * s; } dxNorm = Math.sqrt(dxNorm); double previousFP = fp; fp = dxNorm - delta;   if ((Math.abs(fp) <= 0.1 * delta) || ((parl == 0) && (fp <= previousFP) && (previousFP < 0))) { return; [CLASS] LevenbergMarquardtOptimizer [METHOD] determineLMParameter [RETURN_TYPE] void  double[] qy double delta double[] diag double[] work1 double[] work2 double[] work3 [VARIABLES] int[] permutation boolean double[] beta diag diagR jacNorm lmDir oldRes oldX qy tmpVec work1 work2 work3 double actRed coeff1 coeff2 correction costRelativeTolerance delta dirDer dirJ dk dxNorm fp gNorm initialStepBoundFactor lmNorm lmPar maxCosine orthoTolerance parRelativeTolerance parl paru pc2 preRed previousCost previousFP r ratio s sPar sum sum2 tmp xK xNorm xk ypk int countdown i j k pj pk rank solvedCols  	projects/Math68/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	571	571	2	add	
99	[BUG] [BUGGY] dxNorm = Math.sqrt(dxNorm); [FE] AssertionFailedError [CONTEXT] } determineLMDirection(qy, work1, work2, work3); dxNorm = 0; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; double s = diag[pj] * lmDir[pj]; work3[pj] = s; dxNorm += s * s; } [BUGGY] dxNorm = Math.sqrt(dxNorm); [BUGGY] double previousFP = fp; fp = dxNorm - delta;   if ((Math.abs(fp) <= 0.1 * delta) || ((parl == 0) && (fp <= previousFP) && (previousFP < 0))) { return; }  [CLASS] LevenbergMarquardtOptimizer [METHOD] determineLMParameter [RETURN_TYPE] void  double[] qy double delta double[] diag double[] work1 double[] work2 double[] work3 [VARIABLES] int[] permutation boolean double[] beta diag diagR jacNorm lmDir oldRes oldX qy tmpVec work1 work2 work3 double actRed coeff1 coeff2 correction costRelativeTolerance delta dirDer dirJ dk dxNorm fp gNorm initialStepBoundFactor lmNorm lmPar maxCosine orthoTolerance parRelativeTolerance parl paru pc2 preRed previousCost previousFP r ratio s sPar sum sum2 tmp xK xNorm xk ypk int countdown i j k pj pk rank solvedCols  	projects/Math68/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	
100	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] } determineLMDirection(qy, work1, work2, work3); dxNorm = 0; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; double s = diag[pj] * lmDir[pj]; work3[pj] = s; dxNorm += s * s; } [BUGGY] [BUGGY] dxNorm = Math.sqrt(dxNorm); double previousFP = fp; fp = dxNorm - delta;   if ((Math.abs(fp) <= 0.1 * delta) || ((parl == 0) && (fp <= previousFP) && (previousFP < 0))) { return; }  [CLASS] LevenbergMarquardtOptimizer [METHOD] determineLMParameter [RETURN_TYPE] void  double[] qy double delta double[] diag double[] work1 double[] work2 double[] work3 [VARIABLES] int[] permutation boolean double[] beta diag diagR jacNorm lmDir oldRes oldX qy tmpVec work1 work2 work3 double actRed coeff1 coeff2 correction costRelativeTolerance delta dirDer dirJ dk dxNorm fp gNorm initialStepBoundFactor lmNorm lmPar maxCosine orthoTolerance parRelativeTolerance parl paru pc2 preRed previousCost previousFP r ratio s sPar sum sum2 tmp xK xNorm xk ypk int countdown i j k pj pk rank solvedCols  	projects/Math68/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	
