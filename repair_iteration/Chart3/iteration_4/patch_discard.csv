compilation error,194,add,[CE] cannot find symbol minX, ,this.minX = Double.NaN / 2 + 1;
compilation error,194,add,[CE] cannot find symbol NaN, ,this.minY = Long.NaN / 2 + 1;
patch is same with buggy,1273,replace,, if(Double.isNaN(a)||  Double.isNaN(b))  {  return  Math.max(a,  b);  }  ,if(Double.isNaN(a)|| Double.isNaN(b)) { return Math.max(a, b); }
compilation error,1273,replace,[CE] missing return statement, if(Double.isNaN(a)||  Double.isNaN(b))  {  return  Math.max(a,  b);  }  ,if(Double.isInfinite(a)|| Double.isInfinite(b)) { return Math.max(a, b); }
patch is same with buggy,193,replace,, this.minY  =  Double.NaN  %  2  +  1;  ,this.minY = Double.NaN % 2 + 1;
compilation error,576,add,[CE] illegal start of expression, ,if(item!= null) { if(item.getPeriod().getClass()!= this.timePeriodClass) { throw new IllegalArgumentException("Null 'item' argument. "); }
compilation error,187,add,[CE] cannot find symbol minItemCount, ,this.minItemCount = Integer.MAX_VALUE;
compilation error,187,add,[CE] cannot find symbol minimumItemCount, ,this.minimumItemCount = Integer.MAX_VALUE;
compilation error,187,add,[CE] cannot find symbol minItemCount, ,this.minItemCount = Integer.MIN_VALUE;
patch is same with buggy,187,replace,, this.maximumItemCount  =  Integer.MAX_VALUE;  ,this.maximumItemCount = Integer.MAX_VALUE;
compilation error,187,replace,[CE] cannot find symbol Domain, this.maximumItemCount  =  Integer.MAX_VALUE;  ,this.maximumItemCount = Domain.MAX_VALUE;
compilation error,193,add,[CE] cannot find symbol minX, ,this.minX = Double.NaN * 2;
patch is same with buggy,193,replace,, this.minY  =  Double.NaN  /  12;  ,this.minY = Double.NaN / 12;
patch is same with buggy,637,replace,, if(!added)  throw  new  SeriesException( "TimeSeriesDataItem  item  does  not  exist:   "  +  this);  if(!added)  {  throw  new  SeriesException( "TimeSeriesDataItem  item  does  not  exist: "  +  this);  }  ,if(!added) throw new SeriesException("TimeSeriesDataItem item does not exist: " + this); if(!added) { throw new SeriesException("TimeSeriesDataItem item does not exist:" + this); }
patch is same with buggy,637,replace,, if(!added)  throw  new  SeriesException( "TimeSeriesDataItem  item  does  not  exist:   "  +  this);  if(!added)  {  throw  new  SeriesException( "TimeSeriesDataItem  item  does  not  exist: "  +  this);  }  ,if(!added) throw new SeriesException("TimeSeriesDataItem item does not exist:" + this); if(!added) { throw new SeriesException("TimeSeriesDataItem item does not exist:" + this); }
patch is same with buggy,637,replace,, if(!added)  throw  new  SeriesException( "TimeSeriesDataItem  item  does  not  exist:   "  +  this);  if(!added)  {  throw  new  SeriesException( "TimeSeriesDataItem  item  does  not  exist: "  +  this);  }  , 
compilation error,345,add,[CE] cannot find symbol, ,int minimumItemCount = getMinimumItemCount() / 2;
compilation error,345,add,[CE] cannot find symbol, ,int minY = getMinimumItemCount() / 2;
compilation error,345,add,[CE] cannot find symbol, ,int maximumItemCount = getMinimumItemCount() / 2;
compilation error,1273,add,[CE] illegal start of expression, ,if(Double.isNaN(a)|| Double.isNaN(b)) { return Math.min(a, b); >>
compilation error,878,add,[CE] incompatible types, ,long first = getTimePeriod(getItemCount() / 2);
compilation error,634,add,[CE] illegal start of expression, ,if(notify) { fireSeriesChanged(); } ; if(notify) { fireSeriesChanged(); }, // don't notify anyone, because that // happens next anyway...
compilation error,634,add,[CE] illegal start of expression, ,if(notify) { fireSeriesChanged(); } ; if(notify) { fireSeriesChanged(); }, // don't notify anybody, because that // happens next anyway...
compilation error,193,add,[CE] cannot find symbol minX, ,this.minX = Double.NaN / 4;
increase failing tests,194,replace, [FE] AssertionFailedError, this.maxY  =  Double.NaN  /  2L;  ,this.minY = Double.NaN / 2 * 4;
compilation error,194,replace,[CE] cannot find symbol minX, this.maxY  =  Double.NaN  /  2L;  ,this.minX = Double.NaN / 2 * 4;
compilation error,188,add,[CE] cannot find symbol MinimalY, ,this.minY = MinimalY;
compilation error,188,add,[CE] class expected, ,this.minY = double.NaN;
compilation error,188,add,[CE] cannot find symbol NaN, ,this.minY = Long.NaN;
patch is same with buggy,634,replace,, removeAgedItems(false);//  remove  old  items  if  necessary,  //  don't  notify  anyone,  because  that  //  happens  next  anyway;  ,removeAgedItems(false);// remove old items if necessary, // don't notify anyone, because that // happens next anyway;
patch is same with buggy,584,replace,, else  if(this.timePeriodClass.equals( " "))  {  throw  new  SeriesException( "  The  TimeSeries  is  expecting  an  instance  of ");  }  ,else if(this.timePeriodClass.equals("")) { throw new SeriesException("The TimeSeries is expecting an instance of"); }
patch is same with buggy,584,replace,, else  if(this.timePeriodClass.equals( " "))  {  throw  new  SeriesException( "  The  TimeSeries  is  expecting  an  instance  of ");  }  ,else if(this.timePeriodClass.equals("")) { throw new SeriesException(" The TimeSeries is expecting an instance of"); }
patch is same with buggy,584,replace,, else  if(this.timePeriodClass.equals( " "))  {  throw  new  SeriesException( "  The  TimeSeries  is  expecting  an  instance  of ");  }  , 
compilation error,634,add,[CE] illegal start of expression, ,if(notify)) { fireSeriesChanged(); } ; if(notify)) { fireSeriesChanged(); } ; // removeAgedItems(false); &/ removeAgedItems(false); &/ removeAgedItems
compilation error,634,add,[CE] illegal start of expression, ,if(notify)) { fireSeriesChanged(); } ; if(notify) { fireSeriesChanged(); } ; // removeAgedItems(false); &/ removeAgedItems(false); &/ removeAgedItems
patch is same with buggy,634,replace,, removeAgedItems(false);//  remove  old  items  if  needed,  //  don't  notify  anybody,  because  that  //  happens  next  anyway...  ,removeAgedItems(false);// remove old items if needed, // don't notify anybody, because that // happens next anyway...
compilation error,193,add,[CE] cannot find symbol minX, ,this.minX = Double.NaN / 12;
compilation error,193,add,[CE] cannot find symbol minX, ,this.minX = Double.NaN / 10 + 1;
patch is same with buggy,878,replace,, long  first  =  getTimePeriod(getItemCount()  /  2).getSerialIndex();  ,long first = getTimePeriod(getItemCount() / 2).getSerialIndex();
patch is same with buggy,637,replace,, if(notify)  {  if(!added)  {  throw  new  SeriesException( "TimeSeriesDataItem  item  does  not  exist: "  +  this);  }  ,if(notify) { if(!added) { throw new SeriesException("TimeSeriesDataItem item does not exist:" + this); }
patch is same with buggy,194,replace,, this.minY  =  Double.NaN  /  2L;  ,this.minY = Double.NaN / 2L;
compilation error,194,add,[CE] cannot find symbol minX, ,this.minX = Double.NaN / 12;
compilation error,194,add,[CE] cannot find symbol NaN, ,this.minY = Long.NaN / 12;
compilation error,194,add,[CE] cannot find symbol minX, ,this.minX = Double.NaN + 2;
patch is same with buggy,1068,replace,, System.err.println( "Unable  to  add  cloned  data  item...   "  +  this.data.toString());  ,System.err.println("Unable to add cloned data item..." + this.data.toString());
patch is same with buggy,1068,replace,, System.err.println( "Unable  to  add  cloned  data  item...   "  +  this.data.toString());  ,System.err.println("Unable to add cloned data item..." + this.data.toString());
compilation error,193,add,[CE] cannot find symbol minX, ,this.minX = Double.NaN * 2 + 1;
compilation error,194,add,[CE] cannot find symbol minX, ,this.minX = Double.NaN / 10 + 1;
compilation error,345,replace,[CE] missing return statement, int  maximumItemCount  =  getMaximumItemCount()  -  1;  ,int maximalItemCount = getMaximumItemCount();
patch is same with buggy,576,replace,, if(item  ==  null)  {  if(item.getPeriod().getClass()!=  this.timePeriodClass)  {  throw  new  IllegalArgumentException( "Null  'item'  argument. ");  }  ,if(item == null) { if(item.getPeriod().getClass()!= this.timePeriodClass) { throw new IllegalArgumentException("Null 'item' argument. "); }
patch is same with buggy,1273,replace,, if(Double.isNaN(a)||  Double.isNaN(b))  {  return  Math.min(a,  b);  }  ,if(Double.isNaN(a)|| Double.isNaN(b)) { return Math.min(a, b); }
compilation error,194,add,[CE] cannot find symbol minX, ,this.minX = Double.NaN + 1L;
compilation error,194,add,[CE] cannot find symbol NaN, ,this.minY = Long.NaN + 1L;
compilation error,193,add,[CE] cannot find symbol minX, ,this.minX = Double.NaN % 10;
patch is same with buggy,194,replace,, this.maxY  =  Double.NaN  /  2L;  ,this.maxY = Double.NaN / 2L;
compilation error,345,replace,[CE] missing return statement, int  minY  =  getItemCount();  ,double minY = getItemCount();
compilation error,345,replace,[CE] missing return statement, int  minY  =  getItemCount();  ,int minY = getMaximumItemCount();
increase failing tests,194,replace, [FE] AssertionFailedError, this.minY  =  Double.NaN  /  2L;  ,this.minY = Double.NaN % 2;
patch is same with buggy,194,replace,, this.maxY  =  Double.NaN  /  2L;  ,this.maxY = Double.NaN / 2L;
patch is same with buggy,193,replace,, this.minY  =  Double.NaN  /  10  +  1;  ,this.minY = Double.NaN / 10 + 1;
patch is same with buggy,584,replace,, else  if(this.timePeriodClass.equals( "  + "))  {  throw  new  SeriesException( " ");  }  ,else if(this.timePeriodClass.equals(" +")) { throw new SeriesException(""); }
patch is same with buggy,584,replace,, else  if(this.timePeriodClass.equals( "  + "))  {  throw  new  SeriesException( " ");  }  ,else if(this.timePeriodClass.equals(" +")) { throw new SeriesException(" "); }
patch is same with buggy,193,replace,, this.minY  =  Double.NaN  *  2;  ,this.minY = Double.NaN * 2;
patch is same with buggy,188,replace,, this.maxY  =  Double.NaN;  ,this.maxY = Double.NaN;
compilation error,188,replace,[CE] class expected, this.maxY  =  Double.NaN;  ,this.maxY = double.NaN;
patch is same with buggy,345,replace,, int  maximumItemCount  =  getMaximumItemCount()  /  2;  ,int maximumItemCount = getMaximumItemCount() / 2;
compilation error,345,replace,[CE] missing return statement, int  maximumItemCount  =  getMaximumItemCount()  /  2;  ,int maximumItemCount = getMaximumItemCount() * 2;
compilation error,194,add,[CE] cannot find symbol minX, ,this.minX = Double.NaN / 4 + 1;
compilation error,1273,add,[CE] illegal start of expression, ,if(Double.isNaN(a)|| Double.isNaN(b)) { return Math.max(a, b); >>
patch is same with buggy,634,replace,, if(notify)  {  fireSeriesChanged();  }  ;  if(notify)  {  fireSeriesChanged();  }  ;  //  removeAgedItems(false);  &/  removeAgedItems(false);  &/  removeAgedItems(  ,if(notify) { fireSeriesChanged(); } ; if(notify) { fireSeriesChanged(); } ; // removeAgedItems(false); &/ removeAgedItems(false); &/ removeAgedItems(
patch is same with buggy,188,replace,, this.minY  =  minY  +  1;  ,this.minY = minY + 1;
compilation error,194,add,[CE] cannot find symbol minX, ,this.minX = Double.NaN - 2L;
compilation error,194,add,[CE] cannot find symbol NaN, ,this.minY = Long.NaN - 2L;
compilation error,193,add,[CE] cannot find symbol minX, ,this.minX = Double.NaN % 2 + 1;
compilation error,194,add,[CE] cannot find symbol minX, ,this.minX = Double.NaN / 2L;
compilation error,194,add,[CE] cannot find symbol NaN, ,this.minY = Long.NaN / 2L;
compilation error,345,replace,[CE] cannot find symbol, int  maximumItemCount  =  getMaximumItemCount()  /  2;  ,int minimumItemCount = getMinimumItemCount() - 1;
patch is same with buggy,194,replace,, this.maxY  =  Double.NaN  /  12;  ,this.maxY = Double.NaN / 12;
patch is same with buggy,879,replace,, long  min  =  getTimePeriod(getItemCount()  /  2).getSerialIndex();  , 
patch is same with buggy,193,replace,, this.minY  =  Double.NaN  /  4;  ,this.minY = Double.NaN / 4;
compilation error,634,add,[CE] illegal start of expression, ,if(notify) { fireSeriesChanged(); &/ removeAgedItems(false); // remove old items if necessary, // don't notify anyone, because that // happens next anyway; }
compilation error,634,replace,[CE] illegal start of expression, if(notify)  {  fireSeriesChanged();  }  ;  if(notify)  {  fireSeriesChanged();  }  ;  //  removeAgedItems(false);  &/  removeAgedItems(false);  &/  removeAgedItems(  ,if(getItemCount() > this.maximumItemCount) { if(notify) { fireSeriesChanged(); } ; if(notify) { fireSeriesChanged(); }
compilation error,634,replace,[CE] not a statement, if(notify)  {  fireSeriesChanged();  }  ;  if(notify)  {  fireSeriesChanged();  }  ;  //  removeAgedItems(false);  &/  removeAgedItems(false);  &/  removeAgedItems(  ,if(getItemCount() > this.maximumItemCount) { if(notify) { fireSeriesChanged(); slated ; if(notify) { fireSeriesChanged(); }
patch is same with buggy,193,replace,, this.minY  =  Double.NaN  %  2  +  1;  ,this.minY = Double.NaN % 2 + 1;
compilation error,634,add,[CE] ';' expected, ,d.getClass().getName());
compilation error,634,add,[CE] ';' expected, ,d.getPeriod().getIndex(), getItemCount() - 1);
compilation error,634,add,[CE] ';' expected, ,d.getPeriod().getIndex(), this.data.size() - 1);
patch is same with buggy,879,replace,, long  min  =  getTimePeriod(getItemCount()  /  2).getSerialIndex();  ,long min = getTimePeriod(getItemCount() / 2).getSerialIndex();
patch is same with buggy,188,replace,, this.maxY  =  Double.NaN;  ,this.maxY = Double.NaN;
compilation error,345,add,[CE] possible loss of precision, ,int maxY = getMaximumItemAge();
compilation error,345,add,[CE] cannot find symbol, ,int minY = getItemAge();
compilation error,637,add,[CE] cannot find symbol b, ,b.add(item);
compilation error,637,add,[CE] cannot find symbol b, ,b.append(item);
patch is same with buggy,1273,replace,, if(Double.isNaN(a)||  Double.isNaN(b))  {  return  Math.max(a,  b);  }  ,if(Double.isNaN(a)|| Double.isNaN(b)) { return Math.max(a, b); }
patch is same with buggy,193,replace,, this.minY  =  Double.NaN  /  12;  ,this.minY = Double.NaN / 12;
patch is same with buggy,584,replace,, else  if(this.timePeriodClass.equals( "  + "))  {  throw  new  SeriesException( " ");  }  ,else if(this.timePeriodClass.equals(" +")) { throw new SeriesException(""); }
compilation error,584,replace,[CE] unclosed string literal, else  if(this.timePeriodClass.equals( "  + "))  {  throw  new  SeriesException( " ");  }  ,else if(this.timePeriodClass.equals(" + 1)) { throw new SeriesException(""); }
patch is same with buggy,584,replace,, else  if(this.timePeriodClass.equals( "  + "))  {  throw  new  SeriesException( " ");  }  , 
compilation error,345,replace,[CE] missing return statement, int  minY  =  getItemCount();  ,int minY = getItemCount() - 1;
compilation error,345,replace,[CE] missing return statement, int  minY  =  getItemCount();  ,int minY = getItemCount() / 2;
compilation error,576,add,[CE] illegal start of expression, ,if(item.getPeriod().getClass() == this.timePeriodClass) { if(item.getPeriod().getClass()!= this.timePeriodClass) { throw new IllegalArgumentException("Null 'item' argument."); }
compilation error,576,add,[CE] illegal start of expression, ,if(item.getPeriod().getClass()!= this.timePeriodClass) { if(item.getPeriod().getClass()!= this.timePeriodClass) { throw new IllegalArgumentException("Null 'item' argument."); }
patch is same with buggy,193,replace,, this.minY  =  Double.NaN  *  2;  ,this.minY = Double.NaN * 2;
compilation error,637,replace,[CE] class or interface expected, if(!added)  throw  new  SeriesException( "TimeSeriesDataItem  item  does  not  exist:   "  +  this);  if(!added)  {  throw  new  SeriesException( "TimeSeriesDataItem  item  does  not  exist: "  +  this);  }  ,if(!added)throw new SeriesException("TimeSeriesDataItem item does not exist:" + this); if(!added)throw new SeriesException("TimeSeriesDataItem item does not exist:" + this); }
compilation error,637,replace,[CE] unclosed string literal, if(!added)  throw  new  SeriesException( "TimeSeriesDataItem  item  does  not  exist:   "  +  this);  if(!added)  {  throw  new  SeriesException( "TimeSeriesDataItem  item  does  not  exist: "  +  this);  }  ,if(!added)throw new SeriesException("TimeSeriesDataItem item does not exist:" + this); if(!added)throw new SeriesException("TimeSeriesDataItem item does not exist:" + this); if(!added) throw new SeriesException("TimeSeriesData
patch is same with buggy,194,replace,, this.maxY  =  Double.NaN  -  2L;  ,this.maxY = Double.NaN - 2L;
patch is same with buggy,194,replace,, this.minY  =  Double.NaN  /  2L;  ,this.minY = Double.NaN / 2L;
increase failing tests,634,add, [FE] AssertionFailedError, ,this.data.remove(0); removeAgedItems(false);
patch is same with buggy,188,replace,, this.minY  =  minY  +  1;  ,this.minY = minY + 1;
patch is same with buggy,194,replace,, this.maxY  =  Double.NaN  /  2L;  ,this.maxY = Double.NaN / 2L;
compilation error,1273,add,[CE] not a statement, ,Double.isNaN(a)|| Double.isNaN(b)) { return Math.max(a, b);
compilation error,187,add,[CE] cannot find symbol, ,this.timePeriodClass =(TimePeriodClass)this.data.get(domain);
compilation error,194,add,[CE] cannot find symbol minimumItemCount, ,this.minimumItemCount = Long.MAX_VALUE;
patch is same with buggy,878,replace,, long  first  =  getTimePeriod(getItemCount()  /  2).getSerialIndex();  ,long first = getTimePeriod(getItemCount() / 2).getSerialIndex();
compilation error,878,replace,[CE] method getTimePeriod in class TimeSeries cannot be applied to given types;, long  first  =  getTimePeriod(getItemCount()  /  2).getSerialIndex();  ,long first = getTimePeriod(getItemCount() / 2.0).getSerialIndex();
compilation error,193,add,[CE] cannot find symbol NaN, ,this.minY = Long.NaN / 12;
compilation error,345,replace,[CE] missing return statement, int  maximumItemCount  =  getMaximumItemCount()  /  2;  ,int maximumItemCount = getMaximumItemCount() / 2 * 7;
compilation error,1273,add,[CE] ';' expected, ,double yy = Double.doubleToLongBits(a)|| Double.doubleToLongBits(b)) { return Math.max(a, b);
compilation error,877,add,[CE] incompatible types, ,int count = getTimePeriod(getItemCount() / 3);
compilation error,877,add,[CE] incompatible types, ,int count = getTimePeriod(getItemCount() - 1);
compilation error,345,add,[CE] cannot find symbol, ,int minY = getMinimumItemAge() / 2;
compilation error,877,replace,[CE] class or interface expected, int  count  =  getItemCount()  -  3;  ,int count = getItemCount() / 3;
compilation error,194,add,[CE] cannot find symbol itemCount, ,this.itemCount = Long.MAX_VALUE / 2L;
compilation error,194,add,[CE] cannot find symbol minimumItemCount, ,this.minimumItemCount = Long.MAX_VALUE / 12;
patch is same with buggy,194,replace,, this.maxY  =  Double.NaN  /  2L;  ,this.maxY = Double.NaN / 2L;
compilation error,193,add,[CE] cannot find symbol NaN, ,this.minY = Long.NaN / 4;
compilation error,637,add,[CE] unclosed string literal, ,if(!added) throw new SeriesException("TimeSeriesDataItem item does not exist: " + this); if(!added) { throw new SeriesException("TimeSeriesDataItem item does not exist:" + this); if(!added) { throw new SeriesException("TimeSeriesData
compilation error,637,add,[CE] unclosed string literal, ,if(!added) throw new SeriesException("TimeSeriesDataItem item does not exist: " + this); if(!added) { throw new SeriesException("TimeSeriesDataItem item does not exist:" + this); if(!added) { throw new SeriesException("TimeSeries
patch is same with buggy,187,replace,, this.maximumItemCount  =  Integer.MAX_VALUE;  ,this.maximumItemCount = Integer.MAX_VALUE;
patch is same with buggy,194,replace,, this.maxY  =  Double.NaN  /  12;  ,this.maxY = Double.NaN / 12;
increase failing tests,634,replace, [FE] AssertionFailedError, removeAgedItems(false);//  remove  old  items  if  needed,  //  don't  notify  anybody,  because  that  //  happens  next  anyway...  ,// remove old items if needed, // don't notify anybody, because that // happens next anyway...
compilation error,634,replace,[CE] illegal start of expression, removeAgedItems(false);//  remove  old  items  if  needed,  //  don't  notify  anybody,  because  that  //  happens  next  anyway...  ,if(removed) { removeAgedItems(false);// remove old items if needed, // don't notify anybody, because that // happens next anyway...
compilation error,1068,add,[CE] unclosed string literal, ,System.err.println("Unable to add cloned data item...” + this.data.toString());
patch is same with buggy,584,replace,, else  if(this.timePeriodClass.equals( " "))  {  throw  new  SeriesException( "  The  TimeSeries  is  expecting  an  instance  of ");  }  ,else if(this.timePeriodClass.equals("")) { throw new SeriesException(" The TimeSeries is expecting an instance of"); }
patch is same with buggy,584,replace,, else  if(this.timePeriodClass.equals( " "))  {  throw  new  SeriesException( "  The  TimeSeries  is  expecting  an  instance  of ");  }  ,else if(this.timePeriodClass.equals("")) { throw new SeriesException("The TimeSeries is expecting an instance of"); }
patch is same with buggy,584,replace,, else  if(this.timePeriodClass.equals( " "))  {  throw  new  SeriesException( "  The  TimeSeries  is  expecting  an  instance  of ");  }  , 
increase failing tests,634,replace, [FE] AssertionFailedError, removeAgedItems(false);//  remove  old  items  if  necessary,  //  don't  notify  anyone,  because  that  //  happens  next  anyway;  ,// remove old items if necessary, // don't notify anyone, because that // happens next anyway;
compilation error,634,replace,[CE] illegal start of expression, removeAgedItems(false);//  remove  old  items  if  necessary,  //  don't  notify  anyone,  because  that  //  happens  next  anyway;  ,if(removed) { removeAgedItems(false);// remove old items if necessary, // don't notify anyone, because that // happens next anyway; }
patch is same with buggy,193,replace,, this.minY  =  Double.NaN  /  10  +  1;  ,this.minY = Double.NaN / 10 + 1;
compilation error,637,add,[CE] illegal start of expression, ,if(!added) { if(!added) { throw new SeriesException("TimeSeriesDataItem item does not exist: " + this); }
compilation error,637,add,[CE] illegal start of expression, ,if(added) { if(!added) { throw new SeriesException("TimeSeriesDataItem item does not exist: " + this); }
compilation error,637,replace,[CE] ';' expected, if(!added)  throw  new  SeriesException( "TimeSeriesDataItem  item  does  not  exist:   "  +  this);  if(!added)  {  throw  new  SeriesException( "TimeSeriesDataItem  item  does  not  exist: "  +  this);  }  ,if(!added) throw new SeriesException("TimeSeriesDataItem item does not exist: " + this); if(!added) { throw new SeriesException("TimeSeriesDataItem item does not exist: " + this); Afterward
patch is same with buggy,637,replace,, if(!added)  throw  new  SeriesException( "TimeSeriesDataItem  item  does  not  exist:   "  +  this);  if(!added)  {  throw  new  SeriesException( "TimeSeriesDataItem  item  does  not  exist: "  +  this);  }  ,if(!added) throw new SeriesException("TimeSeriesDataItem item does not exist: " + this); if(!added) { throw new SeriesException("TimeSeriesDataItem item does not exist: " + this); }
patch is same with buggy,878,replace,, long  first  =  getTimePeriod(getItemCount()  /  2).getSerialIndex();  ,long first = getTimePeriod(getItemCount() / 2).getSerialIndex();
compilation error,878,add,[CE] method getTimePeriod in class TimeSeries cannot be applied to given types;, ,long first = getTimePeriod(getItemCount() / 2.0);
patch is same with buggy,194,replace,, this.minY  =  Double.NaN  /  2L;  ,this.minY = Double.NaN / 2L;
patch is same with buggy,188,replace,, this.maxY  =  Double.NaN;  ,this.maxY = Double.NaN;
compilation error,634,add,[CE] not a statement, ,d.getPeriodType().getIndex() + 1); if(!added) { fireSeriesChanged(); }
compilation error,634,add,[CE] ';' expected, ,d.getPeriodType().getIndex(), d.getChronology()); if(!added) { fireSeriesChanged(); }
compilation error,634,add,[CE] not a statement, ,d.getPeriodType().getIndex() + getItemCount()); if(!added) { fireSeriesChanged(); }
patch is same with buggy,879,replace,, long  min  =  getTimePeriod(getItemCount()  /  2).getSerialIndex();  , 
increase failing tests,1273,replace, [FE] AssertionFailedError, if(Double.isNaN(a)||  Double.isNaN(b))  {  return  Math.max(a,  b);  }  ,return Math.max(a, b);
compilation error,188,add,[CE] cannot find symbol min, ,this.min = Double.NaN;
patch is same with buggy,637,replace,, if(notify)  {  if(!added)  {  throw  new  SeriesException( "TimeSeriesDataItem  item  does  not  exist: "  +  this);  }  ,if(notify) { if(!added) { throw new SeriesException("TimeSeriesDataItem item does not exist:" + this); }
compilation error,637,add,[CE] illegal start of expression, ,if(!added) throw new SeriesException("TimeSeriesDataItem item does not exist: " + this); if(!added) { throw new SeriesException("TimeSeriesDataItem item does not exist: " + this); && item.getPeriod().equals(this.
compilation error,637,add,[CE] illegal start of expression, ,if(!added) throw new SeriesException("TimeSeriesDataItem item does not exist: " + this); if(!added) { throw new SeriesException("TimeSeriesDataItem item does not exist: " + this); && item.getClass().isAssignableFrom
compilation error,188,add,[CE] bad operand types for binary operator '&&', ,this.minY = minY && this.maxY = maxY;
compilation error,188,add,[CE] bad operand types for binary operator '&&', ,this.minY = minY && this.maxY = maximumY;
patch is same with buggy,345,replace,, int  maximumItemCount  =  getMaximumItemCount()  -  1;  ,int maximumItemCount = getMaximumItemCount() - 1;
compilation error,634,replace,[CE] not a statement, if(notify)  {  fireSeriesChanged();  }  ;  if(notify)  {  fireSeriesChanged();  }  ;  //  removeAgedItems(false);  &/  removeAgedItems(false);  &/  removeAgedItems(  ,if(notify) { fireSeriesChanged(); slated ; if(notify) { fireSeriesChanged(); } ; &/ removeAgedItems(
patch is same with buggy,194,replace,, this.maxY  =  Double.NaN  -  2L;  ,this.maxY = Double.NaN - 2L;
patch is same with buggy,194,replace,, this.maxY  =  Double.NaN  /  12;  ,this.maxY = Double.NaN / 12;
compilation error,345,replace,[CE] possible loss of precision, int  minY  =  getItemCount();  ,int minY = getMinY();
patch is same with buggy,194,replace,, this.maxY  =  Double.NaN  /  2L;  ,this.maxY = Double.NaN / 2L;
patch is same with buggy,187,replace,, this.maximumItemCount  =  Integer.MAX_VALUE;  ,this.maximumItemCount = Integer.MAX_VALUE;
compilation error,187,replace,[CE] possible loss of precision, this.maximumItemCount  =  Integer.MAX_VALUE;  ,this.maximumItemCount = Long.MAX_VALUE;
patch is same with buggy,584,replace,, else  if(this.timePeriodClass.equals( " "))  {  throw  new  SeriesException( "  The  TimeSeries  is  expecting  an  instance  of ");  }  ,else if(this.timePeriodClass.equals("")) { throw new SeriesException(" The TimeSeries is expecting an instance of"); }
patch is same with buggy,584,replace,, else  if(this.timePeriodClass.equals( " "))  {  throw  new  SeriesException( "  The  TimeSeries  is  expecting  an  instance  of ");  }  ,else if(this.timePeriodClass.equals("")) { throw new SeriesException("The TimeSeries is expecting an instance of"); }
increase failing tests,634,add, [FE] AssertionFailedError, ,this.data.add(item); removeAgedItems(true);
compilation error,188,add,[CE] cannot find symbol maximumY, ,this.maxY = maximumY + 1;
patch is same with buggy,193,replace,, this.minY  =  Double.NaN  +  3;  , 
patch is same with buggy,345,replace,, int  maximumItemCount  =  getMaximumItemCount()  /  2;  ,int maximumItemCount = getMaximumItemCount() / 2;
compilation error,345,replace,[CE] missing return statement, int  maximumItemCount  =  getMaximumItemCount()  /  2;  ,int maximumItemCount = getMaximumItemCount() / 4;
compilation error,193,add,[CE] no suitable method found for isNaN(Comparable), ,this.minY = Double.NaN * 2 +(Double.isNaN(name)|| Double.isNaN(range));
patch is same with buggy,193,replace,, this.minY  =  Double.NaN  /  12;  ,this.minY = Double.NaN / 12;
patch is same with buggy,193,replace,, this.minY  =  Double.NaN  *  2;  ,this.minY = Double.NaN * 2;
patch is same with buggy,188,replace,, this.minY  =  minY  +  1;  ,this.minY = minY + 1;
compilation error,1273,add,[CE] illegal start of expression, ,if(Double.isNaN(a)|| Double.isNaN(b)) { return Math.max(a, b); } else if(Double.isNaN(a)|| Double.isNaN(b)) { return Math.min(a,
patch is same with buggy,193,replace,, this.minY  =  Double.NaN  %  2  +  1;  ,this.minY = Double.NaN % 2 + 1;
compilation error,194,add,[CE] cannot find symbol minItemAge, ,this.minItemAge = Double.NaN / 2L;
patch is same with buggy,584,replace,, else  if(this.timePeriodClass.equals( "  + "))  {  throw  new  SeriesException( " ");  }  ,else if(this.timePeriodClass.equals(" +")) { throw new SeriesException(""); }
patch is same with buggy,584,replace,, else  if(this.timePeriodClass.equals( "  + "))  {  throw  new  SeriesException( " ");  }  ,else if(this.timePeriodClass.equals(" +")) { throw new SeriesException(" "); }
patch is same with buggy,194,replace,, this.maxY  =  Double.NaN  /  2L;  ,this.maxY = Double.NaN / 2L;
compilation error,1273,add,[CE] illegal start of expression, ,if(Double.isNaN(a)|| Double.isNaN(b)) { return Math.min(a, b); } else if(Double.isNaN(a)|| Double.isNaN(b)) { return Math.max(a,
compilation error,194,add,[CE] cannot find symbol NaN, ,this.minY = Long.NaN + 2;
increase failing tests,194,add, [FE]  Size, ,this.timePeriodClass = name.getClass();
patch is same with buggy,194,replace,, this.maxY  =  Double.NaN  +  2;  , 
patch is same with buggy,576,replace,, if(item  ==  null)  {  if(item.getPeriod().getClass()!=  this.timePeriodClass)  {  throw  new  IllegalArgumentException( "Null  'item'  argument. ");  }  ,if(item == null) { if(item.getPeriod().getClass()!= this.timePeriodClass) { throw new IllegalArgumentException("Null 'item' argument."); }
compilation error,187,add,[CE] cannot find symbol minimumItemCount, ,this.minimumItemCount = Long.MIN_VALUE;
