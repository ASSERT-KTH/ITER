compilation error,576,replace,[CE] <identifier> expected, if(item  ==  null)  {  if(item.getPeriod().getClass()  ==  this.timePeriodClass)  {  throw  new  IllegalArgumentException( " ");  }  ,if(item.getPeriod().getClass() == this.timePeriodClass) { throw new IllegalArgumentException("Null 'item' argument. "); }
compilation error,576,replace,[CE] <identifier> expected, if(item  ==  null)  {  if(item.getPeriod().getClass()  ==  this.timePeriodClass)  {  throw  new  IllegalArgumentException( " ");  }  ,if(item.getPeriod().getClass()!= this.timePeriodClass) { throw new IllegalArgumentException("Null 'item' argument. "); }
increase failing tests,189,add, [FE] NullPointerException, ,if(name == null) { this.timePeriodClass = name.getClass(); } else if(name!= null) { this.data.add(name); }
compilation error,187,add,[CE] cannot find symbol MINY, ,this.maximumItemCount = Integer.MAX_VALUE; this.minY = Integer.MINY;
patch is same with buggy,634,replace,, if(notify)  {  fireSeriesChanged();  }  ;  if(notify)  {  fireSeriesChanged();  }  ;  //  removeAgedItems(false);  &/  remove  items  if  necessary,  //  don't  notify  anyone,  because  that  //  happens  next  anyway  ,if(notify) { fireSeriesChanged(); } ; if(notify) { fireSeriesChanged(); } ; // removeAgedItems(false); &/ remove items if necessary, // don't notify anyone, because that // happens next anyway
compilation error,634,replace,[CE] not a statement, if(notify)  {  fireSeriesChanged();  }  ;  if(notify)  {  fireSeriesChanged();  }  ;  //  removeAgedItems(false);  &/  remove  items  if  necessary,  //  don't  notify  anyone,  because  that  //  happens  next  anyway  ,if(notify) { fireSeriesChanged(); bodied ; if(notify) { fireSeriesChanged(); } ; // removeAgedItems(false); &/ remove items if necessary, // don't notify anyone, because that // happens next anyway
compilation error,634,add,[CE] illegal start of expression, ,if(notify) { fireSeriesChanged(); } ; if(notify) { fireSeriesChanged(); }? true : false; // removeAgedItems(true); // remove items if necessary, // don't notify anyone
compilation error,634,add,[CE] illegal start of expression, ,if(notify) { fireSeriesChanged(); } ; if(notify) { fireSeriesChanged(); }? true : false; // removeAgedItems(true); // remove items if necessary, // don't notify
compilation error,634,add,[CE] illegal start of expression, ,if(notify) { fireSeriesChanged(); } ; if(notify) { fireSeriesChanged(); }? true : false; // removeAgedItems(true); // remove old items if necessary, // don't notify
increase failing tests,634,replace, [FE] AssertionFailedError, if(notify)  {  fireSeriesChanged();  }  ;  if(notify)  {  fireSeriesChanged();  }  ;  //  removeAgedItems(false);  &/  remove  old  items  if  necessary,  //  don't  notify  anyone,  because  that  //  happens  next  anyway  ,if(notify) { fireSeriesChanged(); } ; if(notify) { fireSeriesChanged(); } ; // removeAgedItems(false); &/ removeAgedItems(false); &/ removeAgedItems
compilation error,634,replace,[CE] not a statement, if(notify)  {  fireSeriesChanged();  }  ;  if(notify)  {  fireSeriesChanged();  }  ;  //  removeAgedItems(false);  &/  remove  old  items  if  necessary,  //  don't  notify  anyone,  because  that  //  happens  next  anyway  ,if(notify) { fireSeriesChanged(); bodied ; if(notify) { fireSeriesChanged(); } ; // removeAgedItems(false); &/ removeAgedItems(false); &/ removeAgedItems
compilation error,1269,add,[CE] illegal start of expression, ,if(Double.isNaN(a)|| Double.isNaN(b)|| Double.isNaN(a)&& Double.isNaN(b)) }
compilation error,1269,add,[CE] class expected, ,if(Double.isNaN(a)|| Double.isNaN(b)|| Double.isNaN(a)&& double.isNaN(b)) {
compilation error,584,replace,[CE] illegal start of type, else  if(!this.timePeriodClass.isAssignableFrom(c)&&  notify)  {  throw  new  SeriesException( " ");  }  ,else if(!this.timePeriodClass.isAssignableFrom(c)|| notify) { throw new SeriesException(""); }
patch is same with buggy,584,replace,, else  if(!this.timePeriodClass.isAssignableFrom(c)&&  notify)  {  throw  new  SeriesException( " ");  }  ,else if(!this.timePeriodClass.isAssignableFrom(c)&& notify) { throw new SeriesException(""); }
compilation error,1273,add,[CE] not a statement, ,if(Double.isNaN(a)|| Double.isNaN(b)) { return a; bodied else if(Double.isNaN(a)|| Double.isNaN(b)) { return Math.max(a, b); }
patch is same with buggy,187,replace,, if(domain  ==  null)  {  this.domain  =  domain;  this.range  =  range;  }  ,if(domain == null) { this.domain = domain; this.range = range; }
compilation error,634,replace,[CE] not a statement, removeAgedItems(true);//  remove  old  items  if  needed,  but  //  don't  notify  anybody,  because  that  //  happens  next  anyway...  ,if(notify) { fireSeriesChanged(); } ; if(notify) { fireSeriesChanged(); }!(( TimeSeriesDataItem)item.getValue()); // removeAgedItems(true);
compilation error,634,replace,[CE] not a statement, removeAgedItems(true);//  remove  old  items  if  needed,  but  //  don't  notify  anybody,  because  that  //  happens  next  anyway...  ,if(notify) { fireSeriesChanged(); } ; if(notify) { fireSeriesChanged(); }!(( TimeSeriesDataItem)item); // removeAgedItems(true); // remove items if needed,
compilation error,187,add,[CE] illegal start of expression, ,if(domain == null) { this.domain = domain; this.range = range; >>
patch is same with buggy,189,replace,, if(this.timePeriodClass!=  null)  {  this.timePeriodClass  =  getTimePeriodClass();  }  ,if(this.timePeriodClass!= null) { this.timePeriodClass = getTimePeriodClass(); }
compilation error,189,replace,[CE] illegal start of expression, if(this.timePeriodClass!=  null)  {  this.timePeriodClass  =  getTimePeriodClass();  }  ,if(!this.timePeriodClass.isArray()) { if(this.timePeriodClass!= null) { this.timePeriodClass = getTimePeriodClass(); }
patch is same with buggy,1212,replace,, if(yN!=  null)  {  yN  =  new  Double(yN.doubleValue());  }  ,if(yN!= null) { yN = new Double(yN.doubleValue()); }
compilation error,879,add,[CE] ';' expected, ,long min = getTimePeriod(getItemCount() - 2)getSerialIndex();
compilation error,345,replace,[CE] missing return statement, double  maxY  =  getMaxY();  ,double minY = getMinY();
compilation error,193,add,[CE] cannot find symbol minX, ,this.minX = Double.NaN / 2;
patch is same with buggy,187,replace,, if(domain  ==  null)  {  this.domain  =  domain;  this.range  =  range;  }  else  {  this.domain  =  domain;  this.range  =  range;  }  ,if(domain == null) { this.domain = domain; this.range = range; } else { this.domain = domain; this.range = range; }
patch is same with buggy,193,replace,, this.minY  =  Double.NaN  /  10;  ,this.minY = Double.NaN / 10;
compilation error,187,add,[CE] not a statement, ,if(domain == null) { this.domain = domain; slated else { this.domain = domain; this.range = range; }
compilation error,187,add,[CE] not a statement, ,if(domain == null) { this.domain = domain; figured else if(domain!= null) { this.domain = domain; this.range = range; }
compilation error,187,add,[CE] not a statement, ,if(domain == null) { this.domain = domain; slated else { this.range = range; }
patch is same with buggy,187,replace,, this.domain  =  domain;  this.timePeriodClass  =  timePeriodClass;  ,this.domain = domain; this.timePeriodClass = timePeriodClass;
compilation error,187,replace,[CE] cannot find symbol periodPeriodClass, this.domain  =  domain;  this.timePeriodClass  =  timePeriodClass;  ,this.domain = domain; this.timePeriodClass = periodPeriodClass;
compilation error,189,add,[CE] cannot find symbol datePeriodClass, ,if(this.datePeriodClass!= null) { this.timePeriodClass = getTimePeriodClass(); }
increase failing tests,189,add, [FE] NullPointerException, ,if(!this.timePeriodClass.isArray()) { this.timePeriodClass = getTimePeriodClass(); }
compilation error,345,add,[CE] cannot find symbol, ,int minimumItemCount = getMinimumItemCount();
compilation error,345,add,[CE] cannot find symbol, ,int minY = getMinimumItemCount();
compilation error,345,add,[CE] cannot find symbol, ,int maximumItemCount = getMinimumItemCount();
patch is same with buggy,194,replace,, this.minY  =  Double.NaN  /  2  +  1;  ,this.minY = Double.NaN / 2 + 1;
increase failing tests,194,replace, [FE] AssertionFailedError, this.minY  =  Double.NaN  /  2  +  1;  ,this.minY = Double.NaN * 2 + 1;
compilation error,345,replace,[CE] cannot find symbol, int  count  =  getMaximumItemCount();  ,double minY = getMiny();
compilation error,194,add,[CE] cannot find symbol NaN, ,this.minY = Long.NaN / 2;
patch is same with buggy,345,replace,, double  maxY  =  getMaxY();  ,double maxY = getMaxY();
compilation error,345,replace,[CE] missing return statement, double  maxY  =  getMaxY();  ,double maxY = getMinY();
increase failing tests,194,replace, [FE] AssertionFailedError, this.minY  =  Double.NaN  /  2  +  1;  ,this.minY = Double.NaN / 1L;
compilation error,637,replace,[CE] illegal start of expression, if(!added)  {  throw  new  SeriesException( "TimeSeriesDataItem  item  does  not  exist: "  +  this);  }  ,[Delete]
compilation error,194,add,[CE] cannot find symbol minX, ,this.minX = Double.NaN / 10;
compilation error,194,add,[CE] cannot find symbol NaN, ,this.minY = Long.NaN / 10;
compilation error,193,replace,[CE] cannot find symbol minX, this.minY  =  Double.NaN  /  2  +  1;  ,this.minX = Double.NaN / 10;
compilation error,1212,add,[CE] illegal start of expression, ,if(yN!= null) { yN = new Double(yN.doubleValue()); >>
compilation error,194,add,[CE] cannot find symbol NaN, ,this.minY = Long.NaN + 1;
patch is same with buggy,1273,replace,, if(Double.isNaN(a)||  Double.isNaN(b))  {  return  a;  }  else  if(Double.isNaN(a)||  Double.isNaN(b))  {  return  Math.min(a,  b);  }  ,if(Double.isNaN(a)|| Double.isNaN(b)) { return a; } else if(Double.isNaN(a)|| Double.isNaN(b)) { return Math.min(a, b); }
patch is same with buggy,1273,replace,, if(Double.isNaN(a)||  Double.isNaN(b))  {  return  a;  }  else  if(Double.isNaN(a)||  Double.isNaN(b))  {  return  Math.min(a,  b);  }  ,if(Double.isNaN(a)|| Double.isNaN(b)) { return a; } else if(Double.isNaN(a)|| Double.isNaN(b)) { return Math.min(a, b); }
patch is same with buggy,634,replace,, if(notify)  {  fireSeriesChanged();  }  ;  if(notify)  {  fireSeriesChanged();  }  ;  //  removeAgedItems(false);  &/  remove  old  items  if  necessary,  //  don't  notify  anyone,  because  that  //  happens  next  anyway  ,if(notify) { fireSeriesChanged(); } ; if(notify) { fireSeriesChanged(); } ; // removeAgedItems(false); &/ remove old items if necessary, // don't notify anyone, because that // happens next anyway
compilation error,634,replace,[CE] not a statement, if(notify)  {  fireSeriesChanged();  }  ;  if(notify)  {  fireSeriesChanged();  }  ;  //  removeAgedItems(false);  &/  remove  old  items  if  necessary,  //  don't  notify  anyone,  because  that  //  happens  next  anyway  ,if(notify) { fireSeriesChanged(); bodied ; if(notify) { fireSeriesChanged(); } ; // removeAgedItems(false); &/ remove old items if necessary, // don't notify anyone, because that // happens next anyway
compilation error,1273,add,[CE] 'else' without 'if', ,else if(Double.isNaN(a)|| Double.isNaN(b)) { return a; } else if(Double.isNaN(a)|| Double.isNaN(b)) { return Math.max(a, b); }
compilation error,576,replace,[CE] <identifier> expected, item  =(TimeSeriesDataItem)item.clone();  if(item  ==  null)  {  throw  new  IllegalArgumentException( " ");  }  ,if(item!= null) { throw new IllegalArgumentException("Null 'item' argument. "); }
increase failing tests,194,replace, [FE] AssertionFailedError, this.minY  =  Double.NaN  /  1;  ,this.minY = Double.NaN * 1;
compilation error,634,add,[CE] not a statement, ,if(notify) { fireSeriesChanged(); } ; if(notify) { fireSeriesChanged(); } ; }!removeAgedItems(true);// remove old items if needed, but // don't notify anybody, because that
compilation error,603,replace,[CE] cannot find symbol last, RegularTimePeriod  second  =  getTimePeriod(getItemCount()  /  2);  ,RegularTimePeriod second = getTimePeriod(getItemCount() / 2 - 1);
patch is same with buggy,603,replace,, RegularTimePeriod  second  =  getTimePeriod(getItemCount()  /  2);  , 
patch is same with buggy,1068,replace,, System.err.println( "Unable  to  add  cloned  data  item...   "  +  clone.toString());  ,System.err.println("Unable to add cloned data item..." + clone.toString());
patch is same with buggy,1068,replace,, System.err.println( "Unable  to  add  cloned  data  item...   "  +  clone.toString());  ,System.err.println("Unable to add cloned data item..." + clone.toString());
compilation error,1296,add,[CE] illegal start of expression, ,if(Double.isNaN(a)|| Double.isNaN(b)) { return b; >>
compilation error,1296,add,[CE] illegal start of expression, ,if(Double.isNaN(a)|| Double.isNaN(b)) } return b; }
compilation error,1273,add,[CE] 'else' without 'if', ,else if(Double.isNaN(a)|| Double.isNaN(b)) { return b; } else if(Double.isNaN(a)|| Double.isNaN(b)) { return Math.max(a, b); }
compilation error,1273,add,[CE] illegal start of expression, ,if(Double.isNaN(a)|| Double.isNaN(b)) } return 1; }
compilation error,1273,add,[CE] illegal start of expression, ,if(Double.isNaN(a)|| Double.isNaN(b)) >> return 1; }
compilation error,634,add,[CE] not a statement, ,if(notify) { fireSeriesChanged(); bodied ; if(notify) { fireSeriesChanged(); } ; // removeAgedItems(false); &/ removeAgedItems(false); &/ removeAgedItems(
compilation error,584,replace,[CE] illegal start of type, else  if(!this.timePeriodClass.isAssignableFrom(c)&&  notify)  {  throw  new  SeriesException( "The  TimeSeries  is  expecting  an  instance  of ");  }  ,else if(!this.timePeriodClass.isAssignableFrom(c)|| notify) { throw new SeriesException("The TimeSeries is expecting an instance of"); }
patch is same with buggy,584,replace,, else  if(!this.timePeriodClass.isAssignableFrom(c)&&  notify)  {  throw  new  SeriesException( "The  TimeSeries  is  expecting  an  instance  of ");  }  ,else if(!this.timePeriodClass.isAssignableFrom(c)&& notify) { throw new SeriesException("The TimeSeries is expecting an instance of"); }
patch is same with buggy,879,replace,, long  min  =  getTimePeriod(getItemCount()  -  2).getSerialIndex();  ,long min = getTimePeriod(getItemCount() - 2).getSerialIndex();
compilation error,193,add,[CE] cannot find symbol minX, ,this.minX = Double.NaN / 2 + 1;
patch is same with buggy,1296,replace,, if(Double.isNaN(a)||  Double.isNaN(b))  {  return  0;  }  ,if(Double.isNaN(a)|| Double.isNaN(b)) { return 0; }
patch is same with buggy,1296,replace,, if(Double.isNaN(a)||  Double.isNaN(b))  {  return  0;  }  ,if(Double.isNaN(a)|| Double.isNaN(b)) { return 0; }
patch is same with buggy,194,replace,, this.minY  =  Double.NaN  /  2;  ,this.minY = Double.NaN / 2;
patch is same with buggy,193,replace,, this.minY  =  Double.NaN  *  1;  , 
increase failing tests,189,replace, [FE] NullPointerException, if(name!=  null)  {  this.timePeriodClass  =  name.getClass();  }  else  if(name!=  null)  {  this.data.add(name);  }  ,if(this.timePeriodClass!= null) { this.timePeriodClass = name.getClass(); } else if(name!= null) { this.data.add(name); }
compilation error,1296,replace,[CE] illegal start of expression, if(Double.isNaN(a)||  Double.isNaN(b))  {  return  b;  }  ,if(Double.isNaN(a)|| Double.isNaN(b)) } return 0; }
patch is same with buggy,194,replace,, this.maxY  =  Double.NaN  +  1;  ,this.maxY = Double.NaN + 1;
patch is same with buggy,878,replace,, long  first  =  getTimePeriod(getItemCount()  -  2).getSerialIndex();  ,long first = getTimePeriod(getItemCount() - 2).getSerialIndex();
patch is same with buggy,187,replace,, this.data  =  new  java.util.ArrayList();  ,this.data = new java.util.ArrayList();
compilation error,187,replace,[CE] cannot find symbol, this.data  =  new  java.util.ArrayList();  ,this.data = new java.util.ArrayListWithCapacity(2);
compilation error,634,add,[CE] illegal start of expression, ,if(notify) { fireSeriesChanged(); } ; if(notify) { fireSeriesChanged(); }? true : false; // removeAgedItems(true); // remove items if needed, // don't notify anyone
compilation error,634,add,[CE] illegal start of expression, ,if(notify) { fireSeriesChanged(); } ; if(notify) { fireSeriesChanged(); }? true : false; // removeAgedItems(true); // remove items if needed, // don't notify
compilation error,345,add,[CE] cannot find symbol, ,int count = getMinimumItemCount();
compilation error,345,add,[CE] cannot find symbol, ,double count = getMinimumItemCount();
compilation error,194,add,[CE] cannot find symbol minX, ,this.minX = Double.NaN / 4;
compilation error,194,add,[CE] cannot find symbol NaN, ,this.minY = Long.NaN / 4;
patch is same with buggy,1053,replace,, System.err.println( "Failed  to  add  cloned  item...   ");  ,System.err.println("Failed to add cloned item...");
patch is same with buggy,1053,replace,, System.err.println( "Failed  to  add  cloned  item...   ");  , 
patch is same with buggy,1269,replace,, if(Double.isNaN(a)||  Double.isNaN(b)||  Double.isNaN(a)&&  Double.isNaN(b))  {  ,if(Double.isNaN(a)|| Double.isNaN(b)|| Double.isNaN(a)&& Double.isNaN(b)) {
patch is same with buggy,584,replace,, else  if(!this.timePeriodClass.isAssignableFrom(c))  {  throw  new  SeriesException( " ");  }  ,else if(!this.timePeriodClass.isAssignableFrom(c)) { throw new SeriesException(""); }
patch is same with buggy,584,replace,, else  if(!this.timePeriodClass.isAssignableFrom(c))  {  throw  new  SeriesException( " ");  }  ,else if(!this.timePeriodClass.isAssignableFrom(c)) { throw new SeriesException(" "); }
patch is same with buggy,345,replace,, int  count  =  getMaximumItemCount();  , 
patch is same with buggy,193,replace,, this.minY  =  Double.NaN  /  2  +  1;  ,this.minY = Double.NaN / 2 + 1;
compilation error,194,add,[CE] cannot find symbol minX, ,this.minX = Double.NaN / 1L;
patch is same with buggy,193,replace,, this.minY  =  Double.NaN  /  2;  ,this.minY = Double.NaN / 2;
patch is same with buggy,188,replace,, this.minY  =  minY;  ,this.minY = minY;
compilation error,187,add,[CE] incompatible types, ,this.domain = new java.util.ArrayList();
increase failing tests,194,replace, [FE] AssertionFailedError, this.minY  =  Double.NaN  /  2  +  1;  ,this.minY = Double.NaN - 2;
compilation error,1068,add,[CE] unclosed string literal, ,System.err.println("Unable to add cloned data item...” + clone.toString());
compilation error,187,add,[CE] illegal start of expression, ,if(domain!= null) { if(domain == null) { throw new IllegalArgumentException(""); }
compilation error,187,add,[CE] illegal start of expression, ,if(domain!= null) { if(domain == null) { this.domain = domain; this.range = range; }
compilation error,187,add,[CE] illegal start of expression, ,if(domain!= null) { if(domain == null) { throw new IllegalArgumentException("TimeSeries is incomplete."); }
patch is same with buggy,1053,replace,, System.err.println( "Failed  to  add  cloned  item...   ");  ,System.err.println("Failed to add cloned item...");
patch is same with buggy,1053,replace,, System.err.println( "Failed  to  add  cloned  item...   ");  , 
compilation error,1269,add,[CE] illegal start of expression, ,if(Double.isNaN(a)&& Double.isNaN(b)|| Double.isNaN(a)&& Double.isNaN(b)) {
compilation error,187,replace,[CE] illegal start of expression, if(domain  ==  null)  {  this.domain  =  domain;  this.range  =  range;  }  else  {  this.domain  =  domain;  this.range  =  range;  }  ,if(domain!= null) { if(domain == null) { this.domain = domain; this.range = range; } else { this.domain = domain; this.range = range; }
patch is same with buggy,194,replace,, this.minY  =  Double.NaN  /  2;  , 
compilation error,576,add,[CE] illegal start of expression, ,if(item.getPeriod().getClass() == this.timePeriodClass) { if(item.getPeriod().getClass() == this.timePeriodClass) { throw new IllegalArgumentException(""); }
compilation error,576,add,[CE] illegal start of expression, ,if(item.getPeriod().getClass()!= this.timePeriodClass) { if(item.getPeriod().getClass() == this.timePeriodClass) { throw new IllegalArgumentException(""); }
compilation error,584,replace,[CE] illegal start of type, else  if(!this.timePeriodClass.isAssignableFrom(c)&&  notify)  {  throw  new  SeriesException( " ");  }  ,else if(this.timePeriodClass.isAssignableFrom(c)&& notify) { throw new SeriesException("The TimeSeries is expecting an instance of"); }
patch is same with buggy,584,replace,, else  if(!this.timePeriodClass.isAssignableFrom(c)&&  notify)  {  throw  new  SeriesException( " ");  }  , 
compilation error,878,add,[CE] illegal start of expression, ,long first = getTimePeriod(getItemCount() -).getSerialIndex();
compilation error,345,replace,[CE] cannot find symbol DateTimeConstants, int  count  =  getMaximumItemCount();  ,double minY = getMinY() / DateTimeConstants.MILLIS_PER_HOUR;
compilation error,193,add,[CE] cannot find symbol NaN, ,this.minY = Long.NaN / 2 + 1;
compilation error,187,add,[CE] cannot find symbol Preconditions, ,Preconditions.checkNotNull(name);
patch is same with buggy,194,replace,, this.minY  =  Double.NaN  /  2  +  1;  ,this.minY = Double.NaN / 2 + 1;
patch is same with buggy,1269,replace,, if(Double.isNaN(a)||  Double.isNaN(b)||  Double.isNaN(a)&&  Double.isNaN(b))  {  ,if(Double.isNaN(a)|| Double.isNaN(b)|| Double.isNaN(a)&& Double.isNaN(b)) {
patch is same with buggy,193,replace,, this.minY  =  Double.NaN  /  2  +  1;  ,this.minY = Double.NaN / 2 + 1;
patch is same with buggy,187,replace,, this.data  =  new  java.util.ArrayList();  ,this.data = new java.util.ArrayList();
compilation error,576,replace,[CE] <identifier> expected, if(item  ==  null)  {  if(item.getPeriod().getClass()!=  this.timePeriodClass)  {  throw  new  IllegalArgumentException( " ");  }  ,if(item.getPeriod().getClass() == this.timePeriodClass) { throw new IllegalArgumentException(""); }
compilation error,576,add,[CE] inconvertible types, ,item =(TimeSeriesDataItem)item.getPeriod().getClass(); if(item == null) { throw new IllegalArgumentException("Null 'item' argument. "); }
patch is same with buggy,193,replace,, this.minY  =  Double.NaN  *  1;  , 
compilation error,194,add,[CE] cannot find symbol minimumItemCount, ,this.minimumItemCount = Long.MAX_VALUE / 4;
compilation error,603,replace,[CE] cannot find symbol last, RegularTimePeriod  second  =  getTimePeriod(getItemCount()  /  2);  ,RegularTimePeriod second = getTimePeriod(getItemCount() / 2 + 1);
compilation error,187,add,[CE] incompatible types, ,if(domain!= null) { this.domain = domain; this.timePeriodClass = new java.util.ArrayList(); }
compilation error,1273,replace,[CE] illegal start of expression, if(Double.isNaN(a)||  Double.isNaN(b))  {  return  b;  }  else  if(Double.isNaN(a)||  Double.isNaN(b))  {  return  Math.max(a,  b);  }  ,if(Double.isNaN(a)|| Double.isNaN(b)) { return a; if(Double.isNaN(a)|| Double.isNaN(b)) {
patch is same with buggy,576,replace,, item  =(TimeSeriesDataItem)item.clone();  if(item  ==  null)  {  throw  new  IllegalArgumentException( " ");  }  ,item =(TimeSeriesDataItem)item.clone(); if(item == null) { throw new IllegalArgumentException(""); }
compilation error,576,replace,[CE] <identifier> expected, item  =(TimeSeriesDataItem)item.clone();  if(item  ==  null)  {  throw  new  IllegalArgumentException( " ");  }  ,item =(TimeSeriesDataItem)item.clone(); if(item!= null) { throw new IllegalArgumentException(""); }
patch is same with buggy,584,replace,, else  if(!this.timePeriodClass.isAssignableFrom(c)&&  notify)  {  throw  new  SeriesException( "The  TimeSeries  is  expecting  an  instance  of ");  }  ,else if(!this.timePeriodClass.isAssignableFrom(c)&& notify) { throw new SeriesException("The TimeSeries is expecting an instance of"); }
patch is same with buggy,584,replace,, else  if(!this.timePeriodClass.isAssignableFrom(c)&&  notify)  {  throw  new  SeriesException( "The  TimeSeries  is  expecting  an  instance  of ");  }  , 
compilation error,1273,add,[CE] illegal start of expression, ,if(Double.isNaN(a)|| Double.isNaN(b)) { return a; if(Double.isNaN(a)|| Double.isNaN(b)) { return Math.min(a, b); }
patch is same with buggy,1296,replace,, if(Double.isNaN(a)||  Double.isNaN(b))  {  return  0;  }  ,if(Double.isNaN(a)|| Double.isNaN(b)) { return 0; }
patch is same with buggy,193,replace,, this.minY  =  Double.NaN  /  2;  ,this.minY = Double.NaN / 2;
compilation error,877,add,[CE] incompatible types, ,int count = getTimePeriod(getItemCount() / 2);
compilation error,345,replace,[CE] missing return statement, double  maxY  =  getMaxY();  ,double minY = getMinY() / getMaxY();
compilation error,194,add,[CE] cannot find symbol minimumItemCount, ,this.minimumItemCount = Long.MAX_VALUE / 2;
compilation error,345,replace,[CE] missing return statement, double  maxY  =  getMaxY();  ,double maxY = getMaxY() - minY;
patch is same with buggy,345,replace,, double  maxY  =  getMaxY();  , 
compilation error,345,add,[CE] cannot find symbol, ,int minY = getMinimumItemAge();
compilation error,584,add,[CE] , ,else if(!this.timePeriodClass.isAssignableFrom(c)) { throw new SeriesException("")); }
patch is same with buggy,189,replace,, if(this.timePeriodClass!=  null)  {  this.timePeriodClass  =  getTimePeriodClass();  }  ,if(this.timePeriodClass!= null) { this.timePeriodClass = getTimePeriodClass(); }
patch is same with buggy,879,replace,, long  min  =  getTimePeriod(getItemCount()  -  2).getSerialIndex();  ,long min = getTimePeriod(getItemCount() - 2).getSerialIndex();
patch is same with buggy,187,replace,, this.domain  =  domain;  this.timePeriodClass  =  timePeriodClass;  ,this.domain = domain; this.timePeriodClass = timePeriodClass;
compilation error,187,replace,[CE] bad operand types for binary operator '+', this.domain  =  domain;  this.timePeriodClass  =  timePeriodClass;  ,this.domain = domain; this.timePeriodClass = timePeriodClass + 1;
compilation error,634,replace,[CE] illegal start of expression, if(notify)  {  fireSeriesChanged();  }  ;  if(notify)  {  fireSeriesChanged();  }  ;  //  removeAgedItems(false);  &/  remove  old  items  if  necessary,  //  don't  notify  anyone,  because  that  //  happens  next  anyway  ,if(getItemCount() > this.maximumItemCount) { TimeSeriesDataItem item =(TimeSeriesDataItem)this.data.get(item); if(added) { fireSeriesChanged(); }
compilation error,634,replace,[CE] illegal start of expression, if(notify)  {  fireSeriesChanged();  }  ;  if(notify)  {  fireSeriesChanged();  }  ;  //  removeAgedItems(false);  &/  remove  old  items  if  necessary,  //  don't  notify  anyone,  because  that  //  happens  next  anyway  ,if(getItemCount() > this.maximumItemCount) { TimeSeriesDataItem item =(TimeSeriesDataItem)this.data.get(item); if(add) { fireSeriesChanged(); }
patch is same with buggy,584,replace,, else  if(!this.timePeriodClass.isAssignableFrom(c)&&  notify)  {  throw  new  SeriesException( " ");  }  ,else if(!this.timePeriodClass.isAssignableFrom(c)&& notify) { throw new SeriesException(""); }
compilation error,1053,add,[CE] unclosed string literal, ,System.err.println("Failed to add cloned item...”);
compilation error,634,add,[CE] illegal start of expression, ,if(getItemCount() > this.maximumItemCount) { TimeSeriesDataItem item =(TimeSeriesDataItem)this.data.get(item); if(!added) { fireSeriesChanged(); }
compilation error,1273,add,[CE] illegal start of expression, ,{
compilation error,637,replace,[CE] class or interface expected, if(!added)  {  throw  new  SeriesException( "TimeSeriesDataItem  item  does  not  exist: "  +  this);  }  ,}
patch is same with buggy,194,replace,, this.minY  =  Double.NaN  /  2;  ,this.minY = Double.NaN / 2;
patch is same with buggy,194,replace,, this.maxY  =  Double.NaN  /  1L;  , 
compilation error,584,add,[CE] , ,else if(!this.timePeriodClass.isAssignableFrom(c)&& notify) { throw new SeriesException("")); }
patch is same with buggy,1068,replace,, System.err.println( "Unable  to  add  cloned  data  item...   "  +  clone.toString());  , 
compilation error,188,replace,[CE] cannot find symbol maximumY, this.maxY  =  minY;  ,this.maxY = maximumY;
compilation error,194,add,[CE] no suitable method found for getDataItem(Comparable), ,this.timePeriodClass = getDataItem(name);
patch is same with buggy,194,replace,, this.maxY  =  Double.NaN  +  1;  ,this.maxY = Double.NaN + 1;
compilation error,634,replace,[CE] not a statement, if(notify)  {  fireSeriesChanged();  }  ;  if(notify)  {  fireSeriesChanged();  }  ;  //  removeAgedItems(false);  &/  remove  items  if  necessary,  //  don't  notify  anyone,  because  that  //  happens  next  anyway  ,if(add) { if(notify) { fireSeriesChanged(); slated
compilation error,634,replace,[CE] not a statement, if(notify)  {  fireSeriesChanged();  }  ;  if(notify)  {  fireSeriesChanged();  }  ;  //  removeAgedItems(false);  &/  remove  items  if  necessary,  //  don't  notify  anyone,  because  that  //  happens  next  anyway  ,if(d.getSeriesCount() > this.maximumItemCount) { if(notify) { fireSeriesChanged(); figured
patch is same with buggy,1296,replace,, if(Double.isNaN(a)||  Double.isNaN(b))  {  return  b;  }  ,if(Double.isNaN(a)|| Double.isNaN(b)) { return b; }
patch is same with buggy,193,replace,, this.minY  =  Double.NaN  /  10;  ,this.minY = Double.NaN / 10;
compilation error,634,replace,[CE] illegal start of expression, removeAgedItems(true);//  remove  old  items  if  needed,  but  //  don't  notify  anybody,  because  that  //  happens  next  anyway...  ,if(removed) { removeAgedItems(true);// remove old items if needed, // don't notify anyone, because that // happens next anyway...
compilation error,1296,replace,[CE] cannot find symbol DateTimeConstants, if(Double.isNaN(a)||  Double.isNaN(b))  {  return  b;  }  ,if(Double.isNaN(a)|| Double.isNaN(b)) { throw new IllegalArgumentException("TimeSeries error:" + DateTimeConstants.MILLIS_PER_SECOND); }
patch is same with buggy,188,replace,, this.minY  =  minY;  ,this.minY = minY;
compilation error,345,add,[CE] incompatible types, ,int minY = this.data.get(maximumItemCount);
patch is same with buggy,1212,replace,, if(yN!=  null)  {  yN  =  new  Double(yN.doubleValue());  }  ,if(yN!= null) { yN = new Double(yN.doubleValue()); }
compilation error,584,replace,[CE] , else  if(!this.timePeriodClass.isAssignableFrom(c)&&  notify)  {  throw  new  SeriesException( " ");  }  ,else if(this.timePeriodClass.equals("")) { throw new SeriesException("")); }
compilation error,187,replace,[CE] illegal start of expression, if(domain  ==  null)  {  this.domain  =  domain;  this.range  =  range;  }  ,if(domain!= null) { if(this.domain == null) { this.domain = domain; this.range = range; }
compilation error,189,add,[CE] illegal start of expression, ,if(this.timePeriodClass!= null) { if(this.timePeriodClass!= null) { this.timePeriodClass = getTimePeriodClass(); }
compilation error,189,add,[CE] illegal start of expression, ,if(this.timePeriodClass!= null) { if(!this.timePeriodClass.isArray()) { this.timePeriodClass = getTimePeriodClass(); }
increase failing tests,576,replace, [FE] IllegalArgumentException, if(item  ==  null)  {  if(item.getPeriod().getClass()  ==  this.timePeriodClass)  {  throw  new  IllegalArgumentException( " ");  }  ,if(item.getPeriod().getClass() == this.timePeriodClass) { if(item.getPeriod().getClass()!= this.timePeriodClass) { throw new IllegalArgumentException(""); }
compilation error,189,add,[CE] generics are not supported in -source 1.4, ,ArrayList < TimeSeries> timePeriodClass = Collections.emptyList();
compilation error,189,add,[CE] cannot find symbol Arrays, ,Arrays.sort(this.data);
patch is same with buggy,584,replace,, else  if(!this.timePeriodClass.isAssignableFrom(c))  {  throw  new  SeriesException( " ");  }  ,else if(!this.timePeriodClass.isAssignableFrom(c)) { throw new SeriesException(""); }
compilation error,1212,add,[CE] illegal start of expression, ,if(item.getItemCount() > 0) { if(yN!= null) { yN = new Double(yN.doubleValue()); }
compilation error,1212,add,[CE] illegal start of expression, ,if(item.getItemCount() > 1) { if(yN!= null) { yN = new Double(yN.doubleValue()); }
compilation error,1212,add,[CE] illegal start of expression, ,if(item.getItemCount() > 0) { if(yN!= null) { yN = new Double(yN.doubleValue() + 1); }
compilation error,194,add,[CE] cannot find symbol minimumItemCount, ,this.minimumItemCount = Long.MAX_VALUE / 2L;
compilation error,188,add,[CE] incompatible types, ,this.minY = minY +" -";
compilation error,1296,add,[CE] reached end of file while parsing, ,if(Double.isNaN(a)|| Double.isNaN(b)) { return a; } else {
compilation error,634,replace,[CE] illegal start of expression, if(notify)  {  fireSeriesChanged();  }  ;  if(notify)  {  fireSeriesChanged();  }  ;  //  removeAgedItems(false);  &/  remove  old  items  if  necessary,  //  don't  notify  anyone,  because  that  //  happens  next  anyway  ,if(item == null) { if(notify) { fireSeriesChanged(); }
compilation error,634,replace,[CE] illegal start of expression, if(notify)  {  fireSeriesChanged();  }  ;  if(notify)  {  fireSeriesChanged();  }  ;  //  removeAgedItems(false);  &/  remove  old  items  if  necessary,  //  don't  notify  anyone,  because  that  //  happens  next  anyway  ,if(getItemCount() < this.maximumItemCount) { if(notify) { fireSeriesChanged(); }
patch is same with buggy,1053,replace,, System.err.println( "Failed  to  add  cloned  item...   ");  ,System.err.println("Failed to add cloned item...");
patch is same with buggy,1053,replace,, System.err.println( "Failed  to  add  cloned  item...   ");  , 
compilation error,345,replace,[CE] missing return statement, int  count  =  getMaximumItemCount();  ,double minY = getMinY() * getMaxY();
patch is same with buggy,187,replace,, if(domain  ==  null)  {  this.domain  =  domain;  this.range  =  range;  }  ,if(domain == null) { this.domain = domain; this.range = range; }
patch is same with buggy,193,replace,, this.minY  =  Double.NaN  /  10;  ,this.minY = Double.NaN / 10;
patch is same with buggy,1296,replace,, if(Double.isNaN(a)||  Double.isNaN(b))  {  return  0;  }  ,if(Double.isNaN(a)|| Double.isNaN(b)) { return 0; }
compilation error,603,replace,[CE] cannot find symbol last, RegularTimePeriod  second  =  getTimePeriod(getItemCount()  /  2);  ,RegularTimePeriod second = getTimePeriod(getItemCount() - 1);
increase failing tests,634,replace, [FE] AssertionFailedError, if(notify)  {  fireSeriesChanged();  }  ;  if(notify)  {  fireSeriesChanged();  }  ;  //  removeAgedItems(false);  &/  remove  old  items  if  necessary,  //  don't  notify  anyone,  because  that  //  happens  next  anyway  ,if(notify) { fireSeriesChanged(); } ; if(notify) { fireSeriesChanged(); } ;
compilation error,634,replace,[CE] not a statement, if(notify)  {  fireSeriesChanged();  }  ;  if(notify)  {  fireSeriesChanged();  }  ;  //  removeAgedItems(false);  &/  remove  old  items  if  necessary,  //  don't  notify  anyone,  because  that  //  happens  next  anyway  ,if(notify) { fireSeriesChanged(); slated ; if(notify) { fireSeriesChanged(); } ;
compilation error,576,add,[CE] illegal start of expression, ,if(item == null) { if(item.getPeriod().getClass() == this.timePeriodClass) { throw new IllegalArgumentException("Null 'item' argument."); }
compilation error,576,add,[CE] illegal start of expression, ,if(item!= null) { if(item.getPeriod().getClass() == this.timePeriodClass) { throw new IllegalArgumentException(""); }
compilation error,345,add,[CE] cannot find symbol, ,int maxY = getMinimumItemCount();
compilation error,345,add,[CE] cannot find symbol count, ,double minY = Double.valueOf(count);
compilation error,345,replace,[CE] cannot find symbol DateTimeConstants, double  maxY  =  getMaxY();  ,double maxY = getMaxY() / DateTimeConstants.MILLIS_PER_HOUR;
compilation error,637,replace,[CE] class or interface expected, if(!added)  {  throw  new  SeriesException( "TimeSeriesDataItem  item  does  not  exist: "  +  this);  }  ,if(!notify) { throw new SeriesException("TimeSeriesDataItem item does not exist:" + this); }
patch is same with buggy,584,replace,, else  if(!this.timePeriodClass.isAssignableFrom(c)&&  notify)  {  throw  new  SeriesException( " ");  }  ,else if(!this.timePeriodClass.isAssignableFrom(c)&& notify) { throw new SeriesException(""); }
compilation error,584,replace,[CE] illegal start of type, else  if(!this.timePeriodClass.isAssignableFrom(c)&&  notify)  {  throw  new  SeriesException( " ");  }  ,else if(this.timePeriodClass.isAssignableFrom(c)) { throw new SeriesException(""); }
patch is same with buggy,193,replace,, this.minY  =  Double.NaN  /  2;  ,this.minY = Double.NaN / 2;
compilation error,187,add,[CE] cannot find symbol, ,Preconditions.checkArgument(!name.isEmpty());
compilation error,187,add,[CE] cannot find symbol Preconditions, ,Preconditions.checkArgument(domain!= null);
compilation error,1296,replace,[CE] ';' expected, if(Double.isNaN(a)||  Double.isNaN(b))  {  return  b;  }  ,return Double.isNaN(a)|| Double.isNaN(b)) { return b; }
patch is same with buggy,1269,replace,, if(Double.isNaN(a)||  Double.isNaN(b)||  Double.isNaN(a)&&  Double.isNaN(b))  {  ,if(Double.isNaN(a)|| Double.isNaN(b)|| Double.isNaN(a)&& Double.isNaN(b)) {
compilation error,1269,add,[CE] ')' expected, ,if(Double.isNaN(a)|| Double.isNaN(b)|| Double.isNaN(a),&& Double.isNaN(b)) {
compilation error,1269,add,[CE] illegal start of expression, ,if(Double.isNaN(a)|| Double.isNaN(b)|| Double.isNaN(a)&& Number.isNaN(b)) {
compilation error,1273,add,[CE] illegal start of expression, ,[Delete] else if(Double.isNaN(a)|| Double.isNaN(b)) { return Math.min(a, b); }
compilation error,1273,add,[CE] 'else' without 'if', ,} else if(Double.isNaN(a)|| Double.isNaN(b)) { return Math.min(a, b); }
patch is same with buggy,877,replace,, int  count  =  getItemCount()  -  2;  ,int count = getItemCount() - 2;
patch is same with buggy,634,replace,, removeAgedItems(true);//  remove  old  items  if  necessary,  //  don't  notify  anyone,  because  that  //  happens  next  anyway...  , 
patch is same with buggy,879,replace,, long  min  =  getTimePeriod(getItemCount()  -  2).getSerialIndex();  ,long min = getTimePeriod(getItemCount() - 2).getSerialIndex();
compilation error,879,replace,[CE] cannot find symbol removed, long  min  =  getTimePeriod(getItemCount()  -  2).getSerialIndex();  ,long min = getTimePeriod(getItemCount() + 2).getSerialIndex();
patch is same with buggy,194,replace,, this.minY  =  Double.NaN  /  2  +  1;  ,this.minY = Double.NaN / 2 + 1;
patch is same with buggy,584,replace,, else  if(!this.timePeriodClass.isAssignableFrom(c)&&  notify)  {  throw  new  SeriesException( " ");  }  ,else if(!this.timePeriodClass.isAssignableFrom(c)&& notify) { throw new SeriesException(""); }
patch is same with buggy,584,replace,, else  if(!this.timePeriodClass.isAssignableFrom(c)&&  notify)  {  throw  new  SeriesException( " ");  }  , 
patch is same with buggy,1068,replace,, System.err.println( "Unable  to  add  cloned  data  item...   "  +  clone.toString());  ,System.err.println("Unable to add cloned data item..." + clone.toString());
patch is same with buggy,1068,replace,, System.err.println( "Unable  to  add  cloned  data  item...   "  +  clone.toString());  ,System.err.println("Unable to add cloned data item... " + clone.toString());
compilation error,1296,replace,[CE] missing return statement, if(Double.isNaN(a)||  Double.isNaN(b))  {  return  b;  }  ,if(Double.isNaN(a)|| Double.isNaN(b)) { return 0; } else if(Double.isNaN(a)|| Double.isNaN(b)) { return 0; }
patch is same with buggy,584,replace,, else  if(!this.timePeriodClass.isAssignableFrom(c)&&  notify)  {  throw  new  SeriesException( "The  TimeSeries  is  expecting  an  instance  of ");  }  ,else if(!this.timePeriodClass.isAssignableFrom(c)&& notify) { throw new SeriesException("The TimeSeries is expecting an instance of"); }
patch is same with buggy,584,replace,, else  if(!this.timePeriodClass.isAssignableFrom(c)&&  notify)  {  throw  new  SeriesException( "The  TimeSeries  is  expecting  an  instance  of ");  }  , 
patch is same with buggy,584,replace,, else  if(!this.timePeriodClass.isAssignableFrom(c))  {  throw  new  SeriesException( " ");  }  ,else if(!this.timePeriodClass.isAssignableFrom(c)) { throw new SeriesException(""); }
patch is same with buggy,634,replace,, removeAgedItems(true);//  remove  old  items  if  needed,  //  don't  notify  anybody,  because  that  //  happens  next  anyway...  , 
compilation error,1053,add,[CE] void cannot be dereferenced, ,System.err.println("Failed to add cloned item...").println("Failed to add cloned item...");
patch is same with buggy,188,replace,, this.minY  =  minY;  ,this.minY = minY;
compilation error,188,replace,[CE] cannot find symbol y, this.minY  =  minY;  ,this.minY = y;
patch is same with buggy,1212,replace,, if(yN!=  null)  {  yN  =  new  Double(yN.doubleValue());  }  ,if(yN!= null) { yN = new Double(yN.doubleValue()); }
patch is same with buggy,193,replace,, this.minY  =  Double.NaN  +  2;  ,this.minY = Double.NaN + 2;
compilation error,189,add,[CE] illegal start of expression, ,if(this.timePeriodClass!= null) { if(this.timePeriodClass == null) { this.timePeriodClass = getTimePeriodClass(); }
compilation error,345,replace,[CE] cannot find symbol, double  maxY  =  getMaxY();  ,double minY = getMINY();
compilation error,576,replace,[CE] <identifier> expected, if(item  ==  null)  {  if(item.getPeriod().getClass()!=  this.timePeriodClass)  {  throw  new  IllegalArgumentException( " ");  }  ,if(item.getPeriod().getClass()!= this.timePeriodClass) { throw new IllegalArgumentException(""); }
patch is same with buggy,194,replace,, this.minY  =  Double.NaN  /  2;  ,this.minY = Double.NaN / 2;
patch is same with buggy,194,replace,, this.maxY  =  Double.NaN  +  1;  ,this.maxY = Double.NaN + 1;
compilation error,189,add,[CE] illegal start of expression, ,if(range == null) { if(name.getClass()!= TimeSeries.MILLIS_PER_SECOND) { this.data.add(name); }
compilation error,189,add,[CE] illegal start of expression, ,if(range == null) { if(name.getClass()!= TimeSeries.MILLIS_PER_HOUR) { this.data.add(name); }
compilation error,189,add,[CE] illegal start of expression, ,if(name.length() > 0) { if(name.getClass()!= null) { this.data.add(name); }
patch is same with buggy,193,replace,, this.minY  =  Double.NaN  *  1;  , 
compilation error,634,add,[CE] illegal start of expression, ,if(item.getPeriod().equals("")) { if(notify) { fireSeriesChanged(); }
compilation error,634,add,[CE] illegal start of expression, ,if(item == null) { if(!added) { fireSeriesChanged(); }
compilation error,189,replace,[CE] illegal start of expression, if(name!=  null)  {  this.timePeriodClass  =  name.getClass();  }  else  if(name!=  null)  {  this.data.add(name);  }  ,if(this.timePeriodClass!= null) { this.timePeriodClass = name.getClass(); if(name!= null) { this.data.add(name); }
patch is same with buggy,878,replace,, long  first  =  getTimePeriod(getItemCount()  -  2).getSerialIndex();  ,long first = getTimePeriod(getItemCount() - 2).getSerialIndex();
compilation error,1212,add,[CE] cannot find symbol yy, ,if(yN!= null) { yN = new Double(yN.doubleValue()); } else { item.setValue(item.getValue()); yy = new Double(yN.doubleValue()); }
compilation error,1212,add,[CE] cannot find symbol yY, ,if(yN!= null) { yN = new Double(yN.doubleValue()); } else { item.setValue(item.getValue()); yY = new Double(yN.doubleValue()); }
compilation error,194,add,[CE] cannot find symbol minItemCount, ,this.minItemCount = Double.NaN / 4;
patch is same with buggy,189,replace,, if(this.timePeriodClass!=  null)  {  this.timePeriodClass  =  getTimePeriodClass();  }  ,if(this.timePeriodClass!= null) { this.timePeriodClass = getTimePeriodClass(); }
patch is same with buggy,187,replace,, this.data  =  new  java.util.ArrayList();  ,this.data = new java.util.ArrayList();
compilation error,187,replace,[CE] cannot find symbol, this.data  =  new  java.util.ArrayList();  ,this.data = new java.util.ArrayList(Domain.class);
increase failing tests,878,add, [FE]  Size, ,long first = getTimePeriod(getItemCount() + 2).getSerialIndex();
patch is same with buggy,187,replace,, this.domain  =  domain;  this.timePeriodClass  =  timePeriodClass;  ,this.domain = domain; this.timePeriodClass = timePeriodClass;
compilation error,187,replace,[CE] cannot find symbol periodClass, this.domain  =  domain;  this.timePeriodClass  =  timePeriodClass;  ,this.domain = domain; this.timePeriodClass = periodClass;
compilation error,193,replace,[CE] ';' expected, this.minY  =  Double.NaN  /  2  +  1;  ,this.minY = Double.NaN / 2, this.maximumItemAge + 1;
patch is same with buggy,193,replace,, this.minY  =  Double.NaN  /  2  +  1;  , 
patch is same with buggy,634,replace,, removeAgedItems(true);//  remove  old  items  if  needed,  but  //  don't  notify  anybody,  because  that  //  happens  next  anyway...  , 
