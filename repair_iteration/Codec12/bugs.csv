bugid	buggy	buggy_class	suspiciousness	buggy_line	endbuggycode	failing_test_number	action	patch
1	[BUG] [BUGGY] super(in); [FE] AssertionError [CONTEXT] protected BaseNCodecInputStream(InputStream in, BaseNCodec baseNCodec, boolean doEncode) { [BUGGY] super(in); [BUGGY] this.doEncode = doEncode; this.baseNCodec = baseNCodec; } [CLASS] BaseNCodecInputStream [METHOD] <init> [RETURN_TYPE] BaseNCodec,boolean)  InputStream in BaseNCodec baseNCodec boolean doEncode [VARIABLES] byte[] singleByte boolean doEncode BaseNCodec baseNCodec InputStream in  	projects/Codec12/src/main/java/org/apache/commons/codec/binary/BaseNCodecInputStream.java	0.5855400437691199	40	40	12	replace	
2	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] protected BaseNCodecInputStream(InputStream in, BaseNCodec baseNCodec, boolean doEncode) { [BUGGY] [BUGGY] super(in); this.doEncode = doEncode; this.baseNCodec = baseNCodec; } [CLASS] BaseNCodecInputStream [METHOD] <init> [RETURN_TYPE] BaseNCodec,boolean)  InputStream in BaseNCodec baseNCodec boolean doEncode [VARIABLES] byte[] singleByte boolean doEncode BaseNCodec baseNCodec InputStream in  	projects/Codec12/src/main/java/org/apache/commons/codec/binary/BaseNCodecInputStream.java	0.5855400437691199	40	40	12	add	
3	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] private final BaseNCodec baseNCodec; [CLASS] BaseNCodecInputStream  [VARIABLES] 	projects/Codec12/src/main/java/org/apache/commons/codec/binary/BaseNCodecInputStream.java	0.5855400437691199	37	37	12	replace	
4	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] private final BaseNCodec baseNCodec; [CLASS] BaseNCodecInputStream  [VARIABLES] 	projects/Codec12/src/main/java/org/apache/commons/codec/binary/BaseNCodecInputStream.java	0.5855400437691199	37	37	12	add	
5	[BUG] [BUGGY] this.doEncode = doEncode; [FE] AssertionError [CONTEXT] protected BaseNCodecInputStream(InputStream in, BaseNCodec baseNCodec, boolean doEncode) { super(in); [BUGGY] this.doEncode = doEncode; [BUGGY] this.baseNCodec = baseNCodec; } [CLASS] BaseNCodecInputStream [METHOD] <init> [RETURN_TYPE] BaseNCodec,boolean)  InputStream in BaseNCodec baseNCodec boolean doEncode [VARIABLES] byte[] singleByte boolean doEncode BaseNCodec baseNCodec InputStream in  	projects/Codec12/src/main/java/org/apache/commons/codec/binary/BaseNCodecInputStream.java	0.5855400437691199	41	41	12	replace	
6	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] protected BaseNCodecInputStream(InputStream in, BaseNCodec baseNCodec, boolean doEncode) { super(in); [BUGGY] [BUGGY] this.doEncode = doEncode; this.baseNCodec = baseNCodec; } [CLASS] BaseNCodecInputStream [METHOD] <init> [RETURN_TYPE] BaseNCodec,boolean)  InputStream in BaseNCodec baseNCodec boolean doEncode [VARIABLES] byte[] singleByte boolean doEncode BaseNCodec baseNCodec InputStream in  	projects/Codec12/src/main/java/org/apache/commons/codec/binary/BaseNCodecInputStream.java	0.5855400437691199	41	41	12	add	
7	[BUG] [BUGGY] this.baseNCodec = baseNCodec; [FE] AssertionError [CONTEXT] protected BaseNCodecInputStream(InputStream in, BaseNCodec baseNCodec, boolean doEncode) { super(in); this.doEncode = doEncode; [BUGGY] this.baseNCodec = baseNCodec; [BUGGY] } [CLASS] BaseNCodecInputStream [METHOD] <init> [RETURN_TYPE] BaseNCodec,boolean)  InputStream in BaseNCodec baseNCodec boolean doEncode [VARIABLES] byte[] singleByte boolean doEncode BaseNCodec baseNCodec InputStream in  	projects/Codec12/src/main/java/org/apache/commons/codec/binary/BaseNCodecInputStream.java	0.5855400437691199	42	42	12	replace	
8	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] protected BaseNCodecInputStream(InputStream in, BaseNCodec baseNCodec, boolean doEncode) { super(in); this.doEncode = doEncode; [BUGGY] [BUGGY] this.baseNCodec = baseNCodec; } [CLASS] BaseNCodecInputStream [METHOD] <init> [RETURN_TYPE] BaseNCodec,boolean)  InputStream in BaseNCodec baseNCodec boolean doEncode [VARIABLES] byte[] singleByte boolean doEncode BaseNCodec baseNCodec InputStream in  	projects/Codec12/src/main/java/org/apache/commons/codec/binary/BaseNCodecInputStream.java	0.5855400437691199	42	42	12	add	
9	[BUG] [BUGGY] } [FE] AssertionError [CONTEXT] protected BaseNCodecInputStream(InputStream in, BaseNCodec baseNCodec, boolean doEncode) { super(in); this.doEncode = doEncode; this.baseNCodec = baseNCodec; [BUGGY] } [BUGGY]  [CLASS] BaseNCodecInputStream [METHOD] <init> [RETURN_TYPE] BaseNCodec,boolean)  InputStream in BaseNCodec baseNCodec boolean doEncode [VARIABLES] byte[] singleByte boolean doEncode BaseNCodec baseNCodec InputStream in  	projects/Codec12/src/main/java/org/apache/commons/codec/binary/BaseNCodecInputStream.java	0.5855400437691199	43	43	12	replace	
10	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] protected BaseNCodecInputStream(InputStream in, BaseNCodec baseNCodec, boolean doEncode) { super(in); this.doEncode = doEncode; this.baseNCodec = baseNCodec; [BUGGY] [BUGGY] } [CLASS] BaseNCodecInputStream [METHOD] <init> [RETURN_TYPE] BaseNCodec,boolean)  InputStream in BaseNCodec baseNCodec boolean doEncode [VARIABLES] byte[] singleByte boolean doEncode BaseNCodec baseNCodec InputStream in  	projects/Codec12/src/main/java/org/apache/commons/codec/binary/BaseNCodecInputStream.java	0.5855400437691199	43	43	12	add	
11	[BUG] [BUGGY] baseNCodec.decode(buf, 0, c); [FE] AssertionError [CONTEXT] if (doEncode) { baseNCodec.encode(buf, 0, c); } else { [BUGGY] baseNCodec.decode(buf, 0, c); [BUGGY] } [CLASS] BaseNCodecInputStream [METHOD] read [RETURN_TYPE] int  byte[] b int offset int len [VARIABLES] byte[] b buf singleByte boolean doEncode BaseNCodec baseNCodec int c len offset readLen  	projects/Codec12/src/main/java/org/apache/commons/codec/binary/BaseNCodecInputStream.java	0.28005601680560194	119	119	12	replace	
12	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] if (doEncode) { baseNCodec.encode(buf, 0, c); } else { [BUGGY] [BUGGY] baseNCodec.decode(buf, 0, c); } [CLASS] BaseNCodecInputStream [METHOD] read [RETURN_TYPE] int  byte[] b int offset int len [VARIABLES] byte[] b buf singleByte boolean doEncode BaseNCodec baseNCodec int c len offset readLen  	projects/Codec12/src/main/java/org/apache/commons/codec/binary/BaseNCodecInputStream.java	0.28005601680560194	119	119	12	add	
13	[BUG] [BUGGY] int readLen = 0; [FE] AssertionError [CONTEXT] } else if (len == 0) { return 0; } else { [BUGGY] int readLen = 0; [BUGGY]  Rationale for while-loop on (readLen == 0): ----- Base32.readResults() usually returns > 0 or EOF (-1).In the rare case where it returns 0, we just keep trying. This is essentially an undocumented contract for InputStream implementors that want their code to work properly with java.io.InputStreamReader, since the latter hates it when InputStream.read(byte[]) returns a zero.Unfortunately our [CLASS] BaseNCodecInputStream [METHOD] read [RETURN_TYPE] int  byte[] b int offset int len [VARIABLES] byte[] b buf singleByte boolean doEncode BaseNCodec baseNCodec int c len offset readLen  	projects/Codec12/src/main/java/org/apache/commons/codec/binary/BaseNCodecInputStream.java	0.26490647141300877	95	95	12	replace	
14	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] } else if (len == 0) { return 0; } else { [BUGGY] [BUGGY] int readLen = 0;  Rationale for while-loop on (readLen == 0): ----- Base32.readResults() usually returns > 0 or EOF (-1).In the rare case where it returns 0, we just keep trying. This is essentially an undocumented contract for InputStream implementors that want their code to work properly with java.io.InputStreamReader, since the latter hates it when InputStream.read(byte[]) returns a zero.Unfortunately our [CLASS] BaseNCodecInputStream [METHOD] read [RETURN_TYPE] int  byte[] b int offset int len [VARIABLES] byte[] b buf singleByte boolean doEncode BaseNCodec baseNCodec int c len offset readLen  	projects/Codec12/src/main/java/org/apache/commons/codec/binary/BaseNCodecInputStream.java	0.26490647141300877	95	95	12	add	
15	[BUG] [BUGGY] while (readLen == 0) { [FE] AssertionError [CONTEXT] This is essentially an undocumented contract for InputStream implementors that want their code to work properly with java.io.InputStreamReader, since the latter hates it when InputStream.read(byte[]) returns a zero.Unfortunately our readResults() call must return 0 if a large amount of the data being decoded was non-base32, so this while-loop enables proper interop with InputStreamReader for that scenario. ----- This is a fix for CODEC-101  [BUGGY] while (readLen == 0) { [BUGGY] if (!baseNCodec.hasData()) { byte[] buf = new byte[doEncode ? 4096 : 8192]; int c = in.read(buf); if (doEncode) { baseNCodec.encode(buf, 0, c); } else { baseNCodec.decode(buf, 0, c); } } readLen = baseNCodec.readResults(b, offset, len); [CLASS] BaseNCodecInputStream [METHOD] read [RETURN_TYPE] int  byte[] b int offset int len [VARIABLES] byte[] b buf singleByte boolean doEncode BaseNCodec baseNCodec int c len offset readLen  	projects/Codec12/src/main/java/org/apache/commons/codec/binary/BaseNCodecInputStream.java	0.26490647141300877	112	112	12	replace	
16	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] This is essentially an undocumented contract for InputStream implementors that want their code to work properly with java.io.InputStreamReader, since the latter hates it when InputStream.read(byte[]) returns a zero.Unfortunately our readResults() call must return 0 if a large amount of the data being decoded was non-base32, so this while-loop enables proper interop with InputStreamReader for that scenario. ----- This is a fix for CODEC-101  [BUGGY] [BUGGY] while (readLen == 0) { if (!baseNCodec.hasData()) { byte[] buf = new byte[doEncode ? 4096 : 8192]; int c = in.read(buf); if (doEncode) { baseNCodec.encode(buf, 0, c); } else { baseNCodec.decode(buf, 0, c); } } readLen = baseNCodec.readResults(b, offset, len); [CLASS] BaseNCodecInputStream [METHOD] read [RETURN_TYPE] int  byte[] b int offset int len [VARIABLES] byte[] b buf singleByte boolean doEncode BaseNCodec baseNCodec int c len offset readLen  	projects/Codec12/src/main/java/org/apache/commons/codec/binary/BaseNCodecInputStream.java	0.26490647141300877	112	112	12	add	
17	[BUG] [BUGGY] if (!baseNCodec.hasData()) { [FE] AssertionError [CONTEXT] implementors that want their code to work properly with java.io.InputStreamReader, since the latter hates it when InputStream.read(byte[]) returns a zero.Unfortunately our readResults() call must return 0 if a large amount of the data being decoded was non-base32, so this while-loop enables proper interop with InputStreamReader for that scenario. ----- This is a fix for CODEC-101  while (readLen == 0) { [BUGGY] if (!baseNCodec.hasData()) { [BUGGY] byte[] buf = new byte[doEncode ? 4096 : 8192]; int c = in.read(buf); if (doEncode) { baseNCodec.encode(buf, 0, c); } else { baseNCodec.decode(buf, 0, c); } } readLen = baseNCodec.readResults(b, offset, len); } [CLASS] BaseNCodecInputStream [METHOD] read [RETURN_TYPE] int  byte[] b int offset int len [VARIABLES] byte[] b buf singleByte boolean doEncode BaseNCodec baseNCodec int c len offset readLen  	projects/Codec12/src/main/java/org/apache/commons/codec/binary/BaseNCodecInputStream.java	0.26490647141300877	113	113	12	replace	
18	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] implementors that want their code to work properly with java.io.InputStreamReader, since the latter hates it when InputStream.read(byte[]) returns a zero.Unfortunately our readResults() call must return 0 if a large amount of the data being decoded was non-base32, so this while-loop enables proper interop with InputStreamReader for that scenario. ----- This is a fix for CODEC-101  while (readLen == 0) { [BUGGY] [BUGGY] if (!baseNCodec.hasData()) { byte[] buf = new byte[doEncode ? 4096 : 8192]; int c = in.read(buf); if (doEncode) { baseNCodec.encode(buf, 0, c); } else { baseNCodec.decode(buf, 0, c); } } readLen = baseNCodec.readResults(b, offset, len); } [CLASS] BaseNCodecInputStream [METHOD] read [RETURN_TYPE] int  byte[] b int offset int len [VARIABLES] byte[] b buf singleByte boolean doEncode BaseNCodec baseNCodec int c len offset readLen  	projects/Codec12/src/main/java/org/apache/commons/codec/binary/BaseNCodecInputStream.java	0.26490647141300877	113	113	12	add	
19	[BUG] [BUGGY] byte[] buf = new byte[doEncode ? 4096 : 8192]; [FE] AssertionError [CONTEXT] java.io.InputStreamReader, since the latter hates it when InputStream.read(byte[]) returns a zero.Unfortunately our readResults() call must return 0 if a large amount of the data being decoded was non-base32, so this while-loop enables proper interop with InputStreamReader for that scenario. ----- This is a fix for CODEC-101  while (readLen == 0) { if (!baseNCodec.hasData()) { [BUGGY] byte[] buf = new byte[doEncode ? 4096 : 8192]; [BUGGY] int c = in.read(buf); if (doEncode) { baseNCodec.encode(buf, 0, c); } else { baseNCodec.decode(buf, 0, c); } } readLen = baseNCodec.readResults(b, offset, len); } return readLen; [CLASS] BaseNCodecInputStream [METHOD] read [RETURN_TYPE] int  byte[] b int offset int len [VARIABLES] byte[] b buf singleByte boolean doEncode BaseNCodec baseNCodec int c len offset readLen  	projects/Codec12/src/main/java/org/apache/commons/codec/binary/BaseNCodecInputStream.java	0.26490647141300877	114	114	12	replace	
20	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] java.io.InputStreamReader, since the latter hates it when InputStream.read(byte[]) returns a zero.Unfortunately our readResults() call must return 0 if a large amount of the data being decoded was non-base32, so this while-loop enables proper interop with InputStreamReader for that scenario. ----- This is a fix for CODEC-101  while (readLen == 0) { if (!baseNCodec.hasData()) { [BUGGY] [BUGGY] byte[] buf = new byte[doEncode ? 4096 : 8192]; int c = in.read(buf); if (doEncode) { baseNCodec.encode(buf, 0, c); } else { baseNCodec.decode(buf, 0, c); } } readLen = baseNCodec.readResults(b, offset, len); } return readLen; [CLASS] BaseNCodecInputStream [METHOD] read [RETURN_TYPE] int  byte[] b int offset int len [VARIABLES] byte[] b buf singleByte boolean doEncode BaseNCodec baseNCodec int c len offset readLen  	projects/Codec12/src/main/java/org/apache/commons/codec/binary/BaseNCodecInputStream.java	0.26490647141300877	114	114	12	add	
21	[BUG] [BUGGY] int c = in.read(buf); [FE] AssertionError [CONTEXT] InputStream.read(byte[]) returns a zero.Unfortunately our readResults() call must return 0 if a large amount of the data being decoded was non-base32, so this while-loop enables proper interop with InputStreamReader for that scenario. ----- This is a fix for CODEC-101  while (readLen == 0) { if (!baseNCodec.hasData()) { byte[] buf = new byte[doEncode ? 4096 : 8192]; [BUGGY] int c = in.read(buf); [BUGGY] if (doEncode) { baseNCodec.encode(buf, 0, c); } else { baseNCodec.decode(buf, 0, c); } } readLen = baseNCodec.readResults(b, offset, len); } return readLen; } [CLASS] BaseNCodecInputStream [METHOD] read [RETURN_TYPE] int  byte[] b int offset int len [VARIABLES] byte[] b buf singleByte boolean doEncode BaseNCodec baseNCodec int c len offset readLen  	projects/Codec12/src/main/java/org/apache/commons/codec/binary/BaseNCodecInputStream.java	0.26490647141300877	115	115	12	replace	
22	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] InputStream.read(byte[]) returns a zero.Unfortunately our readResults() call must return 0 if a large amount of the data being decoded was non-base32, so this while-loop enables proper interop with InputStreamReader for that scenario. ----- This is a fix for CODEC-101  while (readLen == 0) { if (!baseNCodec.hasData()) { byte[] buf = new byte[doEncode ? 4096 : 8192]; [BUGGY] [BUGGY] int c = in.read(buf); if (doEncode) { baseNCodec.encode(buf, 0, c); } else { baseNCodec.decode(buf, 0, c); } } readLen = baseNCodec.readResults(b, offset, len); } return readLen; } [CLASS] BaseNCodecInputStream [METHOD] read [RETURN_TYPE] int  byte[] b int offset int len [VARIABLES] byte[] b buf singleByte boolean doEncode BaseNCodec baseNCodec int c len offset readLen  	projects/Codec12/src/main/java/org/apache/commons/codec/binary/BaseNCodecInputStream.java	0.26490647141300877	115	115	12	add	
23	[BUG] [BUGGY] if (doEncode) { [FE] AssertionError [CONTEXT] readResults() call must return 0 if a large amount of the data being decoded was non-base32, so this while-loop enables proper interop with InputStreamReader for that scenario. ----- This is a fix for CODEC-101  while (readLen == 0) { if (!baseNCodec.hasData()) { byte[] buf = new byte[doEncode ? 4096 : 8192]; int c = in.read(buf); [BUGGY] if (doEncode) { [BUGGY] baseNCodec.encode(buf, 0, c); } else { baseNCodec.decode(buf, 0, c); } } readLen = baseNCodec.readResults(b, offset, len); } return readLen; } } [CLASS] BaseNCodecInputStream [METHOD] read [RETURN_TYPE] int  byte[] b int offset int len [VARIABLES] byte[] b buf singleByte boolean doEncode BaseNCodec baseNCodec int c len offset readLen  	projects/Codec12/src/main/java/org/apache/commons/codec/binary/BaseNCodecInputStream.java	0.26490647141300877	116	116	12	replace	
24	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] readResults() call must return 0 if a large amount of the data being decoded was non-base32, so this while-loop enables proper interop with InputStreamReader for that scenario. ----- This is a fix for CODEC-101  while (readLen == 0) { if (!baseNCodec.hasData()) { byte[] buf = new byte[doEncode ? 4096 : 8192]; int c = in.read(buf); [BUGGY] [BUGGY] if (doEncode) { baseNCodec.encode(buf, 0, c); } else { baseNCodec.decode(buf, 0, c); } } readLen = baseNCodec.readResults(b, offset, len); } return readLen; } } [CLASS] BaseNCodecInputStream [METHOD] read [RETURN_TYPE] int  byte[] b int offset int len [VARIABLES] byte[] b buf singleByte boolean doEncode BaseNCodec baseNCodec int c len offset readLen  	projects/Codec12/src/main/java/org/apache/commons/codec/binary/BaseNCodecInputStream.java	0.26490647141300877	116	116	12	add	
25	[BUG] [BUGGY] readLen = baseNCodec.readResults(b, offset, len); [FE] AssertionError [CONTEXT] while (readLen == 0) { if (!baseNCodec.hasData()) { byte[] buf = new byte[doEncode ? 4096 : 8192]; int c = in.read(buf); if (doEncode) { baseNCodec.encode(buf, 0, c); } else { baseNCodec.decode(buf, 0, c); } } [BUGGY] readLen = baseNCodec.readResults(b, offset, len); [BUGGY] } return readLen; } } [CLASS] BaseNCodecInputStream [METHOD] read [RETURN_TYPE] int  byte[] b int offset int len [VARIABLES] byte[] b buf singleByte boolean doEncode BaseNCodec baseNCodec int c len offset readLen  	projects/Codec12/src/main/java/org/apache/commons/codec/binary/BaseNCodecInputStream.java	0.26490647141300877	122	122	12	replace	
26	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] while (readLen == 0) { if (!baseNCodec.hasData()) { byte[] buf = new byte[doEncode ? 4096 : 8192]; int c = in.read(buf); if (doEncode) { baseNCodec.encode(buf, 0, c); } else { baseNCodec.decode(buf, 0, c); } } [BUGGY] [BUGGY] readLen = baseNCodec.readResults(b, offset, len); } return readLen; } } [CLASS] BaseNCodecInputStream [METHOD] read [RETURN_TYPE] int  byte[] b int offset int len [VARIABLES] byte[] b buf singleByte boolean doEncode BaseNCodec baseNCodec int c len offset readLen  	projects/Codec12/src/main/java/org/apache/commons/codec/binary/BaseNCodecInputStream.java	0.26490647141300877	122	122	12	add	
27	[BUG] [BUGGY] return readLen; [FE] AssertionError [CONTEXT] byte[] buf = new byte[doEncode ? 4096 : 8192]; int c = in.read(buf); if (doEncode) { baseNCodec.encode(buf, 0, c); } else { baseNCodec.decode(buf, 0, c); } } readLen = baseNCodec.readResults(b, offset, len); } [BUGGY] return readLen; [BUGGY] } } [CLASS] BaseNCodecInputStream [METHOD] read [RETURN_TYPE] int  byte[] b int offset int len [VARIABLES] byte[] b buf singleByte boolean doEncode BaseNCodec baseNCodec int c len offset readLen  	projects/Codec12/src/main/java/org/apache/commons/codec/binary/BaseNCodecInputStream.java	0.26490647141300877	124	124	12	replace	
28	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] byte[] buf = new byte[doEncode ? 4096 : 8192]; int c = in.read(buf); if (doEncode) { baseNCodec.encode(buf, 0, c); } else { baseNCodec.decode(buf, 0, c); } } readLen = baseNCodec.readResults(b, offset, len); } [BUGGY] [BUGGY] return readLen; } } [CLASS] BaseNCodecInputStream [METHOD] read [RETURN_TYPE] int  byte[] b int offset int len [VARIABLES] byte[] b buf singleByte boolean doEncode BaseNCodec baseNCodec int c len offset readLen  	projects/Codec12/src/main/java/org/apache/commons/codec/binary/BaseNCodecInputStream.java	0.26490647141300877	124	124	12	add	
29	[BUG] [BUGGY] } else if (len == 0) { [FE] AssertionError [CONTEXT] public int read(byte b[], int offset, int len) throws IOException { if (b == null) { throw new NullPointerException(); } else if (offset < 0 || len < 0) { throw new IndexOutOfBoundsException(); } else if (offset > b.length || offset + len > b.length) { throw new IndexOutOfBoundsException(); [BUGGY] } else if (len == 0) { [BUGGY] return 0; } else { int readLen = 0;  Rationale for while-loop on (readLen == 0): ----- Base32.readResults() usually returns > 0 or EOF (-1).In the rare case where it returns 0, we just keep trying. This is essentially an undocumented contract for InputStream [CLASS] BaseNCodecInputStream [METHOD] read [RETURN_TYPE] int  byte[] b int offset int len [VARIABLES] byte[] b buf singleByte boolean doEncode BaseNCodec baseNCodec int c len offset readLen  	projects/Codec12/src/main/java/org/apache/commons/codec/binary/BaseNCodecInputStream.java	0.2519763153394848	92	92	12	replace	
30	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] public int read(byte b[], int offset, int len) throws IOException { if (b == null) { throw new NullPointerException(); } else if (offset < 0 || len < 0) { throw new IndexOutOfBoundsException(); } else if (offset > b.length || offset + len > b.length) { throw new IndexOutOfBoundsException(); [BUGGY] [BUGGY] } else if (len == 0) { return 0; } else { int readLen = 0;  Rationale for while-loop on (readLen == 0): ----- Base32.readResults() usually returns > 0 or EOF (-1).In the rare case where it returns 0, we just keep trying. This is essentially an undocumented contract for InputStream [CLASS] BaseNCodecInputStream [METHOD] read [RETURN_TYPE] int  byte[] b int offset int len [VARIABLES] byte[] b buf singleByte boolean doEncode BaseNCodec baseNCodec int c len offset readLen  	projects/Codec12/src/main/java/org/apache/commons/codec/binary/BaseNCodecInputStream.java	0.2519763153394848	92	92	12	add	
31	[BUG] [BUGGY] } else if (offset < 0 || len < 0) { [FE] AssertionError [CONTEXT] public int read(byte b[], int offset, int len) throws IOException { if (b == null) { throw new NullPointerException(); [BUGGY] } else if (offset < 0 || len < 0) { [BUGGY] throw new IndexOutOfBoundsException(); } else if (offset > b.length || offset + len > b.length) { throw new IndexOutOfBoundsException(); } else if (len == 0) { return 0; } else { int readLen = 0;  Rationale for while-loop on (readLen == 0): ----- [CLASS] BaseNCodecInputStream [METHOD] read [RETURN_TYPE] int  byte[] b int offset int len [VARIABLES] byte[] b buf singleByte boolean doEncode BaseNCodec baseNCodec int c len offset readLen  	projects/Codec12/src/main/java/org/apache/commons/codec/binary/BaseNCodecInputStream.java	0.2407717061715384	88	88	12	replace	
32	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] public int read(byte b[], int offset, int len) throws IOException { if (b == null) { throw new NullPointerException(); [BUGGY] [BUGGY] } else if (offset < 0 || len < 0) { throw new IndexOutOfBoundsException(); } else if (offset > b.length || offset + len > b.length) { throw new IndexOutOfBoundsException(); } else if (len == 0) { return 0; } else { int readLen = 0;  Rationale for while-loop on (readLen == 0): ----- [CLASS] BaseNCodecInputStream [METHOD] read [RETURN_TYPE] int  byte[] b int offset int len [VARIABLES] byte[] b buf singleByte boolean doEncode BaseNCodec baseNCodec int c len offset readLen  	projects/Codec12/src/main/java/org/apache/commons/codec/binary/BaseNCodecInputStream.java	0.2407717061715384	88	88	12	add	
33	[BUG] [BUGGY] } else if (offset > b.length || offset + len > b.length) { [FE] AssertionError [CONTEXT] public int read(byte b[], int offset, int len) throws IOException { if (b == null) { throw new NullPointerException(); } else if (offset < 0 || len < 0) { throw new IndexOutOfBoundsException(); [BUGGY] } else if (offset > b.length || offset + len > b.length) { [BUGGY] throw new IndexOutOfBoundsException(); } else if (len == 0) { return 0; } else { int readLen = 0;  Rationale for while-loop on (readLen == 0): ----- Base32.readResults() usually returns > 0 or EOF (-1).In the rare case where it returns 0, we just keep trying. [CLASS] BaseNCodecInputStream [METHOD] read [RETURN_TYPE] int  byte[] b int offset int len [VARIABLES] byte[] b buf singleByte boolean doEncode BaseNCodec baseNCodec int c len offset readLen  	projects/Codec12/src/main/java/org/apache/commons/codec/binary/BaseNCodecInputStream.java	0.2407717061715384	90	90	12	replace	
34	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] public int read(byte b[], int offset, int len) throws IOException { if (b == null) { throw new NullPointerException(); } else if (offset < 0 || len < 0) { throw new IndexOutOfBoundsException(); [BUGGY] [BUGGY] } else if (offset > b.length || offset + len > b.length) { throw new IndexOutOfBoundsException(); } else if (len == 0) { return 0; } else { int readLen = 0;  Rationale for while-loop on (readLen == 0): ----- Base32.readResults() usually returns > 0 or EOF (-1).In the rare case where it returns 0, we just keep trying. [CLASS] BaseNCodecInputStream [METHOD] read [RETURN_TYPE] int  byte[] b int offset int len [VARIABLES] byte[] b buf singleByte boolean doEncode BaseNCodec baseNCodec int c len offset readLen  	projects/Codec12/src/main/java/org/apache/commons/codec/binary/BaseNCodecInputStream.java	0.2407717061715384	90	90	12	add	
35	[BUG] [BUGGY] final byte b = singleByte[0]; [FE] AssertionError [CONTEXT] public int read() throws IOException { int r = read(singleByte, 0, 1); while (r == 0) { r = read(singleByte, 0, 1); } if (r > 0) { [BUGGY] final byte b = singleByte[0]; [BUGGY] return b < 0 ? 256 + b : b; } return EOF; } [CLASS] BaseNCodecInputStream [METHOD] read [RETURN_TYPE] int  [VARIABLES] byte[] singleByte boolean doEncode BaseNCodec baseNCodec int r byte b  	projects/Codec12/src/main/java/org/apache/commons/codec/binary/BaseNCodecInputStream.java	0.23570226039551587	59	59	12	replace	
36	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] public int read() throws IOException { int r = read(singleByte, 0, 1); while (r == 0) { r = read(singleByte, 0, 1); } if (r > 0) { [BUGGY] [BUGGY] final byte b = singleByte[0]; return b < 0 ? 256 + b : b; } return EOF; } [CLASS] BaseNCodecInputStream [METHOD] read [RETURN_TYPE] int  [VARIABLES] byte[] singleByte boolean doEncode BaseNCodec baseNCodec int r byte b  	projects/Codec12/src/main/java/org/apache/commons/codec/binary/BaseNCodecInputStream.java	0.23570226039551587	59	59	12	add	
37	[BUG] [BUGGY] return b < 0 ? 256 + b : b; [FE] AssertionError [CONTEXT] public int read() throws IOException { int r = read(singleByte, 0, 1); while (r == 0) { r = read(singleByte, 0, 1); } if (r > 0) { final byte b = singleByte[0]; [BUGGY] return b < 0 ? 256 + b : b; [BUGGY] } return EOF; } [CLASS] BaseNCodecInputStream [METHOD] read [RETURN_TYPE] int  [VARIABLES] byte[] singleByte boolean doEncode BaseNCodec baseNCodec int r byte b  	projects/Codec12/src/main/java/org/apache/commons/codec/binary/BaseNCodecInputStream.java	0.23570226039551587	60	60	12	replace	
38	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] public int read() throws IOException { int r = read(singleByte, 0, 1); while (r == 0) { r = read(singleByte, 0, 1); } if (r > 0) { final byte b = singleByte[0]; [BUGGY] [BUGGY] return b < 0 ? 256 + b : b; } return EOF; } [CLASS] BaseNCodecInputStream [METHOD] read [RETURN_TYPE] int  [VARIABLES] byte[] singleByte boolean doEncode BaseNCodec baseNCodec int r byte b  	projects/Codec12/src/main/java/org/apache/commons/codec/binary/BaseNCodecInputStream.java	0.23570226039551587	60	60	12	add	
39	[BUG] [BUGGY] if (b == null) { [FE] AssertionError [CONTEXT] public int read(byte b[], int offset, int len) throws IOException { [BUGGY] if (b == null) { [BUGGY] throw new NullPointerException(); } else if (offset < 0 || len < 0) { throw new IndexOutOfBoundsException(); } else if (offset > b.length || offset + len > b.length) { throw new IndexOutOfBoundsException(); } else if (len == 0) { return 0; } else { int readLen = 0;  [CLASS] BaseNCodecInputStream [METHOD] read [RETURN_TYPE] int  byte[] b int offset int len [VARIABLES] byte[] b buf singleByte boolean doEncode BaseNCodec baseNCodec int c len offset readLen  	projects/Codec12/src/main/java/org/apache/commons/codec/binary/BaseNCodecInputStream.java	0.23094010767585027	86	86	12	replace	
40	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] public int read(byte b[], int offset, int len) throws IOException { [BUGGY] [BUGGY] if (b == null) { throw new NullPointerException(); } else if (offset < 0 || len < 0) { throw new IndexOutOfBoundsException(); } else if (offset > b.length || offset + len > b.length) { throw new IndexOutOfBoundsException(); } else if (len == 0) { return 0; } else { int readLen = 0;  [CLASS] BaseNCodecInputStream [METHOD] read [RETURN_TYPE] int  byte[] b int offset int len [VARIABLES] byte[] b buf singleByte boolean doEncode BaseNCodec baseNCodec int c len offset readLen  	projects/Codec12/src/main/java/org/apache/commons/codec/binary/BaseNCodecInputStream.java	0.23094010767585027	86	86	12	add	
