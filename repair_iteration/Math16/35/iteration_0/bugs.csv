bugid	buggy	buggy_class	suspiciousness	buggy_line	endbuggycode	failing_test_number	action	patch
69	[BUG] [BUGGY] final double tempC = tempB + tempA; [FE] AssertionError [CONTEXT] tempA is exact since intPartA and intPartB only have 22 bits each. tempB will have 52 bits of precision.  double tempA = intPartA * fracPartA; double tempB = intPartA * fracPartB + intPartB * fracPartA + intPartB * fracPartB;  important.For accuracy add by increasing size.tempA is exact and much larger than the others.If there are extra bits specified from the pow() function, use them. */ [BUGGY] final double tempC = tempB + tempA; [BUGGY] final double result; if (extra != 0.0) { result = tempC*extra*z + tempC*extra + tempC*z + tempB + tempA; } else { result = tempC*z + tempB + tempA; } if (hiPrec != null) {  hiPrec[0] = tempA; [CLASS] FastMath ExpIntTable ExpFracTable lnMant CodyWaite [METHOD] exp [RETURN_TYPE] double  double x double extra double[] hiPrec [VARIABLES] boolean RECOMPUTE_TABLES_AT_RUNTIME negate negative double[] CBRTTWO COSINE_TABLE_A COSINE_TABLE_B EIGHTHS EXP_FRAC_TABLE_A EXP_FRAC_TABLE_B EXP_INT_TABLE_A EXP_INT_TABLE_B SINE_TABLE_A SINE_TABLE_B TANGENT_TABLE_A TANGENT_TABLE_B hiPrec long[] PI_O_4_BITS RECIP_2PI double E F_11_12 F_13_14 F_15_16 F_1_11 F_1_13 F_1_15 F_1_17 F_1_2 F_1_3 F_1_4 F_1_5 F_1_7 F_1_9 F_3_4 F_5_6 F_7_8 F_9_10 LN_2_A LN_2_B PI TWO_POWER_52 a a2 absAsinh absAtanh b d da daa dab db denom denomb denomr epsilon extra finalRemA finalRemB fracPartA fracPartB intPartA intPartB na nb ra ratio ratioa ratiob rb recip recipa recipb remA remB result temp tempA tempB tempC x xa xb ya yaa yab yb z za zb double[][] LN_HI_PREC_COEF LN_MANT LN_QUICK_COEF int EXP_FRAC_TABLE_LEN EXP_INT_TABLE_LEN EXP_INT_TABLE_MAX_INDEX LN_MANT_LEN SINE_TABLE_LEN finalK intFrac intVal k long HEX_40000000 MASK_30BITS xl  	projects/Math16/src/main/java/org/apache/commons/math3/util/FastMath.java	0.4082482904638631	920	920	2	replace	
70	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] tempA is exact since intPartA and intPartB only have 22 bits each. tempB will have 52 bits of precision.  double tempA = intPartA * fracPartA; double tempB = intPartA * fracPartB + intPartB * fracPartA + intPartB * fracPartB;  important.For accuracy add by increasing size.tempA is exact and much larger than the others.If there are extra bits specified from the pow() function, use them. */ [BUGGY] [BUGGY] final double tempC = tempB + tempA; final double result; if (extra != 0.0) { result = tempC*extra*z + tempC*extra + tempC*z + tempB + tempA; } else { result = tempC*z + tempB + tempA; } if (hiPrec != null) {  hiPrec[0] = tempA; [CLASS] FastMath ExpIntTable ExpFracTable lnMant CodyWaite [METHOD] exp [RETURN_TYPE] double  double x double extra double[] hiPrec [VARIABLES] boolean RECOMPUTE_TABLES_AT_RUNTIME negate negative double[] CBRTTWO COSINE_TABLE_A COSINE_TABLE_B EIGHTHS EXP_FRAC_TABLE_A EXP_FRAC_TABLE_B EXP_INT_TABLE_A EXP_INT_TABLE_B SINE_TABLE_A SINE_TABLE_B TANGENT_TABLE_A TANGENT_TABLE_B hiPrec long[] PI_O_4_BITS RECIP_2PI double E F_11_12 F_13_14 F_15_16 F_1_11 F_1_13 F_1_15 F_1_17 F_1_2 F_1_3 F_1_4 F_1_5 F_1_7 F_1_9 F_3_4 F_5_6 F_7_8 F_9_10 LN_2_A LN_2_B PI TWO_POWER_52 a a2 absAsinh absAtanh b d da daa dab db denom denomb denomr epsilon extra finalRemA finalRemB fracPartA fracPartB intPartA intPartB na nb ra ratio ratioa ratiob rb recip recipa recipb remA remB result temp tempA tempB tempC x xa xb ya yaa yab yb z za zb double[][] LN_HI_PREC_COEF LN_MANT LN_QUICK_COEF int EXP_FRAC_TABLE_LEN EXP_INT_TABLE_LEN EXP_INT_TABLE_MAX_INDEX LN_MANT_LEN SINE_TABLE_LEN finalK intFrac intVal k long HEX_40000000 MASK_30BITS xl  	projects/Math16/src/main/java/org/apache/commons/math3/util/FastMath.java	0.4082482904638631	920	920	2	add	
