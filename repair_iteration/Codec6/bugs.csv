bugid	buggy	buggy_class	suspiciousness	buggy_line	endbuggycode	failing_test_number	action	patch
1	[BUG] [BUGGY] base64.setInitialBuffer(b, offset, len); [FE] AssertionFailedError [CONTEXT] interop with InputStreamReader for that scenario. ----- This is a fix for CODEC-101  if (!base64.hasData()) { byte[] buf = new byte[doEncode ? 4096 : 8192]; int c = in.read(buf);   if (c > 0 && b.length == len) { [BUGGY] base64.setInitialBuffer(b, offset, len); [BUGGY] } if (doEncode) { base64.encode(buf, 0, c); } else { base64.decode(buf, 0, c); } } return base64.readResults(b, offset, len); } [CLASS] Base64InputStream [METHOD] read [RETURN_TYPE] int  byte[] b int offset int len [VARIABLES] byte[] b buf lineSeparator singleByte boolean doEncode Base64 base64 int c len offset  	projects/Codec6/src/java/org/apache/commons/codec/binary/Base64InputStream.java	0.5	170	170	1	replace	
2	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] interop with InputStreamReader for that scenario. ----- This is a fix for CODEC-101  if (!base64.hasData()) { byte[] buf = new byte[doEncode ? 4096 : 8192]; int c = in.read(buf);   if (c > 0 && b.length == len) { [BUGGY] [BUGGY] base64.setInitialBuffer(b, offset, len); } if (doEncode) { base64.encode(buf, 0, c); } else { base64.decode(buf, 0, c); } } return base64.readResults(b, offset, len); } [CLASS] Base64InputStream [METHOD] read [RETURN_TYPE] int  byte[] b int offset int len [VARIABLES] byte[] b buf lineSeparator singleByte boolean doEncode Base64 base64 int c len offset  	projects/Codec6/src/java/org/apache/commons/codec/binary/Base64InputStream.java	0.5	170	170	1	add	
3	[BUG] [BUGGY] this(in, false); [FE] AssertionFailedError [CONTEXT] public Base64InputStream(InputStream in) { [BUGGY] this(in, false); [BUGGY] } [CLASS] Base64InputStream [METHOD] <init> [RETURN_TYPE] InputStream)  InputStream in [VARIABLES] byte[] singleByte boolean doEncode Base64 base64 InputStream in  	projects/Codec6/src/java/org/apache/commons/codec/binary/Base64InputStream.java	0.4082482904638631	61	61	1	replace	
4	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] public Base64InputStream(InputStream in) { [BUGGY] [BUGGY] this(in, false); } [CLASS] Base64InputStream [METHOD] <init> [RETURN_TYPE] InputStream)  InputStream in [VARIABLES] byte[] singleByte boolean doEncode Base64 base64 InputStream in  	projects/Codec6/src/java/org/apache/commons/codec/binary/Base64InputStream.java	0.4082482904638631	61	61	1	add	
5	[BUG] [BUGGY] } [FE] AssertionFailedError [CONTEXT] public Base64InputStream(InputStream in) { this(in, false); [BUGGY] } [BUGGY]  [CLASS] Base64InputStream [METHOD] <init> [RETURN_TYPE] InputStream)  InputStream in [VARIABLES] byte[] singleByte boolean doEncode Base64 base64 InputStream in  	projects/Codec6/src/java/org/apache/commons/codec/binary/Base64InputStream.java	0.4082482904638631	62	62	1	replace	
6	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] public Base64InputStream(InputStream in) { this(in, false); [BUGGY] [BUGGY] } [CLASS] Base64InputStream [METHOD] <init> [RETURN_TYPE] InputStream)  InputStream in [VARIABLES] byte[] singleByte boolean doEncode Base64 base64 InputStream in  	projects/Codec6/src/java/org/apache/commons/codec/binary/Base64InputStream.java	0.4082482904638631	62	62	1	add	
7	[BUG] [BUGGY] super(in); [FE] AssertionFailedError [CONTEXT] public Base64InputStream(InputStream in, boolean doEncode) { [BUGGY] super(in); [BUGGY] this.doEncode = doEncode; this.base64 = new Base64(false); } [CLASS] Base64InputStream [METHOD] <init> [RETURN_TYPE] InputStream,boolean)  InputStream in boolean doEncode [VARIABLES] byte[] singleByte boolean doEncode Base64 base64 InputStream in  	projects/Codec6/src/java/org/apache/commons/codec/binary/Base64InputStream.java	0.4082482904638631	74	74	1	replace	
8	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] public Base64InputStream(InputStream in, boolean doEncode) { [BUGGY] [BUGGY] super(in); this.doEncode = doEncode; this.base64 = new Base64(false); } [CLASS] Base64InputStream [METHOD] <init> [RETURN_TYPE] InputStream,boolean)  InputStream in boolean doEncode [VARIABLES] byte[] singleByte boolean doEncode Base64 base64 InputStream in  	projects/Codec6/src/java/org/apache/commons/codec/binary/Base64InputStream.java	0.4082482904638631	74	74	1	add	
9	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] private final Base64 base64; [CLASS] Base64InputStream  [VARIABLES] 	projects/Codec6/src/java/org/apache/commons/codec/binary/Base64InputStream.java	0.4082482904638631	52	52	1	replace	
10	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] private final Base64 base64; [CLASS] Base64InputStream  [VARIABLES] 	projects/Codec6/src/java/org/apache/commons/codec/binary/Base64InputStream.java	0.4082482904638631	52	52	1	add	
11	[BUG] [BUGGY] this.doEncode = doEncode; [FE] AssertionFailedError [CONTEXT] public Base64InputStream(InputStream in, boolean doEncode) { super(in); [BUGGY] this.doEncode = doEncode; [BUGGY] this.base64 = new Base64(false); } [CLASS] Base64InputStream [METHOD] <init> [RETURN_TYPE] InputStream,boolean)  InputStream in boolean doEncode [VARIABLES] byte[] singleByte boolean doEncode Base64 base64 InputStream in  	projects/Codec6/src/java/org/apache/commons/codec/binary/Base64InputStream.java	0.4082482904638631	75	75	1	replace	
12	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] public Base64InputStream(InputStream in, boolean doEncode) { super(in); [BUGGY] [BUGGY] this.doEncode = doEncode; this.base64 = new Base64(false); } [CLASS] Base64InputStream [METHOD] <init> [RETURN_TYPE] InputStream,boolean)  InputStream in boolean doEncode [VARIABLES] byte[] singleByte boolean doEncode Base64 base64 InputStream in  	projects/Codec6/src/java/org/apache/commons/codec/binary/Base64InputStream.java	0.4082482904638631	75	75	1	add	
13	[BUG] [BUGGY] this.base64 = new Base64(false); [FE] AssertionFailedError [CONTEXT] public Base64InputStream(InputStream in, boolean doEncode) { super(in); this.doEncode = doEncode; [BUGGY] this.base64 = new Base64(false); [BUGGY] } [CLASS] Base64InputStream [METHOD] <init> [RETURN_TYPE] InputStream,boolean)  InputStream in boolean doEncode [VARIABLES] byte[] singleByte boolean doEncode Base64 base64 InputStream in  	projects/Codec6/src/java/org/apache/commons/codec/binary/Base64InputStream.java	0.4082482904638631	76	76	1	replace	
14	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] public Base64InputStream(InputStream in, boolean doEncode) { super(in); this.doEncode = doEncode; [BUGGY] [BUGGY] this.base64 = new Base64(false); } [CLASS] Base64InputStream [METHOD] <init> [RETURN_TYPE] InputStream,boolean)  InputStream in boolean doEncode [VARIABLES] byte[] singleByte boolean doEncode Base64 base64 InputStream in  	projects/Codec6/src/java/org/apache/commons/codec/binary/Base64InputStream.java	0.4082482904638631	76	76	1	add	
15	[BUG] [BUGGY] } [FE] AssertionFailedError [CONTEXT] public Base64InputStream(InputStream in, boolean doEncode) { super(in); this.doEncode = doEncode; this.base64 = new Base64(false); [BUGGY] } [BUGGY]  [CLASS] Base64InputStream [METHOD] <init> [RETURN_TYPE] InputStream,boolean)  InputStream in boolean doEncode [VARIABLES] byte[] singleByte boolean doEncode Base64 base64 InputStream in  	projects/Codec6/src/java/org/apache/commons/codec/binary/Base64InputStream.java	0.4082482904638631	77	77	1	replace	
16	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] public Base64InputStream(InputStream in, boolean doEncode) { super(in); this.doEncode = doEncode; this.base64 = new Base64(false); [BUGGY] [BUGGY] } [CLASS] Base64InputStream [METHOD] <init> [RETURN_TYPE] InputStream,boolean)  InputStream in boolean doEncode [VARIABLES] byte[] singleByte boolean doEncode Base64 base64 InputStream in  	projects/Codec6/src/java/org/apache/commons/codec/binary/Base64InputStream.java	0.4082482904638631	77	77	1	add	
17	[BUG] [BUGGY] if (!base64.hasData()) { [FE] AssertionFailedError [CONTEXT] This is essentially an undocumented contract for InputStream implementors that want their code to work properly with java.io.InputStreamReader, since the latter hates it when InputStream.read(byte[]) returns a zero.Unfortunately our readResults() call must return 0 if a large amount of the data being decoded was non-base64, so this while-loop enables proper interop with InputStreamReader for that scenario. ----- This is a fix for CODEC-101  [BUGGY] if (!base64.hasData()) { [BUGGY] byte[] buf = new byte[doEncode ? 4096 : 8192]; int c = in.read(buf);   if (c > 0 && b.length == len) { base64.setInitialBuffer(b, offset, len); } if (doEncode) { base64.encode(buf, 0, c); } else { [CLASS] Base64InputStream [METHOD] read [RETURN_TYPE] int  byte[] b int offset int len [VARIABLES] byte[] b buf lineSeparator singleByte boolean doEncode Base64 base64 int c len offset  	projects/Codec6/src/java/org/apache/commons/codec/binary/Base64InputStream.java	0.4082482904638631	164	164	1	replace	
18	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] This is essentially an undocumented contract for InputStream implementors that want their code to work properly with java.io.InputStreamReader, since the latter hates it when InputStream.read(byte[]) returns a zero.Unfortunately our readResults() call must return 0 if a large amount of the data being decoded was non-base64, so this while-loop enables proper interop with InputStreamReader for that scenario. ----- This is a fix for CODEC-101  [BUGGY] [BUGGY] if (!base64.hasData()) { byte[] buf = new byte[doEncode ? 4096 : 8192]; int c = in.read(buf);   if (c > 0 && b.length == len) { base64.setInitialBuffer(b, offset, len); } if (doEncode) { base64.encode(buf, 0, c); } else { [CLASS] Base64InputStream [METHOD] read [RETURN_TYPE] int  byte[] b int offset int len [VARIABLES] byte[] b buf lineSeparator singleByte boolean doEncode Base64 base64 int c len offset  	projects/Codec6/src/java/org/apache/commons/codec/binary/Base64InputStream.java	0.4082482904638631	164	164	1	add	
19	[BUG] [BUGGY] byte[] buf = new byte[doEncode ? 4096 : 8192]; [FE] AssertionFailedError [CONTEXT] implementors that want their code to work properly with java.io.InputStreamReader, since the latter hates it when InputStream.read(byte[]) returns a zero.Unfortunately our readResults() call must return 0 if a large amount of the data being decoded was non-base64, so this while-loop enables proper interop with InputStreamReader for that scenario. ----- This is a fix for CODEC-101  if (!base64.hasData()) { [BUGGY] byte[] buf = new byte[doEncode ? 4096 : 8192]; [BUGGY] int c = in.read(buf);   if (c > 0 && b.length == len) { base64.setInitialBuffer(b, offset, len); } if (doEncode) { base64.encode(buf, 0, c); } else { base64.decode(buf, 0, c); [CLASS] Base64InputStream [METHOD] read [RETURN_TYPE] int  byte[] b int offset int len [VARIABLES] byte[] b buf lineSeparator singleByte boolean doEncode Base64 base64 int c len offset  	projects/Codec6/src/java/org/apache/commons/codec/binary/Base64InputStream.java	0.4082482904638631	165	165	1	replace	
20	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] implementors that want their code to work properly with java.io.InputStreamReader, since the latter hates it when InputStream.read(byte[]) returns a zero.Unfortunately our readResults() call must return 0 if a large amount of the data being decoded was non-base64, so this while-loop enables proper interop with InputStreamReader for that scenario. ----- This is a fix for CODEC-101  if (!base64.hasData()) { [BUGGY] [BUGGY] byte[] buf = new byte[doEncode ? 4096 : 8192]; int c = in.read(buf);   if (c > 0 && b.length == len) { base64.setInitialBuffer(b, offset, len); } if (doEncode) { base64.encode(buf, 0, c); } else { base64.decode(buf, 0, c); [CLASS] Base64InputStream [METHOD] read [RETURN_TYPE] int  byte[] b int offset int len [VARIABLES] byte[] b buf lineSeparator singleByte boolean doEncode Base64 base64 int c len offset  	projects/Codec6/src/java/org/apache/commons/codec/binary/Base64InputStream.java	0.4082482904638631	165	165	1	add	
21	[BUG] [BUGGY] int c = in.read(buf); [FE] AssertionFailedError [CONTEXT] java.io.InputStreamReader, since the latter hates it when InputStream.read(byte[]) returns a zero.Unfortunately our readResults() call must return 0 if a large amount of the data being decoded was non-base64, so this while-loop enables proper interop with InputStreamReader for that scenario. ----- This is a fix for CODEC-101  if (!base64.hasData()) { byte[] buf = new byte[doEncode ? 4096 : 8192]; [BUGGY] int c = in.read(buf); [BUGGY]   if (c > 0 && b.length == len) { base64.setInitialBuffer(b, offset, len); } if (doEncode) { base64.encode(buf, 0, c); } else { base64.decode(buf, 0, c); } [CLASS] Base64InputStream [METHOD] read [RETURN_TYPE] int  byte[] b int offset int len [VARIABLES] byte[] b buf lineSeparator singleByte boolean doEncode Base64 base64 int c len offset  	projects/Codec6/src/java/org/apache/commons/codec/binary/Base64InputStream.java	0.4082482904638631	166	166	1	replace	
22	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] java.io.InputStreamReader, since the latter hates it when InputStream.read(byte[]) returns a zero.Unfortunately our readResults() call must return 0 if a large amount of the data being decoded was non-base64, so this while-loop enables proper interop with InputStreamReader for that scenario. ----- This is a fix for CODEC-101  if (!base64.hasData()) { byte[] buf = new byte[doEncode ? 4096 : 8192]; [BUGGY] [BUGGY] int c = in.read(buf);   if (c > 0 && b.length == len) { base64.setInitialBuffer(b, offset, len); } if (doEncode) { base64.encode(buf, 0, c); } else { base64.decode(buf, 0, c); } [CLASS] Base64InputStream [METHOD] read [RETURN_TYPE] int  byte[] b int offset int len [VARIABLES] byte[] b buf lineSeparator singleByte boolean doEncode Base64 base64 int c len offset  	projects/Codec6/src/java/org/apache/commons/codec/binary/Base64InputStream.java	0.4082482904638631	166	166	1	add	
23	[BUG] [BUGGY] if (c > 0 && b.length == len) { [FE] AssertionFailedError [CONTEXT] being decoded was non-base64, so this while-loop enables proper interop with InputStreamReader for that scenario. ----- This is a fix for CODEC-101  if (!base64.hasData()) { byte[] buf = new byte[doEncode ? 4096 : 8192]; int c = in.read(buf);   [BUGGY] if (c > 0 && b.length == len) { [BUGGY] base64.setInitialBuffer(b, offset, len); } if (doEncode) { base64.encode(buf, 0, c); } else { base64.decode(buf, 0, c); } } return base64.readResults(b, offset, len); } [CLASS] Base64InputStream [METHOD] read [RETURN_TYPE] int  byte[] b int offset int len [VARIABLES] byte[] b buf lineSeparator singleByte boolean doEncode Base64 base64 int c len offset  	projects/Codec6/src/java/org/apache/commons/codec/binary/Base64InputStream.java	0.4082482904638631	169	169	1	replace	
24	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] being decoded was non-base64, so this while-loop enables proper interop with InputStreamReader for that scenario. ----- This is a fix for CODEC-101  if (!base64.hasData()) { byte[] buf = new byte[doEncode ? 4096 : 8192]; int c = in.read(buf);   [BUGGY] [BUGGY] if (c > 0 && b.length == len) { base64.setInitialBuffer(b, offset, len); } if (doEncode) { base64.encode(buf, 0, c); } else { base64.decode(buf, 0, c); } } return base64.readResults(b, offset, len); } [CLASS] Base64InputStream [METHOD] read [RETURN_TYPE] int  byte[] b int offset int len [VARIABLES] byte[] b buf lineSeparator singleByte boolean doEncode Base64 base64 int c len offset  	projects/Codec6/src/java/org/apache/commons/codec/binary/Base64InputStream.java	0.4082482904638631	169	169	1	add	
25	[BUG] [BUGGY] if (doEncode) { [FE] AssertionFailedError [CONTEXT] This is a fix for CODEC-101  if (!base64.hasData()) { byte[] buf = new byte[doEncode ? 4096 : 8192]; int c = in.read(buf);   if (c > 0 && b.length == len) { base64.setInitialBuffer(b, offset, len); } [BUGGY] if (doEncode) { [BUGGY] base64.encode(buf, 0, c); } else { base64.decode(buf, 0, c); } } return base64.readResults(b, offset, len); } [CLASS] Base64InputStream [METHOD] read [RETURN_TYPE] int  byte[] b int offset int len [VARIABLES] byte[] b buf lineSeparator singleByte boolean doEncode Base64 base64 int c len offset  	projects/Codec6/src/java/org/apache/commons/codec/binary/Base64InputStream.java	0.4082482904638631	172	172	1	replace	
26	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] This is a fix for CODEC-101  if (!base64.hasData()) { byte[] buf = new byte[doEncode ? 4096 : 8192]; int c = in.read(buf);   if (c > 0 && b.length == len) { base64.setInitialBuffer(b, offset, len); } [BUGGY] [BUGGY] if (doEncode) { base64.encode(buf, 0, c); } else { base64.decode(buf, 0, c); } } return base64.readResults(b, offset, len); } [CLASS] Base64InputStream [METHOD] read [RETURN_TYPE] int  byte[] b int offset int len [VARIABLES] byte[] b buf lineSeparator singleByte boolean doEncode Base64 base64 int c len offset  	projects/Codec6/src/java/org/apache/commons/codec/binary/Base64InputStream.java	0.4082482904638631	172	172	1	add	
27	[BUG] [BUGGY] base64.decode(buf, 0, c); [FE] AssertionFailedError [CONTEXT] if (doEncode) { base64.encode(buf, 0, c); } else { [BUGGY] base64.decode(buf, 0, c); [BUGGY] } [CLASS] Base64InputStream [METHOD] read [RETURN_TYPE] int  byte[] b int offset int len [VARIABLES] byte[] b buf lineSeparator singleByte boolean doEncode Base64 base64 int c len offset  	projects/Codec6/src/java/org/apache/commons/codec/binary/Base64InputStream.java	0.4082482904638631	175	175	1	replace	
28	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] if (doEncode) { base64.encode(buf, 0, c); } else { [BUGGY] [BUGGY] base64.decode(buf, 0, c); } [CLASS] Base64InputStream [METHOD] read [RETURN_TYPE] int  byte[] b int offset int len [VARIABLES] byte[] b buf lineSeparator singleByte boolean doEncode Base64 base64 int c len offset  	projects/Codec6/src/java/org/apache/commons/codec/binary/Base64InputStream.java	0.4082482904638631	175	175	1	add	
29	[BUG] [BUGGY] return base64.readResults(b, offset, len); [FE] AssertionFailedError [CONTEXT]  if (c > 0 && b.length == len) { base64.setInitialBuffer(b, offset, len); } if (doEncode) { base64.encode(buf, 0, c); } else { base64.decode(buf, 0, c); } } [BUGGY] return base64.readResults(b, offset, len); [BUGGY] } [CLASS] Base64InputStream [METHOD] read [RETURN_TYPE] int  byte[] b int offset int len [VARIABLES] byte[] b buf lineSeparator singleByte boolean doEncode Base64 base64 int c len offset  	projects/Codec6/src/java/org/apache/commons/codec/binary/Base64InputStream.java	0.4082482904638631	178	178	1	replace	
30	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT]  if (c > 0 && b.length == len) { base64.setInitialBuffer(b, offset, len); } if (doEncode) { base64.encode(buf, 0, c); } else { base64.decode(buf, 0, c); } } [BUGGY] [BUGGY] return base64.readResults(b, offset, len); } [CLASS] Base64InputStream [METHOD] read [RETURN_TYPE] int  byte[] b int offset int len [VARIABLES] byte[] b buf lineSeparator singleByte boolean doEncode Base64 base64 int c len offset  	projects/Codec6/src/java/org/apache/commons/codec/binary/Base64InputStream.java	0.4082482904638631	178	178	1	add	
31	[BUG] [BUGGY] } else if (len == 0) { [FE] AssertionFailedError [CONTEXT] public int read(byte b[], int offset, int len) throws IOException { if (b == null) { throw new NullPointerException(); } else if (offset < 0 || len < 0) { throw new IndexOutOfBoundsException(); } else if (offset > b.length || offset + len > b.length) { throw new IndexOutOfBoundsException(); [BUGGY] } else if (len == 0) { [BUGGY] return 0; } else {  Rationale for while-loop on (readLen == 0): ----- Base64.readResults() usually returns > 0 or EOF (-1).In the rare case where it returns 0, we just keep trying. This is essentially an undocumented contract for InputStream implementors that want their code to work properly with [CLASS] Base64InputStream [METHOD] read [RETURN_TYPE] int  byte[] b int offset int len [VARIABLES] byte[] b buf lineSeparator singleByte boolean doEncode Base64 base64 int c len offset  	projects/Codec6/src/java/org/apache/commons/codec/binary/Base64InputStream.java	0.3779644730092272	145	145	1	replace	
32	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] public int read(byte b[], int offset, int len) throws IOException { if (b == null) { throw new NullPointerException(); } else if (offset < 0 || len < 0) { throw new IndexOutOfBoundsException(); } else if (offset > b.length || offset + len > b.length) { throw new IndexOutOfBoundsException(); [BUGGY] [BUGGY] } else if (len == 0) { return 0; } else {  Rationale for while-loop on (readLen == 0): ----- Base64.readResults() usually returns > 0 or EOF (-1).In the rare case where it returns 0, we just keep trying. This is essentially an undocumented contract for InputStream implementors that want their code to work properly with [CLASS] Base64InputStream [METHOD] read [RETURN_TYPE] int  byte[] b int offset int len [VARIABLES] byte[] b buf lineSeparator singleByte boolean doEncode Base64 base64 int c len offset  	projects/Codec6/src/java/org/apache/commons/codec/binary/Base64InputStream.java	0.3779644730092272	145	145	1	add	
33	[BUG] [BUGGY] } else if (offset < 0 || len < 0) { [FE] AssertionFailedError [CONTEXT] public int read(byte b[], int offset, int len) throws IOException { if (b == null) { throw new NullPointerException(); [BUGGY] } else if (offset < 0 || len < 0) { [BUGGY] throw new IndexOutOfBoundsException(); } else if (offset > b.length || offset + len > b.length) { throw new IndexOutOfBoundsException(); } else if (len == 0) { return 0; } else {  Rationale for while-loop on (readLen == 0): ----- Base64.readResults() usually returns > 0 or EOF (-1).In the [CLASS] Base64InputStream [METHOD] read [RETURN_TYPE] int  byte[] b int offset int len [VARIABLES] byte[] b buf lineSeparator singleByte boolean doEncode Base64 base64 int c len offset  	projects/Codec6/src/java/org/apache/commons/codec/binary/Base64InputStream.java	0.35355339059327373	141	141	1	replace	
34	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] public int read(byte b[], int offset, int len) throws IOException { if (b == null) { throw new NullPointerException(); [BUGGY] [BUGGY] } else if (offset < 0 || len < 0) { throw new IndexOutOfBoundsException(); } else if (offset > b.length || offset + len > b.length) { throw new IndexOutOfBoundsException(); } else if (len == 0) { return 0; } else {  Rationale for while-loop on (readLen == 0): ----- Base64.readResults() usually returns > 0 or EOF (-1).In the [CLASS] Base64InputStream [METHOD] read [RETURN_TYPE] int  byte[] b int offset int len [VARIABLES] byte[] b buf lineSeparator singleByte boolean doEncode Base64 base64 int c len offset  	projects/Codec6/src/java/org/apache/commons/codec/binary/Base64InputStream.java	0.35355339059327373	141	141	1	add	
35	[BUG] [BUGGY] } else if (offset > b.length || offset + len > b.length) { [FE] AssertionFailedError [CONTEXT] public int read(byte b[], int offset, int len) throws IOException { if (b == null) { throw new NullPointerException(); } else if (offset < 0 || len < 0) { throw new IndexOutOfBoundsException(); [BUGGY] } else if (offset > b.length || offset + len > b.length) { [BUGGY] throw new IndexOutOfBoundsException(); } else if (len == 0) { return 0; } else {  Rationale for while-loop on (readLen == 0): ----- Base64.readResults() usually returns > 0 or EOF (-1).In the rare case where it returns 0, we just keep trying.  [CLASS] Base64InputStream [METHOD] read [RETURN_TYPE] int  byte[] b int offset int len [VARIABLES] byte[] b buf lineSeparator singleByte boolean doEncode Base64 base64 int c len offset  	projects/Codec6/src/java/org/apache/commons/codec/binary/Base64InputStream.java	0.35355339059327373	143	143	1	replace	
36	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] public int read(byte b[], int offset, int len) throws IOException { if (b == null) { throw new NullPointerException(); } else if (offset < 0 || len < 0) { throw new IndexOutOfBoundsException(); [BUGGY] [BUGGY] } else if (offset > b.length || offset + len > b.length) { throw new IndexOutOfBoundsException(); } else if (len == 0) { return 0; } else {  Rationale for while-loop on (readLen == 0): ----- Base64.readResults() usually returns > 0 or EOF (-1).In the rare case where it returns 0, we just keep trying.  [CLASS] Base64InputStream [METHOD] read [RETURN_TYPE] int  byte[] b int offset int len [VARIABLES] byte[] b buf lineSeparator singleByte boolean doEncode Base64 base64 int c len offset  	projects/Codec6/src/java/org/apache/commons/codec/binary/Base64InputStream.java	0.35355339059327373	143	143	1	add	
37	[BUG] [BUGGY] if (b == null) { [FE] AssertionFailedError [CONTEXT] public int read(byte b[], int offset, int len) throws IOException { [BUGGY] if (b == null) { [BUGGY] throw new NullPointerException(); } else if (offset < 0 || len < 0) { throw new IndexOutOfBoundsException(); } else if (offset > b.length || offset + len > b.length) { throw new IndexOutOfBoundsException(); } else if (len == 0) { return 0; } else {  Rationale for while-loop on (readLen == 0): [CLASS] Base64InputStream [METHOD] read [RETURN_TYPE] int  byte[] b int offset int len [VARIABLES] byte[] b buf lineSeparator singleByte boolean doEncode Base64 base64 int c len offset  	projects/Codec6/src/java/org/apache/commons/codec/binary/Base64InputStream.java	0.3333333333333333	139	139	1	replace	
38	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] public int read(byte b[], int offset, int len) throws IOException { [BUGGY] [BUGGY] if (b == null) { throw new NullPointerException(); } else if (offset < 0 || len < 0) { throw new IndexOutOfBoundsException(); } else if (offset > b.length || offset + len > b.length) { throw new IndexOutOfBoundsException(); } else if (len == 0) { return 0; } else {  Rationale for while-loop on (readLen == 0): [CLASS] Base64InputStream [METHOD] read [RETURN_TYPE] int  byte[] b int offset int len [VARIABLES] byte[] b buf lineSeparator singleByte boolean doEncode Base64 base64 int c len offset  	projects/Codec6/src/java/org/apache/commons/codec/binary/Base64InputStream.java	0.3333333333333333	139	139	1	add	
